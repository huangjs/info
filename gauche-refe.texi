\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@setfilename gauche-refe.info
@settitle Gauche Users' Reference
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche: (gauche-refe.info).	        An R5RS Scheme implementation.
@end direntry
@comment %**end of header

@c $Id: gauche-ref.texi,v 1.432 2006-04-07 11:29:48 shirok Exp $

@c module and class index
@defcodeindex md
@defcodeindex cl

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title Gauche Users' Reference
@subtitle version 0.8.14
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2005 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
This is a reference manual of Gauche, an R5RS Scheme implementation.
This manual is for version 0.8.14.
@end ifnottex

@menu
* Introduction::                
* Concepts::                    
* Programming in Gauche::       
* Core syntax::                 
* Macros::                      
* Core library::                
* Object system::               
* Library modules - Overview::  
* Library modules - Gauche extensions::  
* Library modules - SRFIs::     
* Library modules - Utilities::  
* References::                  
* C to Scheme mapping::         
* Function and Syntax Index::   
* Module Index::                
* Class Index::                 
* Variable Index::              
@end menu

@node Introduction, Concepts, Top, Top
@chapter Introduction
@c NODE はじめに

This is a users' guide and reference manual of
the Gauche Scheme system.
Here I tried to describe the implementation precisely,
sometimes referring to background design choices.

The target readers are those who already know Scheme and
want to write useful programs in Gauche.
For those who are new to Scheme, it'll be easier to start
from some kind of tutorial.  I'm planning to write one.

This manual only deals with Scheme side of things.  Gauche has
another face, a C interface.   Details of it will be discussed
in a separate document to be written.
Those who wants to use Gauche as an embedded language, or wants
to write an extension, need that volume.

For the Scheme side, I tried to make this manual self-contained
for the reader's convenience, i.e. as far as you want to look up
Gauche's features you don't need to refer to other documents.
For example, description of functions defined in the standard
documents are included in this manual, instead of saying
``see the standard document''.   However, this document is not a verbatim
copy of the standard documents; sometimes I omit detailed
discussions for brevity.
I put pointers to the original documents, so please consult them if you
need to refer to the standards.

If you're reading this document off-line, you may find the most
recent version on the web:
@example
@uref{http://practical-scheme.net/gauche/}.
@end example


@menu
* Overview of Gauche::          
* Notations::                   
@end menu

@node Overview of Gauche, Notations, Introduction, Introduction
@section Overview of Gauche
@c NODE  Gaucheの概要

Gauche is a script interpreter based on Scheme.
Gauche conforms the language standard
"Revised^5 Report on the Algorithmic Language Scheme"
(@ref{r5rs,[R5RS],R5RS}),
and supports various common libraries defined in SRFIs
(@uref{http://srfi.schemers.org}).

The goal of Gauche is to provide a handy tool for
programmers and system administrators to handle
daily works conveniently and efficiently in the production environment.

There are lots of Scheme implementations available, and each
of them has its design emphasis and weaknesses.  Gauche is
designed with emphasis on the following criteria.

@table @b
@item Quick startup
One of the situation Gauche is aiming at is in the production
environment, where you write ten-lines throw-away script that
may invoked very frequently.  This includes CGI scripts as well.
Gauche includes a set of most common features in its executable,
while splits less common stuffs into libraries which are to be loaded
on demand, to make itself start quickly.

@item Multibyte strings
We can no longer live happily in ASCII-only or 1-byte-per-character world.
The practical language implementations are required to handle
multibyte (wide) characters.
Gauche supports multibyte strings natively, providing robust and
consistent support than @i{ad hoc} library-level implementation.
@xref{Multibyte Strings}, for details.

@item Modular development
Gauche has a simple module system to separate namespaces,
which allows the developers to work in parallel without
worrying name collision.  

@item Integrated object system
A powerful CLOS-like object system with MetaObject protocol
(mostly compatible with STklos and Guile) is provided.

@item System interface
Although Scheme abstracts lots of details of the machine,
sometimes you have to bypass these high-level layers and
go down to the basement to make things work.
Gauche has built-in support of most of POSIX.1 system calls.
Other modules, such as networking module, usually provide
both high-level abstract interface and low-level interface
close to system calls.

@item Enhanced I/O
No real application can be written without dealing with I/O.
Scheme neatly abstracts I/O as a port, but defines least operations on it.
Gauche uses a port object as a unified abstraction, providing
utility functions to operate on the underlying I/O system.
@xref{Input and output}, for the basic I/O support.
@end table

On the other hand, Gauche is @emph{not} designed for 
applications such like high-performance number cruncher or
very large scale database handling.  It is an interpreter, after all.

You can still use Gauche as a "glue" language for such applications,
however.  For example, you can write a performance-critical part 
in another language that compiles to native code, and use Gauche to set up.


@node Notations,  , Overview of Gauche, Introduction
@section Notations
@c NODE 表記について

In this manual, each entry is represented like this:

@deftp {Category} foo arg1 arg2
[spec] Description of foo @dots{}
@end deftp

@var{Category} denotes the category of the entry @b{foo}.
The following category will appear in this manual:

@multitable @columnfractions .4 .6
@item Function
@tab A Scheme function.
@item Special Form
@tab A special form (in the R5RS term, ``syntax'').
@item Macro
@tab A macro.
@item Module
@tab A module
@item Class
@tab A class.
@item Generic Function
@tab A generic function
@item Method
@tab A method
@item Reader Syntax
@tab A lexical syntax that is interpreted by the reader.
@end multitable

For functions, special forms and macros, the entry may followed
by one or more arguments.  In the argument list, the following notations
may appear:

@table @var
@item arg @dots{}
Indicates zero or more arguments.
@item &optional x y z
@itemx &optional (x x-default) (y y-default) z
Indicates it may take up to three optional arguments.
The second form specifies default values.
Note that Gauche doesn't really support Common-Lisp style
@code{&optional} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@item &keyword x y z
@itemx &keyword (x x-default) (y y-default) z
Indicates it may take keyword arguments @var{x}, @var{y} and @var{z.}
Note that Gauche doesn't really support Common-Lisp style
@code{&keyword} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@item &rest args
Indicates it may take rest arguments.
Note that Gauche doesn't really support Common-Lisp style
@code{&rest} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@end table

The description of the entry follows the entry line.
If the specification of the entry comes from some standard or
implementation, its origin is noted in the bracket at the beginning
of the description.  The following origins are noted:

@table @asis
@item [R5RS]
@itemx [R5RS+]
The entry works as specified in ``Revised^5 Report of Algorithmic Language
Scheme.''.  If it is marked as "[R5RS+]", the entry has additional
functionality.
@item [SRFI-@var{n}]
@itemx [SRFI-@var{n}+]
The entry works as specified in SRFI-@var{n}.  If it is marked as
"[SRFI-@var{n}+]", the entry has additional functionality.
@item [POSIX]
The API of the entry reflects the API specified in POSIX.
@end table

@c @node Structure of this document,  , Notations, Introduction
@c @section Structure of this document
@c @c NODE 本書の構成

@c @c EN
@c @c JP
@c @c COMMON

@node Concepts, Programming in Gauche, Introduction, Top
@chapter Concepts
@c NODE 主要な概念

In this chapter I describe a few Gauche's design concepts
that help you to understand how Gauche works.

@menu
* Standard conformance::        
* Multibyte Strings::           
* Multibyte scripts::           
* Case-sensitivity::            
* Integrated Object System::   
* Module system::               
* Compilation::                 
@end menu

@node Standard conformance, Multibyte Strings, Concepts, Concepts
@section Standard conformance
@c NODE 標準への準拠

Gauche conforms "Revised^5 Report of Algorithmic Language Scheme,"
including optional syntax and procedures, except the following features.

@itemize @bullet
@item
By default, Gauche reads symbols in case-sensitive way.
You can switch the reader's case sensitivity by a command-line
option or special reader directive
(@xref{Case-sensitivity}, for details).
@item
Continuations created in a certain situation
(specifically, inside a Scheme code that is called from external
C routine) have limited extent (@xref{Continuation}, for details).
@item
Full numeric tower (integer, rational, real and complex numbers) are supported,
but ratinals are only exact, and complex numbers are always inexact.
The reader can recognize '@code{#}' as insignificant digits.
@item
Procedures @code{rationalize}, @code{transcript-on} and @code{transcript-off}
are not supported.
@end itemize

(Note: A new Scheme standard R6RS has been ratified on September 2007.
Although we don't have a plan to change Gauche to conform R6RS in near future,
we'll gradually add modules that are compatible to R6RS).

Gauche also supports the following SRFIs (Scheme Request for Implementation).

@table @asis
@item SRFI-0, Feature-based conditional expansion construct.
As an autoloaded macro.   @xref{Feature conditional}.

@item SRFI-1, List library.
Supported by the module @code{srfi-1}.  @xref{List library}.
(Some of SRFI-1 procedures are built-in).

@item SRFI-2, AND-LET*: an AND with local bindings, a guarded LET* special form.
Supported natively.  @xref{Binding constructs}.

@item SRFI-4, Homogeneous numeric vector datatypes.
The module @code{gauche.uvector} provides a superset of
@code{srfi-4} procedures, including arithmetic operations and
generic interface on the SRFI-4 vectors.  @xref{Uniform vectors}.

@item SRFI-5, A compatible let form with signatures and rest arguments
Supported by the module @code{srfi-5}.  
@xref{A compatible let form with signatures and rest arguments}.

@item SRFI-6, Basic String Ports.
SRFI-6 procedures are built-in.  @xref{String ports}.

@item SRFI-7, Feature-based program configuration language
Supported as an autoloaded macro.  
@xref{Feature-based program configuration language}.

@item SRFI-8, receive: Binding to multiple values.
Syntax @code{receive} is built-in.  @xref{Binding constructs}.

@item SRFI-9, Defining record types.
Supported by the module @code{srfi-9}.  @xref{Record types}.

@item SRFI-10, Sharp-comma external form.
Built-in.  @xref{Read-time constructor}.

@item SRFI-11, Syntax for receiving multiple values.
Supported by the module @code{srfi-11}.  @xref{Let-values}.

@item SRFI-13, String library
Supported by the module @code{srfi-13}.  @xref{String library}.
(Some of SRFI-13 procedures are built-in).

@item SRFI-14, Character-set library
Character-set object and a few SRFI-14 procedures are built-in.
@xref{Character set}.
Complete set of SRFI-14 is supported by the module @code{srfi-14}.
@xref{Character-set library}.

@item SRFI-16, Syntax for procedures of variable arity (case-lambda)
Built-in.  @xref{Making Procedures}.

@item SRFI-17, Generalized set!
Built-in.  @xref{Assignments}.

@item SRFI-18, Multithreading support
Some SRFI-18 features are built-in, and the rest is in @code{gauche.threads}
module.  @xref{Threads}.

@item SRFI-19, Time Data Types and Procedures.
Time data type is Gauche built-in (@xref{Time}).
Complete set of SRFI-19 is supported by the module @code{srfi-19}.
@xref{Time data types and procedures}.

@item SRFI-22, Running Scheme scripts on Unix
Supported.  @xref{Writing Scheme scripts}.

@item SRFI-23, Error reporting mechanism.
Built-in.   @xref{Signalling exceptions}.

@item SRFI-25, Multi-dimensional array primitives. 
Supported by the module @code{gauche.array}, which defines
superset of SRFI-25.  @xref{Arrays}.

@item SRFI-26, Notation for specializing parameters without currying.
As an autoloaded macro.  @xref{Making Procedures}.

@item SRFI-27, Sources of Random Bits.
Supported by the module @code{srfi-27}.  @xref{Sources of random bits}.

@item SRFI-28, Basic format strings.
Gauche's built-in @code{format} procedure is a superset of
SRFI-28 @code{format}.  @xref{Output}.

@item SRFI-29, Localization
Supported by the module @code{srfi-29}.
@xref{Localization}.

@item SRFI-30, Nested multi-line comments.
Supported by the native reader.  @xref{Lexical structure}.

@item SRFI-31, A special form rec for recursive evaluation
Defined as an autoloaded macro.  @xref{Binding constructs}.

@item SRFI-34, Exception Handling for Programs
Built-in.  @xref{Exceptions}.
(However, Gauche implements srfi-18's semantics of @code{raise} literally,
which differs slightly from srfi-34's.  This may be changed in future.)

@item SRFI-35, Conditions
Built-in.  @xref{Conditions}.

@item SRFI-36, I/O Conditions
Partly supported.  @xref{Conditions}.

@item SRFI-37, args-fold: a program argument processor
Supported by the module @code{srfi-37}.
@xref{A program argument processor}.

@item SRFI-38, External Representation for Data With Shared Structure
Built-in.  See @ref{Reading data} and @ref{Output}.

@item SRFI-39, Parameter objects
Supported by the module @code{gauche.parameter}.
@xref{Parameters}.

@item SRFI-40, A Library of Streams
Supported by the module @code{util.stream}.
@xref{Stream library}.

@item SRFI-42, Eager comprehensions
Supported by the module @code{srfi-42}.
@xref{Eager comprehensions}.

@item SRFI-43, Vector library
Supported by the module @code{srfi-43}.
@xref{Vector library}.

@item SRFI-45, Primitives for Expressing Iterative Lazy Algorithms
Built-in.
@xref{Delayed evaluation}.

@item SRFI-55, require-extension
Supported as an autoloaded macro.
@xref{Requiring extensions}.

@item SRFI-61, A more general @code{cond} clause
Supported natively.  @xref{Conditionals}.

@item SRFI-62, S-expression comments
Supported by the native reader.  @xref{Lexical structure}.

@item SRFI-87, @code{=>} in case clauses
Supported natively.  @xref{Conditionals}.

@end table

@node Multibyte Strings, Multibyte scripts, Standard conformance, Concepts
@section Multibyte Strings
@c NODE マルチバイト文字列

Traditionally, a string is considered as a simple array of bytes.
Programmers tend to imagine a string as a simple
array of characters (though a character may occupy more than one byte).
It's not the case in Gauche.

Gauche supports @emph{multibyte string} natively,
which means characters are represented by variable number of bytes
in a string.   Gauche retains semantic compatibility of
Scheme string, so such details can be hidden, but it'll helpful
if you know a few points.

A string object keeps a type tag and a pointer to the storage
of the string body.  The storage of the body is managed in a sort of
``copy-on-write''
way---if you take substring, e.g. using directly by @code{substring}
or using regular expression matcher, or even if you copy a string
by @code{copy-string}, the underlying storage is shared
(the ``anchor'' of the string is different, so the copied string
is not @code{eq?} to the original string).
The actual string is copied only if you destructively modify it.

Consequently the algorithm like pre-allocating a string by
@code{make-string} and filling it with @code{string-set!}
becomes @emph{extremely} inefficient in Gauche.  Don't do it.
(It doesn't work with mulitbyte strings anyway).
Sequential access of string is much more efficient
using @emph{string ports} (@xref{String ports}).

String search primitives such as @code{string-scan} (@xref{String utilities})
and regular expression matcher (@xref{Regular expression})
can return a matched string directly, without
using index access at all.

You can choose @emph{internal} encoding scheme at the time of compiling
Gauche.   At runtime, a procedure @code{gauche-character-encoding}
can be used to query the internal encoding.  Currently, the following
internal encodings are supported.

@table @code
@item euc-jp
EUC-JP encoding of ASCII, JIS X 0201 kana, JIS X 0212 and JIS X 0213:2000
Japanese character set.
@item sjis
Shift-JIS encoding of JIS X 0201 kana and JIS X 0213:2000
Japanese character set.  For source-code compatibility, the character
code between 0 and 0x7f is mapped to ASCII.
@item utf-8
UTF-8 encoding of Unicode.
@item none
8-bit fixed-length character encoding, with the code between 0 and 0x7f
matches ASCII.  It's up to the application to interpret the string
with certain character encodings.
@end table

Conversions from other encoding scheme is provided 
as a special port. @xref{Character code conversion}, for details.

The way to specify the encoding of source programs will be
explained in the next section.

@node Multibyte scripts, Case-sensitivity, Multibyte Strings, Concepts
@section Multibyte scripts
@c NODE マルチバイトスクリプト

You can use characters other than @code{us-ascii} not only in
literal strings and characters, but in in commens, symbol names,
literal regular expressions, and so on.

So far, Gauche treats any characters other than @code{us-ascii}
as symbol constituent characters.  Unicode defines more than dozen
"space" characters, though, and they will be treated as whitespace
characters in future.  So it's better to avoid those characters
(except in the strings, regexps and characters) for the time being.

By default, Gauche assumes a Scheme program is written in
its internal character encoding.   It is fine as far as you're writing
scripts to use your own environment, but it becomes a problem if
somebody else tries to use your script and finds out you're using
different character encoding than his/hers.

So, if Gauche finds a comment something like the following within
the first two lines of the program source, it assumes the rest of
the source code is written in @code{<encoding-name>}, and does
the appropriate character encoding conversion to read the source code:
@example
;; coding: <encoding-name>
@end example

More precisely, a comment in either first or second line that matches
a regular expression @code{#/coding[:=]\s*([\w.-]+)/} is recognized, 
and the first submatch is taken as an encoding name.
If there are multiple matches, only the first one is effective.   
The first two lines must not contain characters other than us-ascii
in order for this mechanism to work.

The following example tells Gauche that the script is written
in EUC-JP encoding.   Note that the string "@code{-*-}" around the coding
would be recognized by Emacs to select the buffer's encoding
appropriately.

@example
#!/usr/bin/gosh
;; -*- coding: euc-jp -*-

... script written in euc-jp ...
@end example

Internally, the handling of this @emph{magic comment} is done by
a special type of port.  See @ref{Coding-aware ports} for the
details.  See also @ref{Loading Scheme file} for how to disable
this feature.

@node Case-sensitivity, Integrated Object System, Multibyte scripts, Concepts
@section Case-sensitivity
@c NODE 大文字小文字の区別

Historically, most Lisp-family languages are case-insensitive
for symbols.  Scheme is no exception and R5RS defines symbols are
read in case-insensitive way.  (Note that symbols are case-sensitive
internally even in R5RS Scheme; case-insensitivity is about readers.)

However, nowadays programming is hardly completed in one language.
When you have to interact with other languages that distinguish uppercase
and lowercase characters, it is desirable that Scheme distinguishes them
as well.

So Gauche has two modes in reading and writing symbols.
@emph{By default, Gauche reads and writes symbols in case-sensitive manner}.
This behavior doesn't conform R5RS.

@example
; @r{In case-sensitive mode (default)}
(eq? 'a 'A) @result{} #f  ; #t @r{in R5RS}
(symbol->string 'ABC) @result{} "ABC"
(symbol->string 'abc) @result{} "abc"
(display (string->symbol "ABC")) @result{} @r{writes} ABC
(display (string->symbol "abc")) @result{} @r{writes} abc
@end example

You can make Gauche case-insensitive by giving @code{-fcase-fold}
command-line option to the @code{gosh} interpreter (@xref{Invoking Gosh}).
In this mode, the reader folds uppercase characters in symbols to lowercase
ones.  If a symbol name contains uppercase characters, it is written
out using |-escape (@xref{Symbols}).

@example
; @r{In case-insensitive mode (with -fcase-fold option)}
(eq? 'a 'A) @result{} #t
(symbol->string 'ABC) @result{} "abc"
(symbol->string 'abc) @result{} "abc"
(display (string->symbol "ABC")) @result{} @r{writes} |ABC|
(display (string->symbol "abc")) @result{} @r{writes} abc
@end example

Alternatively, if the reader sees a token @code{#!fold-case},
the reader switches to case-insensitive mode.  A token
@code{#!no-fold-case} has an opposite effect---to make the
reader case-sensitive.  These tokens affect the port
from which they are read, and are in effect until EOF
or another instance of these tokens are read.
See @ref{Lexical structure} for more details on @code{#!} syntax.

@node Integrated Object System, Module system, Case-sensitivity, Concepts
@section Integrated Object System
@c NODE 統合されたオブジェクトシステム

Gauche has a STklos-style object system, similar to CLOS.
If you have used some kind of object oriented (OO) languages,
you'll find it easy to understand the basic usage:
@example
;; @r{Defines a class point, that has x and y coordinate}
(define-class point ()
  ((x :init-value 0)
   (y :init-value 0))
  )

(define-method move ((p point) dx dy)
  (inc! (slot-ref p 'x) dx)
  (inc! (slot-ref p 'y) dy))

(define-method write-object ((p point) port)
  (format port "[point ~a ~a]"
          (slot-ref p 'x)
          (slot-ref p 'y)))
@end example

However, if you are familiar with mainstream OO languages but new to CLOS-style
object system, Gauche's object system may look strange
when you look deeper into it.
Here I describe several characteristics of Gauche object system quickly.
@xref{Object system}, for details.

@table @emph
@item Everything is an object (if you care)
You have seen this tagline for the other languages.
And yes, in Gauche, everything is an object in the sense that you can
query its class, and get various meta information of
the object at run time.  You can also define a new method
on any class, including built-in ones.

Note that, however, in CLOS-like paradigm it doesn't really matter
whether everything is an object or not, because of the following
characteristics:

@item Method is dispatched by all of its arguments.
Unlike other object-oriented languages such as C++, Objective-C,
Python, Ruby, etc., in which a method always belong to a single
class, a Gauche method doesn't belong to a specific class.

For example, suppose you define a numeric vector class
@code{<num-vector>} and a numeric matrix class @code{<num-matrix>}.
You can define a method @code{product} with all possible combinations
of those type of arguments:

@example
  (product <num-vector> <num-matrix>)
  (product <num-matrix> <num-vector>)
  (product <num-vector> <num-vector>)
  (product <num-matrix> <num-matrix>)
  (product <number>     <num-vector>)
  (product <number>     <num-matrix>)
  (product <number>     <number>)
@end example

Each method belongs to neither @code{<num-vector>} class nor
@code{<num-matrix>} class.

Since a method is not owned by a class, you can always define your
own method on the existing class (except a few cases
that the system prohibits altering pre-defined methods).  The above
example already shows it; you can make @code{product} method work
on the built-in class @code{<number>}.   That is why I said
it doesn't make much sense to discuss whether everything is object
or not in CLOS-style object system.

To step into the details a bit, the methods are belong to a
@emph{generic function}, which is responsible for dispatching
appropriate methods.

@item Class is also an instance.
By default, a class is also an instance of class
@code{<class>}, and a generic function is an instance of class
@code{<generic>}.  You can subclass @code{<class>} to customize
how a class is initialized or how its slots are accessed.
You can subclass @code{<generic>} to customize how the
applicable methods are selected, which order those methods are
called, etc.   The mechanism is called @emph{metaobject protocol}.
Metaobject protocol allows you to extend the language by
the language itself.  

To find examples, see the files @code{lib/gauche/singleton.scm} and
@code{lib/gauche/mop/validator.scm} included in the distribution.
You can also read @code{lib/gauche/mop/object.scm}, which actually
defines how a class is defined in Gauche.
For more details about metaobject protocol, see @ref{mop,[MOP],MOP}.

@item Class doesn't create namespace
In the mainstream OO language, a class often creates its own namespace.
This isn't the case in CLOS-style object system.
In Gauche, a namespace is managed by the module system
which is orthogonal to the object system.

@end table

@node Module system, Compilation, Integrated Object System, Concepts
@section Module system
@c NODE モジュールシステム

Gauche has a simple module system that allows
modularlized development of large software.

A higher level interface is simple enough from the user's point
of view.   It works like this:
When you want to use the features provided by module
@code{foo}, you just need to say @code{(use foo)} in your code.
This form is a macro and interpreted at compile time.
Usually it loads the files that defines @code{foo}'s features,
and imports the external APIs into the calling module.

The @code{use} mechanism is built on top of two independent
lower mechanisms, namespace separation and file loading mechanism.
Those two lower mechanisms can be used separately, although it is much more
convenient when used together.

The @code{use} mechanism is not transitive; that is,
if a module B uses a module A, and a module C uses the module B,
C doesn't see the bindings in A.  It is because B and A is not in the
@var{is-a} relationship.
Suppose the module A implements a low-level functionality and
the module B implements a high-level abstraction; if C is using
B, what C wants to see is just a high-level abstraction, and
doesn't concern how B implements such functionality.  If C wants
to access low-level stuff, C has to @var{use} A explicitly.

There is another type of relationship, though.  You might want to
take an exiting module A, and add some interface to it and provide
the resulting module B as an extension of A.  In such a case,
B is-a A, and it'd be natural that the module that uses B can also
see A's bindings.   In Gauche, it is called @emph{module inheritance}
and realized by @code{extend} form.

The following sections in this manual describes
modules in details.
@itemize @bullet
@item
@ref{Writing Gauche modules} explains the convention of
writing modules.
@item
@ref{Modules} describes special forms and macros to
define and to use modules, along the built-in functions
to introspect module internals.
@end itemize

@node Compilation,  , Module system, Concepts
@section Compilation
@c NODE コンパイル

Gauche is a Scheme interpreter, in the sense that it reads
a Scheme form at a time and evaluates it.   Actually,
Gauche compiles every toplevel form into an intermediate form
before executing.

Built-in syntaxes and macros are recognized and expanded
at the compilation time.  Some built-in procedures are
expanded in-line as far as the compiler can see the global
binding is not altered at the time the form is compiled.

This raises a few problems you should care.

@table @emph
@item load is done at run time.
@code{load} is a procedure in Gauche, therefore evaluated at run time.
If the loaded program defines a macro, which is available for the compiler
after the toplevel form containing @code{load} is evaluated.  So, suppose
@code{foo.scm} defines a macro @code{foo}, and you use the macro
like this:
@example
;; @r{in ``foo.scm''}
(define-syntax foo
  (syntax-rules () ((_ arg) (quote arg))))

;; @r{in your program}
(begin (load "foo") (foo (1 2 3)))
  @result{} @r{error, bad procedure: `1'}

(load "foo")
(foo (1 2 3)) @result{} '(1 2 3)
@end example
The @code{(begin (load ...))} form fails,  because the compiler
doesn't know @code{foo} is a special form at the compilation time
and compiles @code{(1 2 3)} as if it is a normal procedure call.
The latter example works, however, since the execution
of the toplevel form @code{(load "foo")} is done before
@code{(foo (1 2 3))} is compiled.

To avoid this kind of subtleties, use @code{require} or @code{use}
to load a program fragments.  Those are recognized by the compiler.

@item require is done at compile time
On the other hand, since @code{require} and @code{use} is recognized
by the compiler, the specified file is loaded even if the form
is in the conditional expression.   If you really need to load
a file on certain condition, use @code{load} or do dispatch in macro
(i.e. at compile time).
@end table
@node Programming in Gauche, Core syntax, Concepts, Top
@chapter  Programming in Gauche
@c NODE Gaucheでのプログラミング

@menu
* Invoking Gosh::               
* Interactive development::     
* Writing Scheme scripts::      
* Debugging::                   
* Platform-dependent features::  
* Profiling and tuning::        
* Writing Gauche modules::      
* Using extension packages::    
@end menu

@node Invoking Gosh, Interactive development, Programming in Gauche, Programming in Gauche
@section Invoking Gosh
@c NODE Gaucheを起動する

Gauche can be used either as an independent Scheme interpreter
or as an embedded Scheme library.   The interpreter
which comes with Gauche distribution is a program named @code{gosh}.

@deftp {Program} gosh [options] [scheme-file arg @dots{}]
Gauche's interpreter.   Without @var{scheme-file}, @code{gosh} works
interactively, i.e. it reads a Scheme expression from the standard input,
evaluates it, and prints the result, and repeat that until it reads EOF or
is terminated.

If @code{gosh} is invoked without @var{scheme-file}, but the input
is not a terminal, it enters read-eval-print loop but not writes
out a prompt while waiting input form.  This is useful when you
pipe Scheme program into @code{gosh}.  You can force this behavior
or suppress this behavior by @code{-b} and @code{-i} options.

If @var{scheme-file} is specified, @code{gosh} runs it as a
Scheme program and exit.
@xref{Writing Scheme scripts}, for details.
@end deftp

@subheading Command-line options

The following command line options are recognized by @code{gosh}.
The first command line argument which doesn't begin with `@minus{}'
is recognized as the script file.  If you want to specify a file
that begins with a minus sign, use a dummy option `@code{--}'.

@deftp {Command Option} -I path
Prepends @var{path} to the load path list.
You can specify this option more than once to add multiple paths.
@end deftp

@deftp {Command Option} -A path
Appends @var{path} to the tail of the load path list.
You can specify this option more than once to add multiple paths.
@end deftp

@deftp {Command Option} -q
Makes @code{gosh} not to load the default initialization file.
@end deftp

@deftp {Command Option} -V
Prints the @code{gosh} version and exits.
@end deftp

@deftp {Command Option} -u module
Use @var{module}.  Before starting execution of @var{scheme-file} or entering
the read-eval-print loop, the specified module is @var{use}d, i.e.
it is loaded and imported (@xref{Defining and selecting modules}, for details of @code{use}).
You can specify this option more than once to use multiple modules.
@end deftp

@deftp {Command Option} -l file
Load @var{file} before starting execution of @var{scheme-file} or entering
the read-eval-print loop.   The file is loaded in the same way as
@code{load} (@xref{Loading Scheme file}).
You can specify this option more than once to load multiple files.
@end deftp

@deftp {Command Option} -e scheme-expression
Evaluate @var{scheme-expression}
before starting execution of @var{scheme-file} or entering
the read-eval-print loop.   Evaluation is done in the
@var{interaction-environment} (@xref{Eval and repl}).
You can specify this option more than once to evaluate multiple expressions.
@end deftp

@deftp {Command Option} -E scheme-expression
Same as -e, except the @var{scheme-expression} is read
as if it is surrounded by parenthesis.  For example:
@example
% gosh -umath.const -E"print (sin (* pi/180 15))" -Eexit
0.25881904510252074
@end example
@end deftp

@deftp {Command Option} -b
Batch. Does not print prompts even if the input is a terminal.
@end deftp

@deftp {Command Option} -i
Interactive. Print prompts even if the input is not a terminal.
@end deftp

@deftp {Command Option} -f compiler-option
This option controls compiler and runtime behavior.  For now we have
following options available:
@table @asis
@item no-inline
Prohibits the compiler from inlining procedures and constants. Equivalent to
no-inline-globals, no-inline-locals and no-inline constants combined.
@item no-inline-globals
Prohibits the compiler from inlining global procedures.
@item no-inline-locals
Prohibits the compiler from inlining local procedures.
@item no-inline-constants
Prohibits the compiler from inlining constants.
@item load-verbose
Reports whenever a file is loaded.
@item no-source-info
Don't keep source information for debugging.  Consumes less memory.
@item case-fold
Ignore case for symbols as specified in R5RS.
(It is distinguished by default).  @xref{Case-sensitivity}.
@item test
Adds "@code{../src}" and "@code{../lib}" to the load path before loading 
initialization file.  This is useful when you want to test the
compiled @code{gosh} interpreter inside source tree, without installing it.
@end table
@end deftp

@deftp {Command Option} -p profiler-option
Turn on the profiler.  The following @var{profiler-option} is recognized:

@table @code
@item time
Records and reports time spent on function calls and number of times
each function is called.
@item load
Records and reports time spent on loading each modules.
Useful to tune start-up time of the scripts.
(Results are in elapsed time).
@end table

See @ref{Using profiler} for the details of the profiler.
@end deftp


@deftp {Command Option} @code{--}
When @code{gosh} sees this option, it stops processing the options
and takes next command line argument as a script file.  It is useful
in case if you have a script file that begins with a minus sign,
although it is not generally recommended.
@end deftp

The options -I, -A, -l, -u, -e and -E are processes in the order
of appearance.  For example, adding a load path by -I affects the
-l and -u option after it but not before it.

@subheading Environment variables

The following environment variables are recognized:

@deftp {Environment variable} GAUCHE_LOAD_PATH
You can specify additional load paths by this environment
variable, delimiting the paths by '@code{:}'.
The paths are appended before the system default load paths.
@end deftp

@deftp {Environment variable} GAUCHE_DYNLOAD_PATH
You can specify additional load paths for dynamically loaded
objects by this environment variable, delimiting the paths by '@code{:}'.
The paths are appended before the system default load paths.
@end deftp

@c ----------------------------------------------------------------------
@node Interactive development, Writing Scheme scripts, Invoking Gosh, Programming in Gauche
@section Interactive development
@c NODE  インタラクティブな開発

When @code{gosh} is invoked without any script files,
it goes into interactive read-eval-print loop.

To exit the interpreter, type EOF (usually Control-D in Unix terminals)
or evaluate @code{(exit)}.

In interactive session, @code{gosh} loads @code{gauche.interactive}
module (@xref{Interactive session}) for the
convenience.  The module also loads a file @file{.gaucherc} under
the user's home directory if it exists.
You may put settings there that would help interactive debugging.
(As of Gauche release 0.7.3,
@file{.gaucherc} is no longer loaded when @code{gosh} is run
in script mode.)

I recommend you to run @code{gosh} inside Emacs, for it has
rich features useful to interact with internal Scheme process.
Put the following line to your @file{.emacs} file:
@example
(setq scheme-program-name "gosh -i")
@end example
And you can run @code{gosh} by @key{M-x run-scheme}.

If you want to use multibyte characters in the interaction,
make sure your terminal's settings is in sync with @code{gosh}'s
internal character encodings.

Currently @code{gosh} has no fancy features such as
line-editing or command history.   They'll be added in future.

@c ----------------------------------------------------------------------
@node Writing Scheme scripts, Debugging, Interactive development, Programming in Gauche
@section Writing Scheme scripts
@c NODE Schemeスクリプトを書く

When a Scheme program file is given to @code{gosh}, it
bounds a global variable @code{*argv*} to the list of the remaining
command-line arguments, then loads the Scheme program.
If the first line of @var{scheme-file} begins with two character
sequence ``@code{#!}'', the entire line is ignored by @code{gosh}.
This is useful to write a Scheme program that works as an executable
script in unix-like systems.

Typical Gauche script has the first
line like these
@example
#!/usr/local/bin/gosh
  @r{or,}
#!/usr/bin/env gosh
  @r{or,}
#!/bin/sh
:; exec gosh -- $0 "$@@"
@end example
The second and third form uses a ``shell trampoline'' technique
so that the script works as far as @code{gosh} is in the PATH.
The third form is useful when you want to pass extra arguments
to @code{gosh}, for typically @code{#!}-magic of executable scripts
has limitations for the number of arguments to pass the interpreter.

After the file is successfully loaded, @code{gosh} calls a
procedure named `@code{main}' if it is defined in the user module.
@code{Main} receives a single argument, a list of command line
arguments.  Its first element is the script name itself.

When @code{main} returns, and its value is an integer, @code{gosh}
uses it for exit code of the program.
Otherwise, @code{gosh} exits with exit code 70 (@code{EX_SOFTWARE}).
This behavior is compatible with the SRFI-22.

If the @code{main} procedure is not defined, @code{gosh} exits
after loading the script file.

Although you can still write the program
main body as toplevel expressions, like shell scripts or Perl scripts,
it is much convenient to use this `@code{main}' convention, for
you can load the script file interactively to debug.


@defvar *argv*
The program arguments passed to the Scheme script is bound to this
variable.  If @code{gosh} is invoked in an interactive mode, this
variable always contains @code{()}.

STk uses this variable to pass the command line argument as well,
but other Scheme implementations use different ways.  It is better
to define @code{main} procedure and uses its argument to receive
command line arguments, for it is expected to be more portable.
@end defvar

@defvar *program-name*
This variable is bound to the script file name passed to @code{gosh}.
If @code{gosh} is invoked in the interactive mode, this variable
contains the pathname of @code{gosh} itself.

STk uses the same variable to access the program/script name.
Other Scheme implementations use different ways.
@end defvar

Now I show several simple examples below.
First, this script works like @code{cat(1)}, without any command-line
option processing and error handling.

@example
#!/usr/bin/env gosh

(define (main args)   ;@r{entry point}
  (if (null? (cdr args))
      (copy-port (current-input-port) (current-output-port))
      (for-each (lambda (file)
                  (call-with-input-file file
                    (lambda (in)
                      (copy-port in (current-output-port)))))
                (cdr args)))
  0)
@end example

The following script is a simple grep command.

@example
#!/usr/bin/env gosh

(define (usage)
  (format (current-error-port)
          "Usage: ~a regexp file ...\n" *program-name*)
  (exit 2))

(define (grep rx port)
  (with-input-from-port port
    (lambda ()
      (port-for-each
       (lambda (line)
         (when (rxmatch rx line)
           (format #t "~a:~a: ~a\n"
                   (port-name port)
                   (- (port-current-line port) 1)
                   line)))
       read-line))))

(define (main args)
  (if (null? (cdr args))
      (usage)
      (let ((rx (string->regexp (cadr args))))
        (if (null? (cddr args))
            (grep rx (current-input-port))
            (for-each (lambda (f)
                        (call-with-input-file f
                          (lambda (p) (grep rx p))))
                      (cddr args)))))
  0)
@end example

See also @ref{Parsing command-line options}, for a convenient way to
parse command-line options.

@c ----------------------------------------------------------------------
@node Debugging, Platform-dependent features, Writing Scheme scripts, Programming in Gauche
@section Debugging
@c NODE デバッグ

Gauche doesn't have much support for debugging yet.
The idea of good debugging interfaces are welcome.

For now, the author uses the classic 'debug print stub' technique
when necessary.  A special reader syntax @code{#?=@var{expr}} is
defined, which is read as @code{(debug-print @var{expr})}.
The macro @code{debug-print} evaluates and returns the result(s),
printing messages before and after evaluation of @var{expr}.

@example
gosh> #?=(+ 2 3)
#?="(stdin)":1:(+ 2 3)
#?-    5
5
gosh> #?=(begin (print "foo") (values 'a 'b 'c))
#?="(stdin)":2:(begin (print "foo") (values 'a 'b 'c))
foo
#?-    a
#?+    b
#?+    c
a
b
c
gosh> (define (fact n)
        (if (zero? n)
            1
            (* n #?=(fact (- n 1)))))
fact
gosh> (fact 5)
#?="(stdin)":6:(fact (- n 1))
#?="(stdin)":6:(fact (- n 1))
#?="(stdin)":6:(fact (- n 1))
#?="(stdin)":6:(fact (- n 1))
#?="(stdin)":6:(fact (- n 1))
#?-    1
#?-    1
#?-    2
#?-    6
#?-    24
120
@end example

You can also use trace/untrace macros in Gauche, written by Shigenobu Kimura:
@url{http://homepage.mac.com/skimu/ggc/}.

@c ----------------------------------------------------------------------
@node Platform-dependent features, Profiling and tuning, Debugging, Programming in Gauche
@section Using platform-dependent features
@c NODE プラットフォーム依存の機能

Gauche tries to provide low-level APIs close to what the underlying
system provides, but sometimes they vary among systems.  For example,
POSIX does not require @code{symlink}, so some systems may lack
@code{sys-symlink} (@xref{Directory manipulation}).  Quite a few
unix-specific system functions are not available on Windows platform.
To allow writing a portable program across those platforms, Gauche
uses @code{cond-expand} (@xref{Feature conditional}) extensively.
A set of extended @emph{feature-identifier}s is provided to check
availability of specific features.  For example, on systems that
has @code{symlink}, a feature identifier @code{gauche.sys.symlink}
is defined.   So you can write a code that can switch based on
the availability of @code{sys-symlink} as follows:

@example
(cond-expand
 (gauche.sys.symlink
   ... code that uses sys-symlink ...)
 (else
   ... alternative code ...)
 )
@end example

If you're familiar with system programming in C, you can think
it equivalent to the following C idiom:

@example
#if defined(HAVE_SYMLINK)
... code that uses symlink ...
#else
... alternative code ...
#endif
@end example

There are quite a few such feature identifiers; each identifier is
explained in the maunal entry of the procedures that depend on the feature.
Here we list a few important ones:

@table @code
@item gauche
This feature identifier is always defined.  It is useful when you
write Scheme code portable across multiple implementations.
@item gauche.os.windows
Defined on Windows native platform (currently using MinGW, but we'll
have VC++ version in future).  Note that cygwin is considered unix.
@item gauche.sys.pthreads
Defined if Gauche is compiled with pthread support.
@item gauche.net.ipv6
Defined if Gauche is compiled with IPv6 support.
@end table

Because @code{cond-expand} is a macro, the body of clauses
are expanded into toplevel if @code{cond-expand} itself is in
toplevel.  That means you can switch toplevel definitions:

@example
(cond-expand
 (gauche.os.windows
  (define (get-current-user)
    ... get current username ...))
 (else
  (define (get-current-user)
    (sys-uid->user-name (sys-getuid)))))
@end example

Or even conditionally "use" the modules:

@example
(cond-expand
 (gauche.os.windows
   (use "my-windows-compatibility-module"))
 (else))
@end example

The traditional technique of testing a toplevel binding at runtime
(using @code{global-variable-bound?}, @xref{Module introspection})
does not work well, since the test is done in runtime, while
the @code{use} form takes effect at compile time.  It is strongly
recommended to use @code{cond-expand} whenever possible.

Currently the set of feature identifiers are fixed at the build
time of Gauche, so it's less flexible than C preprocessor conditionals.
We have a plan to extend this feature to enable adding new feature
identifiers; but such feature can complicate semantics when compilation
and execution is interleaved, so we're carefully assessing the effects now.

A couple of notes:

Feature identifiers are not variables.  They can only be used
within the @var{feature-requirement} part of @code{cond-expand}
(see @ref{Feature conditional} for the complete definition of
feature requirements).

By definition of @code{srfi-0}, @code{cond-expand} raises an error
if no feature requirements are satisfied and there's no @code{else}
clause.  A rule of thumb is to provide @code{else} clause always,
even it does nothing (like the above example that has empty @code{else}
clause).

@c ----------------------------------------------------------------------
@node Profiling and tuning, Writing Gauche modules, Platform-dependent features, Programming in Gauche
@section Profiling and tuning
@c NODE プロファイリングとチューニング

If you find your script isn't running fast enough,
there are several possibilities to improve its performance.

It is always a good idea to begin with finding which part
of the code is consuming the execution time.   Gauche has
a couple of basic tools to help it.  A built-in sampling profiler,
explained in the following subsection, can show how much time
is spent in each procedure, and how many times it is called.
The @code{gauche.time} module (@ref{Measure timings}) provides
APIs to measure execution time of specific parts of the code.

Optimization is specialization---you look for the most common
patterns of execution, and put a special path to support those
patterns efficiently.  Gauche itself is no exception, so there
are some patterns Gauche can handle very efficiently, while
some patterns it cannot.  The next subsection, @ref{Performance tips},
will give you some tips of how to adapt your code to fit
the patterns Gauche can execute well.

@menu
* Using profiler::              
* Performance tips::            
@end menu

@node Using profiler, Performance tips, Profiling and tuning, Profiling and tuning
@subsection Using profiler
@c NODE プロファイラを使う

As of 0.8.4, Gauche has a built-in profiler.  It is still experimental
quality and only be tested on Linux.  It isn't available for all
platforms.   It works only in single-thread applications for now.

To use the profiler non-interactively, give @code{-ptime}
command-line option to gosh. 

@example
% gosh -ptime your-script.scm
@end example

After the execution of @file{your-script.scm} is completed, Gauche prints
out the table of functions with its call count and its consumed time,
sorted by the total consumed time.

@example
Profiler statistics (total 1457 samples, 14.57 seconds)
                                                    num    time/    total
Name                                                calls  call(ms) samples
---------------------------------------------------+------+-------+-----------
combinations*                                       237351  0.0142   337( 23%)
(lset-difference #f)                               1281837  0.0020   256( 17%)
(make-anchor make-anchor)                          3950793  0.0005   198( 13%)
member                                             4627246  0.0004   190( 13%)
filter                                              273238  0.0030    81(  5%)
every                                              1315131  0.0004    59(  4%)
(lset-difference #f #f)                            1281837  0.0004    54(  3%)
(make-entry make-entry)                             730916  0.0005    40(  2%)
(clear? #f)                                         730884  0.0005    33(  2%)
(initialize #f)                                     599292  0.0005    32(  2%)
fold                                                237307  0.0013    30(  2%)
acons                                               806406  0.0004    29(  1%)
clear?                                               33294  0.0084    28(  1%)
(combinations* #f)                                  805504  0.0002    15(  1%)
(make-exit make-exit)                               730884  0.0002    15(  1%)
lset-difference                                     237318  0.0006    15(  1%)
reverse!                                            475900  0.0001     6(  0%)
(fold <top> <top> <list>)                           237323  0.0003     6(  0%)
procedure?                                          238723  0.0002     4(  0%)
pair?                                               237307  0.0001     3(  0%)
 :
 :
@end example

Note that the time profiler uses statistic sampling.  Every 10ms
the profiler interrupts the process and records the function that is
executed then.   Compared to the individual execution time per
function call, which is the order of nanoseconds, this sampling rate
is very sparse.  However, if we run the program long enough,
we can expect the distribution of samples per each function 
approximately reflects the distribution of time spent in each function.

Keep in mind that the number is only approximation; the number
of sample counts for a function may easily vary if the program deals
with different data sets.   It should also be noted that, for now, GC 
time is included in the function in which GC is triggered.
This sometimes causes a less important function to "float up" to
near-top of the list.  
To know the general pattern, it is a good custom to run the program
with several different data sets.

On the other hand, the call count is accurate since Gauche actually
counts each call.

Because all functions are basically anonymous in Scheme, the 'name' field of
the profiler result is only a hint.  The functions bound at toplevel
is generally printed with the global variable name it is bound at
the first time.  Internal functions are printed as a list of names,
reflecting the nesting of functions.  Methods are also printed as a
list of the name and specializers.

The profiler has its own overhead; generally the total
process time will increase 20-30%.
If you want to turn on the profiler selectively, or you're running
a non-stop server program and want to obtain the statistics without
exiting the server, you can call the profiler API from your program;
see @ref{Profiler API}, for the details.

@node Performance tips,  , Using profiler, Profiling and tuning
@subsection Performance tips
@c NODE パフォーマンスに関するヒント

Don't guess, just benchmark.  It is the first rule of
performance tuning.  Especially for the higher-level languages 
like Scheme, what impacts on performance greatly depends on
the implementation.  Certain operations that are very cheap
on an implementation may be costly on others.
Gauche has such implementation-specific characteristics, and
to know some of them would help to see what to look out in
the benchmark results.

"80% of execution time is spent in 20% of the code" is another
old saying.  Don't obscure your code by "potential" optimization
that has little impact on the actual execution.  We describe some
tips below, but it doesn't mean you need to watch them all the time.
It is better to keep most of the code clean and easy to understand,
and only do tricks on the innermost loop.

@strong{Ports}: To satisfy the specification of SRFI-18 (Threading),
every call to I/O primitives of Gauche locks the port.
This overhead may be visible if the application does a lot of I/O
with smaller units (e.g. every bytes).   The primitives that deals
with larger unit, such as @code{read} and @code{read-block}, are less
problematic, since usually they just lock the port once per call and do
all the low-level I/O without the lock overhead.
(Note: this doesn't mean those primitives @emph{guarantee}
to lock the port throughout the execution of the function;
furthermore, the port locking feature is optimized for the case
that port accesses rarely collide.  If you know it is possible that
more than one threads read from or write to the same port, it is
your responsibility to use mutex explicitly to avoid the collision.)

If you find out the locking is indeed a bottleneck, there are couple
of things you can consider: (1) Try using the larger-unit primitives,
instead of calling the smaller-unit ones.  (2) Use @code{with-port-locking}
(see @ref{Port and threads}) to lock the port in larger context.

@strong{Strings}: Because of the multibyte strings, two operations
are particularly heavy in Gauche: string mutation and indexed string access.
It is a design choice; we encourage the programming style that
avoids those operations.  When you sequentially access the string,
string ports (see @ref{String ports}) provide a cleaner and
more efficient way.
When you search and retrieve a substring, there are various
higher-level primitives are provided (see @ref{String utilities},
@ref{Regular expression}, and @ref{String library}, for example).
If you're using strings to represent an octet sequence, use uniform
vectors (see @ref{Uniform vectors}) instead.

@strong{Deep recursion}: Gauche's VM uses a stack for efficient
local frame allocation.  If recursion goes very deep (depending on
the code, but usually several hundreds to a thousand), the stack
overflows and Gauche moves the content of the stack into the heap.
This incurs some overhead.  If you observe a performance degradation
beyond a certain amount of data, check out this possibility.

@strong{Generic functions}: Because of its dynamic nature, generic
function calls are slower than procedure calls.  Not only because
of the runtime dispatch overhead, but also because Gauche's compile-time
optimizer can't do much optimization for generic function calls.
You don't need to avoid generic functions because of performance
reasons in general, but if you do find single function call consuming
a large part of execution time and it is calling a generic
function in its inner loop---then it may be worth to modify it.

@strong{Redefining builtin functions}: Gauche inlines some builtin
functions if they are not redefined.  Although sometimes it is useful
to redefine basic functions, you may want to limit the effect.
For example, put redefined functions in a separate module and
use the module in the code that absolutely needs those functions
replaced.  

@strong{Closure creation}: When you create a closure, its closing environment
is copied to the heap.  This overhead is small, but it still may be
visible when a closure is created within an innermost loop that is
called millions of times.   If you suspect this is a problem,
try disassemble the function.   Gauche's compiler uses some basic
techniques of closure analysis to avoid creating closures for
typical cases, in which case you see the local function's bodies
are inlined.  If you see a @code{CLOSURE} instruction, though, it
means a closure is created.

This list isn't complete, and may change when Gauche's implementation
is improved, so don't take this as fixed features.
We'll adjust it occasionally.

@c ----------------------------------------------------------------------
@node Writing Gauche modules, Using extension packages, Profiling and tuning, Programming in Gauche
@section Writing Gauche modules
@c NODE Gaucheのモジュールを書く

Gauche's libraries are organized by modules.   Although Gauche
can load any valid Scheme programs, there is a convention that
Gauche's libraries follow.    When you write a chunk of Scheme
code for Gauche, it is convenient to make it a module,
so that it can be shared and/or reused.

Usually a module is contained in a file, but you can make
a multi-file module.   
First I explain the structure of a single-file module.
The following template is the convention used in Gauche's libraries.

@example
;; Define the module interface
(define-module foo
  (use xxx)
  (use yyy)
  (export foo1 foo2 foo3)
  )
;; Enter the module
(select-module foo)

@dots{} module body @dots{}

;; Make `require' happy
(provide "foo")
@end example

This file must be saved as ``foo.scm'' in some directory in the
@code{*load-path*}.

The @code{define-module} form creates a module @code{foo}.
It also loads and imports some other modules by `@code{use}' macros,
and declares which symbols the @code{foo} module exports, by `@code{export}'
syntax.
(See section @ref{Defining and selecting modules}, for detailed specification of those
syntaxes).

Those @code{use} forms or @code{export} forms are not required to appear
in the @code{define-module} form, but it is a good convention to keep
them in there at the head of the file so that it is visually recognizable
which modules @code{foo} depends and which symbols it exports.

The second form, `@code{select-module}', 
specifies the rest of the file is evaluated in the
module @code{foo} you just defined.   Again, this is just a
convention; you can write entire module body inside @code{define-module}.
However, I think it is error-prone, for the closing parenthesis
can be easily forgotten or the automatic indentation mechanism of
editor will be confused.

After @code{select-module} you can write whatever Scheme expression.
It is evaluated in the selected module, @code{foo}.   Only the bindings
of the exported symbols will be directly accessible from outside.

The last @code{provide} form is just a cliche.  It is needed since
the `use' mechanism uses traditional require-provide mechanism (if you
don't know about it, it's ok--just put it as a magic spell).

So, that's it.   Other programs can use your module by just saying
`@code{(use foo)}'.   If you want to make your module available on your site,
you can put it to the site library location, which can be obtained by
@example
(gauche-site-library-directory)
@end example
in gosh, or
@example
gauche-config --sitelibdir
@end example
from shell.

If you feel like to conserve global module name space, you can organize
modules hierarchically.   Some Gauche libraries already does so.
@xref{Library modules - Overview}, for examples.
For example, @code{text.tr} module is implemented in ``text/tr.scm'' file.
Note that the pathname separator `/' in the file becomes a period in the
module name.

@c ----------------------------------------------------------------------
@node Using extension packages,  , Writing Gauche modules, Programming in Gauche
@section Using extension packages
@c NODE 拡張パッケージの使用

@subheading Building and installing packages

Gauche comes with some amount of libraries, but they aren't 
enough at all to use Gauche in the production environment. 
There are number of additional libraries available.   We call them 
@emph{extension packages}, or simply packages.  Each package
usually provides one or more modules that adds extra
functionality.   Most of the packages provide
binding to other C libraries, such as graphics libraries
or database clients.   If the package has some C code,
it is likely that you need to compile it on your machine with
the installed Gauche system.

Usually a package is in the form of compressed tarball, and the standard
"ungzip + untar + configure + make + make install" sequence does the job.
Read the package's document, for you may be able to tailor
the library for your own needs by giving command-line options
to the @code{configure} script.

From Gauche 0.8, an utility script called @code{gauche-package} is
installed for the convenience.  It automates the build and install
process of packages.

Suppose you have downloaded a package @file{Package-1.0.tar.gz}.
If the package follows the convention, all you have to do is
to type this:

@example
$ gauche-package install Package-1.0.tar.gz
@end example

It ungzips and untars the package, @code{cd} into the @file{Package-1.0}
subdirectory, run configure, make, and make install.
By default, @code{gauche-package} untars the tarball in the current
working directory.  You can change it by a customization file; see below.

If you need a special priviledge to install the files, you can
use @code{--install-as} option which runs @code{make install} part via
the @code{sudo} program.

@example
$ gauche-package install --install-as=root Package-1.0.tar.gz
@end example

If it doesn't work for you, you can just build the package
by @code{gauche-package build Package-1.0.tar.gz}, then
manually cd to the @file{Package-1.0} directory and run 
@code{make install}.

You can give configuration options via @code{-C} or @code{--configure-options}
command-line argument, like this:

@example
$ gauche-package install -C "--prefix=/usr/local" Package-1.0.tar.gz
@end example

If the package has adopted the new package description file, 
it can remember the configuration options you have specified, and
it will automatically reuse them when you install the package
again.  (If you're a package developer, check out 
@file{examples/spigot/README} file in the Gauche source tree
to see how to cooperate with Gauche's package management system.)

If you don't have a tarball in your local directory, but you know
the URL where you can download it, you can directly give the URL
to @code{gauche-package}.  It understands @code{http} and @code{ftp},
and uses either @code{wget} or @code{ncftpget} to download the tarball,
then runs configure and make.

@example
$ gauche-package install http://www.example.com/download/Package-1.0.tar.gz
@end example

@subheading Customizing @code{gauche-package}

The @code{gauche-package} program reads @file{~/.gauche-package} if
it exists.  It must contain an associative list of parameters.
It may look like this:

@example
(
 (build-dir . "/home/shiro/tmp")
 (gzip      . "/usr/local/bin/gzip")
 (bzip2     . "/usr/local/bin/bzip2")
 (tar       . "/usr/local/bin/gtar")
)
@end example

The following is a list of recognized parameters.
If the program isn't given in the configuration file, @code{gauche-package}
searches @code{PATH} to find one.

@table @code
@item build-dir
A directory where the tarball is extracted.  If URL is given,
the downloaded file is also placed in this directory.
@item bzip2
Path to the program @code{bzip2}.
@item cat
Path to the program @code{cat}.
@item make
Path to the program @code{make}.
@item ncftpget
Path to the program @code{ncftpget}.
@item rm
Path to the program @code{rm}.
@item sudo
Path to the program @code{sudo}.
@item tar
Path to the program @code{tar}.
@item wget
Path to the program @code{wget}.
@end table
@node Core syntax, Macros, Programming in Gauche, Top
@chapter Core syntax
@c NODE 基本的な構文

@c ----------------------------------------------------------------------
@menu
* Lexical structure::           
* Literals::                    
* Making Procedures::           
* Assignments::                 
* Conditionals::                
* Binding constructs::          
* Sequencing::                  
* Iteration::                   
* Quasiquotation::              
* Definitions::                 
* Modules::                     
@end menu

@node Lexical structure, Literals, Core syntax, Core syntax
@section Lexical structure
@c NODE 字句構造

Gauche extends R5RS Scheme parser in some ways:

@table @emph
@item Nested block comments (SRFI-30)
A text surrounded by '@code{#|}' and '@code{|#}' becomes a comment.
It can be nested.

@item Numeric literals
Either integral part or fraction part of inexact real numbers can be omitted
if it is zero, i.e. @code{30.}, @code{.25}, @code{-.4} are read as 
real numbers. 
The number reader recognizes '@code{#}' as insignificant digits.
Complex numbers can be written both in the rectangular format
(e.g. @code{1+0.3i}) and in the polar format (e.g. 3.0@@1.57).
Inexact real numbers include
the positive infinity, the negative infinity, and NaN,
which are represented as @code{+inf.0}, @code{-inf.0} and @code{+nan.0},
respectively.  (@code{-nan.0} is also read as NaN.)

@item Symbol names
Symbol names are case sensitive by default (@xref{Case-sensitivity}).
Symbol name can begin with digits, '@code{+}' or '@code{-}', as long as
the entire token doesn't consist valid number syntax.
Other weird characters can be included in a symbol name by surrounding
it with '|', e.g. '@code{|this is a symbol|}'.
@xref{Symbols}, for details.

@item Character literal by character code
Character literals can be written using its code, 
by @code{#\x@var{NN}} (Gauche internal code) or @code{#\u@var{NN}} (Unicode).
@xref{Characters}, for details.

@item Extended sharp syntax
Many more special tokens begins with '@code{#}' are defined.
See the table below.
@end table

The table below lists sharp-syntaxes.

@multitable {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item @code{#!}
 @tab [R6RS][SRFI-22] It is either a beginning of an interpreter line
      (shebang) of a script, or a special token that affects the mode
      of the reader.  See `hash-bang token' section below.
@item @code{#"}, @code{##}, @code{#$}, @code{#%}, @code{#&}, @code{#'}
 @tab Unused.
@item @code{#(}
 @tab [R5RS] Introduces a vector.
@item @code{#)}
 @tab Unused.
@item @code{#*}
 @tab If followed by a double quote, denotes an incomplete string.  @xref{Strings}.
@item @code{#+}
 @tab Unused.
@item @code{#,}
 @tab [SRFI-10] Introduces reader constructor syntax.
@item @code{#-}, @code{#.}
 @tab Unused.
@item @code{#/}
 @tab Introduces a literal regular expression.  @xref{Regular expression}.
@item @code{#0} @dots{} @code{#9}
 @tab [SRFI-38] Shared substructure definition and reference.
@item @code{#:}
 @tab Unused
@item @code{#;}
 @tab [SRFI-62] S-expression comment.  Reads next one S-expression and
      discard it.
@item @code{#<}
 @tab Introduces an unreadable object.
@item @code{#=}, @code{#>}
 @tab Unused.
@item @code{#?}
 @tab Introduces debug macros.  @xref{Debugging}.
@item @code{#@@}
 @tab Unused.
@item @code{#a}
 @tab Unused.
@item @code{#b}
 @tab [R5RS] Binary number prefix.
@item @code{#c}
 @tab Unused.
@item @code{#d}
 @tab [R5RS] Decimal number prefix.
@item @code{#e}
 @tab [R5RS] Exact number prefix.
@item @code{#f}
 @tab [R5RS] Boolean false, or
      introducing SRFI-4 uniform vector.  @xref{Uniform vectors}.
@item @code{#g}, @code{#h}
 @tab Unused.
@item @code{#i}
 @tab [R5RS] Inxact number prefix.
@item @code{#j}, @code{#k}, @code{#l}, @code{#m}, @code{#n}
 @tab Unused.
@item @code{#o}
 @tab [R5RS] Octal number prefix.
@item @code{#p}, @code{#q}, @code{#r}
 @tab Unused.
@item @code{#s}
 @tab [SRFI-4] introducing SRFI-4 uniform vector.  @xref{Uniform vectors}.
@item @code{#t}
 @tab [R5RS] Boolean true.
@item @code{#u}
 @tab [SRFI-4] introducing SRFI-4 uniform vector.  @xref{Uniform vectors}.
@item @code{#v}, @code{#w}
 @tab Unused.
@item @code{#x}
 @tab [R5RS] Hexadecimal number prefix.
@item @code{#y}, @code{#z}
 @tab Unused.
@item @code{#[}
 @tab Introduces a literal character set.  @xref{Character set}.
@item @code{#\}
 @tab [R5RS] Introduces a literal character.  @xref{Characters}.
@item @code{#]}, @code{#^}, @code{#_}
 @tab Unused.
@item @code{#`}
 @tab Introduces an interpolated string.  @xref{String interpolation}.
@item @code{#@{}
 @tab Unused.
@item @code{#|}
 @tab [SRFI-30] Introduces a block comment.  Comment ends by matching '@code{|#}'.
@item @code{#@}}, @code{#~}
 @tab Unused.
@end multitable

@subheading Hash-bang token

A character sequence @code{#!} has two completely different
semantics, depending on how and where it occurs.

If a file begins with @code{#!/} or @code{#! } (hash, bang, and a
space), then the reader assumes it is an interpreter line (shebang) of
a script and ignores the rest of characters until the end of line.
(Actually the source doesn't need to be a file.  The reader checks
whether it is the beginning of a port.)
      
Other than the above case, @code{#!@var{identifier}} is read as
a token with special meanings.  This kind token can be a special
directive for the reader, instead of read as a datum.

By default, three of such tokens are recognized.  @code{#!fold-case}
and @code{#!no-fold-case} switches the reader's case sensitivity;
@code{#!fold-case} makes the reader case insensitive, and
@code{#!no-fold-case} makes it case sensitive.  (Also see
@ref{Case-sensitivity}).

The token @code{#!r6rs} is introduced in R6RS and used to indicate the
program is strictly conforms R6RS.  Gauche doesn't support R6RS, and
currently it issues warning when it sees @code{#!r6rs} token, though
it keeps reading on.

@c ----------------------------------------------------------------------
@node Literals, Making Procedures, Lexical structure, Core syntax
@section Literals
@c NODE リテラル

@defspec quote datum
[R5RS]
Evaluates to @var{datum}.
@example
(quote x) @result{} x
(quote (1 2 3)) @result{} (1 2 3)
@end example
@end defspec

@deftp {Reader Syntax} @code{'@var{datum}}
[R5RS]
Equivalent to @code{(quote datum)}.
@example
'x @result{} x
'(1 2 3) @result{} (1 2 3)
@end example
@end deftp

@emph{Note:}  R5RS says it is an error to alter the value of
a literal expression.
Gauche doesn't check constant-ness of pairs and vectors, and does
not signal an error if you modify them using the destructive
procedures such as @code{set-car!}
and @code{vector-set!}.  Doing so will cause unexpected results.
Gauche does check constant-ness of strings, and signals an error
if you try to alter a constant string.

@c ----------------------------------------------------------------------
@node Making Procedures, Assignments, Literals, Core syntax
@section Making Procedures
@c NODE  手続きを作る

@defspec lambda formals body @dots{}
[R5RS]
Evaluates to a procedure.  The environment in effect when this expression
is evaluated is stored in the procedure.   When the procedure
is called, @var{body} is evaluated sequentially in the
stored environment extended by the bindings of the formal arguments,
and returns the value(s) of the last expression in the body.

@var{Formals} should have one of the following forms:
@itemize @bullet
@item
@code{(@var{variable} @dots{})} : The procedure takes a fixed number of
arguments.  The actual arguments are bound to the corresponding
variables.
@item
@code{@var{variable}} : The procedure takes any number of arguments.
The actual arguments are collected to form a new list and bound to
the variable.
@item
@code{(@var{variable_0} @dots{} @var{variable_N-1}. @var{variable_N})} : 
The procedure takes at least @var{N} arguments.  The actual arguments
up to @var{N} is bound to the corresponding variables.
If more than @var{N} arguments are given, the rest arguments are
collected to form a new list and bound to @var{variable_N}.
@end itemize

@example
(lambda (a b) (+ a b))
  @result{} @r{procedure that adds two arguments}

((lambda (a b) (+ a b)) 1 2)
  @result{} 3
@end example
@end defspec

@emph{Note:} Some Scheme implementations extend the syntax of @var{formals}
to have notation of optional arguments or keyword arguments, similar to
CommonLisp's.  Gauche doesn't have such extensions now.

@defmac cut expr-or-slot expr-or-slot2 @dots{}
@defmacx cute expr-or-slot expr-or-slot2 @dots{}
[SRFI-26]
Convenience macros to notate a procedure compactly.
This form can be used to realize partial application, 
a.k.a sectioning or projection.

Each @var{expr-or-slot} must be either an expression or a symbol @code{<>},
indicating a 'slot'.
The last @var{expr-or-slot} can be a symbol @code{<...>},
indicating a 'rest-slot'.
@code{Cut} expands into a @code{lambda} form that takes as many arguments
as the number of slots in the given form, and 
whose body is an expression
@example
  (@var{expr-or-slot} @var{expr-or-slot2} @dots{})
@end example
where each occurrence of @code{<>} is replaced to the corresponding
argument.
In case there is a rest-slot symbol, the resulting procedure is also
of variable arity, and all the extra arguments are passed
to the call of @var{expr-or-slot}.  See the fourth example below.

@example
(cut cons (+ a 1) <>)  @equiv{} (lambda (x2) (cons (+ a 1) x2))
(cut list 1 <> 3 <> 5) @equiv{} (lambda (x2 x4) (list 1 x2 3 x4 5))
(cut list)             @equiv{} (lambda () (list))
(cut list 1 <> 3 <...>)
   @equiv{} (lambda (x2 . xs) (apply list 1 x2 3 xs))
(cut <> a b)           @equiv{} (lambda (f) (f a b))

;; Usage
(map (cut * 2 <>) '(1 2 3 4))
(for-each (cut write <> port) exprs)
@end example

@code{Cute} is a variation of @code{cut} that evaluates @code{expr-or-slot}s
before creating the procedure.

@example
(cute cons (+ a 1) <>)
   @equiv{} (let ((xa (+ a 1))) (lambda (x2) (cons xa x2)))
@end example

Gauche also has a built-in procedure @code{pa$} for partial application
(@xref{Combinators}).
@end defmac

@defmac case-lambda clause @dots{}
[SRFI-16]
Each @var{clause} should have the form (@var{formals} @var{expr} @dots{}),
where @var{formals} is a formal arguments list as for @code{lambda}.

This expression evaluates to a procedure that accepts a variable
number of arguments and is lexically scoped in the same manner as
procedures resulting from @code{lambda} expressions.
When the procedure is called with some arguments,
then the first @var{clause} for which the arguments agree with
@var{formals} is selected, where agreement is specified as for
the @var{formals} of a @code{lambda} expression.
The variables of @code{formals} are bound to the given
arguments, and the @var{expr} @dots{} are evaluated within the environment.

It is an error for the arguments not to agree with
the @var{formals} of any @var{clause}.
@end defmac

@c ----------------------------------------------------------------------
@node Assignments, Conditionals, Making Procedures, Core syntax
@section Assignments
@c NODE  代入

@defspec set! symbol expression
@defspecx set! (proc arg @dots{}) expression
[R5RS][SRFI-17]
First, @var{expression} is evaluated.
In the first form, the binding of @var{symbol} is modified
so that next reference of @var{symbol} will return
the result of @var{expression}.
If @var{symbol} is not locally bound, the global variable named @var{symbol}
must already exist, or an error is signalled.

The second form is a ``generalized set!'' specified in SRFI-17.
It is a syntactic sugar of the following form.
@example
((setter @var{proc}) @var{arg} @dots{} @var{expression})
@end example
Note the order of the arguments of the setter method
differs from CommonLisp's @code{setf}.

Some examples:

@example
(define x 3)
(set! x (list 1 2))  @result{} @r{undefined}
x                    @result{} (1 2)

(set! (car x) 5)     @result{} @r{undefined}
x                    @result{} (5 2)
@end example
@end defspec

@defmac set!-values (var @dots{}) expr
Sets values of multiple variables at once.  @var{Expr} must yield
as many values as @var{var} @dots{}.  Each value is set to
the corresponding @var{var}.
@example
(define a 0)
(define b 1)
(set!-values (a b) (values 3 4)) @result{} @r{undefined}
a @result{} 3
b @result{} 4
(set!-values (a b) (values b a)) @result{} @r{undefined}
a @result{} 4
b @result{} 3
@end example
@end defmac

@defun setter proc
[SRFI-17]
Returns a setter procedure associated to the procedure @var{proc}.
If no setter is associated to @var{proc}, its behavior is undefined.

A setter procedure @var{g} of a procedure @var{f} is such that when used
as @code{(g a b @dots{} v)}, the next evaluation of @code{(f a b @dots{})}
returns @var{v}.

To associate a setter procedure to another procedure, you can use
the setter of @code{setter}, like this:
@example
(set! (setter @var{f}) @var{g})
@end example

A procedure's setter can be ``locked'' to it.  System default setters,
like @code{set-car!} for @code{car}, is locked and can't be set by
the above way.   In order to lock a setter to a user defined procedure,
use @code{getter-with-setter} below.

If @var{proc} is not a procedure, a setter generic function
of @code{object-apply} is returned;
it allows the applicable object extension to work
seamlessly with the generalized @code{set!}.
@xref{Applicable objects}, for the details.
@end defun

@defun has-setter? proc
Returns @code{#t} if a setter is associated to @var{proc}.
@end defun

@defun getter-with-setter get set
[SRFI-17]
Takes two procedure @var{get} and @var{set}.  Returns a new
procedure which does the same thing as @var{get}, and its setter is
locked to @var{set}.

The intention of this procedure is, according to the SRFI-17 document,
to allow implementations to inline setters efficiently.  Gauche
hasn't implement such optimization yet.
@end defun

A few macros that adopts the same semantics of generalized @code{set!}
are also provided.  They are built on top of @code{set!}.

@defmac push! place item
Conses @var{item}
and the value of @var{place}, then sets the result to @var{place}.
@var{place} is either a variable or a form @var{(proc arg @dots{})}, 
as the second argument of @code{set!}.   The result of this form
is undefined.

@example
(define x (list 2))
(push! x 3) @result{} @r{undefined}
x @result{} (3 2)

(push! (cdr x) 4) @result{} @r{undefined}
x @result{} (3 4 2)
@end example

When @var{place} is a list, it roughly expands like the following.

@example
(push! (foo x y) item)
 @equiv{}
 (let ((tfoo foo)
       (tx x)
       (ty y))
   ((setter tfoo) tx ty (cons item (tfoo tx ty))))
@end example

Note: Common Lisp's @code{push} macro takes its argument reverse
order.   I adopted this order since it is consistent with other
destructive operations.  Perl's @code{push} function takes the same
argument order, but it appends @var{item} at the end of the array
(Perl's @code{unshift} is closer to @code{push!}).
You can use a queue (@xref{Queue}) if you need a behavior of Perl's
@code{push}.
@end defmac

@defmac pop! place
Retrieves the value of @var{place}, sets its cdr back to @var{place}
and returns its car.

@example
(define x (list 1 2 3))
(pop! x) @result{} 1
x @result{} (2 3)

(define x (vector (list 1 2 3)))
x @result{} #((1 2 3))
(pop! (vector-ref x 0)) @result{} 1
x @result{} #((2 3))
@end example

Note: This works the same as Common Lisp's @code{pop}.
Perl's @code{pop} pops value from the end of the sequence;
its @code{shift} does the same thing as @code{pop!}.
@end defmac


@defmac inc! place &optional delta
@defmacx dec! place &optional delta
Evaluates the value of @var{place}.  It should be a number.
Adds (@code{inc!}) or subtracts (@code{dec!}) @var{delta} to/from it,
and then stores the result to @var{place}.  The default value of
@var{delta} is 1.

This is Common Lisp's @code{incf} and @code{decf}.
@end defmac

@defmac update! place proc
Generalized form of @code{push!} etc.  @var{Proc} must be a procedure
which takes one argument and returns one value.   The original value of
@var{place} is passed to the @var{proc}, then its result is set to
@var{place}.
@example
(define a (cons 2 3))
(update! (car a) (lambda (v) (* v 3))) @result{} @r{undefined}
a @result{} (6 . 3)

(update! (cdr a) (cut - <> 3))
a @result{} (6 . 0)
@end example
@end defmac

@c ----------------------------------------------------------------------
@node Conditionals, Binding constructs, Assignments, Core syntax
@section Conditionals
@c NODE 条件式

@defspec if test consequent alternative
@defspecx if test consequent
[R5RS]
@var{Test} is evaluated.  If it yields a true value,
@var{consequent} is evaluated.  Otherwise, @var{alternative} is
evaluated.  If @var{alternative} is not provided, it results undefined value.

@example
(if (number? 3) 'yes 'no) @result{} yes
(if (number? #f) 'yes 'no) @result{} no

(let ((x '(1 . 2)))
  (if (pair? x)
      (values (car x) (cdr x))
      (values #f #f)))
  @result{} 1 @r{and} 2
@end example
@end defspec

@defspec cond clause1 clause2 @dots{}
[R5RS][SRFI-61]
Each @code{clause} must be the form
@example
(@var{test} @var{expr} @dots{})
(@var{test} => @var{expr})
(@var{test} @var{guard} => @var{expr})
(else @var{expr} @var{expr2} @dots{})
@end example
The last form can appear only as the last clause.

@code{cond} evaluates @var{test} of each clauses in order, until
it yields a true value.   Once it yields true, if the clause
is the first form,  the corresponding @var{expr}s are evaluated
and the result(s) of last @var{expr} is(are) returned; if the clause
is the second form, the @var{expr} is evaluated and it must yield
a procedure that takes one argument.  Then the result of @var{test}
is passed to it, and the result(s) it returns will be returned.

The third form is specified in SRFI-61.  In this form, @var{test}
can yield arbitrary number of values.  The result(s)
of @var{test} is(are) passed to @var{guard}; if it returns a true value,
@var{expr} is applied with an equivalent argument list, and its
result(s) is(are) returned.  If @var{guard} returns @code{#f},
the evaluation proceeds to the next clause.

If no test yields true, and the last clause is not the fourth form
(else clause), an undefined value is returned.

If the last clause is else clause and all tests are failed,
@var{expr}s in the else clause are evaluated, and its last
@var{expr}'s result(s) is(are) returned.

@example
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less)) @result{} greater
(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal)) @result{} equal
(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else #f)) @result{} 2
@end example
@end defspec


@defspec case key clause1 clause2 @dots{}
[R5RS][SRFI-87]
@var{Key} may be any expression. 
Each @var{clause} should have the form 
@example
((@var{datum} ...) @var{expr} @var{expr2} @dots{})
((@var{datum} ...) => @var{proc})
@end example
where each @var{datum} is an external representation of some object.
All the @var{datum}s must be distinct. The last @var{clause}
may be an ``else clause,'' which has the form 
@example
(else @var{expr} @var{expr2} @dots{})
(else => @var{proc})
@end example

First, @var{key} is evaluated and its result is compared against each
@var{datum}.  If the result of evaluating @var{key} is equivalent
(using @code{eqv?}, @xref{Equivalence}), to a @var{datum},
then the expressions in the corresponding clause are evaluated
sequentially, and the result(s) of the last expression in the
@var{clause} is(are) returned from the case expression.
The forms containing @code{=>} are specified in SRFI-87.  In these
forms, the result of @var{key} is passed to @var{proc}, and its
result(s) is(are) returned from the case expression.

If the result of evaluating @var{key} is different from every @var{datum},
then if there is an else clause its expressions are evaluated and
the result(s) of the last is(are) the result(s) of the case expression;
otherwise the result of the case expression is undefined.
@c skimu このファイルの他の場所では undefined なのでそれに合わせました。
@example
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite)) @result{} composite

(case (car '(c d))
  ((a) 'a)
  ((b) 'b)) @result{} @r{undefined}

(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant)) @result{} consonant

(case 6
  ((2 4 6 8) => (cut + <> 1))
  (else => (cut - <> 1))) @result{} 7

(case 5
  ((2 4 6 8) => (cut + <> 1))
  (else => (cut - <> 1))) @result{} 4
@end example
@end defspec


@defspec and test @dots{}
[R5RS] 
The @var{test} expressions are evaluated from left to right,
and the value of the first expression that evaluates to a false
value is returned.
Any remaining expressions are not evaluated.
If all the expressions evaluate to true values,
the value of the last expression is returned.
If there are no expressions then @code{#t} is returned.

@example
(and (= 2 2) (> 2 1)) @result{} #t
(and (= 2 2) (< 2 1)) @result{} #f
(and 1 2 'c '(f g))   @result{} (f g)
(and)                 @result{} #t
@end example
@end defspec


@defspec or test @dots{}
[R5RS]
The @var{test} expressions are evaluated from left to right,
and the value of the first expression that evaluates to a true
value is returned. Any remaining expressions are not evaluated.
If all expressions evaluate to false values, the value of the
last expression is returned. If there are no expressions then
@code{#f} is returned.

@example
(or (= 2 2) (> 2 1)) @result{} #t
(or (= 2 2) (< 2 1)) @result{} #t
(or #f #f #f)        @result{} #f
(or (memq 'b '(a b c)) 
    (/ 3 0)) @result{} (b c)
@end example
@end defspec

@defspec when test body @dots{}
@defspecx unless test body @dots{}
Evaluates @var{test}.  If it yields true value (or false in case of
@code{unless}), @var{body} @dots{} are evaluated sequentially, and
the result(s) of the last evaluation is(are) returned.  Otherwise, undefined
value is returned.
@end defspec

@node Binding constructs, Sequencing, Conditionals, Core syntax
@section Binding constructs
@c NODE 変数束縛

@defspec let ((var expr) @dots{}) body @dots{}
@defspecx let* ((var expr) @dots{}) body @dots{}
@defspecx letrec ((var expr) @dots{}) body @dots{}
[R5RS]
Creates a local scope where @var{var} @dots{} are bound to the
value of @var{expr} @dots{}, then evaluates @var{body} @dots{}.
@var{var}s must be symbols, and there shouldn't be a duplication.
The value(s) of the last expression of @var{body} @dots{} becomes
the value(s) of this form.

The three forms differ in terms of the scope @var{expr}s are evaluated.
@code{Let} evaluates @var{expr}s before (outside of) @code{let} form.
@code{Let*} evaluates @var{expr}s in the scope where @var{var}s before
it are bound.   @code{Letrec} evaluates @var{expr}s in the environment
where @var{var}s are already bound (to an undefined value, initially).
@code{letrec} is necessary to define mutually recursive local procedures.
@example
(define x 'top-x)

(let  ((x 3) (y x)) (cons x y)) @result{} (3 . top-x)
(let* ((x 3) (y x)) (cons x y)) @result{} (3 . 3)

(let ((cons (lambda (a b) (+ a b)))
      (list (lambda (a b) (cons a (cons b 0)))))
  (list 1 2))  @result{} (1 2 . 0)

(letrec ((cons (lambda (a b) (+ a b)))
         (list (lambda (a b) (cons a (cons b 0)))))
  (list 1 2))  @result{} 3
@end example
@end defspec

@defmac let1 var expr body @dots{}
A convenient macro when you have only one variable.
Expanded as follows.

@example
(let ((@var{var} @var{expr})) @var{body} @dots{})
@end example
@end defmac

@defmac if-let1 var expr then
@defmacx if-let1 var expr then else
This macro simplifies the following idiom:
@example
(let1 @var{var} @var{expr}
  (if @var{var} @var{then} @var{else}))
@end example
@end defmac

@defmac rlet1 var expr body @dots{}
This macro simplifies the following idiom:
@example
(let1 @var{var} @var{expr}
  @var{body} @dots{}
  @var{var})
@end example
@end defmac

@defmac and-let* (binding @dots{}) body @dots{}
[SRFI-2]
In short, it works like @code{let*}, but returns @code{#f} immediately
whenever the expression in @var{binding}s evaluates to @code{#f}.

Each @var{binding} should be one of the following form:
@table @var
@item (variable expression)
The @var{expression} is evaluated; if it yields true value, the value
is bound to @var{variable}, then proceed to the next binding.  If
no more bindings, evaluates @var{body} @dots{}.   If @var{expression}
yieds @code{#f}, stops evaluation and returns @code{#f} from @code{and-let*}.
@item (expression)
In this form, @var{variable} is omitted.  @var{Expression} is evaluated
and the result is used just to determine whether we continue or
stop further evaluation.
@item bound-variable
In this form, @var{bound-variable} should be an identifier denoting
a bound variable.  If its value is not @code{#f}, we continue
the evaluation of the clauses.
@end table

Let's see some examples.  The following code searches @var{key}
from an assoc-list @var{alist} and returns its value if found.
@example
(and-let* ((entry (assoc key alist))) (cdr entry))
@end example

If @var{arg} is a string representation of an exact integer, returns its value;
otherwise, returns 0:
@example
(or (and-let* ((num (string->number arg))
               ( (exact? num) )
               ( (integer? num) ))
      num)
    0)
@end example

The following is a hypothetical code that searches a certain server port
number from a few possibilities (environment variable, configuration file,
...)
@example
(or (and-let* ((val (sys-getenv "SERVER_PORT")))
      (string->number val))
    (and-let* ((portfile (expand-path "~/.server_port"))
               ( (file-exists? portfile) )
               (val (call-with-input-string portfile port->string)))
      (string->number val))
    8080) ; default
@end example

@end defmac


@defmac fluid-let ((var val) @dots{}) body @dots{}
A macro that emulates dynamic scoped variables.
@var{Var}s must be variables bound in the scope including
@code{fluid-let} form.  @var{Val}s are expressions.
@code{Fluid-let} first evaluates @var{val}s, then 
evaluates @var{body} @dots{}, with binding 
@var{var}s to the corresponding values during the dynamic
scope of @var{body} @dots{}.

Note that, in multithreaded environment,
the change of the value of @var{var}s are visible from
all the threads.   This form is provided mainly for
the porting convenience.   Use parameter objects instead
(@xref{Parameters}) for thread-local dynamic state.
@example
(define x 0)

(define (print-x) (print x))

(fluid-let ((x 1))
  (print-x))  @result{} ;; prints 1
@end example
@end defmac

@defspec receive formals expression body @dots{}
[SRFI-8]
This is the way to receive multiple values.
@var{Formals} can be a (maybe-improper) list of symbols.
@var{Expression} is evaluated, and the returned value(s)
are bound to @var{formals} like the binding of lambda formals,
then @var{body} @dots{} are evaluated.

@example
(define (divrem n m)
  (values (quotient n m) (remainder n m)))

(receive (q r) (divrem 13 4) (list q r))
  @result{} (3 1)

(receive all (divrem 13 4) all)
  @result{} (3 1)

(receive (q . rest) (divrem 13 4) (list q rest))
  @result{} (3 (1))
@end example

See also @code{call-with-values} in @ref{Multiple values}
which is the procedural equivalent of @code{receive}.
You can use @code{define-values} (@xref{Definitions}) to
bind multiple values to the toplevel variables simultaneously.
Also @code{let-values} and @code{let*-values} 
in SRFI-11 (@ref{Let-values}) provides
@code{let}-like syntax with multiple values.
@end defspec

@defmac rec var expr
@defmacx rec (name . vars) expr @dots{}
[SRFI-31]
A macro to evaluate an expression with recursive reference.

In the first form, evaluates expr while @var{var} in @var{expr} is
bound to the result of @var{expr}.
The second form is equivalent to the followings.
@example
(rec @var{name} (lambda @var{vars} @var{expr} @dots{}))
@end example

Some examples:

@example
;; constant infinite stream
(rec s (cons 1 (delay s)))

;; factorial function
(rec (f n) 
  (if (zero? n)
      1 
      (* n (f (- n 1)))))
@end example
@end defmac

@node Sequencing, Iteration, Binding constructs, Core syntax
@section Sequencing
@c NODE 順次実行


@defspec begin form @dots{}
[R5RS]
Evaluates @var{form}s sequentially, and returns the last result(s).

@code{Begin} doesn't introduce new "block" like @code{let}, that is,
you can't place "internal define" at the beginning of @var{form}s
generally.   Semantically @code{begin} behaves as if @var{form}s
are spliced into the surrounding context.
For example, topleve expression like the following is the same
as two toplevel definitions:

@example
(begin (define x 1) (define y 2))
@end example

Here's a trickier example:

@example
(let ()
  (begin 
    (define x 2)
    (begin
      (define y 3)
    ))
  (+ x y))

  @equiv{}

(let ()
  (define x 2)
  (define y 3)
  (+ x y))
@end example
@end defspec

@defmac begin0 exp0 exp1 @dots{}
Evaluates @var{exp0}, @var{exp1}, @dots{}, then returns the result(s)
of @var{exp0}.   The name is taken from MzScheme.
This is called @code{prog1} in CommonLisp.   

Unlike @code{begin}, this @emph{does} creates a "block",
for the @code{begin0} form is expanded as follows.

@example
(receive tmp @var{exp0}
  @var{exp1} @dots{}
  (apply values tmp))
@end example
@end defmac


@node Iteration, Quasiquotation, Sequencing, Core syntax
@section Iteration
@c NODE 繰り返し

@defspec do ((variable init [step]) @dots{}) (test expr @dots{}) body @dots{}
[R5RS]
@end defspec


@defspec let name bindings body @dots{}
[R5RS]
@end defspec



@defmac dotimes (variable limit [result]) body @dots{}
@defmacx dolist (variable lexpr [result]) body @dots{}
Imported from Common Lisp.  These are equivalent to the following forms,
respectively.
@example
(dotimes (variable limit result) body @dots{})
==>
(do ((tlimit limit)
     (variable 0 (+ variable 1)))
    ((>= variable tlimit) result)
  body @dots{})

(dolist (variable lexpr result) body @dots{})
==>
(begin
  (for-each (lambda (variable) body @dots{}) lexpr)
  (let ((variable '())) result))
@end example
@end defmac

@defmac while expr body @dots{}
@defmacx while expr @code{=>} var body @dots{}
@defmacx while expr guard @code{=>} var body @dots{}
@var{Var} is an identifier and @var{guard} is a procedure
that takes one argument.

In the first form, @var{expr} is evaluated, and if it yields a true
value, @var{body} @dots{} are evaluated.  It is repeated while
@var{expr} yields true value.

In the second form, @var{var} is bound to a result of @var{expr}
in the scope of @var{body} @dots{}.

In the third form, the value @var{expr} yields are passed to
@var{guard}, and the execution of @var{body} @dots{} is repeated
while @var{guard} returns a true value.  @var{var} is bound
to the result of @var{expr}.

The return value of @code{while} form itself isn't specified.

@example
(let ((a '(0 1 2 3 4)))
  (while (pair? a)
    (write (pop! a)))) @result{} @r{prints "01234"}

(let ((a '(0 1 2 3 #f 5 6)))
  (while (pop! a) integer? => var
    (write var))) @result{} @r{prints "0123"}
@end example
@end defmac

@defmac until expr body @dots{}
@defmacx until expr guard @code{=>} var body @dots{}
Like @code{while}, but the condition is reversed.  That is,
the first form repeats evaluation of @var{expr} and @var{body} @dots{}
until @var{expr} yields true.  In the second form,
the result of @var{expr} is passed to @var{guard}, and the
execution is repeated until it returns true.  @var{Var} is bound
to the result of @var{expr}.

(The second form without @var{guard} isn't useful in @code{until}, since
@var{var} would always be bound to @code{#f}).

The return value of @code{until} form itself isn't specified.

@example
(let ((a '(0 1 2 3 4)))
  (until (null? a)
    (write (pop! a)))) @result{} @r{prints "01234"}

(until (read-char) eof-object? => ch
  (write-char ch))
 @result{} @r{reads from stdin and writes char until EOF is read}
@end example
@end defmac


@c ----------------------------------------------------------------------
@node Quasiquotation, Definitions, Iteration, Core syntax
@section Quasiquotation
@c NODE 準クオート, 準クオート(Quasiquote)

@defspec quasiquote template
[R5RS]
Quasiquotation is a convenient way to build a structure that has
some fixed parts and some variable parts.  See the explanation below.
@end defspec

@deftp {Reader Syntax} @code{`@var{template}}
[R5RS]
The syntax @code{`x} is read as @code{(quasiquote x)}.
@end deftp

@defspec unquote datum
@defspecx unquote-splicing datum
[R5RS]
These syntaxes have meaning only when they appear in the @var{template}
of quasiquoted form.  The standard says nothing about these syntaxes
appear outside of quasiquote.  Gauche signals an error in such case,
for it usually indicates you forget quasiquote somewhere.
See the explanation below for the meaning of these.
@end defspec

@deftp {Reader Syntax} @code{,@var{datum}}
@deftpx {Reader Syntax} @code{,@@@var{datum}}
[R5RS]
The syntaxes @code{,x} and @code{,@@x} are read as @code{(unquote x)}
and @code{(unquote-splicing x)}, respectively.
@end deftp

@subheading Quasiquote basics

Suppose you want to create a list @code{(foo bar @var{x} @var{y})}, 
where @code{foo} and @code{bar} are symbols, and @var{x} and @var{y}
are the value determined at runtime.  (For the sake of explanation,
let's assume we have variables @var{x} and @var{y} that provides those
values.)  One way to do that is to call the function @code{list}
explicitly.

@example
(let ((x 0) (y 1))
  (list 'foo 'bar x y)) @result{} (foo bar 0 1)
@end example

You can do the same thing with quasiquote, like this:

@example
(let ((x 0) (y 1))
  `(foo bar ,x ,y))  @result{} (foo bar 0 1)
@end example

The difference between the two notations is that the explicit version
quotes the parts that you want to insert literally into the result,
while the quasiquote version @emph{unquotes} the parts that you
don't want to quote.  

The quasiquote version gets simpler and more readable when you
have lots of static parts with scattered variable parts in your
structure.  

That's why quasiquote is frequently used with
legacy macros, which are basically a procedure that
create program fragments from variable parts provided as
macro arguments.  See the simple-minded @code{my-if} macro
that expands to @code{cond} form:

@example
(define-macro (my-if test then else)
  `(cond (,test ,then) 
         (else ,else)))

(macroexpand '(my-if (< n 0) n (- n)))
  @result{} (cond ((< n 0) n) (else (- n)))
@end example

Note the two @code{else}s in the macro definition; one isn't unquoted,
thus appears liteally in the output, while another is unquoted and
the corresponding macro argument is inserted in its place.

Of course you can use quasiquotes unrelated to macros.  It is a general
way to construct structures.  Some even prefer using quasiquote to 
explicit construction even most of the structure is variable, for
quasiquoted form can be more concise.  Gauche also tries to minimize
runtime allocation for quasiquoted forms, so it may potentially
be more efficient; see "How static are quasiquoted forms?" below.

@subheading Splicing

When @code{(unquote-splicing @var{expr})} appears in a quasiquoted form, 
@var{expr} must evaluate to a list, which is @emph{spliced} into the
surrounding context.  It's easier to see examples:

@example
(let ((x '(1 2 3)))
  `(a ,@@x b)) @result{} (a 1 2 3 b)

(let ((x '(1 2 3)))
  `(a ,x b)) @result{} (a (1 2 3) b)

(let ((x '(1 2 3)))
  `#(a ,@@x b)) @result{} #(a 1 2 3 b)
@end example

Compare the unquote version and unquote-splicing version.  Splicing
also works within a vector.

@subheading Some edge cases

@subheading How static are quasiquated forms?

When quasiquoted form contains variable parts, what happens at
runtime is just the same as when an explicit form is used:
@code{`(,x ,y)} is evaluated exactly like @code{(list x y)}.
However, Gauche tries to minimize runtime allocation when
a quasiquoted form has static parts.

First of all, if there's no variable parts in quasiquoted
form, like @code{`(a b c)}, the entire form is allocated statically.
If there is a static tail in the sturcture, it is also allocated
statically; e.g. @code{`((,x a b) (,y c d))} works like
@code{(list (cons x '(a b)) (cons y '(c d)))}.

Furthermore, when an unquoted expression is a
constant expressoin, Gauche embeds it into the static
form.  If you've defined a constant like
@code{(define-constant x 3)}, then the form
@code{`(,x ,(+ x 1))} is compiled as the constant @code{'(3 4)}.
(See @ref{Definitions}, for the explanation of @code{define-constant} form.)

In general it is hard to say which part of quasiquoted form is
compiled as a static datum and which part is not, so you shouldn't
write a code that assumes some parts of the structure returned from
quasiquote are freshly allocated.  In other words, you better avoid
mutating such structures.

@c ----------------------------------------------------------------------
@node Definitions, Modules, Quasiquotation, Core syntax
@section Definitions
@c NODE 定義

@defspec define variable expression
@defspecx define (variable . formals) body @dots{}
[R5RS]
This form has different meanings in the toplevel (without no
local bindings) or inside a local scope.

On toplevel, it defines a global binding to a symbol @var{variable}.
In the first form, it globally binds a symbol @var{variable}
to the value of @var{expression}, in the current module.
@example
(define x (+ 1 2))
x @result{} 3
(define y (lambda (a) (* a 2)))
(y 8) @result{} 16
@end example

The second form is a syntactic sugar of defining a procedure.
It is equivalent to the following form.
@example
(define (@var{name} . @var{args}) @var{body} @dots{})
  @equiv{} (define @var{name} (lambda @var{args} @var{body} @dots{}))
@end example

If the form appears inside a local scope (internal define),
this introduce a local binding of the variable.

@c explanation of internal define here

Note that @code{begin} (@xref{Sequencing}) doesn't introduce a new scope.
@code{Define}s in the @code{begin} act as if @code{begin} and surrounding
parenthesis are not there.  Thus these two forms are equivalent.
@example
(let ((x 0))
  (begin
    (define (foo y) (+ x y)))
  (foo 3))
 @equiv{}
(let ((x 0))
  (define (foo y) (+ x y))
  (foo 3))
@end example
@end defspec

@defmac define-values (var @dots{}) expr
@var{Expr} is evaluated, and it should return as many values as
@var{var}s.  Then each value of the results are
bound to each variable in @var{var} @dots{}.
@xref{Let-values}.
@example
(define-values (lo hi) (min&max 3 -1 15 2))

lo @result{} -1
hi @result{} 15
@end example
@end defmac

@defspec define-constant variable expression
@defspecx define-constant (variable . formals) body @dots{}
Like @code{define}, but that the compiler assumes
the value of @var{variable} won't change and generates 
optimized code.

An error is signalled when you use @code{set!} to change the value
of @var{variable}.   It is allowed to redefine @var{variable},
but a warning is printed.
@end defspec

@defspec define-in-module module variable expression
@defspecx define-in-module module (variable . formals) body @dots{}
This form creates a global binding of @var{variable} in
@var{module}, which must be either a symbol of the module name or
a module object.  If @var{module} is a symbol, the named module
must exist.

@var{Expression} is evaluated in the current module.

The second form is merely a syntactic sugar of:
@example
(define-in-module module variable (lambda formals body @dots{}))
@end example
@end defspec

Note: to find out if a symbol has definition (global binding) in
the current module, you can use @code{global-variable-bound?}
(@xref{Module introspection}).

@c ----------------------------------------------------------------------
@node Modules,  , Definitions, Core syntax
@section Modules
@c NODE モジュール

This section describes the semantics of Gauche modules and its API.
See also @ref{Writing Gauche modules}, for the conventions
Gauche is using for its modules.

@menu
* Module semantics::            
* Modules and libraries::       
* Defining and selecting modules::  
* Using modules::               
* Module inheritance::          
* Module introspection::        
* Predefined modules::          
@end menu

@node Module semantics, Modules and libraries, Modules, Modules
@subsection Module semantics
@c NODE モジュールのセマンティクス

Module is an object that maps symbols onto @emph{bindings},
and affects the resolution of global variable reference.

Unlike CommonLisp's packages, which map names to symbols,
in Gauche symbols are always @code{eq?} if two have the
same name.  However, Gauche's symbol doesn't have a 'value'
slot in it.  From a given symbol, a module finds its binding that
keeps a value.
Different modules can associate different bindings
to the same symbol, that yield different values.

@example
;; Makes two modules A and B, and defines a global variable 'x' in them
(define-module A (define x 3))
(define-module B (define x 4))

;;  #<symbol 'x'> ---[module A]--> #<binding that has 3>
(with-module A x) @result{} 3

;;  #<symbol 'x'> ---[module B]--> #<binding that has 4>
(with-module B x) @result{} 4
@end example

A module can @emph{export} a part or all of its bindings
for other module to use.
A module can @emph{import} other modules, and their exported
bindings become visible to the module.
A module can import any number of modules.

@example
(define-module A
  (export pi)
  (define pi 3.1416))

(define-module B
  (export e)
  (define e 2.71828))

(define-module C
  (import A B))

(select-module C)
(* pi e) @result{} 8.539748448
@end example

A module can also be @emph{inherited}, that is, you can extend
the existing module by inheriting it and adding new bindings
and exports.   From the new module, all ancestor's bindings (including
non-exported bindings) are visible.
(A new module inherits the @code{gauche} module by default, which is why
the built-in procedures and syntax of @code{gauche} are available
in the new module).
From outside, the new module looks like having
all exported bindings of the original module plus the newly
defined and exported bindings.

@example
;; Module A defines and exports deg->rad.
;; A binding of pi is not exported.
(define-module A
  (export deg->rad)
  (define pi 3.1416)   ;; not exported
  (define (deg->rad deg) (* deg (/ pi 180))))

;; Module Aprime defines and exports rad->deg.
;; The binding of pi is visible from inside Aprime.
(define-module Aprime
  (extend A)
  (export rad->deg)
  (define (rad->deg rad) (* rad (/ 180 pi))))

;; Module C imports Aprime.
(define-module C
  (import Aprime)
  ;; Here, both deg->rad and rad->deg are visible,
  ;; but pi is not visible.
  )
@end example

At any moment of the compilation, there is one "current module" available,
and the global variable reference is looked for from the module.
If there is a visible binding of the variable, the variable
reference is compiled to the access of the binding.
If the compiler can't find a visible binding,
it marks the variable reference with the current module, and
delays the resolution of binding at the time the variable is
actually used.  That is, when the variable is referenced
at run time, the binding is again looked for from the marked module
(@emph{not} the current module at the run time) and if found,
the variable reference code is replaced for the the code to
access the binding.  If the variable reference is not found even
at run time, an 'undefined variable' error is signalled.

Once the appropriate binding is found for the global variable,
the access to the binding is hard-wired in the compiled code
and the global variable resolution will never take place again.

The definition special form such as @code{define} and @code{define-syntax}
inserts the binding to the current module.   Thus it may shadow
the binding of imported or inherited modules.

The resolution of binding of a global variable happens like this.
First, the current module is searched.  Then, each
imported module is taken in the reverse order of import, and searched,
including each module's ancestors.
Note that import is not transitive; imported module list is not
chased recursively.
Finally, ancestors of the current module are searched in order.

This order is important when more than one modules
defines the same name and your module imports both.
Assuming your module don't define that name,
if you first import a module @code{A} then a module @code{B},
you'll see @code{B}'s binding.

If you import @code{A}, then @code{B}, then @code{A} again,
the last import takes precedence; that is, you'll see @code{A}'s
binding.

@node Modules and libraries, Defining and selecting modules, Module semantics, Modules
@subsection Modules and libraries
@c NODE モジュールとライブラリ

Modules are run-time data structure; you can procedurally
create modules with arbitrary names at run-time.

However, most libraries use modules to create their own
namespace, so that they can control which bindings to be
visible from library users.

Usually a library is provided in the form of one or more Scheme
source file(s), so it is convenient to have a convention to map 
module names to file names, and vice versa; then, you can load a
library file and import its module by one action with @code{use}
macro, for example.

For the time being, Gauche uses a simple rules for this mapping:
Module names are organized hierarchically, using period `@code{.}'
for separator, e.g. @code{gauche.mop.validator}.  If such a
module is requested and doesn't exist in the current running
environment, Gauche maps the module name to a pathname by
replacing periods to directory separator, i.e.
@code{gauche/mop/validator}, and look for
@code{gauche/mop/validator.scm} in the load paths.

Note that this is just a default behavior.
Theoretically, one Scheme source file may contain multiple
modules, or one module implementation may span to multiple files.
In future, there may be some hook to customize this mapping
for special cases.  So, when you are writing routines that
deal with modules and library files, do not apply the above
default rule blindly.   Gauche provides two procedures,
@code{module-name->path} and @code{path->module-name},
to do mapping for you (see @ref{Module introspection}, for details).

@node Defining and selecting modules, Using modules, Modules and libraries, Modules
@subsection Defining and selecting modules
@c NODE モジュールの定義と選択

@defspec define-module name body @dots{}
@var{Name} must be a symbol.
If a module named @var{name} does not exist, create one.
Then evaluates @var{body} sequentially in the module.
@end defspec

@defspec select-module name
Makes a module named @var{name} as the current module.
It is an error if no module named @var{name} exists.

If @code{select-module} is used in the Scheme file, its effect is
limited inside the file, i.e. even if you load/require a file that uses
@code{select-module} internally, the current module of requirer is
not affected.
@end defspec

@defspec with-module name body @dots{}
Evaluates @var{body} sequentially in the module
named @var{name}.  Returns the last result(s).
If no module named @var{name}, an error is signalled.
@end defspec

@defspec current-module
Evaluates to the current module in the compile context.
Note that this is a special form, not a function.
Module in Gauche is statically determined at compile time.
@lisp
(define-module foo
  (export get-current-module)
  (define (get-current-module) (module-name (current-module))))

(define-module bar
  (import foo)
  (get-current-module)) @result{} foo @r{; not bar}
@end lisp
@end defspec


@node Using modules, Module inheritance, Defining and selecting modules, Modules
@subsection Using modules
@c NODE モジュールの使用

@defspec export symbol @dots{}
Makes bindings of @var{symbol}s in the current module available
to modules that imports the current module.
@end defspec

@defspec export-all
Makes all bindings in the current module available to modules
that imports it.
@end defspec

@defspec import module-name @dots{}
Makes all exported bindings in the module named @var{module-name}
available in the current module.   The named modules should exist
when the compiler sees this special form.

Note that imports are not transitive.  The modules that @var{module-name}s
are importing are not automatically imported to the current module.
This keeps modules' modularity; a library module can import whatever
modules it needs without worrying about polluting the namespace of
the user of the module.
@end defspec

@defmac use name
A convenience macro that combines module imports and on-demand
file loading.  Basically, @code{(use foo)} is equivalent
to the following two forms:
@example
(require "foo")
(import foo)
@end example
That is, it loads the library file named ``@code{foo}'' (if not yet
loaded) which defines a module named @code{foo} in it,
and then import the module
@code{foo} into the current module.

Although the files and modules are orthogonal concept,
it is practically convenient to separate files by modules.
Gauche doesn't force you to do so, and you can always use
@code{require} and @code{import} separately.  However, all
modules provided with Gauche are arranged so that they can be
used by @code{use} macro.

If a module is too big to fit in one file, you can split them
into several subfiles and one main file.  The main file defines
the module, and either loads, requires, or autoloads subfiles.

Actually, the file pathname of the given module name is
obtained by the procedure @code{module-name->path} below.
The default rule is to replace periods `@code{.}' in the @var{name}
for `@code{/}';  for example,
@code{(use foo.bar.baz)} is expanded to:
@example
(require "foo/bar/baz")
(import foo.bar.baz)
@end example
This is not very Scheme-ish way, but nevertheless convenient.
In future, there may be some mechanism to customize this mapping.
@end defmac

@node Module inheritance, Module introspection, Using modules, Modules
@subsection Module inheritance
@c NODE モジュールの継承

The export-import mechanism doesn't work well in some cases, such as:

@itemize @bullet
@item You want to create a module that is mostly the same as the
existing one, but adding or altering some definitions.
@item You wrote a bunch of related modules that are often used together,
and not want your users to repeat a bunch of 'use' forms every time
they use your module.
@end itemize

You can use module inheritance in these cases.

@defmac extend module-name @dots{}
Makes the current module inherit from named modules.
The current inheritance information is altered by the
inheritance information calculated from given modules.

A new module inherits from @code{gauche} module when created.
If you put @code{(extend scheme)} in that module, for example,
the module resets to inherit directly from @code{scheme} module
that has only bindings defined in R5RS, hence, after the export
form, you can't use 'import' or any other @code{gauche}-specific
bindings in the module.

If a named module is not defined yet, @code{extend}
tries to load it, using the same convention @code{use} macro does.

A module can inherit multiple modules, exactly the same way as
a class can inherit from multiple classes.  The resolution of
order of inheritance needs to be explained a bit.

Each module has a @emph{module precedence list}, which lists
modules in the order of how they are searched.  When the module
inherits multiple modules, module precedence lists of inherited
modules are merged into a single list, keeping the constraints
that: (1) if a module A appears before module B in some module
precedence list, A has to appear before B in the resulting module
precedence list; and (2) if a module A appears before module B
in @code{extend} form, A has to appear before B in the resulting
module precedence list.   If no precedence list can be constructed
with these constraints, an error is signalled.
@end defmac

For example, suppose you wrote a library in modules
@code{mylib.base}, @code{mylib.util} and @code{mylib.system}.
You can bundle those modules into one module by creating
a module @code{mylib}, as follows:

@example
(define-module mylib
  (extend mylib.system mylib.util mylib.base))
@end example

The user of your module just says @code{(use mylib)} and
all exported symbols from three submodules become available.

@node Module introspection, Predefined modules, Module inheritance, Modules
@subsection Module introspection
@c NODE モジュールイントロスペクション

This subsection lists procedures that operates on modules at run-time.
With these procedures you can introspect the modules, create new modules
procedurally, or check the existence of certain modules/libraries, for
example.  However, don't forget that modules are primarily
compile-time structures.  Tweaking modules at run-time is only
for those who know what they are doing.

@deftp {Builtin Class} <module>
@clindex module
A module class.
@end deftp

@defun module? obj
Returns true if @var{obj} is a module.
@end defun

@defun find-module name
Returns a module object whose name is a symbol @var{name}.
If the named module doesn't exist, @code{#f} is returned.
@end defun

@defun make-module name &keyword if-exists
Creates and returns a module that has symbol @var{name}.
If the named module already exists, the behavior is specified by
@var{if-exists} keyword argument.  If it is @code{:error} (default),
an error is signalled.  If it is @code{#f}, @code{#f} is returned.

Note that creating modules on-the-fly isn't usually necessary
for ordinal scripts, since to execute already written program requires modules
to be specified by name, i.e. syntax @code{define-module}, @code{import},
@code{extend}, @code{with-module} all takes module names, not
modules.  It is because module are inherently compile-time structure.
However, there are some cases that dynamically created modules
are useful, especially the program itself is dynamically created.
You can pass a module to @code{eval} to compile and
evaluate such dynamically created
programs in it (@xref{Eval and repl}).

You can also pass @code{#f} to @var{name} to create
@emph{anonymous} module.   Anonymous modules can't be
looked up by @code{find-module}, nor can be imported
or inherited (since @code{import} and @code{extend} take
module names, not modules). 
It is useful when you want to have a temporary, segregated namespace
dynamically---for example, you can create an anonymous module
to evaluate code fragments sent from other program, and
discards the module when the connection is terminated.
Anonymous modules are not registered in the system dictionary
and are garbage collected when nobody keeps reference to it.
@end defun

@defun all-modules
Returns a list of all named modules.
Anonymous modules are not included.
@end defun

@defun module-name module
@defunx module-imports module
@defunx module-exports module
@defunx module-table module
Accessors of a module object.  Returns the name of the module (a symbol),
list of imported modules, list of exported symbols, and a hash table
that maps symbols to bindings, of the @var{module} are returned,
respectively.

If the @var{module} exports all symbols, @code{module-exports} returns
@code{#t}.

It is an error to pass a non-module object.
@end defun

@defun module-parents module
@defunx module-precedence-list module
Returns the information of module inheritance.
@code{Module-parents} returns the modules @var{module} directly inherits
from.  @code{Module-precedence-list} returns the module precedence
list of @var{module} (@xref{Module inheritance}).
@end defun

@defun global-variable-bound? module symbol
Returns true if @var{symbol}'s global binding is visible
from @var{module}.  @var{Module} must be a module object or
a symbol name of an existing module.

Note: there used to be the @code{symbol-bound?} procedure to
check whether a global variable is bound.  It is deprecated and
the new code should use @code{global-variable-bound?} instead.
The reason of change is that because of the name @code{symbol-bound?} and
the fact that it assumes current-module by default, it gives
an illusion as if a global bound value is somewhat 'stored'
in a symbol itself (like CommonLisp's model).  It caused a lot
of confusion when the current module differs between
compile-time and runtime.  The new name and API made it clear
that you are querying module's property.
@end defun

@defun global-variable-ref module symbol &optional default
Returns a value globally bound to the @var{symbol} visible
from @var{module}.  @var{Module} must be a module object or
a symbol name of an existing module.  If there's no visible
global binding from @var{module} for @var{symbol},
an error is signalled, unless the @var{default} argument is
provided, in which case it is returned instead.
@end defun

@defun module-name->path symbol
Converts a module name @var{symbol} to a fragment of pathname string
(which you use for @code{require} and @code{provide}).
@end defun

@defun path->module-name string
Reverse function of @code{module-name->path}.
@end defun

If you want to find out
specific libraries and/or modules are installed in the system and
available from the program, see @ref{Operations on libraries}.

@node Predefined modules,  , Module introspection, Modules
@subsection Predefined modules
@c NODE 組み込みモジュール

Several modules are predefined in Gauche.

@deftp {Builtin Module} null
@mdindex null
This module corresponds to the null environment referred in R5RS.
This module contains only syntactic bindings of R5RS syntax.
@end deftp

@deftp {Builtin Module} scheme
@mdindex scheme
This module contains all the binding of @code{null} module,
and the binding of procedures defined in R5RS.
@end deftp

Note that if you change the current module to @code{null} or
@code{scheme} by @code{select-module}, there will be no way
to switch back to other modules, since module-related syntaxes
and procedures are not visible from @code{null} and @code{scheme}
modules.

@deftp {Builtin Module} gauche
@mdindex gauche
This module contains all the bindings of @code{scheme} module,
plus Gauche specific built-in procedures.
@end deftp

@deftp {Builtin Module} user
@mdindex user
This module is the default module the user code is compiled.
all the bindings of @code{gauche} module is imported.
@end deftp

@node Macros, Core library, Core syntax, Top
@chapter Macros
@c NODE マクロ

Gauche supports both R5RS hygienic macros and
traditional macros.

Macro of Lisp-family language is very different feature from
ones of other languages, such as C preprocessor macros.
It allows you to extend the original language syntax.
You can use macros to change Gauche syntax
so that you can run a Scheme program written to other Scheme
implementations, and you can even design your own mini-language
to solve your problem easily.

@menu
* Hygienic Macros::             
* Traditional Macros::          
* Macro expansion::             
* Macro utilities::             
@end menu

@node Hygienic Macros, Traditional Macros, Macros, Macros
@section Hygienic Macros
@c NODE 健全なマクロ

R5RS hygienic macro is based on a special pattern language,
and guaranteed that no "variable capture" occurs.
"Variable capture" means that if you insert new variable
bindings in the expanded form, the new bindings
shadows the bindings in the form passed to the macro.

@defspec define-syntax name transformer-spec
[R5RS]
@end defspec

@defspec let-syntax ((name transformer-spec) @dots{}) body
@defspecx letrec-syntax ((name transformer-spec) @dots{}) body
[R5RS]
@end defspec

@defspec syntax-rules literals clause1 clause2 @dots{}
[R5RS]
@end defspec


@node Traditional Macros, Macro expansion, Hygienic Macros, Macros
@section Traditional Macros
@c NODE 伝統的なマクロ

@defspec define-macro name procedure
@defspecx define-macro (name . formals) body @dots{}
Defines @var{name} to be a global macro whose transformer is @var{procedure}.
The second form is a shorthand notation of the following form:
@example
(define-macro name (lambda formals body @dots{}))
@end example

When a form @code{(name @var{arg} @dots{})} is seen by the compiler,
it calls @var{procedure} with @var{arg} @dots{}.  When @var{procedure}
returns, the compiler inserts the returned form in place of the original
form, and compile it again.
@end defspec

@node Macro expansion, Macro utilities, Traditional Macros, Macros
@section Macro expansion
@c NODE マクロの展開

@defun macroexpand form
@defunx macroexpand-1 form
If @var{form} is a list and its first element is a variable
globally bound to a macro, @code{macroexpand-1}
invokes its macro transformer and
returns the expanded form.  Otherwise, returns @var{form} as is.

@code{macroexpand} repeats @code{macroexpand-1} until the
@var{form} can't be expanded.

These procedures can be used to expand globally defined macros.
@end defun

@defspec %macroexpand form
@defspecx %macroexpand-1 form
@end defspec

@node Macro utilities,  , Macro expansion, Macros
@section Macro utilities
@c NODE マクロユーティリティ

@defmac syntax-error msg arg @dots{}
@defmacx syntax-errorf fmt arg @dots{}
Signal an error.  They are same as
@code{error} and @code{errorf} (@xref{Signalling exceptions}),
except that the error is signalled at macro-expansion time
(i.e. compile time) rather than run time.

They are useful to tell the user the wrong usage of macro in
the comprehensive way, instead of the cryptic error from the macro
expander.   Because of the purpose, @var{arg} @dots{} are first
passed to @code{unwrap-syntax} described below, to strip off
the internal syntactic binding informations.

@example
(define-syntax my-macro
  (syntax-rules ()
    ((_ a b)   (foo2 a b))
    ((_ a b c) (foo3 a b c))
    ((_ . ?)
     (syntax-error "malformed my-macro" (my-macro . ?)))))

(my-macro 1 2 3 4)
  @result{} @r{error: "malformed my-macro: (mymacro 1 2 3 4)"}
@end example

@end defmac

@defun unwrap-syntax form
Removes internal syntactic information from @var{form}.
In order to implement a hygienic macro, macro expander replaces
symbols in the macro form for identifiers, which captures the
syntactic environment where they are defined.  Although it is
necessary information for the compiler, it is rather confusing
for users if it appears in the messages.  This function
replaces occurrences of identifiers in @var{form} to the original
symbols.
@end defun

@node Core library, Object system, Macros, Top
@chapter Core library
@c NODE 組み込みライブラリ

@c ----------------------------------------------------------------------
@menu
* Equivalence::                 
* Numbers::                     
* Booleans::                    
* Pairs and Lists::             
* Symbols::                     
* Keywords::                    
* Identifiers::                 
* Characters::                  
* Character set::               
* Strings::                     
* Regular expression::          
* Vectors::                     
* Hashtables::                  
* Treemaps::                    
* Weak pointers::               
* Control features::            
* Exceptions::                  
* Eval and repl::               
* Input and output::            
* Loading Programs::            
* Comparison and sorting::      
* System interface::            
* Development helper API::      
@end menu

@node Equivalence, Numbers, Core library, Core library
@section Equivalence
@c NODE 等価

Scheme has three different general equivalence test predicates.
Other than these, some types have their own comparison predicates.

@defun eq? obj1 obj2
[R5RS]
This is the fastest and finest predicate.
Returns @code{#t} if @var{obj1} and @var{obj2} are allocated objects of
the same types, and denote the same location.  Returns @code{#t}
if both objects are @code{#f}, @code{#t}, or @code{()}.
You can think @var{eq?} as a pointer comparison.
Note that the result is unspecified in Scheme standard when
both objects are characters or numbers.

@example
(eq? #t #t)               @result{} #t
(eq? #t #f)               @result{} #f
(eq? 'a 'a)               @result{} #t
(eq? 'a 'b)               @result{} #f
(eq? (list 'a) (list 'a)) @result{} #f
(let ((x (list 'a)))
  (eq? x x))              @result{} #t
@end example
@end defun

@defun eqv? obj1 obj2
[R5RS]
When @var{obj1} and @var{obj2} are both exact or both inexact numbers,
@var{eqv?} returns @code{#t} iff @code{(= @var{obj1} @var{obj2})} is true.
When @var{obj1} and @var{obj2} are both characters,
@var{eqv?} returns @code{#t} iff @code{(char=? @var{obj1} @var{obj2})} is true.
Otherwise, @code{eqv?} is the same as @code{eq?} on Gauche.

@example
(eqv? #\a #\a)             @result{} #t
(eqv? #\a #\b)             @result{} #f
(eqv? 1.0 1.0)             @result{} #t
(eqv? 1 1)                 @result{} #t
(eqv? 1 1.0)               @result{} #f
(eqv? (list 'a) (list 'a)) @result{} #f
(let ((x (list 'a)))
  (eqv? x x))              @result{} #t
@end example
@end defun

@defun equal? obj1 obj2
[R5RS+]
If @var{obj1} and @var{obj2} are both aggregate types,
@code{equal?} compares its elements recursively.
Otherwise, @code{equal?} behaves the same as @code{eqv?}.

If @var{obj1} and @var{obj2} are other than booleans, numbers,
characters, pairs, strings and vectors, and the class of both
objects are the same, @code{equal?} calls the generic
function @code{object-equal?}.
By defining the method, users can extend the behavior of @code{equal?}
for user-defined classes.

@example
(equal? (list 1 2) (list 1 2)) @result{} #t
(equal? "abc" "abc")           @result{} #t
(equal? 100 100)               @result{} #t
(equal? 100 100.0)             @result{} #f
@end example

Note: If both @var{obj1} and @var{obj2} have circular structure,
@code{equal?} may diverge.  You might want to use @code{isomorph?}
instead (see @ref{Determine isomorphism}).
@end defun

@deffn {Generic Function} object-equal? obj1 obj2
This generic function is called when @code{equal?} is called on the objects
it doesn't know about.  You can define this method on your class
so that @code{equal?} can check equivalence.   This method is supposed
to return @code{#t} if @var{obj1} is equal to @var{obj2}, @code{#f}
otherwise.  If you want to check equivalence of elements recursively,
do not call @code{object-equal?} directly; call @code{equal?} on each element.

@example
(define-class <foo> ()
  ((x :init-keyword :x)
   (y :init-keyword :y)))

(define-method object-equal? ((a <foo>) (b <foo>))
  (and (equal? (slot-ref a 'x) (slot-ref b 'x))
       (equal? (slot-ref a 'y) (slot-ref b 'y))))

(equal? (make <foo> :x 1 :y (list 'a 'b))
        (make <foo> :x 1 :y (list 'a 'b)))
  @result{} #t

(equal? (make <foo> :x 1 :y (make <foo> :x 3 :y 4))
        (make <foo> :x 1 :y (make <foo> :x 3 :y 4)))
  @result{} #t
@end example
@end deffn

Sometimes you want to test if two aggregate structures
are topologically equal, i.e., if one has a shared substructure,
the other has a shared substructure in the same way.
@code{Equal?} can't handle it; module @code{util.isomorph} 
provides a procedure @code{isomorphic?} which does the job
(@xref{Determine isomorphism}).

@c ----------------------------------------------------------------------
@node Numbers, Booleans, Equivalence, Core library
@section Numbers
@c NODE 数値

Gauche supports the following types of numbers
@table @asis
@item multi-precision exact integer
There's no limit of the size of number except the memory of the machine.
@item multi-precision exact non-integral rational numbers.
Both denominator and numerator are represented by exact integers.
There's no limit of the size of number except the memory of the machine.
@item inexact floating-point real numbers
Using @code{double}-type of underlying C compiler, usually IEEE 64-bit
floating point number.
@item inexact floating-point complex numbers
Real part and imaginary part are represented by inexact floating-point
real numbers.
@end table

@menu
* Number classes::              
* Numerical predicates::        
* Numerical comparison::        
* Arithmetics::                 
* Numerical conversions::       
* Bitwise operations::          
@end menu

@node Number classes, Numerical predicates, Numbers, Numbers
@subsection Number classes
@c NODE 数値クラス

@deftp {Builtin Class} <number>
@deftpx {Builtin Class} <complex>
@deftpx {Builtin Class} <real>
@deftpx {Builtin Class} <rational>
@deftpx {Builtin Class} <integer>
@clindex number
@clindex complex
@clindex real
@clindex rational
@clindex integer
These classes consist a class hierarchy of number objects.
@code{<complex>} inherits @code{<number>}, @code{<real>} inherits
@code{<complex>},@code{<rational>} inherits @code{<real>}
 and @code{<integer>} inherits @code{<rational>}.

Note that these classes does not exactly corresponds to the
number hierarchy defined in R5RS.  Especially, 
only exact integers are the instances of the @code{<integer>}
class.  That is,
@lisp
(integer? 1)        @result{} #t
(is-a? 1 <integer>) @result{} #t
(is-a? 1 <real>)    @result{} #t

(integer? 1.0)        @result{} #t
(is-a? 1.0 <integer>) @result{} #f
(is-a? 1.0 <real>)    @result{} #t

(class-of (expt 2 100)) @result{} #<class <integer>>
(class-of (sqrt -3)) @result{} #<class <complex>>
@end lisp
@end deftp

@node Numerical predicates, Numerical comparison, Number classes, Numbers
@subsection Numerical predicates
@c NODE 数値に関する述語

@defun number? obj
@defunx complex? obj
@defunx real? obj
@defunx rational? obj
@defunx integer? obj
[R5RS]
Returns @code{#t} if @var{obj} is a number, a complex number, a real number,
a rational number or an integer, respectively.   In Gauche, a set of
numbers is the same as a set of complex numbers, and a set of
rational numbers is the same as a set of real numbers
(since we have only limited-precision floating numbers).

@example
(complex? 3+4i)   @result{} #t
(complex? 3)      @result{} #t
(real? 3)         @result{} #t
(real? -2.5+0.0i) @result{} #t
(real? #e1e10)    @result{} #t
(integer? 3+0i)   @result{} #t
(integer? 3.0)    @result{} #t
@end example
@end defun

@defun exact? obj
@defunx inexact? obj
[R5RS]
Returns @code{#t} if @var{obj} is an exact number and an inexact number,
respectively.

@example
(exact? 1)       @result{} #t
(exact? 1.0)     @result{} #f
(inexact? 1)     @result{} #f
(inexact? 1.0)   @result{} #t

(exact? (modulo 5 3)) @result{} #t
(inexact? (modulo 5 3.0)) @result{} #f
@end example
@end defun

@defun zero? z
[R5RS]
Returns @code{#t} if a number @var{z} equals to zero.

@example
(zero? 1)        @result{} #f
(zero? 0)        @result{} #t
(zero? 0.0)      @result{} #t
(zero? 0.0+0.0i) @result{} #t
@end example
@end defun

@defun positive? x
@defunx negative? x
[R5RS]
Returns @code{#t} if a real number @var{x} is positive and negative,
respectively.  It is an error to pass a non-real number.
@end defun

@defun odd? n
@defunx even? n
[R5RS]
Returns @code{#t} if an integer @var{n} is odd and even, 
respectively.  It is an error to pass a non-integral number.

@example
(odd? 3)     @result{} #t
(even? 3)    @result{} #f
(odd? 3.0)   @result{} #t
@end example
@end defun

@defun fixnum? n
@defunx bignum? n
Returns @code{#t} iff @var{n} is an exact integer whose internal
representation is @var{fixnum} and @var{bignum}, respectively.
Portable Scheme programs don't need to care about the internal
representation of integer.   These are for certain low-level
routines that does particular optimization.
@end defun

@node Numerical comparison, Arithmetics, Numerical predicates, Numbers
@subsection Numerical comparison
@c NODE 数値の比較

@defun @code{=} z1 z2 z3 @dots{}
[R5RS]
If all the numbers @var{z} are equal, returns @code{#t}.

@example
(= 2 2)          @result{} #t
(= 2 3)          @result{} #f
(= 2 2.0)        @result{} #t
(= 2 2.0 2.0+0i) @result{} #t
(= 2/4 1/2)      @result{} #t
@end example
@end defun

@defun @code{<} x1 x2 x3 @dots{}
@defunx @code{<=} x1 x2 x3 @dots{}
@defunx @code{>} x1 x2 x3 @dots{}
@defunx @code{>=} x1 x2 x3 @dots{}
[R5RS]
Returns @code{#t} If all the real numbers @var{x} are
monotonically increasing,
monotonically nondecreasing, monotonically decreasing, or monotonically
nonincreasing, respectively.
@end defun


@defun max x1 x2 @dots{}
@defunx min x1 x2 @dots{}
[R5RS]
Returns a maximum or minimum number in the given real numbers, respectively.
@end defun

@defun min&max x1 x2 @dots{}
Returns a maximum and minimum number in the given real numbers.
@end defun

@node Arithmetics, Numerical conversions, Numerical comparison, Numbers
@subsection Arithmetics
@c NODE 数値の演算

@defun @code{+} z @dots{}
@defunx @code{*} z @dots{}
[R5RS]
Returns the sum or the product of given numbers, respectively.
If no argument is given, @code{(+)} yields 0 and @code{(*)} yields 1.
@end defun

@defun @code{-} z1 z2 @dots{}
@defunx @code{/} z1 z2 @dots{}
[R5RS]
If only one number @var{z1} is given, returns its
negation and reciprocal, respectively.

If more than one number are given, returns:
@example
@var{z1} - @var{z2} - @var{z3} @dots{}
@var{z1} / @var{z2} / @var{z3} @dots{}
@end example
respectively.

@example
(- 3)       @result{} -3
(- -3.0)    @result{} 3.0
(- 5+2i)    @result{} -5.0-2.0i
(/ 3)       @result{} 1/3
(/ 5+2i)    @result{} 0.172413793103448-0.0689655172413793i

(- 5 2 1)     @result{} 2
(- 5 2.0 1)   @result{} 2.0
(- 5+3i -i)   @result{} 5.0+2.0i
(/ 14 6)      @result{} 7/3
(/ 6+2i 2)    @result{} 3.0+1.0i
@end example

Note: Gauche didn't have exact rational number support until 0.8.8;
before that, @code{/} coerced the result to inexact even if both
divisor and dividend were exact numbers, when the result wasn't
a whole number.  It is not the case anymore.

If the existing code relies on the old behavior, it runs
very slowly on the newer versions of Gauche, since the calculation
proceeds with exact rational arithmetics that is much slower than
floating point arithmetics.  You want to use @code{/.} below
to use fast inexact arithmetics (unless you
need exact results).
@end defun

@defun +. z @dots{}
@defunx *. z @dots{}
@defunx -. z1 z2 @dots{}
@defunx /. z1 z2 @dots{}
Like @code{+}, @code{*}, @code{-}, and @code{/}, but the arguments
are coerced to inexact number.  So they always return inexact number.
These are useful when you know you don't need exact calculation
and want to avoid accidental overhead of bignums and/or exact
rational numbers.
@end defun

@defun abs z
[R5RS+]
For real number @var{z}, returns an absolute value of it.
For complex number @var{z}, returns the magnitude of the number.
The complex part is Gauche extension.
@example
(abs -1)   @result{} 1
(abs -1.0) @result{} 1.0
(abs 1+i)  @result{} 1.4142135623731
@end example
@end defun

@defun quotient n1 n2
@defunx remainder n1 n2
@defunx modulo n1 n2
[R5RS]
Returns the quotient, remainder and modulo of dividing an integer @var{n1}
by an integer @var{n2}.   The result is an exact number only if
both @var{n1} and @var{n2} are exact numbers.

Remainder and modulo differ when either one of the arguments is negative.
Remainder @var{R} and quotient @var{Q} have the following relationship.
@example
  @var{n1} = @var{Q} * @var{n2} + @var{R}
@end example
where @code{abs(@var{Q}) = floor(abs(@var{n1})/abs(@var{n2}))}.
Consequently, @var{R}'s sign is always the same as @var{n1}'s.

On the other hand, modulo works as expected for positive @var{n2},
regardless of the sign of @var{n1}
(e.g. @code{(modulo -1 @var{n2}) == @var{n2} - 1}).
If @var{n2} is negative, it is mapped to the positive case by
the following relationship.
@example
  modulo(@var{n1}, @var{n2}) = @minus{}modulo(@minus{}@var{n1}, @minus{}@var{n2})
@end example
Consequently, @var{modulo}'s sign is always the same as @var{n2}'s.
@example
(remainder 10 3)    @result{} 1
(modulo 10 3)       @result{} 1

(remainder -10 3)   @result{} -1
(modulo -10 3)      @result{} 2

(remainder 10 -3)   @result{} 1
(modulo 10 -3)      @result{} -2

(remainder -10 -3)  @result{} -1
(modulo -10 -3)     @result{} -1
@end example
@end defun

@defun quotient&remainder n1 n2
Calculates the quotient and the remainder of dividing integer @var{n1}
by integer @var{n2} simultaneously, and returns them as two values.
@end defun

@defun gcd n @dots{}
@defunx lcm n @dots{}
[R5RS]
Returns the greatest common divisor or the least common multiplier
of the given integers, respectively
@end defun

@defun numerator q
@defunx denominator q
[R5RS]
Returns the numerator and denominator of a rational number @var{q}.
@end defun


@defun floor x
@defunx ceiling x
@defunx truncate x
@defunx round x
[R5RS]
The argument @var{x} must be a real number.
@code{Floor} and @code{ceiling} return a maximum integer that
isn't greater than @var{x} and a minimum integer that isn't less
than @var{x}, respectively.
@var{Truncate} returns an integer that truncates
@var{x} towards zero.  @var{Round} returns an integer that is closest
to @var{x}.  If fractional part of @var{x} is exactly 0.5, @var{round}
returns the closest even integer.
@end defun

@defun floor->exact x
@defunx ceiling->exact x
@defunx truncate->exacte x
@defunx round->exact x
These are convenience procedures of the popular 
phrase @code{(inexact->exact (floor x))} etc.
@end defun

@defun clamp x &optional min max
Returns
@example
 @var{min} @r{if} @var{x} @code{<} @var{min}
 @var{x}   @r{if} @var{min} @code{<=} @var{x} @code{<=} @var{max}
 @var{max} @r{if} @var{max} @code{<} @var{x}
@end example
If @var{min} or @var{max} is omitted or @code{#f}, it is regarded
as @var{-infinity} or @var{+infinity}, respectively.
Returns an exact integer only if all the given numbers are exact integers.
@example
(clamp 3.1 0.0 1.0) @result{} 1.0
(clamp 0.5 0.0 1.0) @result{} 0.5
(clamp -0.3 0.0 1.0) @result{} 0.0
(clamp -5 0)        @result{} 0
(clamp 3724 #f 256) @result{} 256
@end example
@end defun


@defun exp z
@defunx log z
@defunx log z1 z2
@defunx sin z
@defunx cos z
@defunx tan z
@defunx asin z
@defunx acos z
@defunx atan z
[R5RS][R6RS]
Transcendental functions.  Work for complex numbers as well.

The two-argument version of @code{log} is added in R6RS, and returns
base-@var{z2} logarithm of @var{z1}.
@end defun

@defun atan y x
[R5RS]
For real numbers @var{x} and @var{y}, returns @code{atan(@var{y}/@var{x})}.
@end defun

@defun sinh z
@defunx cosh z
@defunx tanh z
@defunx asinh z
@defunx acosh z
@defunx atanh z
Hyperbolic trigonometric functions.  Work for complex numbers as well.
@end defun

@defun sqrt z
[R5RS]
Returns a square root of a complex number @var{z}.
The branch cut scheme is the same as Common Lisp.
For real numbers, it returns a positive root.
@end defun

@defun expt z1 z2
[R5RS]
Returns @var{z1}^@var{z2} (@var{z1} powered by @var{z2}),
where @var{z1} and @var{z2} are complex numbers.
@end defun

@c NB: These should be moved to a separate subsection once we got
@c more fixnum-specific operation support.

@defun fixnum-width
@defunx greatest-fixnum
@defunx least-fixnum
[R6RS]
These procedures return the width of fixnum (@var{w}),
the greatest integer representable by fixnum (@var{2^w - 1}),
and the least integer representable by fixnum (@var{- 2^w}),
respectively.  You might want to care the fixnum range when
you are writing a performance-critical section.

These names are defined in R6RS.  Common Lisp and ChezScheme have
@code{most-positive-fixnum} and @code{most-negative-fixnum}.
@end defun

@node Numerical conversions, Bitwise operations, Arithmetics, Numbers
@subsection Numerical conversions
@c NODE 数値の変換

@defun make-rectangular x1 x2
@defunx make-polar x1 x2
[R5RS]
Creates a complex number from two real numbers, @var{x1} and @var{x2}.
@code{make-rectangular} returns @var{x1} + @b{i}@var{x2}.
@code{make-polar} returns @var{x1}@b{e}^(@b{i}@var{x2}).
@end defun

@defun real-part z
@defunx imag-part z
@defunx magnitude z
@defunx angle z
[R5RS]
Decompose a complex number @var{z} and returns a real number.
@code{real-part} and @code{imag-part} return @var{z}'s real and imaginary
part, respectively.  @code{magnitude} and @code{angle} return
@var{z}'s magnitude and angle, respectively.
@end defun

@defun decode-float x
For a given floating-point number, returns
a vector of three exact integers, @code{#(@var{m}, @var{e}, @var{sign})},
where
@example
  @var{x} = (* @var{sign} @var{m} (expt 2.0 @var{e}))
  @var{sign} is either 1, 0 or -1.
@end example
The API is taken from ChezScheme.
@example
(decode-float 3.1415926)
 @result{} #(7074237631354954 -51 1)
(* 7074237631354954 (expt 2.0 -51))
 @result{} 3.1415926
@end example
@end defun

@defun fmod x y
@defunx modf x
@defunx frexp x
@defunx ldexp x n
[POSIX] 
These procedures can be used to compose and decompose floating
point numbers.  @code{Fmod} computes the remainder of dividing @var{x}
by @var{y}, that is, it returns @var{x}-@var{n}*@var{y} where
@var{n} is the quotient of @var{x}/@var{y} rounded towards zero
to an integer.   @code{Modf} returns two values; a fractional
part of @var{x} and an integral part of @var{x}.   @code{Frexp}
returns two values, @var{fraction} and @var{exponent} of @var{x},
where @var{x} = @var{fraction} * 2^@var{exponent}, and
0 <= @var{fraction} <= 0.5.  @var{Ldexp} is a reverse operation of 
@code{frexp}; it returns a real number @var{x} * 2^@var{n}.
@example
(fmod 32.1 10.0)  @result{} 2.1
(fmod 1.5 1.4)    @result{} 0.1
(modf 12.5)       @result{} 0.5 @r{and} 12.0
(frexp 3.14)      @result{} 0.785 @r{and} 2
(ldexp 0.785 2)   @result{} 3.14
@end example
@end defun

@defun exact->inexact z
@defunx inexact->exact z
[R5RS]
Converts an exact number to an inexact number, or vice versa.

Since we have finite precision to represent floating numbers,
it is always possible to convert arbitrary inexact real number
to an exact rational number.  It may not be what you want, though.
See the following example:

@example
(inexact->exact 3.1415926535879)
  @result{} 7074237752024177/2251799813685248
@end example

If you intend to obtain an exact integer by rounding an inexact
real number, you have to use one of @code{floor}, @code{ceiling},
@code{truncate} or @code{round} explicitly.  You may also use
@code{floor->exact}, @code{round->exact} etc.

@example
(inexact->exact (round 3.1415926535879)) @result{} 3

(round->exact 3.1415926535879)           @result{} 3
@end example

Gauche doesn't support exact complex numbers.  Passing an inexact
complex number with non-zero imaginary part to @code{inexact->exact}
causes an error.

If you pass an inexact number to @code{exact->inexact} or
an exact number to @code{inexact->exact}, Gauche returns
the argument as is, instead of reporting an error.
This is also an implementation dependent behavior and
you shouldn't count on that.
@end defun

@defun number->string z &optional radix use-upper?
@defunx string->number string &optional radix
[R5RS+]
These procedures convert a number and its string representation
in radix @var{radix} system.
@var{radix} must be between 2 and 36 inclusive.
If @var{radix} is omitted, 10 is assumed.

@code{Number->string} takes a number @var{z} and returns a string.
If @var{z} is not an exact integer, @var{radix} must be 10.
For the numbers with radix more than 10, lower case alphabet
character is used for digits, unless the optional argument
@var{use-upper?} is true, in that case upper case characters are used.
The argument @var{use-upper?} is Gauche's extension.

@code{String->number} takes a string @var{string} and parses it
as a number in radix @var{radix} system.  If the number looks like
non-exact number, only radix 10 is allowed.  If the given string
can't be a number, @code{#f} is returned.
@end defun

@deffn {Generic Function} x->number obj
@deffnx {Generic Function} x->integer obj
Generic coercion functions.  Returns `natural' interpretation of @var{obj}
as a number or an exact integer, respectively.
The default methods are defined for numbers and strings; a string is
interpreted by @var{string->number}, and if the string can't be
interpreted as a number, 0 is returned.
Other @var{obj} is simply converted to 0.
If @var{obj} is naturally interpreted
as a number that is not an exact integer, @code{x->integer} uses
@code{round} and @code{inexact->exact} to obtain an integer.

Other class may provide a method to customize the behavior.
@end deffn

@node Bitwise operations,  , Numerical conversions, Numbers
@subsection Bitwise operations
@c NODE ビット演算

These procedures treat integers as half-open bit vectors.
If an integer is positive, it is regarded as if infinite number
of zeros are padded to the left.  If an integer is negative,
it is regarded in 2's complement form, and infinite number of
1's are padded to the left.

The API is consistent to SLIB's ``logical'' module.

@defun ash n count
Shifts integer @var{n} left with @var{count} bits.
If @var{count} is negative, @code{ash} shifts @var{n} right with
@minus{}@var{count} bits.

@example
; @r{Note: 6  @equiv{} [...00110], and}
; @r{      -6 @equiv{} [...11010]}
(ash 6 2)   @result{} 24  ;@r{[...0011000]}
(ash 6 -2)  @result{} 1   ;@r{[...0000001]}
(ash -6 2)  @result{} -24 ;@r{[...1101000]}
(ash -6 -2) @result{} -2  ;@r{[...1111110]}
@end example
@end defun
        
@defun logand n1 n2 @dots{}
@defunx logior n1 n2 @dots{}
@defunx logxor n1 n2 @dots{}
Returns bitwise and, bitwise inclusive or and bitwise exclusive or
of two or more integers @var{n1}, @var{n2} @dots{}.
@end defun

@defun lognot n
Returns bitwise not of an integer @var{n}.
@end defun

@defun logtest n1 n2 @dots{}
@equiv{} @code{(not (zero? (logand @var{n1} @var{n2} @dots{})))}
@end defun

@defun logbit? index n
Returns @code{#t} if @var{index}-th bit of integer @var{n} is 1, 
@var{#f} otherwise.
@end defun

@defun bit-field n start end
Extracts @var{start}-th bit (inclusive) to @var{end}-th bit (exclusive) from
an exact integer @var{n}, where @var{start} < @var{end}.
@end defun

@defun copy-bit index n bit
If @var{bit} is true, sets @var{index}-th bit of an exact integer @var{n}.
If @var{bit} is false, resets @var{index}-th bit of an exact integer @var{n}.
@end defun

@defun copy-bit-field n start end from
Returns an exact integer, each bit of which is the same as
@var{n} except the @var{start}-th bit (inclusive) to @var{end}-th
bit (exclusive), which is a copy of the lower
@code{(@var{end}-@var{start})}-th bits of an exact
integer @var{from}.

@example
(number->string (copy-bit-field #b10000000 1 5 -1) 2)
  @result{} "10011110"

(number->string (copy-bit-field #b10000000 1 7 #b010101010) 2)
  @result{} "11010100"
@end example
@end defun

@defun logcount n
If @var{n} is positive, returns the number of @code{1}'s in the
bits of @var{n}.  If @var{n} is negative, 
returns the number of @code{0}'s in the bits of 2's complement
representation of @var{n}.

@example
(logcount 0)      @result{} 0
(logcount #b0010) @result{} 1
(logcount #b0110) @result{} 2
(logcount #b1111) @result{} 4

(logcount #b-0001) @result{} 0  ;; 2's complement:  ....111111
(logcount #b-0010) @result{} 1  ;; 2's complement:  ....111110
(logcount #b-0011) @result{} 1  ;; 2's complement:  ....111101
(logcount #b-0100) @result{} 2  ;; 2's complement:  ....111100
@end example
@end defun

@defun integer-length n
Returns the minimum number of bits required to represent an
exact integer @var{n}.  Negative integer is assumed to be in
2's complement form.  A sign bit is not considered.

@example
(integer-length 255)  @result{} 8
(integer-length 256)  @result{} 9

(integer-length -256)  @result{} 8
(integer-length -257)  @result{} 9
@end example
@end defun

@c ----------------------------------------------------------------------
@node Booleans, Pairs and Lists, Numbers, Core library
@section Booleans
@c NODE 論理値

@deftp {Builtin Class} <boolean>
@clindex boolean
A boolean class.  Only @code{#t} and @code{#f} belong to this class.
@end deftp

@defun not obj
[R5RS]
Returns @code{#t} if and only if @var{obj} is @code{#f},
and returns @code{#f} otherwise.
@end defun

@defun boolean? obj
[R5RS]
Returns @code{#t} if @var{obj} is a boolean value.
@end defun

@defun boolean obj
Returns @code{#f} iff @var{obj} is @code{#f}, and returns @code{#t}
otherwise.  Convenient to coerce a value to boolean.
@end defun


@c ----------------------------------------------------------------------
@node Pairs and Lists, Symbols, Booleans, Core library
@section Pairs and Lists
@c NODE ペアとリスト

Pairs and lists are one of the most fundamental data structure in Scheme.
Gauche core provides all standard list procedures, plus some useful
procedures that are commonly supported in lots of implementations.
If they are not enough, you can find more procedures in the modules
described in @ref{List library}, 
@ref{Additional list library}, and
@ref{Combination library}.
See also @ref{Collection framework} and
@ref{Sequence framework} for generic collection/sequence
operations.

@menu
* Pair and null class::         
* List predicates::             
* List constructors::           
* List accessors and modifiers::  
* Other list procedures::       
@end menu

@node Pair and null class, List predicates, Pairs and Lists, Pairs and Lists
@subsection Pair and null class
@c NODE pairクラスとnullクラス

@deftp {Builtin Class} <list>
@clindex list
An abstract class represents lists.   A parent class of @code{<null>}
and @code{<pair>}.   Inherits @code{<sequence>}.

Note that a circular list is also an instance of the @code{<list>} class,
while R5RS procedure @code{list?} returns false on the circular lists and
dotted lists.
@lisp
(use srfi-1)
(list? (circular-list 1 2)) @result{} #f
(is-a? (circular-list 1 2) <list>) @result{} #t
@end lisp
@end deftp

@deftp {Builtin Class} <null>
@clindex null
A class of empty list.  @code{()} is the only instance.
@end deftp

@deftp {Builtin Class} <pair>
@clindex pair
A class of pairs.
@end deftp

@node List predicates, List constructors, Pair and null class, Pairs and Lists
@subsection List predicates
@c NODE リストに関する述語

@defun pair? obj
[R5RS]
Returns @code{#t} if @var{obj} is a pair, @code{#f} otherwise.
@end defun

@defun null? obj
[R5RS] 
Returns @code{#t} if @var{obj} is an empty list, @code{#f} otherwise.
@end defun

@defun list? obj
[R5RS]
Returns @code{#t} if @var{obj} is a proper list, @code{#f} otherwise.
This function returns @code{#f} if @var{obj} is a dotted or circular list.

See also @code{proper-list?}, @code{circular-list?} and
@code{dotted-list?} in @ref{SRFI-1 List predicates}.
@end defun

@node List constructors, List accessors and modifiers, List predicates, Pairs and Lists
@subsection List constructors
@c NODE リストの作成

@defun cons obj1 obj2
[R5RS] 
Constructs a pair of @var{obj1} and @var{obj2} and returns it.
@lisp
(cons 'a 'b) @result{} (a . b)
@end lisp
@end defun

@defun acons obj1 obj2 obj3
Returns @code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})}.
Useful to put an entry at the head of an associative list.
@lisp
(acons 'a 'b '((c . d))) @result{} ((a . b) (c . d))
@end lisp
@end defun

@defun make-list len &optional fill
[SRFI-1]
Makes a proper list of length @var{len}.  If optional argument
@var{fill} is provided, each element is initialized by it.  Otherwise
each element is undefined.
@lisp
(make-list 5 #t) @result{} (#t #t #t #t #t)
@end lisp
@end defun

@defun list obj @dots{}
[R5RS]
Makes a list, whose elements are @var{obj} @dots{}.
@lisp
(list 1 2 3) @result{} (1 2 3)
(list) @result{} ()
@end lisp
@end defun

@defun list* obj1 obj2 @dots{}
Like @code{list}, but the last argument becomes cdr of the last pair.
SRFI-1 defines the same function with the name @code{cons*}.
@lisp
(list* 1 2 3) @result{} (1 2 . 3)
(list* 1) @result{} 1
@end lisp
@end defun

@defun list-copy list
[SRFI-1]
Shallow copies @var{list}.  If @var{list} is circular,
this function diverges.
@end defun


@node List accessors and modifiers, Other list procedures, List constructors, Pairs and Lists
@subsection List accessors and modifiers
@c NODE リストへのアクセスと変更

@defun car pair
@defunx cdr pair
[R5RS] 
Returns car and cdr of @var{pair}, respectively.
@end defun

@defun set-car! pair obj
@defunx set-cdr! pair obj
[R5RS] 
Modifies car and cdr of @var{pair}, by @var{obj}, respectively.

Note: @code{(setter car)} @equiv{} @code{set-car!}, and
@code{(setter cdr)} @equiv{} @code{set-cdr!}.
@end defun

@defun caar pair
@defunx cadr pair
@findex cdar
@findex cddr
@findex caaar
@findex caadr
@findex cadar
@findex caddr
@findex cdaar
@findex cdadr
@findex cddar
@findex cdddr
@findex caaaar
@findex caaadr
@findex caadar
@findex caaddr
@findex cadaar
@findex cadadr
@findex caddar
@findex cadddr
@findex cdaaar
@findex cdaadr
@findex cdadar
@findex cdaddr
@findex cddaar
@findex cddadr
@dots{}
@end defun
@defun cdddar pair
@defunx cddddr pair
[R5RS]
@code{caar} @equiv{} @code{(car (car x))},
@code{cadr} @equiv{} @code{(car (cdr x))}, and so on.

The corresponding setters are also defined.
@example
(let ((x (list 1 2 3 4 5)))
  (set! (caddr x) -1)
  x)
  @result{} (1 2 -1 4 5)
@end example
@end defun

@defun length list
[R5RS]
Returns the length of a proper list @var{list}.
If @var{list} is a dotted list, an error is signalled.
If @var{list} is a circular list, this function diverges.

If you want to handle circular lists as well, 
See @code{length+} in @ref{SRFI-1 List miscellaneous routines}.
@end defun

@defun list-tail list k &optional fallback
[R5RS]
Returns @var{k}-th cdr of @var{list}.
@var{list} can be a proper, dotted or circular list.
(If @var{list} is a dotted list, its last @code{cdr} is simply ignored).

If @var{k} is negative or larger than the length of @var{list},
the behavior depends on whether the optional @var{fallback} argument
is given or not.  If @var{fallback} is given, it is returned.
Otherwise, an error is signalled.
@end defun

@defun list-ref list k &optional fallback
[R5RS+]
Returns @var{k}-th element of @var{list}.
@var{list} can be a proper, dotted or circular list.

By default, @code{list-ref} signals an error if @var{k} is
negative, or greater than or equal to the length of @var{list}.
However, if an optional argument @var{fallback} is given,
it is returned for such case.  This is an extension of Gauche.
@end defun

@defun last-pair list
[SRFI-1]
Returns the last pair of @var{list}.
@var{list} can be a proper or dotted list.
@end defun

@node Other list procedures,  , List accessors and modifiers, Pairs and Lists
@subsection Other list procedures
@c NODE 他のリスト手続き

@defun append list @dots{}
[R5RS]
Returns a list consisting of the elements of the first @var{list} followed by
the elements of the other lists.  The resulting list is always newly
allocated, except that it shares structure with the last list argument.
The last argument may actually be any object; an improper list results
if the last argument is not a proper list. 
@end defun

@defun append! list @dots{}
[SRFI-1]
Returns a list consisting of the elements of the first @var{list} followed by
the elements of the other lists.  The cells in the lists except the last
one may be reused to construct the result.   The last argument may be
any object.
@end defun


@defun reverse list
[R5RS]
Returns a newly allocated list consisting of the elements of @var{list}
in reverse order.
@end defun

@defun reverse! list
[SRFI-1]
Returns a list consisting of the elements of @var{list} in reverse order.
The cells of @var{list} may be reused to construct the returned list.
@end defun

@defun memq obj list
@defunx memv obj list
@defunx member obj list
[R5RS]
Searches @var{obj} in the @var{list}.  If @code{n}-th element of
@var{list} equals to @var{obj} (in the sense of @code{eq?} for @code{memq},
@code{eqv?} for @code{memv}, and @code{equal?} for @code{member}), 
@code{(list-tail @var{list} @var{n})} is returned.
Otherwise, @code{#f} is returned.

If you use SRFI-1 (@xref{List library}), @code{member} is extended
to take optional argument for a equality procedure.
@example
(memq 'a '(a b c))          @result{} (a b c)
(memq 'b '(a b c))          @result{}  (b c)
(memq 'a '(b c d))          @result{} #f
(memq (list 'a) '(b (a) c)) @result{} #f
(memv 101 '(100 101 102))   @result{} (101 102)
@end example
@end defun

@defun assq obj list
@defunx assv obj list
@defunx assoc obj list
[R5RS]
Each element in @var{list} must be a pair.
These procedures search a pair whose car matches @var{obj}
(in the sense of @code{eq?} for @code{assq},
@code{eqv?} for @code{assv}, and @code{equal?} for @code{assoc})
from left to right, and return the leftmost matched pair if any.
If no pair matches, these return @code{#f}.

If you use SRFI-1 (@xref{List library}), @code{assoc} is extended
to take optional argument for a equality procedure.
@end defun

@c ----------------------------------------------------------------------
@node Symbols, Keywords, Pairs and Lists, Core library
@section Symbols
@c NODE シンボル

@deftp {Builtin Class} <symbol>
@clindex symbol
A class for symbols.
@end  deftp

@deftp {Reader Syntax} @code{|@i{name}|}
Denotes a symbol that has weird name, i.e. the name including the
characters which is not allowed in the R5RS symbol syntax.
If the interpreter is running in case-insensitive mode, this syntax
can be used to include uppercase characters in a symbol
(@xref{Case-sensitivity}).

The syntax is taken from CommonLisp.  Some other Scheme implementation
use it as well.
@end deftp

@defun symbol? obj
[R5RS] 
Returns true if and only if @var{obj} is a symbol.
@example
(symbol? 'abc)     @result{} #t
(symbol? 0)        @result{} #f
(symbol? 'i)       @result{} #t
(symbol? '-i)      @result{} #f
(symbol? '|-i|)    @result{} #t
@end example
@end defun

@defun symbol->string symbol
[R5RS]
Returns the name of @var{symbol} in a string.  Returned
string is immutable.

@example
(symbol->string 'foo) @result{} foo
@end example
@end defun

@defun string->symbol string
[R5RS]
Returns a symbol whose name is a string @var{string}.
@var{String} may contain weird characters.

@example
(string->symbol "a") @result{} a
(string->symbol "A") @result{} A
(string->symbol "weird symbol name") @result{} |weird symbol name|
@end example
@end defun

@defun gensym &optional prefix
@end defun

@c ----------------------------------------------------------------------
@node Keywords, Identifiers, Symbols, Core library
@section Keywords
@c NODE キーワード

@deftp {Builtin Class} <keyword>
@clindex keyword
A keyword is a sort of a special symbol that is automatically quoted.
It is extensively used in pass-by-name arguments (keyword arguments),
and keyword-value list.
Unlike CommonLisp, keywords and symbols are distinct types.

See also @code{let-keywords} macro (@ref{Optional argument parsing})
for keyword argument processing.
@end  deftp

@deftp {Reader syntax} @code{:@var{name}}
Read to a keyword whose name is @var{name}.
(Note that the preceding ':' is not a part of the keyword's name.)
@end deftp

@defun keyword? obj
Returns @code{#t} if @var{obj} is a keyword.
@end defun

@defun make-keyword name
Returns a keyword whose name is @var{name}, which can be
can be a string or a symbol.
@example
(make-keyword "foo")  @result{} :foo

(make-keyword 'foo)   @result{} :foo
@end example
@end defun

@defun keyword->string keyword
Returns the name of the keyword @var{keyword}, in a string.
@example
(keyword->string :foo) @result{} "foo"
@end example
@end defun

@defun get-keyword key kv-list &optional fallback
A useful procedure to extract a value from key-value list.
A key-value list @var{kv-list} must contains even number of elements;
the first, third, fifth @dots{} elements are regarded as keys,
and the second, fourth, sixth @dots{} elements are the values of
the preceding keys.

This procedure looks for @var{key} from the keys, and if it finds one,
it returns the corresponding value.
If there are more than one matching keys, the leftmost one is taken.
If there is no matching key, it returns @var{fallback} if provided,
or signals an error otherwise.

It is an error if @var{kv-list} is not a proper, even-number element list.

Actually, `keywords' in the keyword-value list and the @var{key} argument
need not be a keyword---it can be any Scheme object.  Key comparison
is done by @code{eq?}.

This procedure is taken from STk.

@example
(get-keyword :y '(:x 1 :y 2 :z 3))
  @result{} 2
(get-keyword 'z '(x 1 y 2 z 3))
  @result{} 3

(get-keyword :t '(:x 1 :y 2 :z 3))
  @result{} #<error>
(get-keyword :t '(:x 1 :y 2 :z 3) #f)
  @result{} #f
@end example
@end defun

@defmac get-keyword* key kv-list &optional fallback
Like @code{get-keyword}, but @var{fallback} is evaluated only
if @var{kv-list} does not have @var{key}.
@end defmac

@defun delete-keyword key kv-list
@defunx delete-keyword! key kv-list
Removes all the keys and values from @var{kv-list} for
keys that are @code{eq?} to @var{key}.

@code{delete-keyword} doesn't change @var{kv-list}, but the returned
list may share the common tail of it.

@code{delete-keyword!} doesn't allocate, and @emph{may} destructively
changes @var{kv-list}.  You still have to use the returned value,
for the original list may not be changed if its first key matches
@var{key}.

If there's no key that matches @var{key}, @var{kv-list} is returned.

@example
(delete-keyword :y '(:x 1 :y 2 :z 3 :y 4))
 @result{} (:x 1 :z 3)
@end example

@end defun



@c ----------------------------------------------------------------------
@node Identifiers, Characters, Keywords, Core library
@section Identifiers
@c NODE Identifier

@deftp {Builtin Class} <identifier>
@clindex identifier
@end  deftp

@defun identifier? obj
@end defun

@defun identifier->symbol identifier
@end defun


@c ----------------------------------------------------------------------
@node Characters, Character set, Identifiers, Core library
@section Characters
@c NODE 文字

@deftp {Builtin Class} <char>
@clindex char
@end  deftp

@deftp {Reader Syntax} @code{#\@i{charname}}
[R5RS]
Denotes a literal character.

When the reader reads @code{#\}, it fetches a subsequent character.
If it is one of @code{()[]@{@}" \|;#}, this is a character literal of itself.
Otherwise, the reader reads subsequent characters until it sees
a non word-constituent character.  If only one character is read,
it is the character.  Otherwise, the reader matches the read characters
with predefined character names.  If it doesn't match any, an error
is signalled.

The following character names are recognized.
These character names are case insensitive.
@table @code
@item space
Whitespace (ASCII #x20)
@item newline, nl, lf
Newline (ASCII #x0a)
@item return, cr
Carriage return (ASCII #x0d)
@item tab, ht
Horizontal tab (ASCII #x09)
@item page
Form feed (ASCII #x0c)
@item escape, esc
Escape (ASCII #x1b)
@item delete, del
Delete (ASCII #x7f)
@item null
NUL character (ASCII #x00)
@item x@var{N}
A character whose internal encoding is the integer @var{N},
when @var{N} is a hexadecimal integer.
Note that this notation is not portable among different
internal encoding schemes except ASCII character range.
@item u@var{N}
A character whose UCS character code is the integer @var{N},
where @var{N} is 4-digit or 8-digit hexadecimal number.
If Gauche is compiled with the internal encoding other than UTF-8,
the reader uses @code{gauche.charconv} module to convert Unicode
to the internal character code.  Note that the specified character
may not be defined in the internal encoding; in which case, either
a substitution character is used, or an error is signalled.
@end table

@example
#\newline @result{} #\newline ; @r{newline character}
#\x0a     @result{} #\newline ; @r{ditto}
#\x41     @result{} #\A       ; @r{ASCII letter 'A'}
#\u0041   @result{} #\A       ; @r{ASCII letter 'A', specified by UCS}
#\u3042   @result{} ; @r{Hiragana letter A, specified by UCS}
#\u0002a6b2 @result{} ; @r{JISX0213 Kanji 2-94-86, specified by UCS4}
@end example

You can denote multibyte characters with this syntax if
the program text is written in the same encoding as the internal
character encoding.
@end deftp

@defun char? obj
[R5RS]
Returns @code{#t} if @var{obj} is a character, @code{#f} otherwise.
@end defun

@defun char@code{=}? char1 char2
@defunx char@code{<}? char1 char2
@defunx char@code{<=}? char1 char2
@defunx char@code{>}? char1 char2
@defunx char@code{>=}? char1 char2
[R5RS]
Compares characters.  Character comparison is done in internal
character encoding.
@end defun

@defun char-ci@code{=}? char1 char2
@defunx char-ci@code{<}? char1 char2
@defunx char-ci@code{<=}? char1 char2
@defunx char-ci@code{>}? char1 char2
@defunx char-ci@code{>=}? char1 char2
[R5RS]
Compares characters in case-insensitive way.
In the current version, character cases are not well defined
outside the ASCII character range.
@end defun

@defun char-alphabetic? char
@defunx char-numeric? char
@defunx char-whitespace? char
@defunx char-upper-case? char
@defunx char-lower-case? char
[R5RS]
Returns true if a character @var{char} is an alphabetic character
(@code{[A-Za-z]}), a numeric character (@code{[0-9]}), a whitespace
character, an upper case character or a lower case character, respectively.
Currently, these procedures works only for ASCII characters.  They
return @code{#f} for all other characters.
@end defun

@defun char->integer char
@defunx integer->char n
[R5RS]
@code{char->integer} returns an exact integer that represents
internal encoding of the character @var{char}.
@code{integer->char} returns a character whose internal encoding
is an exact integer @var{n}.  The following expression is always
true for valid character @var{char}:
@example
(eq? char (integer->char (char->integer char)))
@end example

The result is undefined if you pass @var{n} to @code{integer->char}
that doesn't have a corresponding character.
@end defun

@defun char->ucs char
@defunx ucs->char n
Converts a character @var{char} to integer UCS codepoint,
and integer UCS codepoint @var{n} to a character, respectively.

If Gauche is compiled with UTF-8 encoding, these procedures are the 
same as @code{char->integer} and @code{integer->char}.

When Gauche's internal encoding differs from UTF-8, these procedures
implicitly loads @code{gauche.charconv} module to convert internal
character code to UCS or vice versa (@xref{Character code conversion}).
If @var{char} doesn't have corresponding UCS codepoint, 
@code{char->ucs} returns @code{#f}.  If UCS codepoint @var{n} can't
be represented in the internal character encoding, @code{ucs->char}
returns @code{#f}, unless the conversion routine provides a substitution
character.
@end defun

@defun char-upcase char
@defunx char-downcase char
[R5RS]
Returns the upper case and lower case of @var{char}, respectively.
If @var{char} doesn't have such distinction of upper or lower case,
@code{char} itself is returned.

In the current version, character cases are not well defined
outside the ASCII character range.
@end defun

@defun digit->integer char &optional (radix 10)
If given character @var{char} is a valid digit character in radix
@var{radix} number, the corresponding integer is returned.  Otherwise
@code{#f} is returned.
@example
(digit->integer #\4) @result{} 4
(digit->integer #\e 16) @result{} 14
(digit->integer #\9 8) @result{} #f
@end example
Note: CommonLisp has a similar function in rather confusing name,
@code{digit-char-p}.
@end defun

@defun integer->digit integer &optional (radix 10)
Reverse operation of @code{digit->integer}.  Returns a character that
represents the number @var{integer} in the radix @var{radix} system.
If @var{integer} is out of the valid range, @code{#f} is returned.
@example
(integer->digit 13 16) @result{} #\d
(integer->digit 10) @result{} #f
@end example
Note: CommonLisp's @code{digit-char}.
@end defun

@defun gauche-character-encoding
Returns a symbol designates the native character encoding, selected
at the compile time.
The possible return values are those:
@table @code
@item euc-jp
EUC-JP
@item utf-8
UTF-8
@item sjis
Shift JIS
@item none
No multibyte character support (8-bit fixed-length character).
@end table
@end defun

@defun supported-character-encodings
Returns a list of string names of character encoding schemes
that are supported in the native multibyte encoding scheme.
@end defun



@c ----------------------------------------------------------------------
@node Character set, Strings, Characters, Core library
@section Character Set
@c NODE 文字集合

@deftp {Builtin Class} <char-set>
@clindex char-set
Character set class.  Character set object represents a set of characters.
Gauche provides built-in support of character set creation and
a predicate that tests whether a character is in the set or not.

Further operations, such as set algebra, is defined in SRFI-14
module (@xref{Character-set library}).
@end deftp

@deftp {Reader Syntax} @code{#[@i{char-set-spec}]}
You can write a literal character set in this syntax.
@i{char-set-spec} is a sequence of characters to be included
in the set.  You can include the following special sequences:
@table @code
@item @var{x}-@var{y}
Characters between @var{x} and @var{y}, inclusive.
@var{x} must be smaller than @var{y} in the internal encoding.
@item ^
If @i{char-set-spec} begins with caret, the actual character set
is a complement of what the rest of @i{char-set-spec} indicates.
@item \x@var{NN}
A character whose internal code is a hexadecimal number @var{NN}.
@item \u@var{NNNN}
A character whose UCS-2 code is a 4-digit hexadecimal number @var{NNNN}.
@item \U@var{NNNNNNNN}
A character whose UCS-4 code is a 8-digit hexadecimal number @var{NNNNNNNN}.
@item \s
Whitespace characters.
@item \S
Complement of whitespace characters.
@item \d
Decimal digit characters.
@item \D
Complement of decimal digit characters.
@item \w
Word constituent characters.  Currently, it is alphanumeric characters
and underscore.
@item \W
Complement of word constituent characters.
@item \\
A backslash character.
@item \-
A minus character.
@item \^
A caret character.
@item [:alnum:] @dots{}
Character set a la POSIX.  The following character set name is
recognized: @code{alnum}, @code{alpha}, @code{blank}, @code{cntrl},
@code{digit}, @code{graph}, @code{lower}, @code{print}, @code{punct},
@code{space}, @code{upper} and @code{xdigit}.
@end table

@example
#[aeiou]     ; @r{a character set consists of vowels}
#[a-zA-Z]    ; @r{alphabet}
#[[:alpha:]] ; @r{alphabet (using POSIX notation)}
#[\x0d\x0a]  ; @r{newline and carriage return}
#[\\\-]      ; @r{backslash and minus}
#[]          ; @r{empty charset}
@end example
@end deftp

@defun char-set? obj
[SRFI-14]
Returns true if and only if @var{obj} is a character set object.
@end defun

@defun char-set-contains? char-set char
[SRFI-14]
Returns true if and only if a character set object
@var{char-set} contains a character @var{char}.
@example
(char-set-contains? #[a-z] #\y) @result{} #t
(char-set-contains? #[a-z] #\3) @result{} #f

(char-set-contains? #[^ABC] #\A) @result{} #f
(char-set-contains? #[^ABC] #\D) @result{} #t

@end example
@end defun

@defun char-set char @dots{}
[SRFI-14]
Creates a character set that contains @var{char} @dots{}.
@example
(char-set #\a #\b #\c)   @result{} #[a-c]
@end example
@end defun

@defun char-set-copy char-set
[SRFI-14]
Copies a character set @var{char-set}.
@end defun


@c ----------------------------------------------------------------------
@node Strings, Regular expression, Character set, Core library
@section Strings
@c NODE 文字列

@deftp {Builtin Class} <string>
@clindex string
A string class.   In Gauche, a string can be viewed in two ways:
a sequence of characters, or a sequence of bytes.
@end deftp

R5RS string operations are very minimal.  Gauche supports some
extra built-in operations, and also a rich string library
defined in SRFI-13.   @xref{String library}, for details about SRFI-13.

@menu
* String syntax::               
* String Predicates::           
* String Constructors::         
* String interpolation::        
* String Accessors & Modifiers::  
* String Comparison::           
* String utilities::            
* Incomplete strings::          
@end menu

@node String syntax, String Predicates, Strings, Strings
@subsection String syntax
@c NODE 文字列の表記

@deftp {Reader syntax} @code{"}@dots{}@code{"}
[R5RS+]
Denotes a literal string.  Inside the double quotes, the following
backslash escape sequences are recognized.

@table @code
@item \"
[R5RS] Double-quote character
@item \\
[R5RS] Backslash character
@item \n
Newline character (ASCII 0x0a).
@item \r
Return character (ASCII 0x0d).
@item \f
Form-feed character (ASCII 0x0c).
@item \t
Tab character (ASCII 0x09)
@item \0
ASCII NUL character (ASCII 0x00).
@item \<whitespace>*<newline><whitespace>*
Ignored.  This can be used to break a long string literal for readability.
This escape sequence is introduced in R6RS.
@item \x@var{NN}
A byte represented by two-digit hexadecimal number @var{NN}.
The byte is interpreted as the internal multibyte encoding.
@item \u@var{NNNN}
A character whose UCS2 code is represented by four-digit
hexadecimal number @var{NNNN}.
@item \U@var{NNNNNNNN}
A character whose UCS4 code is represented by eight-digit
hexadecimal number @var{NNNNNNNN}.
@end table

If Gauche is compiled with internal encoding other than UTF-8,
the reader uses @code{gauche.charconv} module to interpret
@code{\uNNNN} and @code{\UNNNNNNNN} escape sequence.

The following code is an example of backslash-newline escape sequence:
@example
(define *message* "\
  This is a long message \
  in a literal string.")

*message*  
  @result{} "This is a long message in a literal string."
@end example

Note the whitespace just after `message'.   Since any whitespaces
before `in' is eaten by the reader, you have to put a whitespace
between `message' and the following backslash.  If you want to include
an actual newline character in a string, and any indentation after it,
you can put '\n' in the next line like this:

@example
(define *message/newline* "\
  This is a long message, \
  \n   with a line break.")
@end example
@end deftp

@deftp {Reader syntax} @code{#*"}@dots{}@code{"}
Denotes incomplete string.  The same escape sequences as the complete
string syntax are recognized.

Rationale of the syntax: '@code{#*}' is used for bit vector
in Common Lisp.  Since an incomplete strings is really a byte vector,
it has similarity.  (Bit vector can be added later, if necessary,
and two can coexist).
@end deftp


@node String Predicates, String Constructors, String syntax, Strings
@subsection String Predicates
@c NODE 文字列に関する述語

@defun string? obj
[R5RS]
Returns @code{#t} if @var{obj} is a string, @code{#f} otherwise.
@end defun

@defun string-immutable? obj
Returns @code{#t} if @var{obj} is an immutable string, @code{#f} otherwise
@end defun

@defun string-incomplete? obj
Returns @code{#t} if @var{obj} is an incomplete string, @code{#f} otherwise
@end defun

@node String Constructors, String interpolation, String Predicates, Strings
@subsection String Constructors
@c NODE 文字列の作成

@defun make-string k &optional char
[R5RS]
Returns a string of length @var{k}.  If optional @var{char} is given,
the new string is filled with it.  Otherwise, the string is filled with
a whitespace.  The result string is always complete.

@example
(make-string 5 #\x) @result{} "xxxxx"
@end example

Note that the algorithm to allocate a string by @code{make-string} and
then fills it one character at a time is @emph{extremely} inefficient
in Gauche, and should be avoided.   That kind of algorithms unnecessarily
assumes underlying string allocation and representation mechanism,
which Gauche doesn't follow.
You can use an output string port for a string construction
(@xref{String ports}).
Even creating a list of characters and
using @code{list->string} is faster than using @code{make-string} and
@code{string-set!}.
@end defun

@defun make-byte-string k &optional byte
Creates and returns an incomplete string o size @var{k}.
If @var{byte} is given,
which must be an exact integer, and its lower 8 bits
are used to initialize every byte in the created string.
@end defun

@defun string char @dots{}
[R5RS]
Returns a string consisted by @var{char} @dots{}.
@end defun

@deffn {Generic Function} x->string obj
A generic coercion function.
Returns a string representation of @var{obj}.
The default methods are defined as follows: strings are returned
as is, numbers are converted by @code{number->string}, symbols are
converted by @code{symbol->string}, and other objects are
converted by @code{display}.

Other class may provide a method to customize the behavior.
@end deffn

@node String interpolation, String Accessors & Modifiers, String Constructors, Strings
@subsection String interpolation
@c NODE 文字列の補間

The term "string interpolation" is used in various scripting languages
such as Perl and Python to refer to the feature to embed expressions
in a string literal, which are evaluated and then their results are
inserted into the string literal at run time.

Scheme doesn't define such a feature, but Gauche implements it as a
reader macro.

@deftp {Reader syntax} @code{#`}@var{string-literal}
Evaluates to a string.  If @var{string-literal} contains the
character sequence @code{,@var{expr}}, where 
@var{expr} is a valid external representation
of a Scheme expression, @var{expr} is evaluated and
its result is inserted in the original place (by using @code{x->string},
see @ref{String Constructors}).

The comma and the following expression must be adjacent (without containing
any whitespace characters), or it is not recognized as a special sequence.

Two adjacent commas are converted to a single comma.  You can embed
a comma before a non-whitespace character in @var{string-literal}
by this.

Other characters in the @var{string-literal} are copied as is.

If you use a variable as @var{expr} and need to delimit it from the
subsequent string, you can use the symbol escape syntax
using `|' character, as shown in the last two examples below.

@example
#`"This is Gauche, version ,(gauche-version)."
 @result{} "This is Gauche, version 0.8.14."

#`"Date: ,(sys-strftime \"%Y/%m/%d\" (sys-localtime (sys-time)))"
 @result{} "Date: 2002/02/18"

(let ((a "AAA")
      (b "BBB"))
 #`"xxx ,a ,b zzz")
 @result{} "xxx AAA BBB zzz"

#`"123,,456,,789"
 @result{} "123,456,789"

(let ((n 5)) #`"R,|n|RS")
 @result{} "R5RS"

(let ((x "bar")) #`"foo,|x|.")
 @result{} "foobar"
@end example

In fact, the reader expands this syntax into a macro call,
which is then expanded into a call of @code{string-append}
as follows:
@example
#`"This is Gauche, version ,(gauche-version)."
 @equiv{}
(string-append "This is Gauche, version "
               (x->string (gauche-version))
               ".")
@end example
@end deftp

@emph{Rationale of the syntax:}
Some other scripting languages use `@code{$expr}' or '@code{#@{...@}}'.
I chose this syntax with respect to the quasiquote (@xref{Quasiquotation}).
Although it may be awkward to delimit variable names by `|',
the comma syntax should be easier to read than the other exotic syntax
for seasoned Scheme programmers.

Note that Scheme allows wider range of characters for valid identifier names
than usual scripting languages.
Consequently, you will almost always need to use `|' delimiters
when you interpolate the value of a variable.
For example, while you can write
@code{"$year/$month/$day $hour:$minutes:$seconds"} in Perl,
you should write @code{#`",|year|/,|month|/,day ,|hour|:,|minutes|:,seconds"}.
It may be better always to delimit direct variable references
in this syntax to avoid confusion.

@node String Accessors & Modifiers, String Comparison, String interpolation, Strings
@subsection String Accessors & Modifiers
@c NODE 文字列のアクセスと変更

@defun string-length string
[R5RS]
Returns a length of (possibly incomplete) string @var{string}.
@end defun

@defun string-size string
Returns a size of (possibly incomplete) @var{string}.
A size of string is a number of bytes @var{string} occupies on memory.
The same string may have different sizes if the native encoding scheme
differs.

For incomplete string, its length and its size always match.
@end defun

@defun string-ref cstring k &optional fallback
[R5RS+]
Returns @var{k}-th character of a complete string @var{cstring}.
It is an error to pass an incomplete string.

By default, an error is signalled if @code{k} is out of range
(negative, or greater than or equal to the length of @var{cstring}).
However, if an optional argument @var{fallback} is given,
it is returned in such case.  This is Gauche's extension.
@end defun

@defun string-byte-ref string k
Returns @var{k-th} byte of a (possibly incomplete) string @var{string}.
Returned value is an integer in the range between 0 and 255.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
@end defun

@defun string-set! string k char
[R5RS] Substitute @var{string}'s @var{k}-th character by @var{char}.
@var{k} must be greater than or equal to zero, and less than
@code{(string-length @var{string})}.
Return value is undefined.

If @var{string} is an incomplete string, integer value of the lower 8 bits
of @var{char} is used to set @var{string}'s @var{k}-th byte.

See the notes in @code{make-string} about performance consideration.
@end defun

@defun string-byte-set! string k byte
Substitute @var{string}'s @var{k}-th byte by integer @var{byte}.
@var{byte} must be in the range between 0 to 255, inclusive.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
If @var{string} is a complete string, it is turned to incomplete string
by this operation.
Return value is undefined.
@end defun

@node String Comparison, String utilities, String Accessors & Modifiers, Strings
@subsection String Comparison
@c NODE 文字列の比較

@defun string=? string1 string2
@defunx string-ci@code{=}? string1 string2
[R5RS]
@end defun

@defun string@code{<}? string1 string2
@defunx string@code{<=}? string1 string2
@defunx string@code{>}? string1 string2
@defunx string@code{>=}? string1 string2
@defunx string-ci@code{<}? string1 string2
@defunx string-ci@code{<=}? string1 string2
@defunx string-ci@code{>}? string1 string2
@defunx string-ci@code{>=}? string1 string2
[R5RS]
@end defun

@node String utilities, Incomplete strings, String Comparison, Strings
@subsection String utilities
@c NODE 文字列を扱うその他の手続き

@defun substring string start end
[R5RS]
Returns a substring of @var{string}, starting from @var{start}-th
character (inclusive) and ending at @var{end}-th character (exclusive).
The @var{start} and @var{end} arguments must satisfy 
@code{0 <= @var{start} < @var{N}},
@code{0 <= @var{end} <= @var{N}}, and
@code{@var{start} <= @var{end}}, where @var{N} is the length of the
string.

When @var{start} is zero and @var{end} is @var{N}, this procedure
returns a copy of @var{string}.

Actually, extended @code{string-copy} explained below
is a superset of @code{substring}.  This procedure is 
kept mostly for compatibility of R5RS programs.
See also @code{subseq} in @ref{Sequence framework}, 
for the generic version.
@end defun

@defun string-append string @dots{}
[R5RS]
Returns a newly allocated string whose content is concatenation of 
@var{string} @dots{}.

See also @code{string-concatenate} in @ref{SRFI-13 String reverse & append}.
@end defun

@defun string->list string &optional start end
@defunx list->string list
[R5RS+][SRFI-13]
Converts a string to a list of characters or vice versa.

You can give an optional start/end indexes to @code{string->list},
as specified in SRFI-13.

For @var{list->string}, every elements of @var{list} must be
a character, or an error is signalled.  If you want to build
a string out of a mixed list of strings and characters, you
may want to use @code{tree->string} in @ref{Lazy text construction}.
@end defun

@defun string-copy string &optional start end
[R5RS+][SRFI-13]
Returns a copy of @var{string}.  You can give @var{start} and/or
@var{end} index to extract the part of the original string
(it makes @code{string-copy} a superset of @code{substring} effectively).

If only @var{start} argument is given, a substring beginning from
@var{start}-th character (inclusive) to the end of @var{string} is
returned.  If both @var{start} and @var{end} argument are given,
a substring from @var{start}-th character (inclusive) to
@var{end}-th character (exclusive) is returned.
See @code{substring} above for the condition that @var{start} and
@var{end} should satisfy.
@end defun

@defun string-fill! string char &optional start end
[R5RS+][SRFI-13] Fills @var{string} by @var{char}.  Optional
@var{start} and @var{end} limits the effective area.
@example
(string-fill! "orange" #\X)
  @result{} "XXXXXX"
(string-fill! "orange" #\X 2 4)
  @result{} "orXXge"
@end example
@end defun

@defun string-join strs &optional delim grammer
[SRFI-13] Concatenate strings in the list @var{strs},
with a string @var{delim} as `glue'.

The argument @var{grammer} may be one of the following symbol
to specify how the strings are concatenated.
@table @code
@item infix
Use @var{delim} between each string.  This mode is default.
Note that this mode introduce ambiguity when @var{strs}
is an empty string or a list with a null string.
@example
(string-join '("apple" "mango" "banana") ", ") 
  @result{} "apple, mango, banana"
(string-join '() ":")
  @result{} ""
(string-join '("") ":")
  @result{} ""
@end example
@item strict-infix
Works like @code{infix}, but empty list is not allowed to @var{strs},
thus avoiding ambiguity.
@item prefix
Use @var{delim} before each string.
@example
(string-join '("usr" "local" "bin") "/" 'prefix)
  @result{} "/usr/local/bin"
(string-join '() "/" 'prefix)
  @result{} ""
(string-join '("") "/" 'prefix)
  @result{} "/"
@end example
@item suffix
Use @var{delim} after each string.
@example
(string-join '("a" "b" "c") "&" 'suffix)
  @result{} "a&b&c&"
(string-join '() "&" 'suffix)
  @result{} ""
(string-join '("") "&" 'suffix)
  @result{} "&"
@end example
@end table

@end defun

@defun string-scan string item &optional return
Scan @var{item} (either a string or a character) in @var{string}.
The @var{return} argument specifies what value should be returned
when @var{item} is found in @var{string}.  It must be one of the
following symbols.

@table @code
@item index
Returns the index in @var{string} if @var{item} is found, or @code{#f}.
This is the default behavior.
@example
(string-scan "abracadabra" "ada") @result{} 5
(string-scan "abracadabra" #\c) @result{} 4
(string-scan "abracadabra" "aba") @result{} #f
@end example
@item before
Returns a substring of @var{string} before @var{item}, or
@code{#f} if @var{item} is not found.
@example
(string-scan "abracadabra" "ada" 'before) @result{} "abrac"
(string-scan "abracadabra" #\c 'before) @result{} "abra"
@end example
@item after
Returns a substring of @var{string} after @var{item}, or
@code{#f} if @var{item} is not found.
@example
(string-scan "abracadabra" "ada" 'after) @result{} "bra"
(string-scan "abracadabra" #\c 'after) @result{} "adabra"
@end example
@item before*
Returns a substring of @var{string} before @var{item}, and
the substring after it.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'before*)
  @result{} "abrac" @r{and} "adabra"
(string-scan "abracadabra" #\c 'before*)
  @result{} "abra" @r{and} "cadabra"
@end example
@item after*
Returns a substring of @var{string} up to the end of @var{item},
and the rest.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'after*)
  @result{} "abracada" @r{and} "bra"
(string-scan "abracadabra" #\c 'after*)
  @result{} "abrac" @r{and} "adabra"
@end example
@item both
Returns a substring of @var{string} before @var{item} and
after @var{item}.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'both)
  @result{} "abrac" @r{and} "bra"
(string-scan "abracadabra" #\c 'both)
  @result{} "abra" @r{and} "adabra"
@end example
@end table
@end defun

@defun string-split string splitter
Splits @var{string} by @var{splitter} and returns a list of strings.
@var{splitter} can be a character, a character set, a string,
a regexp, or a procedure.

If @var{splitter} is a character, the character is used as a delimiter.

If @var{splitter} is a character set, any consecutive characters
that are member of the character set are used as a delimiter.

If a procedure is given to @var{splitter}, it is called for each
character in @var{string}, and the consecutive characters that caused
@var{splitter} to return a true value are used as a delimiter.

@example
(string-split "/aa/bb//cc" #\/)    @result{} ("" "aa" "bb" "" "cc")
(string-split "/aa/bb//cc" "/")    @result{} ("" "aa" "bb" "" "cc")
(string-split "/aa/bb//cc" "//")   @result{} ("/aa/bb" "cc")
(string-split "/aa/bb//cc" #[/])   @result{} ("" "aa" "bb" "cc")
(string-split "/aa/bb//cc" #/\/+/) @result{} ("" "aa" "bb" "cc")
(string-split "/aa/bb//cc" #[\w])  @result{} ("/" "/" "//" "")
(string-split "/aa/bb//cc" char-alphabetic?) @result{} ("/" "/" "//" "")

;; some boundary cases
(string-split "abc" #\/) @result{} ("abc")
(string-split ""    #\/) @result{} ("")
@end example

See also @code{string-tokenize} in
(@xref{SRFI-13 other string operations}).
@end defun

@node Incomplete strings,  , String utilities, Strings
@subsection Incomplete strings
@c NODE 不完全文字列

A string can be flagged as "incomplete" if it may contain
byte sequences that do not consist of a valid multibyte character
in the Gauche's native encoding.

Incomplete strings may be genereated in several circumstances;
reading binary data as a string, reading a string data that has
been 'chopped' in middle of a multibyte character, or 
concatenating a string with other incomplete strings, for example.

Incomplete strings should be regarded as an exceptional case.
It used to be a way to handle byte strings, but now we have
u8vector (@xref{Uniform vectors}) for that purpose.
In fact, we're planning to remove it in the future releases.

Just in case, if you happen to get an incomplete string,
you can convert it to a complete string by the following 
procedure:

@defun string-incomplete->complete str &optional handling
Reinterpret the content of an incomplete string @var{str}
and returns a newly created complete string from it.
The @var{handling} argument specifies how to handle the illegal
byte sequences in @var{str}.
@table @asis
@item @code{#f}
If @var{str} contains an illegal byte sequence, give up the
conversion and returns @code{#f}.  This is the default behavior.
@item @code{:omit}
Omit any illegal byte sequences.  Always returns a complete string.
@item a character
Replace each byte in illegal byte sequences by the given character.
Always returns a complete string.
@end table
If @var{str} is already a complete string, its copy is returned.
@end defun

@c ----------------------------------------------------------------------
@node Regular expression, Vectors, Strings, Core library
@section Regular expression
@c NODE 正規表現

Gauche has a built-in regular expression engine which is mostly
upper-compatible of POSIX extended regular expression.
Gauche's regexp also includes some extensions from Perl 5 regexp.

@deftp {Builtin Class} <regexp>
@clindex regexp
Regular expression object.  You can construct a regexp object
from a string by @code{string->regexp} at run time.  Gauche also 
has a special syntax to denote regexp literals, which construct
regexp object at loading time.

Gauche's regexp engine is fully aware of multibyte characters.
@end deftp

@deftp {Builtin Class} <regmatch>
@clindex regmatch
Regexp match object.  A regexp matcher @code{rxmatch} returns
this object if match.  This object contains all the information
about the match, including submatches.

The advantage of using match object, rather than substrings or
list of indices is efficiency.  The regmatch object keeps internal
state of match, and computes indices and/or substrings only when
requested.  This is particularly effective for mutibyte strings,
for index access is slow on them.
@end deftp

@deftp {Reader Syntax} @code{#/@i{regexp-spec}/}
@deftpx {Reader Syntax} @code{#/@i{regexp-spec}/i}
Denotes literal regular expression object.  When read, it becomes
an instance of @code{<regexp>}.

If a letter '@code{i}' is given at the end, the created regexp
becomes @emph{case-folding regexp}, i.e. it matches in the case-insensitive
way.  (The current version only cares ASCII characters for case-folding---
beyond ASCII characters, the match is done in the same way as normal match.)

The advantage of using this syntax over @code{string->regexp} is
that the regexp is compiled only once.  You can use literal regexp
inside loop without worrying about regexp compilation overhead.
If you want to construct regexp on-the-fly, however, use @code{string->regexp}.
@end deftp

Gauche's built-in regexp syntax follows POSIX extended regular 
expression, with a bit of extensions taken from Perl.

Note that the syntax described here is just a surface syntax.
Gauche's regexp compiler works on the abstract syntax tree,
and alternative syntax such as SRE will be supported in the
future versions.

@table @code
@item @i{re}*
Matches zero or more repetition of @i{re}.

@item @i{re}+
Matches one or more repetition of @i{re}.

@item @i{re}?
Matches zero or one occurrence of @i{re}.

@item @i{re}@{@i{n}@}
@itemx @i{re}@{@i{n},@}
@itemx @i{re}@{@i{n},@i{m}@}
Bounded repetition.  @code{@i{re}@{@i{n}@}} matches exactly @i{n}
occurrences of @i{re}.   @code{@i{re}@{@i{n},@}} matches
@i{n} or more occurrences of @i{re}.
@code{@i{re}@{@i{n},@i{m}@}} matches at least @var{n} and at most
@var{m} occurrences of @i{re}, where @var{n} <= @var{m}.

@item @i{re}*?
@itemx @i{re}+?
@itemx @i{re}??
@itemx @i{re}@{@i{n},@}?
@itemx @i{re}@{@i{n},@i{m}@}?
Same as the above repetition construct, but these syntaxes
use "non-greedy" or "lazy" match strategy.  That is, they try to match
the minimum number of occurrences of @i{re} first, then retry
longer ones only if it fails.  Compare the following examples:
@example
(rxmatch-substring (#/<.*>/ "<tag1><tag2><tag3>") 0)
  @result{} "<tag1><tag2><tag3>"

(rxmatch-substring (#/<.*?>/ "<tag1><tag2><tag3>") 0)
  @result{} "<tag1>"
@end example

@item (@i{re}@dots{})
Clustering with capturing.  The regular expression enclosed
by parenthesis works as a single @i{re}.  Besides, the string
that matches @i{re} @dots{} is saved as a @emph{submatch}.

@item (?:@i{re}@dots{})
Clustering without capturing.   @code{@i{re} @dots{}} works as
a single @i{re}, but the matched string isn't saved.

@item (?<@i{name}>@i{re}@dots{})
Named capture and clustering.  Like @code{(@i{re}@dots{})}, 
but adds the name @i{name} to the matched substring.
You can refer to the matched substring by both index number
and the name.

When the same name appears more than once in a regular
expression, it is undefined which matched substring is
returned as the submatch of the named capture.

@item (?i:@i{re}@dots{})
@itemx (?-i:@i{re}@dots{})
Lexical case sensitivity control.  
@code{(?i:@i{re}@dots{})} makes @i{re}@dots{} matches case-insensitively,
while @code{(?-i:@i{re}@dots{})} makes 
@i{re}@dots{} matches case-sensitively.

Perl's regexp allows several more flags to appear between '?' and ':'.
Gauche only supports above two, for now.

@item @i{pattern1}|@i{pattern2}|@dots{}
Alternation.  Matches either one of patterns, where each
pattern is @i{re} @dots{}.

@item \@i{n}
Backreference.  @i{n} is an integer.
Matches the substring captured by the @i{n}-th capturing group.
(counting from 1).  When capturing groups are nested, groups
are counted by their beginnings.
If the @i{n}-th capturing group is in a repetition and has mached
more than once, the last matched substring is used.

@item \k<@i{name}>
Named backreference.  Matches the substring captured by
the capturing group with the name @i{name}.
If the named capturing group is in a repetition and has mached
more than once, the last matched substring is used.
If there are more than one capturing group with @i{name},
matching will succeed if the input matches either one of the substrings
captured by those groups.

@item .
Matches any character (including newline).

@item [@i{char-set-spec}]
Matches any of the character set specified by @i{char-set-spec}.
@xref{Character set}, for the details of @i{char-set-spec}.

@item \s, \d, \w
Matches a whitespace character (@code{#[[:space:]]}),
a digit character (@code{#[[:digit:]]}), or
a word-constituent character (@code{#[[:alpha:][:digit:]_]}),
respectively.

Can be used both inside and outside of character set.

@item \S, \D, \W
Matches the complement character set of @code{\s}, @code{\d} and
@code{\w}, respectively.

@item ^, $
Beginning and end of string assertion, 
when appears at the beginning or end of the pattern.

@item \b, \B
Word boundary and non word boundary assertion, respectively.
That is, @code{\b} matches an empty string between
word-constituent character and non-word-constituent character,
and @code{\B} matches an empty string elsewhere.

@item \;
@itemx \"
@itemx \#
These are the same as @code{;}, @code{"}, and @code{#}, respectively,
and can be used to avoid confusing Emacs or other syntax-aware editors 
that are not familiar with Gauche's extension.

@item (?=@i{pattern})
@itemx (?!@i{pattern})
Positive/negative lookahead assertion.  
Match succeeds if @i{pattern} matches (or does not match) 
the input string from the current position, but this doesn't
move the current position itself, so that the following
regular expression is applied again from the current position.

For example, the following expression matches strings
that might be a phone number, except the numbers in Japan
(i.e. ones that begin with "81").
@example
\+(?!81)\d@{9,@}
@end example

@item (?<=@i{pattern})
@itemx (?<!@i{pattern})
Positive/negative lookbehind assertion.

@item @i{re}*+
@itemx @i{re}++
@itemx @i{re}?+
They are the same as (?>@i{re}*), (?>@i{re}+), (?>@i{re}?), respectively.

@end table

@defun string->regexp string &keyword case-fold
Takes @var{string} as a regexp specification, and constructs
an instance of @code{<regexp>} object.

If a true value is given to the keyword argument @var{case-fold},
the created regexp object becomes case-folding regexp.
(See the above explanation about case-folding regexp).
@end defun

@defun regexp? @var{obj}
Returns true iff @var{obj} is a regexp object.
@end defun

@defun regexp->string @var{regexp}
Returns a source string describing the regexp @var{regexp}.
The returned string is immutable.
@end defun

@defun rxmatch regexp string
@var{Regexp} is a regular expression object.
A string @var{string} is matched by
@var{regexp}.  If it matches, the function returns a @code{<regmatch>}
object.  Otherwise it returns @code{#f}.

This is called @code{match}, @code{regexp-search} or @code{string-match}
in some other Scheme implementations.
@end defun

@deftp {Generic application} @var{regexp} @var{string}
A regular expression object can be applied directly to the string.
This works the same as @code{(rxmatch @var{regexp} @var{string})},
but allows shorter notation.   @xref{Applicable objects}, for
generic mechanism used to implement this.
@end deftp

@defun rxmatch-start match &optional (i 0)
@defunx rxmatch-end match &optional (i 0)
@defunx rxmatch-substring match &optional (i 0)
@var{Match} is a match object returned by @code{rxmatch}.
If @var{i} equals to zero, the functions return
start, end or the substring of entire match, respectively.
With positive integer @var{I}, it returns those of @var{I}-th
submatches.  It is an error to pass other values to @var{I}.

It is allowed to pass @code{#f} to @var{match} for convenience.
The functions return @code{#f} in such case.

These functions correspond to scsh's @code{match:start}, @code{match:end}
and @code{match:substring}.
@end defun

@defun rxmatch-num-matches match
Returns the number of matches in @var{match}.
The number includes the "whole match", so it is always a positive
integer for a @code{<regmatch>} object.  The number also includes
the submatches that don't have value (see the examples below).

For the convenience, @code{rxmatch-num-matches} returns 0
if @var{match} is @code{#f}.

@example
(rxmatch-num-matches (rxmatch #/abc/ "abc"))
  @result{} 1

(rxmatch-num-matches (rxmatch #/(a(.))|(b(.))/ "ba"))
  @result{} 5

(rxmatch-num-matches #f)
  @result{} 0
@end example

@end defun

@defun rxmatch-after match &optional (i 0)
@defunx rxmatch-before match &optional (i 0)
Returns substring of the input string after or before @var{match}.
If optional argument is given, the @var{i}-th submatch is used
(0-th submatch is the entire match).
@example
(define match (rxmatch #/(\d+)\.(\d+)/ "pi=3.14..."))

(rxmatch-after match) @result{} "..."
(rxmatch-after match 1) @result{} ".14..."

(rxmatch-before match) @result{} "pi="
(rxmatch-before match 2) @result{} "pi=3."
@end example
@end defun

@defun rxmatch->string regexp string &optional selector @dots{}
A convenience procedure to match a string to the given regexp,
then returns the matched substring, or @code{#f} if it doesn't match.

If no @var{selector} is given, it is the same as this:
@example
(rxmatch-substring (rxmatch @var{regexp} @var{string}))
@end example

If an integer is given as a selector, it returns the subtring
of the numbered submatch.

If a symbol @code{after} or @code{before} is given, it returns
the substring after or before the match.  You can give these symbols
and an integer to extract a substring before or after the numbered
submatch.

@example
gosh> (rxmatch->string #/\d+/ "foo314bar")
"314"
gosh> (rxmatch->string #/(\w+)@@([\w.]+)/ "foo@@example.com" 2)
"example.com"
gosh> (rxmatch->string #/(\w+)@@([\w.]+)/ "foo@@example.com" 'before 2)
"foo@@"
@end example
@end defun

@deftp {Generic application} @var{regmatch} &optional @var{index}
@deftpx {Generic application} @var{regmatch} @code{'before} &optional @var{index}
@deftpx {Generic application} @var{regmatch} @code{'after} &optional @var{index}
A regmatch object can be applied directly to the integer index,
or a symbol @code{before} or @code{after}.
They works the same as @code{(rxmatch-substring @var{regmatch} @var{index})},
@code{(rxmatch-before @var{regmatch})}, and
@code{(rxmatch-after @var{regmatch})}, respectively.
This allows shorter notation.  @xref{Applicable objects}, for
generic mechanism used to implement this.

@example
(define match (#/(\d+)\.(\d+)/ "pi=3.14..."))

  (match)           @result{} "3.14"
  (match 1)         @result{} "3"
  (match 2)         @result{} "14"

  (match 'after)    @result{} "..."
  (match 'after 1)  @result{} ".14..."

  (match 'before)   @result{} "pi="
  (match 'before 2) @result{} "pi=3."

(define match (#/(?<integer>\d+)\.(?<fraction>\d+)/ "pi=3.14..."))

  (match 1)         @result{} "3"
  (match 2)         @result{} "14"

  (match 'integer)  @result{} "3"
  (match 'fraction) @result{} "14"

  (match 'after 'integer)   @result{} ".14..."
  (match 'before 'fraction) @result{} "pi=3."

@end example
@end deftp

@defun regexp-replace regexp string substitution
@defunx regexp-replace-all regexp string substitution
Replaces the part of @var{string} that matched to @var{regexp}
for @var{substitution}.  @code{regexp-replace} just replaces
the first match of @var{regexp}, while @code{regexp-replace-all}
repeats the replacing throughout entire @var{string}.

@var{substitution} may be a string or a procedure.  If it is a string,
it can contain references to the submatches by
digits preceded by a backslash (e.g. @code{\2})
or the named submatch reference (e.g. @code{\k<@var{name}>}.
@code{\0} refers to the
entire match.  Note that you need two backslashes to include
backslash character in the literal string; if you want to include a backslash
character itself in the @var{substitution}, you need four backslashes.

@example
(regexp-replace #/def|DEF/ "abcdefghi" "...")
  @result{} "abc...ghi"
(regexp-replace #/def|DEF/ "abcdefghi" "|\\0|")
  @result{} "abc|def|ghi"
(regexp-replace #/def|DEF/ "abcdefghi" "|\\\\0|")
  @result{} "abc|\\0|ghi"
(regexp-replace #/c(.*)g/ "abcdefghi" "|\\1|")
  @result{} "ab|def|hi"
(regexp-replace #/c(?<match>.*)g/ "abcdefghi" "|\\k<match>|")
  @result{} "ab|def|hi"
@end example

If @var{substitution} is a procedure, for every match in @var{string}
it is called with one argument, regexp-match object.  The returned
value from the procedure is inserted to the output string using
@code{display}.

@example
(regexp-replace #/c(.*)g/ "abcdefghi" 
                (lambda (m)
                  (list->string
                   (reverse
                    (string->list (rxmatch-substring m 1))))))
 @result{} "abfedhi"
@end example

Note: @code{regexp-replace-all} applies itself recursively to the remaining 
of the string after match.  So the beginning of string assertion
in @var{regexp} doesn't only mean the beginning of input string.
@end defun

@defun regexp-replace* string rx1 sub1 rx2 sub2 @dots{}
@defunx regexp-replace-all* string rx1 sub1 rx2 sub2 @dots{}
First applies @code{regexp-replace} or @code{regexp-replace-all} to
@var{string} with a regular expression @var{rx1} substituting for
@var{sub1}, then applies the function on the result string
with a regular expression @var{rx2} substituting for @var{sub2}, and
so on.  These functions are handy when you want to apply
multiple substitutions sequentially on a string.
@end defun

@defun regexp-quote string
Returns a string with the characters that are special to regexp escaped.
@example
(regexp-quote "[2002/10/12] touched foo.h and *.c")
 @result{} "\\[2002/10/12\\] touched foo\\.h and \\*\\.c"
@end example
@end defun


In the following macros, @var{match-expr} is an expression
which produces a match object or @code{#f}. Typically
it is a call of @code{rxmatch}, but it can be any expression.

@defmac rxmatch-let match-expr (var @dots{}) form @dots{}

Evaluates @var{match-expr}, and if matched, binds @var{var @dots{}}
to the matched strings, then evaluates @var{form}s.
The first @var{var} receives the entire match, and subsequent
variables receive submatches.  If the number of submatches are
smaller than the number of variables to receive them, the rest
of variables will get @code{#f}.

It is possible to put @code{#f} in variable position, which says
you don't care that match.

@example
(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (time hh mm ss)
  (list time hh mm ss))
 @result{} ("23:59:58" "23" "59" "58")

(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (#f hh mm)
  (list hh mm))
 @result{} ("23" "59")
@end example

This macro corresponds to scsh's @code{let-match}.
@end defmac

@defmac rxmatch-if match-expr (var @dots{}) then-form else-form
Evaluates @var{match-expr}, and if matched, binds @var{var} @dots{}
to the matched strings and evaluate @var{then-form}.
Otherwise evaluates @var{else-form}.
The rule of binding @var{var}s is the same as @code{rxmatch-let}.

@example
(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11:22:33")
    (time)
  (format #f "time is ~a" time)
  "unknown time")
 @result{} "time is 11:22"

(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11-22-33")
    (time)
  (format #f "time is ~a" time)
  "unknown time")
 @result{} "unknown time"
@end example

This macro corresponds to scsh's @code{if-match}.
@end defmac

@defmac rxmatch-cond clause @dots{}
Evaluate condition in @var{clause}s one by one.
If a condition of a clause satisfies, rest portion of the clause
is evaluated and becomes the result of @code{rxmatch-cond}.
@var{Clause} may be one of the following pattern.

@table @code
@item (@var{match-expr} (@var{var} @dots{}) @var{form} @dots{})
Evaluate @var{match-expr}, which may return a regexp match
object or @code{#f}.  If it returns a match object, the matches
are bound to @var{var}s, like @var{rxmatch-let}, and @var{form}s
are evaluated.

@item (test @var{expr} @var{form} @dots{})
Evaluates @var{expr}.  If it yields true, evaluates @var{form}s.

@item (test @var{expr} => @var{proc})
Evaluates @var{expr} and if it is true,
calls @var{proc} with the result of @var{expr} as the only argument.

@item (else @var{form} @dots{})
If this clause exists, it must be the last clause.
If other clauses fail, @var{form}s are evaluated.
@end table

If no @code{else} clause exists, and all the other clause fail,
an undefined value is returned.

@example
;; @r{parses several possible date format}
(define (parse-date str)
  (rxmatch-cond
    ((rxmatch #/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ str)
        (#f mm dd yyyy)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ str)
        (#f yyyy mm dd)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^\d+\/\d+\/\d+$/ str)
        (#f)
     (errorf "ambiguous: ~s" str))
    (else (errorf "bogus: ~s" str))))

(parse-date "2001/2/3") @result{} (2001 2 3)
(parse-date "12/25/1999") @result{} (1999 12 25)
@end example

This macro corresponds to scsh's @code{match-cond}.
@end defmac

@defmac rxmatch-case string-expr clause @dots{}
@var{String-expr} is evaluated, and @var{clause}s are interpreted
one by one.  A @var{clause} may be one of the following pattern.

@table @code
@item (@var{re} (@var{var} @dots{}) @var{form} @dots{})
@var{Re} must be a literal regexp object (@xref{Regular expression}).
If the result of @var{string-expr} matches @var{re},
the match result is bound to @var{var}s
and @var{form}s are evaluated, and @code{rxmatch-case} returns
the result of the last @var{form}.

If @var{re} doesn't match the result of @var{string-expr},
@var{string-expr} yields non-string value, the interpretation proceeds
to the next clause.

@item (test @var{proc} @var{form} @dots{})
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{form}s are evaluated, and
@code{rxmatch-case} returns the result of the last @var{form}.

If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.

@item (test @var{proc} => @var{proc2})
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{proc2} is applied on the result,
and its result is returned as the result of @code{rxmatch-case}.

If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.

@item (else @var{form} @dots{})
This form must appear at the end of @var{clause}s, if any.
If other clauses fail, @var{form}s are evaluated,
and the result of the last @var{form} becomes the result of
@code{rxmatch-case}.
@end table

If no @code{else} clause exists, and all other clause fail,
an undefined value is returned.

The @code{parse-date} example above becomes simpler if you use
@code{rxmatch-case}
@example
(define (parse-date2 str)
  (rxmatch-case str
    (test (lambda (s) (not (string? s))) #f)
    (#/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ (#f mm dd yyyy)
     (map string->number (list yyyy mm dd)))
    (#/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ (#f yyyy mm dd)
     (map string->number (list yyyy mm dd)))
    (#/^\d+\/\d+\/\d+$/                (#f)
     (errorf "ambiguous: ~s" str))
    (else (errorf "bogus: ~s" str))))
@end example
@end defmac


@c ----------------------------------------------------------------------
@node Vectors, Hashtables, Regular expression, Core library
@section Vectors
@c NODE ベクタ

@deftp {Builtin Class} <vector>
@clindex vector
A vector is a simple 1-dimensional array of Scheme objects.
You can access its element by index in constant time.
Once created, a vector can't be resized.

Class @code{<vector>} inherits @code{<sequence>} and 
you can use various generic functions such as @code{map} and @code{fold}
on it.   @xref{Collection framework}, and @xref{Sequence framework}.

If you keep only a homogeneous numeric type, you may be able
to use SRFI-4 homogeneous vectors (@xref{Homogeneous vectors}).

@xref{Vector library}, for additional operations on vectors.
@end deftp

@defun vector? obj
[R5RS]
Returns @code{#t} if @var{obj} is a vector, @code{#f} otherwise.
@end defun

@defun make-vector k &optional fill
[R5RS]
Creates and returns a vector with length @var{k}.
If optional argument @var{fill} is given, each element of the vector
is initialized by it.  Otherwise, the initial value of each element
is undefined.
@end defun

@defun vector obj @dots{}
[R5RS]
Creates a vector whose elements are @var{obj} @dots{}.
@end defun

@defun vector-length vector
[R5RS]
Returns the length of a vector @var{vector}.

With @code{gauche.collection} module,
you can also use a method @code{size-of}.
@end defun

@defun vector-ref vector k &optional fallback
[R5RS+]
Returns @var{k}-th element of vector @var{vector}.

By default, @code{vector-ref} signals an error if @var{k} is
negative, or greater than or equal to the length of @var{vector}.
However, if an optional argument @var{fallback} is given,
it is returned for such case.  This is an extension of Gauche.

With @code{gauche.sequence} module,
you can also use a method @code{ref}.
@end defun

@defun vector-set! vector k obj
[R5RS]
Sets @var{k}-th element of the vector @var{vector} to @var{obj}.
It is an error if @var{k} is negative or greater than or equal to the
length of @var{vector}.

With @code{gauche.sequence} module, you can also use
a setter method of @code{ref}.
@end defun

@defun vector->list vector &optional start end
@defunx list->vector list &optional start end
[R5RS+][SRFI-43+]
Converts a vector to a list, or vice versa.

The optional @var{start} and @var{end} arguments
limit the range of the source.
@example
(vector->list '#(1 2 3 4 5))     @result{} (1 2 3 4 5)
(list->vector '(1 2 3 4 5))      @result{} #(1 2 3 4 5)
(vector->list '#(1 2 3 4 5) 2 4) @result{} (3 4)
(list->vector (circular-list 'a 'b 'c) 1 6)
  @result{} #(b c a b c)
@end example

With @var{gauche.collection} module, you can use
@code{(coerce-to <list> @var{vector})} and 
@code{(coerce-to <vector> @var{list})} as well.
@end defun

@defun vector-fill! vector fill &optional start end
[R5RS+][SRFI-43]
Sets all elements in a vector @var{vector} to @var{fill}.

Optional @var{start} and @var{end} limits the range
of effect between @var{start}-th index (inclusive) to
@var{end}-th index (exclusive).  @var{Start} defaults to
zero, and @var{end} defaults to the length of @var{vector}.
These optional arguments are Gauche's extension.
@end defun

@defun vector-copy vector &optional start end fill
[SRFI-43]
Copies a vector @var{vector}.  Optional @var{start} and @var{end}
arguments can be used to limit the range of @var{vector} to be copied.
If the range specified by @var{start} and @var{end} falls outside of
the original @var{vector}, the @var{fill} value is used to fill
the result vector.

@example
(vector-copy '#(1 2 3 4 5))     @result{} #(1 2 3 4 5)
(vector-copy '#(1 2 3 4 5) 2 4) @result{} #(3 4)
(vector-copy '#(1 2 3 4 5) 3 7 #f) @result{} #(4 5 #f #f)
@end example
@end defun

@c ----------------------------------------------------------------------
@node Hashtables, Treemaps, Vectors, Core library
@section Hashtables
@c NODE ハッシュテーブル

@deftp {Builtin Class} <hash-table>
@clindex hash-table
Hash table class.  Inherits @code{<collection>} and @code{<dictionary>}.
@end deftp


@defun make-hash-table &optional type
Creates a hash table.   A symbol @var{type} specifies the type of the table.
The following types are currently supported.
(If @var{type} is omitted, @code{eq?} is assumed.)
@table @code
@item eq?
Keys are compared by @code{eq?}.
@item eqv?
Keys are compared by @code{eqv?}.
@item equal?
Keys are compared by @code{equal?}.
@item string=?
Keys are compared by @code{string=?}.  Key must be a string.
@end table

Hash functions used for @code{eq?}, @code{eqv?} and
@code{string=?}-type hash tables are built in the system;
they can be called from Scheme as @code{eq-hash}, @code{eqv-hash},
and @code{string-hash} (SRFI-13).  Those functions can't be extended
for user-defined objects.   On the other hand, @code{equal?}-type
hash tables uses @code{hash} function below, with which you
define hash functions for user-defined objects.

@end defun

@defun hash obj
Returns a hash value of @var{obj}.  This is the hash function used
in @code{equal?}-type hash table.  The hash value is an exact
non-negative integer, and it has two properties:
@itemize
@item
For any object @var{a} and @var{b}, 
if @code{(equal? @var{a} and @var{b})}, 
then @code{(= (hash @var{a}) (hash @var{b}))},
while @code{hash} is defined for types of @var{a} and @var{b}.
@item
The value of @code{hash} is independent from the runtime state
of the machine (such as address of the data); so you can safely save
the hash value to file and read it again with different process
without losing validity of the hash value.
@end itemize
If @var{obj} is either a number, a boolean, a character, 
a symbol, a keyword, a string, a list or a vector,
internal hash function is used to calculate the hash value.
If @var{obj} is other than that, @code{hash} calls
a generic function @code{object-hash} to calculate the hash value.
@end defun

@deffn {Generic Function} object-hash obj
By defining a method for this generic function, objects of
user-defined types can have a hash value and can be used
in @code{equal?} hash table.  

The method has to return an exact non-negative integer, and
has to follow the same constraints as of @code{hash}.

If the method needs to get hash value of @var{obj}'s elements,
it has to call @code{hash} on them, not @code{object-hash}.
For the hashing of primitive objects are done in @code{hash}.
@example
(define-class <myclass> () (x y))

;; user-defined equality function
(define-method object-equal? ((a <myclass>) (b <myclass>))
  (and (equal? (ref a 'x) (ref b 'x))
       (eq?    (ref a 'y) (ref b 'y))))

;; user-defined hash function
(define-method object-hash ((a <myclass>))
  (hash (list (ref a 'x) (ref a 'y))))
@end example
@end deffn

@defun eq-hash obj
@defunx eqv-hash obj
These are hash functions used for @code{eq?}-type and @code{eqv?}-type
hash tables.  Returns a non-negative integer up to 2^@emph{n}-1, where
@emph{n} is system-dependent value no less than 32.
The returned hash value is system- and process-dependent,
and can't be carried over the boundary of the running process.

Note: don't hash numbers by @code{eq-hash}.  Two numbers
are not guaranteed to be @code{eq?} even if they are numerically equal,
so they are not supposed to be used as a key in @code{eq?}-type hash table.
@end defun

@defun hash-table? obj
Returns @code{#t} if @var{obj} is a hash table.
@end defun

@defun hash-table-type ht
Returns one of symbols @code{eq?}, @code{eqv?}, @code{equal?} or
@code{string=?}, indicating the type of the hash table @var{ht}.
@end defun

@defun hash-table-num-entries ht
Returns the number of entries in the hash table @var{ht}.
@end defun

@defun hash-table type key&value @dots{}
Constructs and returns a hash table of type @var{type} from given
list of arguments.
@var{Type} is the same as of @code{make-hash-table}.
Each @var{key&value} must be a pair, and its car is used as a key
and its cdr is used as a value.

@example
(hash-table 'eq? '(a . 1) '(b . 2))
  @equiv{}
  (let ((h (make-hash-table 'eq?)))
     (hash-table-put! h 'a 1)
     (hash-table-put! h 'b 2)
     h)
@end example
@end defun

@defun hash-table-get ht key &optional default
Search @var{key} from a hash table @var{ht}, and returns its value
if found.  If the key is not found in the table and @var{default} is
given, it is returned.  Otherwise an error is signalled.
@end defun

@defun hash-table-put! ht key value
Puts a key @var{key} with a value @var{value} to the hash table @var{ht}.
@end defun

@deffn {Method} ref (ht <hash-table>) key &optional default
@deffnx {Method} {(setter ref)} (ht <hash-table>) key value
Method versions of @code{hash-table-get} and @code{hash-table-put!}.
@end deffn

@defun hash-table-exists? ht key
Returns @code{#t} if a hash table @var{ht} has a key @var{key}.
@end defun

@defun hash-table-delete! ht key
Deletes an entry that has a key @var{key} from the hash table @var{ht}.
Returns @code{#t} if the entry has exist, or @code{#f} if the entry
hasn't exist.   The same function is called @code{hash-table-remove!} in STk
(except that it returns an undefined value); I use `delete' for consistency
to SRFI-1, SRFI-13 and other parts of the libraries.
@end defun

@defun hash-table-clear! ht
Removes all entries in the hash table @var{ht}.
@end defun

@defun hash-table-push! ht key value
Conses @var{value} to the existing value for the key @var{key} in the
hash table @var{ht} and makes it the new value for @var{key}.
If there's no entry for @var{key}, an entry
is created with the value @code{(list @var{value})}.

Works the same as the following code, except that this function
only looks up the @var{key} once, thus it's more efficient.
@example
(hash-table-put! ht key
    (cons value (hash-table-get ht key '())))
@end example
@end defun

@defun hash-table-pop! ht key &optional default
Looks for the value for the key @var{key} in the hash table @var{ht}.
If found and it is a pair, replaces the value for its cdr and returns
car of the original value.  If no entry for @var{key} is in the table,
or the value is not a pair, the table is not modified and
the procedure returns @var{default} if given, or signals an error otherwise.  

During the operation the key is looked for only once, thus runs
efficiently.
@end defun

@defun hash-table-update! ht key proc &optional default
A more general version of @code{hash-table-push!} etc.
It works basically as the following code piece,
except that the lookup of @var{key} is only done once.
@example
(let ((tmp (proc (hash-table-get @var{ht} @var{key} @var{default}))))
  (hash-table-put! @var{ht} @var{key} tmp)
  tmp)
@end example

For example, when you use a hash table to count the occurrences
of items, the following line is suffice to increment the counter
of the item, regardless of whether @var{item} has already appeared or not.

@example
(hash-table-update! ht item (cut + 1 <>) 0))
@end example

@end defun


@defun hash-table-for-each ht proc
@defunx hash-table-map ht proc
A procedure @var{proc} is called with two arguments, a key and its associated
value, over all the entries in the hash table @var{ht}.
@end defun

@defun hash-table-fold ht kons knil
For all entries in the hash table @var{ht},
a procedure @var{kons} is called with three arguments;
a key, its associated value, and the previous return value of @var{kons}.
The first call of @var{kons} receives @var{knil} as the third argument.
The return value of the last call of @var{kons} is returned
from @code{hash-table-fold}.
@end defun

@defun hash-table-keys ht
@defunx hash-table-values ht
Returns all the keys or values of hash table @var{ht} in a list,
 respectively.
@end defun

See also @ref{Additional list library}, where @code{hash-table->alist}
and @code{alist->hash-table} are defined.

@c ----------------------------------------------------------------------
@node Treemaps, Weak pointers, Hashtables, Core library
@section Treemaps
@c NODE ツリーマップ

@deftp {Builtin Class} <tree-map>
@clindex tree-map
Tree map class.   Tree maps are a data structure that maps key objects
to value objects.  It's like hash tables except tree maps uses
balanced tree internally.  Insertion and lookup is O(log n).

Unlike hashtables, a tree map keeps the order of the keys, so
it is easy to traverse entries in the order of keys, to find 
minimum/maximum keys, or to find a key closest to the given value.

The @code{<tree-map>} class inherits @code{<sequence>} and
@code{<ordered-dictionary>}.
@end deftp

@defun make-tree-map key=? key<?
Creates and returns an instance of @code{<tree-map>}.
The arguments @var{key=?} and @var{key<?} are both
procedures that take two arguments, which are the keys.
The @code{key=?} procedure should return @code{#t} if
two arguments are equivalent, or @code{#f} otherwise.
The @code{key<?} procedure should return @code{#t} if
the first argument is strictly less than the second argument,
or @code{#f} otherwise.
@end defun

@defun tree-map-copy tree-map
Copies and returns  @var{tree-map}.  Modification
on the returned tree doesn't affect the original tree.
@end defun

@defun tree-map-empty? tree-map
Returns @code{#t} if @var{tree-map} doesn't have any elements,
or @code{#f} otherwise.
@end defun

@defun tree-map-num-entries tree-map
Returns the number of elements in @var{tree-map}.
@end defun

@defun tree-map-exists? tree-map key
Returns @code{#t} if @var{tree-map} has an entry with @var{key},
or @code{#f} otherwise.
@end defun

@defun tree-map-get tree-map key &optional fallback
Looks for @var{key} in @var{tree-map}.  If the entry is found,
returns a value corresponding to the key.  Otherwise, returns
@var{fallback} if it is provided, or signals an error.
@end defun

@defun tree-map-put! tree-map key value
Inserts an entry with a @var{key} and corresponding @var{value}
into @var{tree-map}.  If there already exists an entry with a
key which is equivalent (under @var{key=?}), the entry is modified
to have @var{value}.
@end defun

@defun tree-map-delete! tree-map key
Deletes an entry with @var{key} from @var{tree-map} if such an entry
exists, and returns @code{#t}.
If @var{tree-map} doesn't have such an entry, @code{#f} is returned.
@end defun

@defun tree-map-clear! tree-map
Removes all entries in @var{tree-map}.
@end defun

@defun tree-map-update! tree-map key proc &optional fallback
A generalized version of @code{tree-map-push!} etc.
It works like the following code, except that searching
for the key is done only once.
@example
(let ((tmp (proc (tree-map-get @var{tree-map} @var{key} @var{fallback}))))
  (tree-map-put! @var{tree-map} @var{key} tmp)
  tmp)
@end example
@end defun

@defun tree-map-push! tree-map key value
Looks for an entry with @var{key} in @var{tree-map}.  If it exists,
the procedure conses @var{value} to the original value and makes
it as a new value.
Otherwise, the procedure creates a new entry for the @var{key}
and makes @code{(list @var{value})} its value.
@end defun

@defun tree-map-pop! tree-map key &optional fallback
Looks for an entry with @var{key} in @var{tree-map}.  If it exists
and its value is a pair, then the procedure updates
its value with @code{cdr} of the original value, and returns
@code{car} of the original entry.   If such an entry does not
exist, or has a non-pair value, the procedure doesn't
modify @var{tree-map} and returns @var{fallback} if it is given,
otherwise reports an error.
@end defun

@defun tree-map-min tree-map
@defunx tree-map-max tree-map
Returns a pair of a key and its value with the minimum
or maximum key, respectively.   If @var{tree-map} is empty,
@code{#f} is returned.
@end defun

@defun tree-map-pop-min! tree-map
@defunx tree-map-pop-max! tree-map
Looks for an entry with minimum or maximum key, respectively,
then deletes the entry from @var{tree-map} and returns 
a pair of the key and its value of the original entry.
If @var{tree-map} is empty, @code{#f} is returned.
@end defun

@defun tree-map-fold tree-map proc seed
@defunx tree-map-fold-right tree-map proc seed
Iterate over elements in @var{tree-map}, applying 
@var{proc} which has a type @code{(key, value, seed) -> seed}.
The difference of @code{tree-map-fold} and @code{tree-map-fold-right}
is the associative order of applying @code{proc},
just like the difference between @code{fold} and @code{fold-right}.
@example
tree-map-fold:
  (proc Kn Vn (proc Kn-1 Vn-1 ... (proc K0 V0 seed)))

tree-map-fold-right
  (proc K0 V0 (proc K1 V1 ... (proc Kn Vn seed)))
@end example

Some examples:
@example
(define tree (alist->tree-map '((3 . a) (7 . b) (5 . c)) = <))

(tree-map-fold tree list* '()) 
   @result{} (7 b 5 c 3 a)
(tree-map-fold-right tree list* '()) 
   @result{} (3 a 5 c 7 b)
@end example
@end defun

@defun tree-map-floor tree-map probe &optional fallback-key fallback-value
@defunx tree-map-ceiling tree-map probe &optional fallback-key fallback-value
@defunx tree-map-predecessor tree-map probe &optional fallback-key fallback-value
@defunx tree-map-successor tree-map probe &optional fallback-key fallback-value
These procedures search the entry which has the closest key
to the given @var{probe}.  If such an entry is found, returns
two values, its key and its value.  Otherwise, returns two values,
@var{fallback-key} and @var{fallback-value}, both defaulted to @code{#f}.

The criteria of ``closest'' differ slightly among these procedures;
@code{tree-map-floor} finds the maximum key which is no greater than
@var{probe}; @code{tree-map-ceiling} finds the minimum key which is 
no less than @var{probe}; @code{tree-map-predecessor} finds the
maximum key which is strictly less than @var{probe};
and @code{tree-map-successor} finds the minimum key which 
is strictly greater than @var{probe}.
@end defun

@defun tree-map-floor-key tree-map probe @var{optional} fallback-key
@defunx tree-map-ceiling-key tree-map probe @var{optional} fallback-key
@defunx tree-map-predecessor-key tree-map probe @var{optional} fallback-key
@defunx tree-map-successor-key tree-map probe @var{optional} fallback-key
Like @code{tree-map-floor} etc., but only returns the key of
the found entry (or @var{fallback-key} if there's no entry which satisfies
the criteria).
@end defun

@defun tree-map-floor-value tree-map probe @var{optional} fallback-value
@defunx tree-map-ceiling-value tree-map probe @var{optional} fallback-value
@defunx tree-map-predecessor-value tree-map probe @var{optional} fallback-value
@defunx tree-map-successor-value tree-map probe @var{optional} fallback-value
Like @code{tree-map-floor} etc., but only returns the value of
the found entry (or @var{fallback-value} if there's no entry which satisfies
the criteria).
@end defun

@defun tree-map-keys tree-map
@defunx tree-map-values tree-map
Returns a list of all keys and all values, respectively.
The keys and values are in ascending order of the keys.
@end defun

@defun tree-map->alist tree-map
Returns a list of pairs of keys and values for all entries.
The pairs are in ascending order of the keys.
@end defun

@defun alist->tree-map alist key=? key<?
Creates a new tree map with @var{key=?} and @var{key<?},
then populates it with @var{alist}, each pair in which are
interpreted as a cons of a key and its value.  Returns the
created tree map.
@end defun

@c ----------------------------------------------------------------------
@node Weak pointers, Control features, Treemaps, Core library
@section Weak pointers
@c NODE Weak ポインタ

A weak pointer is a reference to an object that doesn't prevent
the object from being garbage-collected.
Gauche provides weak pointers as a @emph{weak vector} object.
A weak vector is like a vector of objects, except each object
can be garbage collected if it is not referenced from objects
other than weak vectors.   If the object is collected, the
entry of the weak vector is replaced for @code{#f.}
@example
gosh> (define v (make-weak-vector 1))
v
gosh> (weak-vector-ref v 0)
#f
gosh> (weak-vector-set! v 0 (cons 1 1))
#<undef>
gosh> (weak-vector-ref v 0)
(1 . 1)
gosh> (gc)
#<undef>
gosh> (gc)
#<undef>
gosh> (weak-vector-ref v 0)
#f
@end example

@deftp {Builtin Class} <weak-vector>
@clindex weak-vector
The weak vector class.  Inherits @code{<sequence>} and @code{<collection>},
so you can use
@code{gauche.collection} (@xref{Collection framework}) and
@code{gauche.sequence} (@xref{Sequence framework}).
@example
(coerce-to <weak-vector> '(1 2 3 4))
  @result{} a weak vector with four elements
@end example
@end deftp

@defun make-weak-vector size
Creates and returns a weak vector of size @var{size}.
@end defun

@defun weak-vector-length wvec
Returns the length of a weak vector @var{wvec}.
@end defun

@defun weak-vector-ref wvec k &optioal fallback
Returns @var{k}-th element of a weak vector @var{wvec}.

By default, @code{weak-vector-ref} signals an error if @var{k} is
negative, or greater than or equal to the size of @var{wvec}.
However, if an optional argument @var{fallback} is given,
it is returned for such case.

If the element has been garbage collected, this procedure returns
@var{fallback} if it is provided,  @code{#f} otherwise.

With @code{gauche.sequence} module,
you can also use a method @code{ref}.
@end defun

@defun weak-vector-set! wvec k obj
Sets @var{k}-th element of the weak vector @var{wvec} to @var{obj}.
It is an error if @var{k} is negative or greater than or equal to the
size of @var{wec}.
@end defun

@c ----------------------------------------------------------------------
@node Control features, Exceptions, Weak pointers, Core library
@section Control features
@c NODE 制御

@menu
* Procedures::                  
* Applicable objects::          
* Continuation::                
* Multiple values::             
* Delayed evaluation::          
@end menu

@node Procedures, Applicable objects, Control features, Control features
@subsection Procedures
@c NODE 手続き

@deftp {Builtin Class} <procedure>
@clindex procedure
@end deftp

@defun procedure? obj
[R5RS]
Returns @code{#t} if @var{obj} is a procedure, @code{#f} otherwise.
@end defun

@defun apply proc arg1 @dots{} args
[R5RS]
Calls a procedure @var{proc} with a list of arguments,
@code{(@var{arg1} @dots{} . @var{args})}.
The last argument @var{args} must be a proper list.
Returns (a) value(s) @var{proc} returns.
@example
(apply list 'a 'b '(c d e)) @result{} (a b c d e)

(apply + 1 2 '(3 4 5))      @result{} 15
@end example
@end defun


@menu
* Mapping::                     
* Combinators::                 
* Optional argument parsing::   
* Procedure arity::             
@end menu

@node Mapping, Combinators, Procedures, Procedures
@subsubsection Mapping
@c NODE マッピング

@defun map proc list1 list2 @dots{}
[R5RS+]
Applies @var{proc} for each element(s) of given list(s),
and returns a list of the results.  R5RS doesn't specify
the application order of @code{map}, but Gauche guarantees
@var{proc} is always applied in order of the list(s).
Gauche's @code{map} also terminates as soon as one of
the list is exhausted.

@example
(map car '((a b) (c d) (e f))) @result{} (a c e)

(map cons '(a b c) '(d e f))
  @result{} ((a . d) (b . e) (c . f))
@end example

Note that the @code{gauche.collection} module (@xref{Collection framework})
extends @code{map} to work on any type of collection.
@end defun

@defun for-each proc list1 list2 @dots{}
[R5RS]
Applies @var{proc} for each element(s) of given list(s) in order.
The results of @var{proc} are discarded.  The return value of
@code{for-each} is undefined.  When more than one list is given,
@code{for-each} terminates as soon as one of the list is exhausted.

Note that the @code{gauche.collection} module (@xref{Collection framework})
extends @code{for-each} to work on any type of collection.
@end defun


@node Combinators, Optional argument parsing, Mapping, Procedures
@subsubsection Combinators
@c NODE コンビネータ

Gauche has some primitive procedures that allows combinatory programming.

@defun pa$ proc arg @dots{}
Partial application.  Returns a procedure, and when it is
called with arguments @var{m} @dots{}, it is equivalent to call
@code{(proc arg @dots{} m @dots{})}.

@example
(define add3 (pa$ + 3))
(add3 4) @result{} 7

(map (pa$ * 2) '(1 2 3)) @result{} (2 4 6)
@end example

Macros @code{cut} and @code{cute} defined in SRFI-26 provide
a similar abstraction, with a bit more flexible but less compact
notation.  @xref{Making Procedures}.
@end defun

@defun apply$ proc
@defunx map$ proc
@defunx for-each$ proc
Partial application versions of @code{apply}, @code{map} and @code{for-each}.

@example
(define map2* (map$ (pa$ * 2)))
(map2* '(1 2 3)) @result{} (2 4 6)
@end example

@end defun

@defun count$ pred
@defunx fold$ kons &optional knil
@defunx fold-right$ kons &optional knil
@defunx reduce$ f &optional ridentity
@defunx reduce-right$ f &optional ridentity
@defunx filter$ pred
@defunx remove$ pred
@defunx partition$ pred
@defunx member$ item
@defunx find$ pred
@defunx find-tail$ pred
@defunx any$ pred
@defunx every$ pred
@defunx delete$ pred
@defunx assoc$ item
Partial application versions of some srfi-1 procedures
(@xref{List library}).
@end defun

@defun compose f @dots{}
Combine procedures.  All arguments must be procedures.
When two procedures are given, @code{(compose f g)} is equivalent to
the following code:
@example
(lambda args (call-with-values (lambda () (apply g args)) f))
@end example

When more than two arguments are passed, they are composed
as follows:
@example
(compose f g h ...) @equiv{} (compose (compose f g) h ...)
@end example

Some examples:

@example
(define not-zero? (compose not zero?))
(not-zero? 3) @result{} #t
(not-zero? 0) @result{} #f

(define dot-product (compose (apply$ +) (map$ *)))
(dot-product '(1 2 3) '(4 5 6)) @result{} 32
@end example

A couple of edge cases: if only one argument is given, the argument
itself is returned.  If no arguments are given, the procedure @code{values} 
is returned.
@end defun

@defun complement pred
Returns a procedure that reverses the meaning of the predicate @var{pred}.
That is, for the arguments for which @var{pred} returns true return
false, and vice versa.

@example
(map (complement even?) '(1 2 3)) @result{} '(#t #f #t)
(map (complement =) '(1 2 3) '(1 1 3)) @result{} '(#f #t #f)
((complement (lambda () #f))) @result{} #t
@end example
@end defun

@defun any-pred pred @dots{}
Returns a procedure which applies given argument(s) to
each predicate @var{pred}.  If any @var{pred} returns
a non-@code{#f} value, the value is returned.  If all the @var{pred}s
return @code{#f}, @code{#f} is returned.

@example
(define string-or-symbol? (any-pred string? symbol?))
(string-or-symbol? "abc") @result{} #t
(string-or-symbol? 'abc)  @result{} #t
(string-or-symbol? 3)     @result{} #f

(define <> (any-pred < >))
(<> 3 4) @result{} #t
(<> 3 3) @result{} #f

((any-pred (cut memq <> '(a b c))
           (cut memq <> '(1 2 3)))
 'b)  @result{} '(b c)
@end example
@end defun

@defun every-pred pred @dots{}
Returns a procedure which applies given argument(s) to
each predicate @var{pred}.  If every @var{pred} returns
a non-@code{#f} value, the value returned by the last @var{pred}
is returned.  If any @var{pred} returns @code{#f}, @code{every-pred}
returns @code{#f} without calling further @var{pred}s.

@example
((every-pred odd? positive?) 3)  @result{} #t
((every-pred odd? positive?) 4)  @result{} #f
((every-pred odd? positive?) -3) @result{} #f

(define safe-length (every-pred list? length))
(safe-length '(a b c))  @result{} 3
(safe-length "aaa")     @result{} #f
@end example
@end defun

@node Optional argument parsing, Procedure arity, Combinators, Procedures
@subsubsection Optional argument parsing
@c NODE 省略可能引数のパージング

To have optional arguments or keyword arguments in Scheme,
you have to take variable arguments as a list and decompose
them by yourself.   The following macros help it.

@defmac let-optionals* restargs (var-spec @dots{}) body @dots{}
@defmacx let-optionals* restargs (var-spec @dots{} . restvar) body @dots{}
Given a list of values @var{restargs}, binds variables according
to @var{var-spec}, then evaluates @var{body}.

@var{Var-spec} can be either a symbol, or a list of two elements
and its car is a symbol.  The symbol is the bound variable name.
The values in @var{restargs} are bound to the symbol in order.
If there are not as many values in @var{restargs} as @var{var-spec},
the rest of @var{symbol}s are bound to the default values, determined
as follows: If @var{var-spec} is just a symbol, the default value is
undefined.  If @var{var-spec} is a list, the default value is
the result of evaluation of the second element of the list.
In the latter case the second
element is only evaluated when there are not enough arguments.
The binding proceeds in the order of @var{var-spec}, so the second
element may refer to the bindings of previous @var{var-spec}.

In the second form, @var{restvar} must be a symbol and bound to
the list of values whatever left from @var{restargs} after binding
to @var{var-spec}.

It is not an error if @var{restarg} has more values than @var{var-spec}s.
The extra values are simply ignored in the first form.

@example
(define (proc x . args)
  (let-optionals* args ((a 'a)
                        (b 'b)
                        (c 'c))
    (list x a b c)))

(proc 0)         @result{} (0 a b c)
(proc 0 1)       @result{} (0 1 b c)
(proc 0 1 2)     @result{} (0 1 2 c)
(proc 0 1 2 3)   @result{} (0 1 2 3)

(define (proc2 . args)
  (let-optionals* args ((a 'a) . b)
    (list a b)))

(proc2)          @result{} (a ())
(proc2 0)        @result{} (0 ())
(proc2 0 1)      @result{} (0 (1))
(proc2 0 1 2)    @result{} (0 (1 2))

(define (proc3 . args)
  (let-optionals* args ((a 0)
                        (b (+ a 1))
                        (c (+ b 1)))
    (list a b c)))

(proc3)          @result{} (0 1 2)
(proc3 8)        @result{} (8 9 10)
(proc3 8 2)      @result{} (8 2 3)
(proc3 8 2 -1)   @result{} (8 2 -1)
@end example
@end defmac

@defmac get-optional restargs default
This is a short version of @var{let-optionals*} where you have only
one optional argument.  Given the optional argument list @var{restargs},
this macro returns the value of optional argument if one is given,
or the result of @var{default} otherwise.  @var{Default} is not
evaluated unless @var{restargs} is an empty list.

@example
(define (proc x . maybe-opt)
  (let ((option (get-optional maybe-opt #f)))
    (list x option)))

(proc 0)         @result{} (0 #f)
(proc 0 1)       @result{} (0 1)
@end example
@end defmac

@defmac let-keywords restarg (var-spec @dots{}) body @dots{}
@defmacx let-keywords restarg (var-spec @dots{} . restvar) body @dots{}
This macro is for keyword arguments.  @var{Var-spec} can be
one of the following forms:

@table @code
@item (@var{symbol} @var{expr})
If the @var{restrag} contains keyword which has the same name as @var{symbol},
binds @var{symbol} to the corresponding value.  If such a keyword doesn't
appear in @var{restarg}, binds @var{symbol} to the result of @var{expr}.
@item (@var{symbol} @var{keyword} @var{expr})
If the @var{restarg} contains keyword @var{keyword},
binds @var{symbol} to the corresponding value.  If such a keyword doesn't
appear in @var{restarg}, binds @var{symbol} to the result of @var{expr}.
@end table

The default value @var{expr} is only evaluated when the keyword is
not given to the @var{restarg}.

If you use the first form, @code{let-keyword} regards it an error
when @code{restarg} contains a keyword argument that is not listed
in @var{var-spec}s.  For the backward compatibility it only issues
warning now, but in future releases it will raise an error.
When you want to allow keyword arguments other than listed in
@var{var-spec}s, use the second form.

In the second form, @var{restvar} must be either a symbol or @code{#f}.
If it is a symbol, it is bound to a list of keyword arguments
that are not processed by @var{var-spec}s.  If it is @code{#f},
such keyword arguments are just ignored.

@example
(define (proc x . options)
  (let-keywords options ((a 'a)
                         (b :beta 'b)
                         (c 'c)
                         . rest)
    (list x a b c rest)))

(proc 0)         @result{} (0 a b c ())
(proc 0 :a 1)    @result{} (0 1 b c ())
(proc 0 :beta 1) @result{} (0 a 1 c ())
(proc 0 :beta 1 :c 3 :unknown 4) @result{} (0 a 1 3 (:unknown 4))
@end example
@end defmac

@defmac let-keywords* restarg (var-spec @dots{}) body @dots{}
@defmacx let-keywords* restarg (var-spec @dots{} . restvar) body @dots{}
Like @code{let-keywords}, but the binding is done in the order of
@var{var-spec}s.  So each @var{expr} can refer to the variables bound by
preceding @var{var-spec}s.
@end defmac

@node Procedure arity,  , Optional argument parsing, Procedures
@subsubsection Procedure arity
@c NODE 手続きのアリティ

Interface to query procedure's arity.
The API is taken from MzScheme (PLT Scheme).

@defun arity @var{proc}
Given procedure @var{proc},
returns an integer, an @emph{arity-at-least} object, or
a list of integer(s) and @emph{arity-at-least} objects.

An integer result indicates @var{proc} takes exactly that number
of arguments.  An @emph{arity-at-least} indicates @var{proc} takes
at least @code{(arity-at-least-value @emph{arity-at-least})}
arguments.   The list indicates there are multiple procedures
with different arities.

Since one can add methods to an existing procedure or generic function
at any moment in Gauche, the value returned by @code{arity} only
indicates the current state of the procedure.  It will change
if new method is added to the procedure/generic-function.

@example
(arity cons) @result{} 2
(arity list) @result{} #<arity-at-least 0>
(arity make) @result{} (#<arity-at-least 1>)
@end example
@end defun

@defun arity-at-least? @var{obj}
Returns true if @var{obj} is an arity-at-least object.
@end defun

@defun arity-at-least-value @var{arity-at-least}
Returns the number of required arguments the arity-at-least object
indicates.
@end defun

@defun procedure-arity-includes? @var{proc} @var{k}
If a procedure @var{proc} can take @var{k} arguments, returns @code{#t}.
Otherwise returns @code{#f}.
@end defun


@node Applicable objects, Continuation, Procedures, Control features
@subsection Applicable objects
@c NODE 適用可能なオブジェクト

Gauche has a special hook to make an arbitrary object @emph{applicable}.

@deffn {Generic Function} object-apply @var{object} @var{arg} @dots{}
If an object that is neither a procedure nor a generic function
is applied to some arguments, 
the object and the arguments are passed to a generic function
@code{object-apply}.

This can be explained better by examples.
@end deffn

For example, suppose you try to evaluate the
following expression:

@example
("abcde" 2)
@end example

The operator evaluates to a string, which is neither a procedure
nor a generic function.  So Gauche interprets the expression
as if it were like this:

@example
(object-apply "abcde" 2)
@end example

Gauche doesn't define a method of @code{object-apply} that takes
@code{<string>} and @code{<integer>} by default, so this signals an error.
However, if you define such a method:

@example
(define-method object-apply ((s <string>) (i <integer>))
  (string-ref s i))
@end example

Then the first expression works as if a string is @emph{applied} on
the integer:

@example
("abcde" 2) @result{} #\c
@end example

This mechanism works on almost all occasions where a procedure is allowed.

@example
(apply "abcde" '(1))   @result{} (#\b)
(map "abcde" '(3 2 1)) @result{} (#\d #\c #\b)
@end example

Among Gauche built-in objects, @code{<regexp>} object and
@code{<regmatch>} object have @code{object-apply} defined.
@xref{Regular expression}.

@deffn {Generic Function} {(setter object-apply)} @var{object} @var{arg} @dots{} @var{value}
If a form of applying an applicable object appears in the first position
of @code{set!} form, this method is called, that is:
@example
(set! (@var{object} @var{arg} @dots{}) @var{value})
 @result{} ((setter object-apply) @var{object} @var{arg} @dots{} @var{value})
@end example
@end deffn




@node Continuation, Multiple values, Applicable objects, Control features
@subsection Continuation
@c NODE 継続


@defun call-with-current-continuation proc
@defunx call/cc proc
[R5RS]
Encapsulates the current continuation to a procedure
(``continuation procedure''), and calls @var{proc} with it.
When @var{proc} returns, its value becomes @code{call/cc}'s value.
When the continuation procedure is invoked with zero or more arguments
somewhere, the further calculation is abandoned and @code{call/cc} returns
with the arguments given to the continuation procedure.

First class continuation is one of the most distinct feature of Scheme, but
this margin is too small to contain explanation.
Please consult to the appropriate documents.

Gauche supports full continuation, with a few limitations in rare
cases.   Normally a continuation has an unlimited extent.  However,
if a continuation is created during ``callback'' from C code---
that is, you call some C-implemented function that calls Scheme
code again---the continuation's extent is limited until the Scheme
evaluation returns to the C code.   If you try to invoke the continuation
from out of its extent, Gauche detects it and signals an error.
This is a fundamental limitation and not likely to be addressed.

Note that it is still allowed to invoke a continuation from
such callbacks.
Also, the typical higher-order functions such as @code{map}, @code{for-each}
or @code{apply} are not using callbacks, and not affected by this limitation

Fortunately, there are not much cases that you need to create an
unlimited extent continuation in such callbacks.
So far, the following code is executed in such callbacks.  Besides them,
typical callback functions from external C libraries, like GUI toolkit,
obeys the same limitation.
@itemize @bullet
@item
A @code{write-object} method that is invoked from @code{write},
@code{display} or @code{format} (@xref{Output}).
@item
A filler and a flusher callbacks of buffered ports
(@xref{Virtual ports}).
@end itemize

@end defun

@defmac let/cc var body @dots{}
This macro expands to :
@code{(call/cc (lambda (@var{var}) @var{body} @dots{}))}.
The API is taken from PLT Scheme.
@end defmac



@defun dynamic-wind before thunk after
[R5RS]
@var{Before}, @var{thunk} and @var{after} are all procedures with
no arguments.
In normal situation, @code{dynamic-wind} calls @var{before}, then @var{thunk},
then @var{after}, then returns whatever value(s) @var{thunk} returned.

If a control flow goes out from @var{thunk} by invoking a continuation
captured outside of the dynamic scope of @code{dynamic-wind}
(for example, an error is signalled in @var{thunk}),
@var{after} is called.  

If a control flow goes into @var{thunk} by invoking a continuation
captured inside @var{thunk} from outside of the dynamic
scope of @code{dynamic-wind}, @var{before} is called.
@example
(letrec ((paths '())
         (c #f)
         (add (lambda (s) (push! paths s))))
  (dynamic-wind
   (lambda () (add 'connect))
   (lambda ()
     (add (call/cc (lambda (c0) (set! c c0) 'talk1))))
   (lambda () (add 'disconnect)))
  (if (< (length paths) 4)
      (c 'talk2)
      (reverse paths)))
 @result{} (connect talk1 disconnect connect talk2 disconnect)
@end example
@end defun


@node Multiple values, Delayed evaluation, Continuation, Control features
@subsection Multiple values
@c NODE 多値

@defun values obj @dots{}
[R5RS]
Returns @var{obj} @dots{} as multiple values.
Caller can capture multiple values by a built-in syntax
@code{receive} (@ref{Binding constructs}), or the R5Rs procedure
@code{call-with-values} described below.
See also @ref{Let-values}.
@example
(values 1 2) @result{} 1 @r{and} 2
@end example
@end defun

@defun call-with-values producer consumer
[R5RS]
Call a procedure @var{producer} with no argument.
Then applies a procedure @var{consumer} on the
value(s) @var{producer} returned.  Returns the value(s) @var{consumer}
returns.
@example
(call-with-values (lambda () (values 1 2)) cons)
  @result{} (1 . 2)
@end example
@end defun

@defmac values-ref mv-expr k
Returns @var{k}-th value of what @var{mv-expr} returns.
Conceptually, it is the same as the following code.
@example
(call-with-values (lambda () mv-expr) (lambda r (list-ref r k)))
@end example
This macro uses shortcuts for the typical cases like @var{k} is zero.

Similar to Common Lisp's @code{nth-value}, but the argument order
is flipped to match other Scheme's @code{*-ref} procedures.
@end defmac

@node Delayed evaluation,  , Multiple values, Control features
@subsection  Delayed evaluation
@c NODE 遅延評価

Gauche provides an extended lazy evaluation mechanism according
to srfi-45.  Instead of two primitives as R5RS, we have three:
@code{lazy}, @code{delay}, and @code{force}.

It is found that the traditional mechanism that uses only
@code{delay} and @code{force} didn't mix well with tail-recursive
algorithms: It required unbound memory, despite that the
body of the algorithm could be expressed in iterative manner.
For the detailed explanation please look at the srfi-45 document.
Here we explain how to use those primitives.

@defspec lazy expression
@defspecx delay expression
[SRFI-45][R5RS]
These forms creates a @emph{promise} that delays the evaluation
of @var{expression}.  @var{Expression} will be evaluated
when the promise is passed to @code{force}.

If @var{expression} itself is expected to yield a promise,
you should use @code{lazy}.  Othewise, you should use @code{delay}.
If you can think in types, the difference may be clearer.

@example
lazy  : Promise a -> Promise a
delay : a -> Promise a
@end example

Since we don't have static typing, we can't enforce this usage.
The programmer has to choose appropriate one from the context.
Generally, @code{lazy} appearers only to surround the entire
body of function that express a lazy algorithm.

For the real-world example of use of @code{lazy},
you may want to check the implementation of @code{util.stream}
(@xref{Stream library}).
@end defspec

@defun force promise
[R5RS]
If @var{promise} is not a promise, it is just returned.

Otherwise, if @var{promise}'s value hasn't been computed,
@code{force} makes @var{promise}'s encapsulated expression
be evaluated, and returns the result.

Once @var{promise}'s value is computed, it is memorized in it
so that subsequent @code{force} on it won't cause the computation.
@end defun

@defun promise? obj
Returns @code{#t} iff @var{obj} is a promise object.
@end defun

The following example represents Fibonacci numbers by
a lazy list.   The list @code{fib} is calculated by
adding @code{fib} itself shifted one element.
Since it uses cached result of previous elements, calculation
of n-th Fibonacci number can be done in O(n).

@example
(define (lcar lis)   ;; lazy car
  (car (force lis)))

(define (lcdr lis)   ;; lazy cdr
  (cdr (force lis)))

(define (ltake lis n)  ;; lazy take
  (if (<= n 0) '() (cons (lcar lis) (ltake (lcdr lis) (- n 1)))))

(define (lmap proc l1 l2)  ;; lazy map
  (if (null? l1)
    '()
    (cons (proc (lcar l1) (lcar l2))
          (delay (lmap proc (lcdr l1) (lcdr l2))))))

;; lazy list of fibonacci numbers
(define fibs (list* 1 1 (delay (lmap + fibs (cdr fibs)))))

;; take a look
(ltake fibs 20)
  @result{} (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 
      987 1597 2584 4181 6765)
@end example

Note that, although it is elegant, it also requires O(n) storage
even when you only need n-th Fibonacci number.  That's because
the @code{delay} expression in the tail of @code{fibs} is grabbing
the head of @code{fibs} list and never releases it.

@c ----------------------------------------------------------------------
@node Exceptions, Eval and repl, Control features, Core library
@section Exceptions
@c NODE 例外

Gauche's exception system consists of three components;
(1) the way to signal an exceptional case has occurred,
(2) the way to specify how to handle such a case,
and (3) the standard objects (@emph{conditions}) 
to communicate the code that
signals an exceptional case and the code that handles it.

Those three components are typically used together, so first
we explain the typical usage patterns using examples.  Then
we describe each feature in detail.

Note for terminology: some languages use the word @emph{exception}
to refer to an object used to communicate the code that encountered
an exceptional situation with a handler that deals with it.
Gauche uses a term @emph{condition} to refer to such objects,
following SRFI-35.  @emph{Exception} is the situation, and
@emph{condition} is a runtime object that describes it.

@menu
* Exception handling overview::  
* Signalling exceptions::       
* Handling exceptions::         
* Conditions::                  
@end menu

@node Exception handling overview, Signalling exceptions, Exceptions, Exceptions
@subsection Exception handling overview
@c NODE 例外処理の概要

@subsubheading Catching specific errors

One of the most typical exception handling is to catch a
specific error raised by some built-in or library procedures.
A macro @code{guard} can be used for such a purpose.  The code
looks like this:

@example
(guard (exc
        ((condition-has-type? exc <read-error>) (format #t "read error!")
                                                'read-error)
        (else 'other-error))
  (read-from-string "(abc"))
@end example

The cadr of @code{guard} clause is a form of 
@code{(@var{variable} @var{clause} @dots{})}.  In this example,
the variable is @code{exc}, and it has two clauses.
Each @var{clause} has the form like the one in @code{cond}.

The cddr of @code{guard} is the body, a list of expressions.  This
example has only one expression, @code{(read-from-string "(abc")}.

@code{guard} starts executing its body.
@code{read-from-string} raises an error of type @code{<read-error>}
when it encounters syntactic errors.  The form @code{guard} intercepts
the error, and binds the condition object to the variable @var{exc},
then checks the clauses following @var{exc} in a similar manner
to @code{cond}---in this case, the thrown condition is of type
@code{<read-error>}, so the test of the first clause is satisfied,
and the rest of clause is executed, i.e. @code{"read error!"} is
printed and a symbol @code{read-error} is returned.

If you're familiar with other languages, you may recognize the
pattern.  The cddr of @code{guard} form is like @var{try} clause
of C++/Java or the cadr of @code{handler-case} of Common Lisp;
and the cdadr of @code{guard} form is like @code{catch} clauses
or the cddr of @code{handler-case}.

In the test expressions it is common to check the type of
thrown condition.  The function @code{condition-has-type?} is
defined in SRFI-35 but it's rather lengthy.  Gauche's condition
classes can also work like a predicate, so you can write the
above expression like this.

@example
(guard (exc
        ((<read-error> exc) 'read-error)
        (else 'other-error))
  (read-from-string "(abc")))
@end example

@emph{Note:} Generally you can't use @code{is-a?} to test if
the thrown condition is of a specific type, since a condition
may be @emph{compound}.  See @ref{Conditions} about compound
conditions.

If no tests of @var{clause}s satisfy and no @code{else} clause is given,
the exception `falls off' the @code{guard} construct, i.e. 
it will be handled by the outer level of @code{guard} form or
top-level.  For example, the following @code{guard} form
only handles @code{<read-error>} and @code{<system-error>};
if the body throws other type of conditions, it must be handled
by outer level.

@example
(guard (exc
        ((<read-error> exc) (handle-read-error))
        ((<system-error> exc) (handle-system-error))
        )
  body @dots{})
@end example

See @ref{Handling exceptions} for more details on @code{guard} and
other lower-level exception handling constructs.


@subsubheading Signalling exceptions from your code

The generic way to signal an exception is to use @code{raise} procedure.

@example
(raise @var{condition})
@end example

You can pass any object to @var{condition}; its interpretation
solely depends on the exception handler.  If you know the code
raises an integer as a condition, you can catch it by @code{guard}
as this:

@example
(guard (exc
        ((integer? exc) 'raised))
  (raise 3))
@end example

However, as a convention, it is preferable to use an instance
of @code{<condition>} or one of its subclasses.  A macro @code{condition}
can be used to create a condition object.  The following examples
show how to create a condition with some slot values and then raise it.

@example
;; create and raise an error condition
(raise (condition
        (<error> (message "An error occurred."))))

;; create and raise a system error condition
(raise (condition
        (<system-error> (message "A system error occurred.")
                        (errno EINTR))))
@end example

See @ref{Conditions} for the details of @code{condition} macro
and what kind of condition classes are provided.

The most common type of condition is an error condition, so
a convenience procedure @code{error} and @code{errorf} are
provided.  They create an error condition with a message and
raise it.

@example
;; `error' concatenates the arguments into a message.
(unless (integer? obj)
  (error "Integer expected, but got:" obj))

;; `errorf' uses format to create a message.
(unless (equal? x y)
  (errorf "~s and ~s don't match" x y))
@end example

@emph{Note:} unlike the exception throwing constructs in some languages,
such as @code{throw} of C++/Java, which abandons its continuation,
Scheme's @code{raise} may return to its caller.   If you don't
want @code{raise} to return, a rule of thumb is always to pass
one of error conditions to it; then Gauche guarantees @code{raise}
wont return.   See the description of @code{raise} in
@ref{Signalling exceptions} for more details.


@subsubheading Defining your own condition

You can also define your own condition classes
to pass application-specific information from the point of
raising exception to the handlers.

To fit to Gauche's framework (SRFI-35), it is desirable that
the new condition class inherits a built-in @code{<condition>} class
or one of its descendants, and also is an instance of a metaclass
@code{<condition-meta>}.

One way of ensuring the above convention as well as increasing 
portability is to use @code{define-condition-type} macro, defined
in @code{SRFI-35}.

@example
(define-condition-type <myapp-error> <error>
  myapp-error?
  (debug-info myapp-error-debug-info)
  (reason myapp-error-reason))
@end example

This defines a condition type (which is a class in Gauche)
@code{<myapp-error>}, with a predicate @code{myapp-error?}
and slots with accessors.   Then you can use the new
condition type like the following code:

@example
(guard (exc
         ((myapp-error? exc)
          (let ((debug-info (myapp-error-debug-info exc))
                (reason (myapp-error-reason exc)))
            ... handle myapp-error ...)))
  ...
  ...
  (if (something-went-wrong)
    (raise (condition
             (<myapp-error> (debug-info "during processing xxx")
                            (reason "something went wrong")))))
  ...
  ...
  )
@end example

If you don't mind to lose srfi compatibility, you can use
Gauche's extended @code{error} and @code{errorf} procedures to write
more concise code to raise a condition of subtype of @code{<error>}:

@example
  (if (something-went-wrong)
    (error <myapp-error>
           :debug-info "during processing xxx"
           :reason "something went wrong"))
@end example


See the description of @code{define-condition-type} macro
for how the condition type is implemented in Gauche's object system.

@node Signalling exceptions, Handling exceptions, Exception handling overview, Exceptions
@subsection Signalling exceptions
@c NODE 例外の通知

@subsubheading Signalling errors

The most common case of exceptions is an error.
Two convenience functions to signal an error condition
in simple cases are provided.
To signal a compound condition, you can use @code{raise} as explained below.

@defun error string arg @dots{}
@defunx error condition-type keyword-arg @dots{} string arg @dots{}
[SRFI-23+] Signals an error.  The first form creates an @code{<error>}
condition, with a message consists of @var{string} and @var{arg} @dots{},
and raises it.  It is compatible to srfi-23's @code{error} behavior.

@example
gosh> (define (check-integer x)
        (unless (integer? x)
           (error "Integer required, but got:" x)))
check-integer
gosh> (check-integer "a")
*** ERROR: Integer required, but got: "a"
Stack Trace:
_______________________________________
@end example

The second form can be used to raise an error other than the
@code{<error>} condition.  @var{condition-type} must be
a condition type (see @ref{Conditions} for more explanation of
condition types).  It may be followed by keyword-value list 
to initialize the condition slots, and then optionally followed by
a string and other objects that becomes an error message.

@example
(define-condition-type <my-error> <error> #f
  (reason)
  (priority))

...
  (unless (memq operation *supported-operations*)
    (error <my-error> 
           :reason 'not-supported :priority 'urgent
           "Operation not supported:" operation))
...
@end example
@end defun

@defun errorf fmt-string arg @dots{}
@defunx errorf condition-type keyword-arg @dots{} fmt-string arg @dots{}
Similar to @code{error}, but the error message is formatted by
@code{format}, i.e. the first form is equivalent to:
@example
(define (errorf fmt . args)
  (error (apply format #f fmt args)))
@end example

The second form can be used to raise an error other than an
@code{<error>} condition.  Meaning of @var{condition-type} and
@var{keyword-arg}s are the same as @code{error}.
@end defun

@subsubheading Signalling generic conditions

@defun raise condition
[SRFI-18] 
This is the base mechanism of signalling exceptions.

The procedure invokes the current exception handler.
The argument @var{condition} represents the nature of the exception,
and passed to the exception handler.
Gauche's built-in and library functions always use
an instance of @code{<condition>} or one of its subclasses as @var{condition},
but you can pass any Scheme object to @code{raise}.  The interpretation
of @var{condition} is up to the exception handler.

@emph{Note:} Unlike some of the mainstream languages in which
"throwing" an exception never returns, you can set up an exception
handler in the way that @code{raise} may return.  The details
are explained in @ref{Handling exceptions}.

If you don't want @code{raise} to return, the best way is to
pass a condition which is an instance of @code{<serious-condition>} 
or one of its subclasses.  Gauche's internal mechanism
guarantees raising such an exception won't return.
See @ref{Conditions} for the hierarchy of built-in conditions.
@end defun


@node Handling exceptions, Conditions, Signalling exceptions, Exceptions
@subsection Handling exceptions
@c NODE 例外の処理

@subsubheading High-level exception handling mechanism

@defmac guard (var clause @dots{}) body @dots{}
[SRFI-34]
This is @emph{the} high-level form to handle errors in Gauche.

@var{var} is a symbol, and @var{clause}s are the same form as
@code{cond}'s clauses, i.e. each clause can be either one of
the following forms:
@enumerate
@item
@code{(@var{test} @var{expr} @dots{})}
@item
@code{(@var{test} => @var{proc})}
@end enumerate

The last @var{clause} may be @code{(else @var{expr} @dots{})}.

This form evaluates @var{body} @dots{} and returns the value(s) of
the last @var{body} expression in normal case.
If an exception is raised during the evaluation of body expressions,
the raised exception is bound to a variable @var{var}, then
evaluates @var{test} expression of each clause.  If one of @var{test}
expressions returns true value, then the corresponding @var{expr}s
are evaluated if the clause is the first form above, or an @var{proc}
is evaluated and the result of @var{test} is passed to the procedure
@var{proc} if the clause is the second form.

When the @var{test}(s) and @var{expr}(s) in the clauses are evaluated,
the exception handler that is in effect of the caller of @code{guard} are
installed; that is, if an exception is raised again within @var{clause}s,
it is handled by the @emph{outer} exception handler or @code{guard} form.

If no @var{test} returns true value and the last @code{clause} is
@code{else} clause, then the associated @var{expr}s are evaluated.
If no @var{test} returns true value and there's no @code{else} clause,
the raised exception is re-raised, to be handled by the outer exception
handler.

When the exception is handled by one of @code{clause}s, @code{guard}
returns the value(s) of the last @var{expr} in the handling clause.

The @var{clause}s are evaluated in the same dynamic environment as
the @code{guard} form, i.e. any @code{dynamic-wind}s inside @code{body}
are unwound before evaluation of the @var{clause}s.  It is different
from the lower level forms
@code{with-error-handler} and @code{with-exception-handler}, whose
handler is evaluated before the dynamic environment are unwound.

@example
(let ((z '()))
  (guard (e (else (push! z 'caught)))
    (dynamic-wind (lambda () (push! z 'pre))
                  (lambda () (error "foo"))
                  (lambda () (push! z 'post))))
  (reverse z))
 @result{} (pre post caught)

(guard (e (else (print 'OUTER) #f))
  (with-output-to-string ()
    (print 'INNER)
    (error "foo")))
 @result{} prints OUTER to the current output port of guard,
      not to the string port.
@end example
@end defmac

@defmac unwind-protect body cleanup
Executes @var{body}, then executes @var{cleanup}, and
returns the result(s) of @var{body}.  If an exception is raised
within @var{body}, @var{cleanup} is executed before the
exception escapes from the @code{unwind-protect} form.
For example, the following code calls @code{start-motor},
@code{drill-a-hole}, and @code{stop-motor} in order if
everything goes ok, and if anything goes wrong in @code{start-motor}
or @code{drill-a-hole}, @code{stop-motor} is still called
before the exception escapes @code{unwind-protect}.

@example
(unwind-protect
  (begin (start-motor)
         (drill-a-hole))
  (stop-motor))
@end example

The @var{cleanup} form is evaluated in the same dynamic environment
as @code{unwind-protect}.
If an exception is thrown within @var{cleanup}, it will be
handled outside of the @code{unwind-protect} form.

Although this form looks similar to @code{dynamic-wind}, they
work at different layers and should not be confused.  
@code{dynamic-wind} is the bottom-level
building block and used to manage current exception handlers,
current i/o ports, parameters, etc.
@code{dynamic-wind}'s @var{before} and @var{after} thunks are
called whenever any of those control flow transition occurs.
On the other hand, @code{unwind-protect} only cares about
the Gauche's exception system.  @code{unwind-protect}'s @var{cleanup}
is called only when @var{body} throws Gauche's exception.
In the above example, if control escapes from @code{drill-a-hole} 
by calling a continuation captured outside of @code{unwind-protect},
@var{cleanup} is not called; because the control may return to
@code{drill-a-hole} again.  It can happen if user-level thread
system is implemented by @code{call/cc}, for example.

The name of this form is taken from Common Lisp.  Some Scheme
systems have similar macros in different names, such as
@code{try-finally}.
@end defmac


@defun with-error-handler handler thunk
Makes @var{handler} the active error handler and executes @var{thunk}.
If @var{thunk} returns normally, the result(s) will be returned.
If an error is signalled during execution of @var{thunk},
@var{handler} is called with one argument, an exception object
representing the error, with the continuation of @code{with-error-handler}.
That is, @code{with-error-handler} returns whatever value(s) @var{handler}
returns.

If @var{handler} signals an error, it will be handled by the
handler installed when @code{with-error-handler} called.

The dynamic environment where @var{handler} is executed is
the same as the error occurs.  If @code{dynamic-wind} is used
in @var{thunk}, its @var{after} method is called after @var{handler}
has returned, and before @code{with-error-handler} returns.

Note: Using this procedure directly is @emph{no longer recommended}, since
@code{guard} is more safe and portable.  We'll keep this for
a while for the backward compatibility, but we recommend to rewrite
code to use @code{guard} instead of this.
The common idiom of "cleanup on error"
code:
@example
(with-error-handler (lambda (e) (cleanup) (raise e))
  (lambda () body @dots{}))
@end example
should be written like this:
@example
(guard (e (else (cleanup) (raise e)))
  body @dots{})
@end example
@end defun


@subsubheading Behavior of unhandled exception

If an exception is raised where no program-defined exception handler is
installed, the following action is taken.

@itemize @bullet
@item 
If the program is running interactively (in repl), the information
of the thrown exception and stack trace are displayed, and
the program returns to the toplevel prompt.
@item
If the program is running non-interactively, the information
of the thrown exception and stack trace are displayed, then
the program exits with an exit status @code{EX_SOFTWARE} (70).
@end itemize

@subsubheading Low-level exception handling mechanism

This layer provides SRFI-18 compatible simple exception mechanism.
You can override the behavior of higher-level constructs such as
@code{with-error-handler} by using @code{with-exception-handler}.

Note that it is a double-edged sword.  You'll get a freedom to
construct your own exception handling semantics, but the Gauche
system won't save if something goes wrong.   Use these primitives
when you want to customize the system's higher-level semantics
or you are porting from other SRFI-18 code.

@defun current-exception-handler
[SRFI-18]
Returns the current exception handler.
@end defun

@defun with-exception-handler handler thunk
[SRFI-18]
A procedure @var{handler} must take one argument.  This procedure
sets @var{handler} to the current exception handler and calls
@var{thunk}.
@end defun

Generally, if you want to handle non-continuable exception such as
errors using this low-level mechanism,
you have to transfer the control from the handler explicitly
(See the explanation of @code{with-error-handler} above).
@code{raise} detects if the handler returns on the
non-continuable exceptions and reports an error using the
default error handler mechanism, but it is just a safety net.

Note also that @var{handler} is called in the same dynamic environment
of @code{raise}.  So if you raise an exception inside @var{handler},
it is captured by @var{handler} again.   It is the programmer's
responsibility to propagate the exception handling to the ``outer''
exception handlers.

The behavior of those procedures can be explained in
the following conceptual Scheme code.

@example
;; @r{Conceptual implementation of low-level exception mechanism.}
;; @r{Suppose %xh is a list of exception handlers}

(define (current-exception-handler) (car %xh))

(define (raise exn)
  (receive r ((car %xh) exn)
    (when (uncontinuable-exception? exn)
      (set! %xh (cdr %xh))
      (raise (@r{@i{make-error}} "returned from uncontinuable exception")))
    (apply values r)))

(define (with-exception-handler handler thunk)
  (let ((prev %xh))
    (dynamic-wind
      (lambda () (set! %xh (cons handler %xh)))
      thunk
      (lambda () (set! %xh prev)))))
@end example


@node Conditions,  , Handling exceptions, Exceptions
@subsection Conditions
@c NODE コンディション

@subsubheading Built-in Condition classes

Gauche currently has the following hierarchy of built-in condition
classes.  It approximately reflects SRFI-35 and SRFI-36 condition hierarchy,
although they have Gauche-style class names.  If there's a corresponding
SRFI condition type, the class has the SRFI name as well.

@example
  <condition>
    +- <compound-condition>
    +- <serious-condition>
    |    +- <serious-compound-condition> ; also inherits <compound-condition>
    +- <message-condition>
         +- <error>                      ; also inherits <serious-condition>
              +- <system-error>
              +- <unhandled-signal-error>
              +- <read-error>
              +- <io-error>
                   +- <port-error>
                        +- <io-read-error>
                        +- <io-write-error>
                        +- <io-closed-error>
                        +- <io-unit-error>
@end example

Note that some conditions may occur simultaneously; for example,
error during reading from a file because of device failure may consist
both @code{<system-error>} @emph{and} @code{<io-read-error>}.
In such cases, a @emph{compound condition} is raised.
So you can't just use, for instance, @code{(is-a? obj <io-read-error>)}
to check if @code{<io-read-error>} is thrown. 
See the "Condition API" section below.

@deftp {Metaclass} <condition-meta>
@clindex condition-meta
Every condition class is an instance of this class.
This class defines @code{object-apply} so that you can use
a condition class as a predicate, e.g.:

@example
(<error> obj) @equiv{} (condition-has-type? obj <error>)
@end example
@end deftp


@deftp {Class} <condition>
@deftpx {Condition Type} &condition
@clindex condition
@vindex &condition
[SRFI-35]
The root class of the condition hierarchy.
@end deftp

@deftp {Class} <compound-condition>
@clindex compound-condition
Represents a compound condition.  A compound condition can be
created from one or more conditions by @code{make-compound-condition}.
Don't use this class directly.

A compound condition returns @code{#t} for @code{condition-has-type?}
if any of the original conditions has the given type.
@end deftp

@deftp {Class} <serious-condition>
@deftpx {Condition Type} &serious
@clindex serious-condition
@vindex &serious
[SRFI-35]
Conditions of this class are for the situations that are too serious
to ignore or continue.  Particularly, you can safely assume that
if you @code{raise} this type of condition, it never returns.
@end deftp

@deftp {Class} <serious-compound-condition>
@clindex serious-compound-condition
This is an internal class to represent a compound condition
with any of its component condition is serious.   Inherits both
@code{<compound-condition>} and @code{<serious-condition>}.
@code{make-compound-condition} uses this class if the passed
conditions includes a serious one.  
Don't use this class directly.
@end deftp

@deftp {Class} <message-condition>
@deftpx {Condition Type} &message
@clindex message-condition
[SRFI-35]
This class represents a condition with a message.  It has one slot.

@defivar {<message-condition>} message
A message.

@end defivar
@end deftp

@deftp {Class} <error>
@deftpx {Condition Type} &error
@clindex error
@vindex &error
[SRFI-35]
Indicates an error.  Inherits @code{<serious-condition>}
and @code{<message-condition>}, thus has @code{message} slot.

Note: SRFI-35 @code{&error} condition only inherits @code{&serious}
and not @code{&message}, so you have to use compound condition
to attach a message to the error condition.  Gauche uses multiple
inheritance here, largely because of backward compatibility.
To write a portable code, an error condition should be used
with a message condition, like this:

@example
(condition
  (&message (message "Error message"))
  (&error))
@end example
@end deftp

@deftp {Class} <system-error>
@clindex system-error
A subclass of @code{<error>}.
When a system call returns an error, this type of exception is
thrown.  The @code{message} slot usually contains the description
of the error (like the one from @code{strerror(3)}).
Besides that, this class has one more instance slot:

@defivar {<system-error>} errno
Contains an integer value of system's error number.

Error numbers may differ among systems.  Gauche defines
constants for typical Unix error values (e.g. @code{EACCES}, @code{EBADF},
etc), so it is desirable to use them instead of literal numbers.
See the description of @code{sys-strerror} in @ref{System inquiry}
for available constants.
@end defivar

This class doesn't have corresponding SRFI condition type,
but important to obtain OS's raw error code.  In some cases,
this type of condition is compounded with other condition
types, like @code{<io-read-error>}.
@end deftp

@deftp {Class} <unhandled-signal-error>
@clindex unhandled-signal-error
A subclass of @code{<error>}.  The default handler of most of
signals raises this condition.   See @ref{Handling signals} for
the details.
@defivar {<unhandled-signal-error>} signal
An integer indicating the received signal number.
There are constants defined for typical signal numbers; see
@ref{Signals and signal sets}.
@end defivar
@end deftp

@deftp {Class} <read-error>
@deftpx {Condition Type} &read-error
@clindex read-error
@vindex &read-error
[SRFI-36]
A subclass of @code{<error>}.
When the reader detects a lexical or syntactic error during
reading an S-expression, this type of condition is raised.

@defivar {<read-error>} port
A port from which the reader is reading.
(NB: SRFI-36's @code{&read-error} doesn't have this slot.  Portable
program shouldn't rely on this slot).
@end defivar

@defivar {<read-error>} line
A line count (1-base) of the input where the reader raised this error.
It may be -1 if the reader is reading from a port that doesn't keep
track of line count.
@end defivar

@defivar {<read-error>} column 
@defivarx {<read-error>} position
@defivarx {<read-error>} span
These slots are defined in SRFI-36's @code{&read-error}.
For the time being, these slots always hold @code{#f}.
@end defivar

@end deftp

@deftp {Class} <io-error>
@deftpx {Condition Type} &io-error
@clindex io-error
@vindex &io-error
[SRFI-36]
A base class of I/O errors.  Inherits @code{<error>}.
@end deftp

@deftp {Class} <port-error>
@deftpx {Condition Type} &io-port-error
@clindex port-error
@vindex &io-port-error
[SRFI-36]
An I/O error related to a port.   Inherits @code{<io-error>}.

@defivar <port-error> port
Holds the port where the error occurred.
@end defivar
@end deftp

@deftp {Class} <io-read-error>
@deftpx {Condition Type} &io-read-error
@clindex io-read-error
@vindex &io-read-error
[SRFI-36]
An I/O error during reading from a port.  Inherits @code{<port-error>}.
@end deftp

@deftp {Class} <io-write-error>
@deftpx {Condition Type} &io-write-error
@clindex io-write-error
@vindex &io-write-error
[SRFI-36]
An I/O error during writing to a port.  Inherits @code{<port-error>}.
@end deftp

@deftp {Class} <io-closed-error>
@deftpx {Condition Type} &io-closed-error
@clindex io-closed-error
@vindex &io-closed-error
[SRFI-36]
An I/O error when read/write is attempted on a closed port.
Inherits @code{<port-error>}.
@end deftp

@deftp {Class} <io-unit-error>
@clindex io-unit-error
An I/O error when the read/write is requested with a unit
that is not supported by the port (e.g. a binary I/O is requested
on a character-only port).   Inherits @code{<port-error>}.
@end deftp


@subsubheading Condition API

@defmac define-condition-type name supertype predicate field-spec @dots{}
[SRFI-35+]
Defines a new condition type.  In Gauche, a condition type is
a class, whose metaclass is @code{<condition-meta>}.

@var{Name} becomes the name of the new type, and also the variable
of that name is bound to the created condition type.
@var{Supertype} is the name of the supertype (direct superclass)
of this condition type.  A condition type must inherit from
@code{<condition>} or its descendants.
(Multiple inheritance can't be specified by this form, and generally
should be avoided in condition type hierarchy.  Instead, you
can use compound conditions, which don't introduce multiple inheritance.)

A variable @var{predicate} is bound to a predicate procedure for
this condition type.

Each @code{field-spec} is a form of @code{(field-name accessor-name)},
and the condition will have fields named by @var{field-name}, and
a variable @var{accessor-name} will be bound to a procedure that
accesses the field.   In Gauche, each field becomes a slot of
the created class.

Gauche extends srfi-35 to allow @var{predicate} and/or @code{accessor-name}
to be @code{#f}, or @code{accessor-name} to be omitted,
if you don't need to them to be defined.

When @code{define-condition-type} is expanded into a class
definition, each slot gets a @code{:init-keyword} slot option
with the keyword whose name is the same as the slot name.
@end defmac

@defun condition-type? obj
[SRFI-35]
Returns @code{#t} iff @var{obj} is a condition type.  In Gauche,
it means @code{(is-a? obj <condition-meta>)}.
@end defun

@defun make-condition-type name parent field-names
[SRFI-35]
A procedural version to create a new condition type. 
@end defun

@defun make-condition type field-name value @dots{}
[SRFI-35]
Creates a new condition of condition-type @var{type}, and
initializes its fields as specified by @code{field-name} and @code{value}
pairs
Returns @code{#t} iff @var{obj} is a condition.  In Gauche,
it means @code{(is-a? obj <condition>)}.
@end defun

@defun condition-has-type? obj type
[SRFI-35]
Returns @code{#t} iff @var{obj} belongs to a condition type @var{type}.
Because of compound conditions, this is not equivalent to @code{is-a?}.
@end defun

@defun condition-ref condition field-name
[SRFI-35]
Retrieves the value of field @var{field-name} of @var{condition}.
If @var{condition} is a compound condition, you can access to the
field of its original conditions; if more than one original condition
have @var{field-name}, the first one passed to @code{make-compound-condition}
has precedence.

You can use @var{slot-ref} and/or @var{ref} to access to the field
of conditions; compound conditions define a @code{slot-missing} method
so that @var{slot-ref} behaves as if the compound conditions have all the
slots of the original conditions.  Using @code{condition-ref} increases
portability, though.
@end defun

@defun make-compound-condition condition0 condition1 @dots{}
[SRFI-35]
Returns a compound condition that has all @var{condition0} @var{condition1}
@dots{}.  The returned condition's fields are the union of all the fields
of given conditions; if any conditions have the same name of fields,
the first one takes precedence.   The returned condition also has
condition-type of all the types of given conditions.
(This is not a multiple inheritance.  See @code{<compound-condition>} above.)
@end defun

@defun extract-condition condition condition-type
[SRFI-35]
@var{Condition} must be a condition and have type @var{condition-type}.
This procedure returns a condition of @var{condition-type},
with field values extracted from @var{condition}.
@end defun

@defmac condition type-field-binding @dots{}
[SRFI-35]
A convenience macro to create a (possibly compound) condition.
@var{Type-field-binding} is a form of 
@code{(@var{condition-type} (@var{field-name} @var{value-expr}) @dots{})}.

@example
(condition
  (type0 (field00 value00) ...)
  (type1 (field10 value10) ...)
  ...)
 @equiv{}
(make-compound-condition
  (make-condition type0 'field00 value00 ...)
  (make-condition type1 'field10 value10 ...)
  ...)
@end example
@end defmac


@c ----------------------------------------------------------------------
@node Eval and repl, Input and output, Exceptions, Core library
@section Eval and repl
@c NODE eval と repl

@defun eval expr env
[R5RS]
Evaluate @var{expr}.   @var{env} must be a value returned by
the following procedures below.  Right now it is just a
@code{<module>} object, but it is possible that the Gauche
adopts a first-class environment object in future.
@end defun

@defun null-environment version
@defunx scheme-report-environment version
@defunx interaction-environment
[R5RS]
Returns an environment specifier which can be used as the second
argument of @code{eval}.   Right now an environment specifier
is just a module.  @code{(null-environment 5)} returns
a @code{null} module, which contains just the syntactic bindings
specified in R5RS, @code{(scheme-report-environment 5)}
returns a @code{scheme} module, which contains syntactic and procedure
bindings in R5RS, and @code{(interaction-environment)} returns
a @code{user} module that contains all the Gauche built-ins plus
whatever the user defined.
It is possible that the Gauche adopts a first-class environment object
in future, so do not rely on the fact that the environment specifier
is just a module.

An error is signaled if a value other than 5 is passed as @var{version}
argument.

@end defun

@defun read-eval-print-loop &optional reader evaluator printer prompter
This exports @code{Gosh}'s default read-eval-print loop to applications.
Each argument can be @code{#f}, which indicates it to use Gauche's
default procedure(s), or a procedure that satisfies the
following conditions.

@table @emph
@item reader
A procedure that takes no arguments.  It is supposed to read an expression
and returns it.
@item evaluator
A procedure that takes two arguments, an expression and an environment
specifier.  It is supposed to evaluate the expression and returns zero or
more value(s).
@item printer
A procedure that takes zero or more arguments.   It is supposed to
print out these values.   The result of this procedure is discarded.
@item prompter
A procedure that takes no arguments.  It is supposed to print
out the prompt.   The result of this procedure is discarded.
@end table

Given those procedures, @code{read-eval-print-loop} runs as follows:

@enumerate
@item
Prints the prompt by calling @var{prompter}.
@item
Reads an expression by calling @var{reader}.  If it returns EOF,
exits the loop and returns from @code{read-eval-print-loop}.
@item
Evaluates an expression by calling @var{evaluator}
@item
Prints the result by calling @var{printer}, then repeats from 1.
@end enumerate

When an error is signaled from one of those procedures, it is
captured and reported by the default escape handler, then
the loop restarts from 1.

It is OK to capture a continuation within those procedures
and re-invoke them afterwards.
@end defun

@c ----------------------------------------------------------------------
@node Input and output, Loading Programs, Eval and repl, Core library
@section Input and Output
@c NODE 入出力

@menu
* Ports::                       
* Port and threads::            
* Common port operations::      
* File ports::                  
* String ports::                
* Coding-aware ports::          
* Input::                       
* Output::                      
@end menu

@node Ports, Port and threads, Input and output, Input and output
@subsection Ports
@c NODE ポート

@deftp {Builtin Class} <port>
@clindex port
A port class.   A port is Scheme's way of abstraction of I/O channel.
Gauche extends a port in number of ways so that it can be used
in wide range of applications.

Standard Scheme (R5RS) essentially defines a port as an entity that
you can fetch a character at a time and
look one character ahead from an input port, 
and put a character at a time to an output port.
Other R5RS I/O routines can be built on top of them.

Besides this basics, Gauche's port can handle the following
operations.

@table @asis
@item Binary I/O
You can read/write one octet at a time, instead of a character.
(Remember, Gauche handles multibyte characters, so a character
may be consisted from more than one bytes).
Most ports allow you to mix binary I/O and character I/O, if needed.

The most basic binary I/O primitives are @code{read-byte} and
@code{write-byte}.  You can also use higher-level functionality,
such as @code{pack} and @code{unpack} in @ref{Packing Binary Data}.

@item Block I/O
You can read/write a specified number of byte sequences.
This can be an efficient way of moving block of data,
if the port's underlying implementation supports block I/O
operation.

@item Conversion
Some ports can be used to convert a data stream from one format
to another; one of such applications is character code conversion
ports, provided by @code{gauche.charconv} module
(@xref{Character code conversion}, for details).

@item Extra features
There are also a ports with special functionality.
A coding-aware port (@xref{Coding-aware ports}) recognizes a special
"magic comment" in the file to know which character encoding the
file is written.
Virtual ports (@xref{Virtual ports}) allows you to program the
behavior of the port in Scheme.
@end table

@end deftp

@node Port and threads, Common port operations, Ports, Input and output
@subsection Port and threads
@c NODE ポートとスレッド

When Gauche is compiled with thread support, 
the builtin port operations locks the port, so that port access
from multiple threads will be serialized.   
(It is required by SRFI-18, BTW).
Here, "builtin port operations" are the port access functions
that takes a port and does some I/O or query on it,
such as @code{read}/@code{write}, @code{read-char}/@code{write-char}, 
@code{port->string}, etc.
Note that @code{call-with-*} and @code{with-*} procedures do not
lock the port during calling the given procedures, since the
procedure may pass the reference of the port to the other thread,
and Gauche wouldn't know if that's the case.

This means you don't need to be too paranoia to worry about
ports under multithreaded environment.  However, keep it in
mind that this locking mechanism is meant to be a safety net
from breaking the port's internal state, and not to be
a general mutex mechanism.  It assumes port accesses rarely
conflict, and uses spin lock to reduce the overhead of majority
cases.  If you know there will be more than one thread accessing
the same port, you should use explicit mutex to avoid conflicts.

@defun with-port-locking port thunk
Executes @var{thunk}, while making the calling thread
hold the exclusive lock of @var{port} during the dynamic extent
of @var{thunk}.

Calls of the builtin port functions during the lock is held
would bypass mutex operations and yield better performance.

Note that the lock is held during the dynamic extent of @var{thunk};
so, if @var{thunk} invokes a continuation captured outside of
@code{with-port-locking}, the lock is released.  If the continuation
captured within @var{thunk} is invoked afterwards, the lock is re-acquired.

@code{With-port-locking} may be nested.  The lock is valid during
the outermost call of @code{with-port-locking}.

Note that this procedure uses the port's built-in lock mechanism
which uses busy wait when port access conflicts.  It should be
used only for avoiding fine-grain lock overhead; use explicit
mutex if you know there will be conflicts.
@end defun

@node Common port operations, File ports, Port and threads, Input and output
@subsection Common port operations
@c NODE ポート共通の操作

@defun port? obj
@defunx input-port? obj
@defunx output-port? obj
[R5RS]
Returns true if @var{obj} is a port, an input port and an output port,
respectively.  @code{Port?} is not listed in the
R5RS standard procedures, but mentioned in the "Disjointness of Types"
section.
@end defun

@defun port-closed? port
Returns true if @var{obj} is a port and it is already closed.
A closed port can't be reopened.
@end defun

@defun current-input-port
@defunx current-output-port
[R5RS]
Returns the current input port and the current output port, respectively.
@end defun

@defun current-error-port
Returns the current output port.
@end defun

@defun standard-input-port
@defunx standard-output-port
@defunx standard-error-port
Returns ports that are bound initially to current input, output and
error port, respectively.
@end defun

@defun with-input-from-port port thunk
@defunx with-output-to-port port thunk
@defunx with-error-to-port port thunk
Calls @var{thunk}.  During evaluation of thunk, the current input port, current
output port and current error port are set to @var{port}, respectively.
@end defun

@defun with-ports iport oport eport thunk
Does the above three functions at once.
Calls @var{thunk} while the current input, output, and error ports are
set to @var{iport}, @var{oport}, and @var{eport}, respectively.
You may pass @code{#f} to any port argument(s) if you don't need
to alter the port(s).
@end defun


@defun close-input-port port
@defunx close-output-port port
[R5RS]
Closes input and output @var{port}, respectively
@end defun

@defun port-type port
Returns the type of @var{port} in one of the symbols @code{file}, 
@code{string} or @code{proc}.
@end defun

@defun port-name port
Returns the name of @var{port}.  If the port is associated to a file,
it is the name of the file.   Otherwise, it is some description of the port.
@end defun

@defun port-buffering port
@defunx {(setter port-buffering)} port buffering-mode
If @var{port} is type of file port (i.e. @code{(port-type @var{port})}
returns @code{file}), these procedures gets and sets the port's
buffering mode.  For input ports, the port buffering mode may be
either one of @code{:full}, @code{:modest} or @code{:none}.
For output ports, @code{port-buffering}, it may be
one of @code{:full}, @code{:line} or @code{:none}.
@xref{File ports}, for explanation of those modes.

If @code{port-buffering} is applied to ports other than file ports,
it returns @code{#f}.  If the setter of port-buffering is
applied to ports other than file ports, it signals an error.
@end defun

@defun port-current-line port
Returns the current line count of @var{port}.  This information is
only available on file-based port, and as long as you're doing
sequential character I/O on it.  Otherwise, this returns -1.
@end defun

@defun port-file-number port
Returns an integer file descriptor, if the @var{port} is associated
to the system file I/O.  Returns @code{#f} otherwise.
@end defun

@defun port-seek port offset &optional whence
If the given @var{port} allows random access, this procedure sets
the read/write pointer of the @var{port} according to the given @var{offset}
and @var{whence}, then returns the updated offset (number of bytes
from the beginning of the data).  If @var{port} is not random-accessible,
@code{#f} is returned.  In the current version, file ports and
input string ports are fully random-accessible.  You can only query
the current byte offset of output string ports.

Note that port position is represented by byte count, not character count.

It is allowed to seek after the data if @var{port} is an output
file port.  See POSIX lseek(2) document for details of the behavior.
For input file port and input string port, you can't seek after the data.

The @var{whence} argument must be a small integer that represents
from where @var{offset} should be counted.   The following constant
values are defined.

@table @code
@item SEEK_SET
@var{Offset} represents the byte count from the beginning of the data.
This is the default behavior when @var{whence} is omitted.

@item SEEK_CUR
@var{Offset} represents the byte count relative to the current read/write
pointer.  If you pass 0 to @var{offset}, you can get the current
port position without changing it.

@item SEEK_END
@var{Offset} represents the byte count relative to the end of the data.
@end table
@end defun

@defun port-tell port
Returns the current read/write pointer of @var{port} in byte count,
if @var{port} is random-accessible.   Returns @code{#f} otherwise.
This is equivalent to the following call:
@example
(port-seek @var{port} 0 SEEK_CUR)
@end example
@end defun

@emph{Note on the names}:  @code{Port-seek} is called
@code{seek}, @code{file-position} or @code{input-port-position}/
@code{output-port-position} on some implementations.
@code{Port-tell} is called @code{tell}, @code{ftell} or
@code{set-file-position!}.   Some implementations have
@code{port-position} for different functionality.
CommonLisp has @code{file-position}, but it is not suitable
for us since @var{port} need not be a file port.  @code{Seek} and
@code{tell} reflects POSIX name, and with Gauche naming convention
we could use @code{sys-seek} and @code{sys-tell}; however, @var{port}
deals with higher level of abstraction than system calls, so I dropped
those names, and adopted new names.

@defun copy-port src dst &keyword (unit 0)
Copies data from an input port @var{src} to an output port @var{dst},
until eof is read from @var{src}.

The keyword argument @var{unit} may be zero, a positive exact integer,
a symbol @code{byte} or a symbol @code{char}, to specify the unit
of copying.  If it is an integer, a buffer of the size
(in case of zero, a system default size) is used to copy,
using block I/O.  Generally it is the fastest if you copy
between normal files.   If @var{unit} is a symbol @code{byte},
the copying is done byte by byte, using C-verson of @code{read-byte}
and @code{write-byte}.  If @var{unit} is a symbol @code{char},
the copying is done character by character, using C-version of
@code{read-char} and @code{write-char}.
@end defun


@node File ports, String ports, Common port operations, Input and output
@subsection File ports
@c NODE ファイルポート

@defun open-input-file filename &keyword if-does-not-exist buffering element-type
@defunx open-output-file filename &keyword if-does-not-exist if-exists buffering element-type
[R5RS+]
Opens a file @var{filename} for input or output, and
returns an input or output port associated with it, respectively.

The keyword arguments specify precise behavior on the exceptional case.

@table @code
@item :if-exists
This keyword argument can be specified only for @code{open-output-file}, and
specifies the action when the @var{filename} already exists.
One of the following value can be given.
@table @code
@item :supersede
The existing file is truncated.  This is the default behavior.
@item :append
The output data will be appended to the existing file.
@item :overwrite
The output data will overwrite the existing content.
If the output data is shorter than the existing file, the rest of
existing file remains.
@item :error
An error is signalled.
@item #f
No action is taken, and the function returns @code{#f}.
@end table

@item :if-does-not-exist
This keyword argument specifies the action when @var{filename} does not exist.
@table @code
@item :error
An error is signalled.  This is the default behavior of
@code{open-input-file}.
@item :create
A file is created.  This is the default behavior of @code{open-output-file}.
The check of file existence and creation is done atomically; you can
exclusively create the file by specifying @code{:error} or @code{#f} to
@var{if-exists}, along this option.
You can't specify this value for @code{open-input-file}.
@item #f
No action is taken, and the function returns @code{#f}.
@end table

@item :buffering
This argument specifies the buffering mode.  The following values are
allowed.
The port's buffering mode can be get/set by @code{port-buffering}.
(@xref{Common port operations}).
@table @code
@item :full
Buffer the data as much as possible.  This is the default mode.
@item :none
No buffering is done.  Every time the data is written (to an output port)
or read (from an input port), the underlying system call is used.
Process's standard error port is opened in this mode by default.
@item :line
This is valid only for output ports.  The written data is buffered, but
the buffer is flushed whenever a newline character is written.
This is suitable for interactive output port.  Process's standard
output port is opened in this mode by default.
(Note that this differs from the line buffering mode of C stdio, which
flushes the buffer as well when input is requested from the same file
descriptor.)
@item :modest
This is valid only for input ports.  This is almost the same as the mode
@code{:full}, except that @code{read-block} may return less data
than requested if the requested amount of data is not immediately available.
(In the @code{:full} mode, @code{read-block} waits the entire data to be
read).   This is suitable for the port connected to a pipe or network.
@end table

@item :element-type
This argument specifies the type of the file.
@table @code
@item :character
The file is opened in "character" (or "text") mode.
@item :binary
The file is opened in "binary" mode.
@end table
@emph{In the current version, this argument is ignored and all files
are opened in binary mode.  It doesn't make difference in the Unix platforms.}
@end table

By combination of @var{if-exists} and @var{if-does-not-exist} flags,
you can implement various actions:
@example
(open-output-file "foo" :if-exists :error)
 @result{} ;@r{opens "foo" exclusively, or error}

(open-output-file "foo" :if-exists #f)
 @result{} ;@r{opens "foo" exclusively, or returns} #f

(open-output-file "foo" :if-exists :append
                        :if-does-not-exist :error)
 @result{} ;@r{opens "foo" for append only if it already exists}
@end example

To check the existence of a file without opening it,
use @code{sys-access} or @code{file-exists?} (@xref{File stats}).

Note: @code{gauche.charconv} module extends these procedures to
take @var{encoding} keyword argument so that they can read or write
in different character encoding scheme.  @xref{Character code conversion}.

Note for portability: Some Scheme implementations (e.g. STk) allows
you to specify a command to @var{filename} and reads from, or
writes to, the subprocess standard input/output.  Some other scripting
languages (e.g. Perl) have similar features.  In Gauche,
@code{open-input-file} and @code{open-output-file} strictly operates
on files (what the underlying OS thinks as files).
However, you can use ``process ports'' to invoke
other command in a subprocess and to communicate it.
@xref{Process ports}, for details.
@end defun

@defun call-with-input-file string proc &keyword if-does-not-exist buffering element-type
@defunx call-with-output-file string proc &keyword if-does-not-exist if-exists buffering element-type
[R5RS]
Opens a file specified by @var{string} for input/output,
and call @var{proc} with one argument, the file port.  When @var{proc}
returns, or an error is signalled from @var{proc} that is not captured
within @var{proc}, the file is closed.

The keyword arguments @code{if-exists}, @code{element-type} and
@code{if-does-not-exist} have the same meanings of
@code{open-input-file} and @code{open-output-file}'s.  Note that
if you specify @code{#f} to @var{if-exists} and/or @var{if-does-not-exist},
@var{proc} may receive @code{#f} instead of a port object when
the file is not opened.

Returns the value(s) @code{proc} returned.
@end defun

@defun with-input-from-file string thunk &keyword if-does-not-exist buffering element-type
@defunx with-output-to-file string thunk &keyword if-does-not-exist if-exists buffering element-type
[R5RS]
Opens a file specified by @var{string} for input or output
and makes the opened port as the current input or output port,
then calls @var{thunk}.  The file is closed when @var{thunk}
returns or an error is signalled from @var{thunk} that is not
captured within @var{thunk}.

Returns the value(s) @code{thunk} returns.

The keyword arguments have the same
meanings of @code{open-input-file} and @code{open-output-file}'s,
except that when @code{#f} is given to @var{if-exists} and
@var{if-does-not-exist} and the opening port is failed,
@var{thunk} isn't called at all and @code{#f} is returned
as the result of @code{with-input-from-file} and
@code{with-output-to-file}.
@end defun

@emph{Notes on semantics of closing file ports:}
R5RS states, in the description of @code{call-with-input-file} et al., 
that @emph{"If @emph{proc} does not return, then the port will
not be closed automatically unless it is possible
to prove that the port will never again be used for read or write
operation."}

Gauche's implementation slightly misses this criteria; the mere fact
that an uncaptured error is thrown in @var{proc} does not prove
the port will never be used.  Nevertheless, it is very difficult
to think the situation that you can do meaningful operation on
the port after such an error is signalled; you'd have no idea
what kind of state the port is in.  In practical programs, you
should capture error explicitly inside @var{proc} if you still want
to do some meaningful operation with the port.

Note that if a continuation captured outside @code{call-with-input-file}
et al. is invoked inside @var{proc}, the port is not closed.
It is possible that the control returns later into the @var{proc},
if a continuation is captured in it (e.g. coroutines).
The low-level exceptions (@xref{Handling exceptions})
also doesn't ensure closing the port.


@defun open-input-fd-port fd &keyword buffering name owner?
@defunx open-output-fd-port fd &keyword buffering name owner?
Creates and returns an input or output port on top of the given
file descriptor.  @var{Buffering} specifies the buffering mode
as described in @code{open-input-file} entry above; the default
is @code{:full}.  @var{Name} is used for the created port's name
and returned by @code{port-name}.  A boolean flag @code{owner?}
specifies whether @var{fd} should be closed when the port is closed.
@end defun

@defun port-fd-dup! toport fromport
Interface to the system call @code{dup2(2)}.
Atomically closes the file descriptor associated to @var{toport},
creates a copy of the file descriptor associated to @var{fromport}, 
and sets the new file descriptor to @var{toport}.
Both @var{toport} and @var{fromport} must be file ports.
Before the original file descriptor of @var{toport} is closed,
any buffered output (when @var{toport} is an output port) is flushed,
and any buffered input (when @var{toport} is an input port) is discarded.

`Copy' means that, even the two file descriptors differ in their values,
they both point to the same system's open file table entry.  For example
they share the current file position; after @var{port-fd-dup!}, 
if you call @code{port-seek} on @var{fromport}, the change is also visible
from @var{toport}, and vice versa.  Note that this 'sharing' is in the
system-level; if either @var{toport} or @var{fromport} is buffered,
the buffered contents are not shared.

This procedure is mainly intended for programs that needs to control 
open file descriptos explicitly; e.g. a daemon process would want to redirect
its I/O to a harmless device such as @file{/dev/null}, and a shell process
would want to set up file descriptors before executing the child process.
@end defun

@node String ports, Coding-aware ports, File ports, Input and output
@subsection String ports
@c NODE 文字列ポート

String ports are the ports that you can read from or write to
memory.

@defun open-input-string string
[SRFI-6]
Creates an input string port that has the content @var{string}.
This is a more efficient way to access a string in order
rather than using @code{string-ref} with incremental index.

@example
(define p (open-input-string "foo x"))
(read p) @result{} foo
(read-char p) @result{} #\space
(read-char p) @result{} #\x
(read-char p) @result{} #<eof>
(read-char p) @result{} #<eof>
@end example
@end defun

@defun get-remaining-input-string port
@var{Port} must be an input string port.
Returns the remaining content of the input port.
The internal pointer of @var{port} isn't moved, so the
subsequent read from @var{port} isn't affected.
If @var{port} has already reached to EOF, a null string is returned.

@example
(define p (open-input-string "abc\ndef"))
(read-line p)                  @result{} "abc"
(get-remaining-input-string p) @result{} "def"
(read-char p)                  @result{} #\d
(read-line p)                  @result{} "ef"
(get-remaining-input-string p) @result{} ""
@end example
@end defun


@defun open-output-string
[SRFI-6]
Creates an output string port.   Anything written to the
port is accumulated in the buffer, and can be obtained
as a string by @code{get-output-string}.
This is a far more efficient way to construct a string
sequentially than pre-allocate a string and fill it with
@code{string-set!}.
@end defun

@defun get-output-string port
[SRFI-6]
Takes an output string port @code{port} and returns a string
that has been accumulated to @code{port} so far.
If a byte data has been written to the port, this function
re-scans the buffer to see if it can consist a complete string;
if not, an incomplete string is returned.

This doesn't affect the @var{port}'s operation, so you can keep
accumulating content to @var{port} after calling @code{get-output-string}.
@end defun

@defun call-with-input-string string proc
@defunx call-with-output-string proc
@defunx with-input-from-string string thunk
@defunx with-output-to-string thunk
These utility functions are trivially defined as follows.
The interface is parallel to the file port version.
@example
(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (call-with-input-string str proc)
  (let ((in (open-input-string str)))
    (proc in)))

(define (with-output-to-string thunk)
  (let ((out (open-output-string)))
    (with-output-to-port out thunk)
    (get-output-string out)))

(define (with-input-from-string str thunk)
  (with-input-from-port (open-input-string str) thunk))
@end example
@end defun

@defun call-with-string-io str proc
@defunx with-string-io str thunk
@example
(define (call-with-string-io str proc)
  (let ((out (open-output-string))
        (in  (open-input-string str)))
    (proc in out)
    (get-output-string out)))

(define (with-string-io str thunk)
  (with-output-to-string
    (lambda ()
      (with-input-from-string str
        thunk))))
@end example
@end defun

@defun write-to-string obj &optional writer
@defunx read-from-string string &optional start end
These convenience functions cover common idioms using string ports.
@example
(write-to-string obj writer)
  @equiv{}
  (with-output-to-string (lambda () (writer obj)))

(read-from-string string)
  @equiv{}
  (with-input-from-string string read)
@end example
The default value of @var{writer} is the procedure @code{write}.
The default values of @var{start} and @var{end} is 0 and
the length of @var{string}.

Portability note: Common Lisp has these functions, with
different optional arguments.
STk has @code{read-from-string} without optional argument.
@end defun

@node Coding-aware ports, Input, String ports, Input and output
@subsection Coding-aware ports
@c NODE コーディング認識ポート

A coding-aware port is a special type of procedural input port that
is used by @code{load} to read a program source.  The port recognizes
the magic comment to specify the character encoding of the
program source, such as @code{;; -*- coding: utf-8 -*-}, and makes
an appropriate character encoding conversion.  
See @ref{Multibyte scripts} for the details of coding magic comment.

@defun open-coding-aware-port iport
Takes an input port and returns an input coding aware port,
which basically just pass through the data from @var{iport} to
its reader.  However, if a magic comment appears within the
first two lines of data from @var{iport}, the coding aware port
applies the necessary character encoding conversion to the rest of the
data as they are read.

The passed port, @var{iport}, is "owned" by the created coding-aware
port.  That is, when the coding-aware port is closed, @var{iport} is
also closed.  The content read from @var{iport} is buffered in the
coding-aware port, so other code shouldn't read from @var{iport}.

By default, Gauche's @code{load} uses a coding aware port to read
the program source, so that the coding magic comment works for
the Gauche source programs (see @ref{Loading Scheme file}).
However, since the mechanism itself
is independent from @code{load}, you can use this port for
other purposes; it is particularly useful to write a function
that processes Scheme source programs which may have the coding
magic comment.
@end defun

@node Input, Output, Coding-aware ports, Input and output
@subsection Input 
@c NODE 入力

For the input-related procedures, the optional @var{iport} argument must be
an input port, and when omitted, the current input port is assumed.

@menu
* Reading data::                
* Read-time constructor::       
* Input utility functions::     
@end menu

@node Reading data, Read-time constructor, Input, Input
@subsubsection Reading data
@c NODE データの読み込み

@defun read &optional iport
[R5RS]
Reads an S-expression from @var{iport} and returns it.
Gauche recognizes the lexical structure specified in R5RS,
and some additional lexical structures listed in @ref{Lexical structure}.

If @var{iport} has already reached to the end of file,
an eof object is returned.

The procedure reads up to the last character that consists the S-expression,
and leaves the rest in the port.  It's not like CommonLisp's @code{read},
which consumes whitespaces after S-expression by default.
@end defun

@defun read-with-shared-structure &optional iport
@defunx read/ss &optional iport
[SRFI-38]
These procedures are defined in srfi-38 to recognize shared substructure
notation (@code{#n=}, @code{#n#}).   Gauche's builtin @code{read} recognizes
the srfi-38 notation, so these are just synonyms to @code{read}; these
are only provided for srfi-38 compatibility.
@end defun

@defun read-char &optional iport
[R5RS]
Reads one character from @var{iport} and returns it.
If @var{iport} has already 
reached to the end, returns an eof object.
If the byte stream in @var{iport} doesn't consist a valid character,
the behavior is undefined.  (In future, a port will have a option
to deal with invalid characters).
@end defun

@defun peek-char &optional iport
[R5RS]
Reads one character in @var{iport} and returns it, keeping the character
in the @var{port}.
If the byte stream in @var{iport} doesn't consist a valid character,
the behavior is undefined.  (In future, a port will have a option
to deal with invalid characters).
@end defun

@defun read-byte &optional iport
Reads one byte from an input port @var{iport}, and returns it as an integer
in the range between 0 and 255.
If @var{iport} has already reached EOF, an eof object is returned.
@end defun

@defun peek-byte &optional iport
Peeks one byte at the head of an input port @var{iport}, and returns 
it as an integer in the range between 0 and 255.
If @var{iport} has already reached EOF, an eof object is returned.
@end defun

@defun read-line &optional iport allow-byte-string?
Reads one line (a sequence of characters terminated by newline or EOF)
and returns a string.  The terminating newline is not included.
This function recognizes popular line terminators (LF only, CRLF, and CR only).
If @var{iport} has already reached EOF, an eof object is returned.

If a byte sequence is read from @var{iport}
which doesn't constitute a valid character in the native encoding,
@code{read-line} signals an error by default.  However, if a true value
is given to the argument @var{allow-byte-string?}, 
@code{read-line} returns a byte string (incomplete string) in such case,
without reporting an error.
It is particularly useful if you read from a source whose
character encoding is not yet known; for example, to read XML document,
you need to check the first line to see if there is a charset parameter
so that you can then use an appropriate character conversion port.
@end defun

@defun read-block nbytes &optional iport
Reads @var{nbytes} bytes from @var{iport}, and returns an incomplete
string consisted by those bytes.  The size of returned string may
shorter than @var{nbytes} when @var{iport} doesn't have enough bytes
to fill.  
If @var{nbytes} is zero, a null string is always returned.

If @var{iport} has already reached EOF, an eof object is returned.

If @var{iport} is a file port, the behavior of @code{read-block}
differs by the buffering mode of the port (@xref{File ports}, for
the detail explanation of buffering modes).
@itemize @bullet
@item
If the buffering mode is @code{:full}, @code{read-block} waits 
until @var{nbytes} data is read, except it reads EOF.
@item
If the buffering mode is @code{:modest} or @code{:none}, @code{read-block}
returns shorter string than @var{nbytes} even if it doesn't reach EOF,
but the entire data is not available immediately.
@end itemize

@code{Read-block} returns newly allocated string every time.
If you want to avoid allocation and read the data into a pre-allocated
fixed-length buffer, you can use @code{read-block!}
in @code{gauche.uvector} module (@xref{Uvector block I/O}).
It uses a uniform vector as the buffer.

If you want to write a chunk of bytes to a port,
you can use either @code{display} if the data is in string,
or @code{write-block} in @code{gauche.uvector} (@xref{Uvector block I/O})
if the data is in uniform vector.
@end defun

@defun eof-object
[R6RS]
Returns an EOF object.
@end defun


@defun eof-object? obj
[R5RS]
Returns true if @var{obj} is an EOF object.
@end defun

@defun char-ready? port
[R5RS]
If a character is ready to be read from @var{port}, returns @code{#t}.

For now, this procedure actually checks only if next @emph{byte} is
immediately available from @var{port}.   If the next byte is a part of
a multibyte character, the attempt to read the whole character may block,
even if @code{char-ready?} returns @code{#t} on the port.
(It is unlikely to happen in usual situation, but theoretically it can.
If you concern, use @code{read-block} to read the input as a byte
sequence, then use input string port to read characters.)
@end defun

@defun byte-ready? port
If one byte (octet) is ready to be read from @var{port}, returns
@code{#t}.
@end defun

@node Read-time constructor, Input utility functions, Reading data, Input
@subsubsection Read-time constructor
@c NODE 読み込み時コンストラクタ

Read-time constructor, defined in SRFI-10, provides an easy way
to create an external representation of user-defined structures.

@deftp {Reader Syntax} @code{#,(@var{tag} @var{arg} @dots{})}
[SRFI-10]
Gauche maintains a global table that associates a @var{tag} (symbol)
to @emph{a constructor procedure}.

When the reader encounters this syntax, it reads @var{arg} @dots{},
finds a reader constructor associated with @var{tag}, and
calls the constructor with @var{arg} @dots{} as arguments,
then inserts the value returned by the constructor as the result
of reading the syntax.

Note that this syntax is processed inside the reader---the
evaluator doesn't see any of @var{arg}s, but only sees the object
the reader returns.
@end deftp

@defun define-reader-ctor @var{tag} @var{procedure}
[SRFI-10]
Associates a reader constructor @var{procedure} with @var{tag}.

Examples:
@example
(define-reader-ctor 'pi (lambda () (* (atan 1) 4)))

#,(pi) @result{} 3.141592653589793

'(#,(pi)) @result{} (3.141592653589793)

(define-reader-ctor 'hash
  (lambda (type . pairs)
    (let ((tab (make-hash-table type)))
      (for-each (lambda (pair)
                  (hash-table-put! tab (car pair) (cdr pair)))
                pairs)
      tab)))

(define table
 #,(hash eq? (foo . bar) (duh . dah) (bum . bom)))

table @result{} #<hash-table eq? 0x80f9398>
(hash-table-get table 'duh) @result{} dah
@end example

Combined with @code{write-object} method (@xref{Output}),
it is easy to make a user-defined class written in the form
it can be read back:

@example
(define-class <point> ()
  ((x :init-value 0 :init-keyword :x)
   (y :init-value 0 :init-keyword :y)))

(define-method write-object ((p <point>) out)
  (format out "#,(<point> ~s ~s)" (ref p 'x) (ref p 'y)))

(define-reader-ctor '<point>
  (lambda (x y) (make <point> :x x :y y)))
@end example

@end defun

@emph{NOTE:} The extent of the effect of @code{define-reader-ctor}
is not specified in SRFI-10, and might pose a compatibility problem
among implementations that support SRFI-10.
(In fact, the very existence of @code{define-reader-ctor} is
up to an implementation choice.)

In Gauche, at least for the time being, @code{define-reader-ctor}
take effects as soon as the form is compiled and evaluated.  Since
Gauche compiles and evaluates each toplevel form in order, @var{tag}
specified in @code{define-reader-ctor} can be used immediately after that.
However, it doesn't work if the call of @code{define-reader-ctor} and
the use of @var{tag} is enclosed in a @code{begin} form, for the entire
@code{begin} form is compiled at once before being evaluated.

Other implementations may require to read the entire file before
making its @code{define-reader-ctor} call effective.  If so, it
effectively prevents one from using @code{define-reader-ctor} and
the defined @var{tag} in the same file.   It is desirable to separate
the call of @code{define-reader-ctor} and the use of @var{tag}
in the different files if possible.

Another issue about the current @code{define-reader-ctor} is that
it modifies the global table of Gauche system, hence it is not modular.
The code written by different people might use the same tags,
and yield an unexpected result.   In future versions, Gauche may
have some way to encapsulate the scope of @var{tag}, although
the author doesn't have clear idea yet.


@node Input utility functions,  , Read-time constructor, Input
@subsubsection Input utility functions
@c NODE 入力ユーティリティ手続き

@defun port->string port
@defunx port->list reader port
@defunx port->string-list port
@defunx port->sexp-list port
Generally useful input procedures.  The API is taken from
scsh and STk.

@code{port->string} reads @var{port}
until EOF and returns the accumulated data as a string.

@code{port->list} applies @var{reader} on @var{port} repeatedly, until
@var{reader} returns an EOF, then returns the list of objects
@var{reader} returned.

@code{(port->string-list port)} @equiv{}
@code{(port->list read-line port)}
, and
@code{(port->sexp-list port)} @equiv{}
@code{(port->list read port)}
.
@end defun

@defun port-fold fn knil reader
@defunx port-fold-right fn knil reader
@defunx port-for-each fn reader
@defunx port-map fn reader
Convenient iterators over the input read by @var{reader}.
Basically, @var{reader} is called repeatedly without arguments
and @var{fn} is called for each item it returns, until @var{reader}
returns EOF.   Actually @var{reader} can be any thunk; it doesn't
need to be related to input port.

Suppose @var{reader} returns a series of items
@{X0, X1, @dots{}, Xn@}.
@code{port-fold} returns the following:
@example
(fn Xn (fn Xn-1 @dots{} (fn X0 knil)))
@end example
while @var{port-fold-right} returns the following:
@example
(fn X0 (fn X1 @dots{} (fn Xn knil)))
@end example
That is, @code{(port-fold cons '() read)} returns a reverse
list of all the inputs, while @code{(port-fold-right cons '() read)}
returns the same thing as @code{(port->list read port)}.

On the other hand, @code{port-for-each} and @code{port-map}
applies @var{fn} to each item.  The former discards the results
@var{fn} returns, while the latter returns a list of results.
@end defun

@node Output,  , Input, Input and output
@subsection Output
@c NODE 出力

For the following procedures, the optional @var{port} argument must be
an output port, and when omitted, the current output port is assumed.

@defun write obj &optional port
@defunx display obj &optional port
[R5RS]
Produces a printable representation of an object @var{obj} to the output port.
@code{Write} uses object's standard external representation
whenever possible, so that the written output would be
read back by @code{read},
whereas @code{display} produces more human-readable output.

When @code{write} and @code{display} encounter an object of
a user-defined class, they call the generic function @code{write-object}.

These procedures may not stop when @var{obj} contains a cyclic structure.
See @code{write/ss} below.
@end defun

@defun write-with-shared-structure obj &optional port
@defunx write/ss obj &optional port
@defunx write* obj &optional port
[SRFI-38]
Produces the output like @code{write}, except that they recognize shared
substructures and/or cyclic structures, and use @code{#n=} and @code{#n#}
syntax to indicate them.

@example
(write/ss 
  (let ((x (list 'a)))
    (list x x)))
 @result{} ;; writes (#0=(a) #0#)

(write/ss 
  (let ((x (list 'a)))
    (set-cdr! x x)
    x))
 @result{} ;; writes #0=(a . #0#)
@end example

The @code{read} procedure can recognize this syntax, so when you
read it back, you can get a structure which is isomorphic to
the original one.

Three procedures are the same.
Gauche has been used the name @code{write*} for long, which is
taken from STklos.  However, @code{write-with-shared-structure}
and @code{write/ss} have been introduced in srfi-38, so these names will
be more portable.

Note: The user-defined @code{write-object} methods work 
transparently for these procedures as well.
@end defun


@defun print expr @dots{}
Displays @var{expr}s (using @code{display}) to the current output port,
then writes a newline.
@end defun

@deffn {Method} write-object (obj <object>) port
You can customize how the object is printed out by this method.
@end deffn

@defun newline &optional port
[R5RS]
Writes a newline character to @var{port}
@end defun

@defun flush &optional port
@defunx flush-all-ports
Output the buffered data in @var{port}, or all ports, respectively.

The function "flush" is called in variety of ways on the various
Scheme implementations: @code{force-output} (Scsh, SCM),
@code{flush-output} (Gambit), or @code{flush-output-port} (Bigloo).
The name @code{flush} is taken from STk and STklos.
@end defun

@defun write-char char &optional port
[R5RS]
Write a single character @var{char} to the output port @var{port}.
@end defun

@defun write-byte byte &optional port
Write a byte @var{byte} to the port.
@var{byte} must be an exact integer in range between 0 and 255.
@end defun

@defun format port string arg @dots{}
@defunx format string arg @dots{}
[SRFI-28+]
Format @var{arg} @dots{} according to @var{string}.
This function is a subset of CommonLisp's @code{format} function,
with a bit of extension.  It is also a superset of SRFi-28,
Basic format strings (@ref{srfi-28,[SRFI-28],SRFI-28}).

@var{port} specifies the destination; if it is an output port, the
formatted result is written to it; if it is @code{#t},
the result is written to the current output port;
if it is @code{#f}, the formatted result is returned as a string.
@var{Port} can be omitted, as SRFI-28 @code{format};
it has the same effects as giving @code{#f} to the @var{port}.

@var{string} is a string that contains format directives.
A format directive is a character sequence begins with tilda, `@code{~}',
and ends with some specific characters.  A format directive takes
the corresponding @var{arg} and formats it.  The rest of string is
copied to the output as is.

@example
(format #f "the answer is ~s" 42)
  @result{} "the answer is 42"
@end example

The format directive can take one or more @var{parameters}, separated
by comma characters.  A parameter may be an integer or a character;
if it is a character, it should be preceded by a quote character.
Parameter can be omitted, in such case the system default value is
used.  The interpretation of the parameters depends on the 
format directive.

Furthermore, a format directive can take two
additional flags: atmark `@code{@@}' and colon `@code{:}'.  One or
both of them may modify the behavior of the format directive.
Those flags must be placed immediately before the directive
character.

If a character `@code{v}' or `@code{V}' is in the place of the
parameter, the value of the parameter is taken from the format's
argument.  The argument must be either an integer, a character, or
@code{#f} (indicating that the parameter is effectively omitted).

Some examples:

@table @code
@item ~10,2s
A format directive @code{~s}, with two parameters, 10 and 2.
@item ~12,,,'*A
A format directive @code{~a}, with 12 for the first parameter and
a character `@code{*}' for the fourth parameter.  The second and
third parameters are omitted.
@item ~10@@d
A format directive @code{~d}, with 10 for the first parameter and
`@code{@@}' flag.
@item ~v,vx
A format directive @code{~x}, whose first and second parameter will
be taken from the arguments.
@end table

The following is a complete list of the supported format directives.
Either upper case or lower case character can be used for the format
directive; usually they have no distinction, except noted.

@table @asis
@item @b{~}@var{mincol},@var{colinc},@var{minpad},@var{padchar},@var{maxcol}@b{A}
Ascii output.  The corresponding argument is printed by @code{display}.
If an integer @var{mincol} is given, it specifies the minimum number
of characters to be output; if the formatted result is shorter than
@var{mincol}, a whitespace is padded to the right (i.e. the result
is left justified).

The @var{colinc}, @var{minpad} and @var{padchar} parameters
control, if given, further padding.  A character @var{padchar} replaces
the padding character for the whitespace.  If an integer @var{minpad}
is given and greater than 0, at least @var{minpad} padding character
is used, regardless of the resulting width.  If an integer @var{colinc}
is given, the padding character is added (after @var{minpad}) in chunk
of @var{colinc} characters, until the entire width exceeds @var{mincol}.

If atmark-flag is given, the format result is right justified, i.e.
padding is added to the left.

The @var{maxcol} parameter, if given, limits the maximum number of characters
to be written.  If the length of formatted string exceeds
@var{maxcol}, only @var{maxcol} characters are written.
If colon-flag is given as well and the length of formatted string
exceeds @var{maxcol}, @var{maxcol} - 4 characters are written and
a string ``@code{ ...}'' is attached after it.

@example
(format #f "|~a|" "oops")
  @result{} "|oops|"
(format #f "|~10a|" "oops")
  @result{} "|oops      |"
(format #f "|~10@@a|" "oops")
  @result{} "|      oops|"
(format #f "|~10,,,'*@@a|" "oops")
  @result{} "|******oops|"

(format #f "|~,,,,10a|" '(abc def ghi jkl))
  @result{} "|(abc def gh|" 
(format #f "|~,,,,10:a|" '(abc def ghi jkl))
  @result{} "|(abc de ...|" 
@end example

@item @b{~}@var{mincol},@var{colinc},@var{minpad},@var{padchar},@var{maxcol}@b{S}
S-expression output.  The corresponding argument is printed
by @code{write}.  The semantics of parameters and flags are the same
as @code{~A} directive.

@example
(format #f "|~s|" "oops")
  @result{} "|\"oops\"|"
(format #f "|~10s|" "oops")
  @result{} "|\"oops\"    |"
(format #f "|~10@@s|" "oops")
  @result{} "|    \"oops\"|"
(format #f "|~10,,,'*@@s|" "oops")
  @result{} "|****\"oops\"|"
@end example

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{D}
Decimal output.  The argument is formatted as an decimal integer.
If the argument is not an integer, all parameters are ignored 
(after processing `@code{v}' parameters) and
it is formatted by @code{~A} directive.

If an integer parameter @var{mincol} is given, it specifies minimum
width of the formatted result; if the result is shorter than it,
@var{padchar} is padded on the left (i.e. the result is right
justified).  The default of @var{padchar} is a whitespace.

@example
(format #f "|~d|" 12345)
  @result{} "|12345|"
(format #f "|~10d|" 12345)
  @result{} "|     12345|"
(format #f "|~10,'0d|" 12345)
  @result{} "|0000012345|"
@end example

If atmark-flag is given, the sign `@code{+}' is printed for the
positive argument.

If colon-flag is given, every @var{interval}-th digit of
the result is grouped and @var{commachar} is inserted between them.
The default of @var{commachar} is `@code{,}', and the default of
@var{interval} is 3.

@example
(format #f "|~:d|" 12345)
  @result{} "|12,345|"
(format #f "|~,,'_,4:d|" -12345678)
  @result{} "|-1234_5678|"
@end example

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{B}
Binary output.  The argument is formatted as a binary integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{O}
Octal output.  The argument is formatted as an octal integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{X}
@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{x}
Hexadecimal output.
The argument is formatted as a hexadecimal integer.
If `@code{X}' is used, upper case alphabets are used for
the digits larger than 10.  If `@code{x}' is used, lower case
alphabets are used.
The semantics of parameters and flags are the same as
the @code{~D} directive.

@example
(format #f "~8,'0x" 259847592)
  @result{} "0f7cf5a8"
(format #f "~8,'0X" 259847592)
  @result{} "0F7CF5A8"
@end example

@item @b{~}@var{count}@b{*}
Moves the argument counter @var{count} times forward, effectively skips
next @var{count} arguments.  The default value of @var{count} is 1,
hence skip the next argument.  If a colon-flag is given, moves the argument
counter backwards, e.g. @code{~:*} makes the next directive to process
last argument again.  If an atmark-flag is given, @var{count} specifies
absolute position of the arguments, starting from 0.
@end table

@end defun


@c ----------------------------------------------------------------------
@node Loading Programs, Comparison and sorting, Input and output, Core library
@section Loading Programs
@c NODE プログラムのロード

@menu
* Loading Scheme file::         
* Loading dynamic library::     
* Require and provide::         
* Autoload::                    
* Operations on libraries::     
@end menu

@node Loading Scheme file, Loading dynamic library, Loading Programs, Loading Programs
@subsection Loading Scheme file
@c NODE Schemeファイルのロード

@defun load file &keyword paths (error-if-not-found #t) environment ignore-coding
[R5RS+]
Loads @var{file}, that is, read Scheme expressions in @var{file} and
evaluates them.
An extension ``@code{.scm}'' may be omitted from @var{file}.

If @var{file} doesn't begin with ``/'' or ``./'' or ``../'',
it is searched from the system file search list,
stored in a variable @code{*load-path*}.
Or you can explicitly specify the search path by passing
a list of directory names to the keyword argument @var{paths}.

On success, @code{load} returns @code{#t}.
If the specified file is not found, an error is signalled unless
the keyword argument @var{error-if-not-found} is @code{#f}, in
which case @code{load} returns @code{#f}.

By default, @code{load} uses a coding-aware port 
(@xref{Coding-aware ports}) so that the "@code{coding:}" magic 
comment at the beginning of the source file is effective.
(See @ref{Multibyte scripts}, for the details of
the coding magic comment).  If a true value is given to the
keyword argument @var{ignore-coding}, @code{load} doesn't
create the coding-aware port and directly reads from the
file port.

If a module is given to the keyword argument @var{environment},
@code{load} works as if the given module is selected at the beginning
of the loaded file.

The current module is preserved; even @code{select-module} is
called in @var{file}, the module in which @code{load} is called
is restored afterwards.

If you want to load a library file, it's better to use `@code{use}'
(@xref{Defining and selecting modules}), or `@code{require}' described below.
@xref{Compilation}, for difference between @code{load} and @code{require}.
@end defun

@defvar *load-path*
Keeps a list of directories that are searched by @code{load} and
@code{require}.

If you want to add other directories to the search path,
do not modify this variable directly; use @code{add-load-path},
described below, instead.
@end defvar

@defspec add-load-path path &optional (afterp #f)
Adds a path @var{path} to the library load path list.
If a true value is given to @var{afterp}, @var{path} is added
after the existing paths; otherwise, @var{path} is added before the
existing paths.

Use this form instead of changing @code{*load-path*} directly.
This form is a special form and recognized by the compiler;
if you change @code{*load-path*}, it is in effect at run time,
and that may be too late for ``use'' or ``require''.

Furthermore,
@code{add-load-path} looks for the architecture dependent directories
under the specified path and if it exists, sets up the internal
path list for dynamic loading correctly.   Suppose you have
your Scheme module in @code{/home/yours/lib}, and that requires 
a dynamic loadable library.  You can put the library under
@code{/home/yours/lib/@var{ARCH}/}, where @var{ARCH} is
the value @code{(gauche-architecture)} returns (@xref{Environment Inquiry}).
Then you can have compiled libraries for multiple platforms and
Gauche can still find the right library.
@end defspec

@defun load-from-port port
Reads Scheme expressions from an input port @var{port} and evaluates
them, until EOF is read.

Note that unless you pass a coding-aware port to @var{port},
the "@code{coding:}" magic comment won't be handled.
@end defun

@defun current-load-port
@defunx current-load-history
@defunx current-load-next
These procedures allows you to query the current context of loading.
They returns the following values when called inside a file being loaded:
@table @code
@item current-load-port
Returns the port object from which the file is being read.
@item current-load-history
Returns a list of pairs of a port and a line number (integer),
representing the nesting of loads.  Suppose you load
@file{foo.scm}, and from its line 7 it loads @file{bar.scm}, 
and from its line 18 it loads @file{baz.scm}.   If you call
@code{current-load-history} in the file @file{baz.scm}, you'll get
@example
((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
@end example
@item current-load-next
Returns a list of remaining directories to be searched
at the time this file is found.   Suppose the @code{*load-path*}
is @code{("." "../lib" "/home/gauche/lib" "/share/gauche/lib")}
and you load @file{foo.scm}, which happens to be in @file{../lib/}.
Then, inside @file{foo.scm}, @code{current-load-next} returns:
@example
("/home/gauche/lib" "/share/gauche/lib")
@end example
@end table

When called outside of @code{load}, these procedures returns
@code{#f}, @code{()} and @code{()}, respectively.
@end defun


@node Loading dynamic library, Require and provide, Loading Scheme file, Loading Programs
@subsection Load dynamic library
@c NODE ダイナミックライブラリのロード

@defun dynamic-load file &keyword init-function export-symbols
Loads and links a dynamic loadable library (shared library) @var{file}.
@var{File} shouldn't contain the suffix (``.so'' on most systems);
@code{dynamic-load} adds it, for it may differ among platforms.

The keyword argument @var{init-function} specifies the initialization
function name of the library in a string.  By default, if the file
basename (without extension) is ``foo'', the initialization function
name is ``Scm_Init_foo''.

The keyword argument @var{export-symbols} tells whether the dynamic loader
that the external symbols in @var{file} should be appended to
the symbol table of the running process.  (Note: I'm talking about
C function and variable names, not Scheme symbols).
By default, the symbols
in @var{file} are not visible from other dynamically loaded libraries.
If you want to allow other dynamically loaded libraries to call
C function in your library, you should give @code{#t} to this 
argument.  It sets @code{RTLD_GLOBAL} flag for @code{dlopen()}.

Usually a dynamic loadable library is provided with wrapping Scheme
module, so the user doesn't have to call this function directly.

There's no way to unload the loaded libraries.
@end defun


@node Require and provide, Autoload, Loading dynamic library, Loading Programs
@subsection Require and provide
@c NODE requireとprovide

@defspec require feature
If @var{feature} is not loaded, load it.  @var{Feature} must be a string,
and it is taken as a file name (without suffix) to be loaded.
This loading takes place at compile time.   The loaded file must provide
@var{feature}; if not, a warning is issued.

If you load SLIB module, @code{require} is extended.  @xref{SLIB} for
details.
@end defspec

@defun provide feature
Adds @var{feature} to the system's provided feature list, so that
the subsequent @code{require} won't load the same file again.
Usually this procedure should be called at the end of the Scheme file
that is to be @code{require}d.   The reason that it should be at the end
of file is that if an error is raised during loading, you may want to
fix the error and @code{require} it again.
@end defun

@defun provided? feature
Returns @code{#t} if @var{feature} is already provided.
@end defun

@node Autoload, Operations on libraries, Require and provide, Loading Programs
@subsection Autoload

@defmac autoload file/module item @dots{}
Sets up @var{item} @dots{} to be autoloaded.
That is, when an @var{item} is referenced for the first time,
@var{file/module} is loaded before the @var{item} is evaluated.
This delays the loading of @var{file/module} until it is needed.

You can specify either a string file name or a symbol module name
to @var{file/module}.  If it is a string, the named file is
loaded.  If it is a symbol, the named module is loaded (using the
same rule as of @code{use}), then the binding of @var{item} in the
@var{file/module} is imported to the module used the autoload
(@xref{Defining and selecting modules}, for details of @code{use}).

@var{Item} can be either a variable name (symbol), 
or a form @code{(:macro @var{symbol})}.  If it is a variable,
the named file/module is loaded when the variable is
about to be evaluated.  If it is the latter form,
the named file/module is loaded when a form
@code{(@var{symbol} arg @dots{})} is about to be @emph{compiled},
which enables autoloading macros.

@var{file/module} must define @var{symbol} in it, or an error is signalled
when @var{file/module} is autoloaded.

The following is an example of autoloading procedures.
@example
(autoload "foo" foo0 foo1)
(autoload "bar" bar0 bar1)

(define (foobar x)
  (if (list? x)
      (map bar0 x)
      (foo0)))

(foobar '(1 2)) ; @r{"bar" is loaded at this moment}

(foobar #f)     ; @r{"foo" is loaded at this moment}
@end example

Note that if you set to autoload macro, the file/module is loaded
immediately when such form that uses the macro is compiled,
regardless of the piece of
the code is executed or not.
@end defmac

@node Operations on libraries,  , Autoload, Loading Programs
@subsection Operations on libraries
@c NODE ライブラリの操作

There are several procedures you can use to check if
certain libraries and/or modules are installed in the system.

In the following descriptions, @var{pattern} is either a
symbol or a string.  If it is a symbol, it specifies
a module name (e.g. @code{foo.bar}).  If it is 
a string, it specifies a partial pathname of the library
(e.g. @code{"foo/bar"}), which will be searched under
library search paths.
You can also use glob-like metacharacters '@code{*}' and 
'@code{?}' in @var{pattern}.

@defun library-fold pattern proc seed &keyword paths strict? allow-duplicates?
A basic iterator for library/module files.
This procedure searches Scheme program files which matches
@var{pattern}, under directories listed in @var{paths} 
(the default is the standard file load paths, @code{*load-path*}).
For each matched file, it calls @var{proc} with three arguments:
the matched module or library name, the full path of the program
file, and the state value.  @var{Seed} is used as the initial
state value, and the value @var{proc} returns is used as the state
value for the next call of @var{proc}.  The value returned from
the last @var{proc} becomes the return value of @code{library-fold}.



If @var{pattern} is a symbol and the keyword argument @var{strict?}
is @code{#t} (which is the default), this procedure calls
@code{library-has-module?} on the files whose name seems to
match the given pattern of module name, in order to find out
the file really implements the module.  It can be a time consuming
process if you try to match large number of modules; you can pass
@code{#f} to @var{strict?} to avoid the extra check.
If @var{pattern} is a string, matching is done only for file names
so @var{strict?} is ignored.

By default, if there are more than one files that have the same name
that matches @var{pattern} in @var{paths}, only the first
one appears in @var{paths} is taken.  This gives you
the file you'll get if you use @code{require} or @code{use}
for that library.  If you want to iterate all of matching files,
pass @code{#t} to the @var{allow-duplicates?} keyword argument.

Here are some examples (the result may differ in your environment).
@example
(library-fold 'srfi-1 acons '())
 @result{} ((srfi-1 . "../lib/srfi-1.scm"))

(library-fold "srfi-1" acons '())
 @result{} (("srfi-1" . "../lib/srfi-1.scm"))

;; Note the returned list is in a reverse order of
;; how @code{acons} is called.
(library-fold 'srfi-1 acons '() :allow-duplicates? #t)
 @result{} ((srfi-1 . "/usr/share/gauche/0.7.1/lib/srfi-1.scm")
   (srfi-1 . "../lib/srfi-1.scm"))

;; In the following cases, the module name doesn't match,
;; but the filename does.
(library-fold 'srfi-19.* acons '())
 @result{} ()

(library-fold "srfi-19/*" acons '())
 @result{} (("srfi-19/read-tai" . "../lib/srfi-19/read-tai.scm")
   ("srfi-19/format" . "../lib/srfi-19/format.scm"))

;; Finds available dbm implementations
(library-fold 'dbm.* acons '())
 @result{} ((dbm.cdb . "/usr/share/gauche/0.7.1/lib/dbm/cdb.scm")
   (dbm.gdbm . "../lib/dbm/gdbm.scm")
   (dbm.ndbm . "../lib/dbm/ndbm.scm")
   (dbm.odbm . "../lib/dbm/odbm.scm"))
@end example
@end defun

@defun library-map pattern proc &keyword paths allow-duplicates? strict?
@defunx library-for-each pattern proc &keyword paths allow-duplicates? strict?
@code{Map} and @code{for-each} version of iterator over matched
libraries/modules.  See @code{library-fold} above for detailed
operation of matching and the meanings of keyword arguments.

@var{Proc} receives two arguments, the matched module/library name
and full path of the file.  @code{Library-map} returns a list
of results of @var{proc}.  @code{Library-for-each} discards
the results.

@example
(library-map 'srfi-4 list :allow-duplicates? #t)
 @result{} ((srfi-4 "../lib/srfi-4.scm")
            (srfi-4 "/usr/share/gauche/0.7.1/lib/srfi-4.scm"))

(library-map 'dbm.* (lambda (m p) m))
 @result{} (dbm.odbm dbm.ndbm dbm.gdbm dbm.cdb)
@end example
@end defun

@defun library-exists? mod/path &keyword paths force-search? strict?
Search a library or a module specified by @var{mod/path}, 
and returns a true value if it finds one.  @var{Paths} and @var{strict?}
keyword arguments have the same meaning as @code{library-fold}.

Unlike the iterator procedures above, this procedure first
checks loaded libraries and modules in the calling process,
and returns true if it finds @var{mod/path} in it,
without looking into the filesystem.   Passing @code{#t} to
@var{force-search?} keyword arguments skips the checking of
loaded libraries and modules.
@end defun


@defun library-has-module? path module
Returns @code{#t} iff a file specified by @var{path} exists and 
appears to implement a module named by @code{module}.  @var{path} must be
an actual filename.

@example
(library-has-module? "./test/foo/bar.scm" 'foo.bar)
 @result{} #t ;; @r{if ./test/foo/bar.scm implements module foo.bar}.
@end example

This procedure assumes a typical layout of the source code
to determine if the given file implements the module, i.e.,
it reads the first form of the code and see if it is a
@code{define-module} form that is defining the given module.
@end defun

@c ----------------------------------------------------------------------
@node Comparison and sorting, System interface, Loading Programs, Core library
@section Comparison and sorting
@c NODE 比較とソート

@defun compare obj1 obj2
A general comparison procedure.  Returns -1 if @var{obj1} is less than
@var{obj2}, 0 if @var{obj1} is equal to @var{obj2}, and 1 if @var{obj1}
is greater than @var{obj2}.  Signals an error if @var{obj1} and @var{obj2}
are incomparable.

Some built-in types are handled by this procedure reflecting ``natural''
order of comparison.  Other built-in types are generally
uncomparable.  For Scheme-defined classes, this procedure calls
a generic function @code{object-compare}.
@end defun

@deffn {Generic Function} object-compare obj1 obj2
Specializing this generic function extends @code{compare} procedure
for user-defined classes.
@end deffn

@defun sort seq &optional cmpfn
@defunx sort! seq &optional cmpfn
Sorts elements in a sequence @var{seq} (a list or a vector) 
in ascending order and returns the sorted sequence.
@code{sort!} destructively reuses the original sequence.
The sorting order is specified by @code{cmpfn}, which is
a procedure takes two elements of @var{seq}, and returns @code{#t}
if the first argument strictly precedes the second.

Note that it is not guaranteed that, after @code{sort!},
@var{seq} points to a sorted sequence.
if @var{seq} is a list, the first pair of the original
@var{seq} may no longer be the first in the sorted sequence.
Always use the returned value of @code{sort!}.

@example
(sort '(("Chopin" "Frederic") 
        ("Liszt" "Franz")
        ("Alkan" "Charles-Valentin"))
      (lambda (x y) (string<? (car x) (car y))))
  @result{} (("Alkan" "Charles-Valentin")
      ("Chopin" "Frederic")
      ("Liszt" "Franz"))
@end example

When @var{cmpfn} is omitted, the @code{compare} procedure
is used to determine which element is @emph{less}.

In the current implementation, quicksort and heapsort
algorithm is used when @var{cmpfn} is omitted,
and merge sort algorithm is used when @var{cmpfn} is given.
This might be changed later.

If you want to keep a sorted set of objects to which you
add objects one at at time, you can also use treemaps
(@xref{Treemaps}).
@end defun

@defun stable-sort seq &optional cmpfn
@defunx stable-sort! seq &optional cmpfn
Sort a sequence @var{seq} (a list or a vector), using stable sort algorithm
(currently they are using merge sort).  
The sorting order is specified by @code{cmpfn}, which is
a procedure takes two elements of @var{list}, and returns @code{#t}
if the first argument strictly precedes the second.
@end defun

@defun sort-by seq key &optional cmpfn
@defunx sort-by! seq key &optional cmpfn
@defunx stable-sort-by seq key &optional cmpfn
@defunx stable-sort-by! seq key &optional cmpfn
Sorts @var{seq}, by comparing the key values obtained by
applying the @var{key} procedure to each element of @var{seq}.
The code @code{(stable-sort-by seq key cmp)} returns the same result
as the following code:

@example
(stable-sort seq (lambda (a b) (cmp (key a) (key b))))
@end example

Besides more compact notation, @code{sort-by} family procedures
guarantee that @var{key} procedure is called at most the number
of elements in @var{seq}.  In the above example using @code{stable-sort},
@var{key} may be called @var{n}log@var{n} or even more times
where @var{n} is the number of elements in @var{seq}.
So @code{sort-by} etc. are good if the @var{key} procedure is
a relatively heavy operation.

The trade-off is the space; @code{sort-by} family consumes
extra space to save all the key values, which is proportional
to the number of elements.
@end defun


@c ----------------------------------------------------------------------
@node System interface, Development helper API, Comparison and sorting, Core library
@section System interface
@c NODE システムインタフェース

Gauche supports most of POSIX.1 functions and other system functions
popular among Unix variants as built-in procedures.

Lots of Scheme implementations provide some sort of system interface
under various APIs.  Some are just called by different names
(e.g, @code{delete-file} or @code{remove-file} or @code{unlink} to delete
a file), some do more abstraction introducing new Scheme objects.
Instead of just picking one of such interfaces, I decided to implement
Gauche's system interface API in two layers; the lower level layer,
described in this section, follows the operating system's API
as close as possible.  On top of that, the higher-level APIs are
provided, with considering compatibility to the existing systems.

The low level system interface has the name @code{sys-}@var{name}
and usually correspond to the system call @var{name}.
I tried to keep the interface similar whenever reasonable.

Gauche restarts a system call after it is interrupted by a signal.
See @ref{Signal} for the details.

If you are familiar with system programming in C,
see also @ref{C to Scheme mapping}, which shows
correspondence between C standard library functions
and Gauche procedures.

@menu
* Program termination::         
* Environment Inquiry::         
* Filesystems::                 
* Unix groups and users::       
* Locale::                      
* Signal::                      
* System inquiry::              
* Time::                        
* Unix process management::     
* I/O multiplexing::            
* Miscellaneous system calls::  
@end menu

@node Program termination, Environment Inquiry, System interface, System interface
@subsection Program termination
@c NODE プログラムの終了

Gauche has a few ways to terminate itself (other than returning
from @code{main}).  The @code{exit} procedure is a graceful way
with all proper cleanups.  @code{sys-exit} and @code{sys-abort}
may be used in emergency where proper cleanup is impossible.


@defun exit &optional (code 0) (fmtstr #f) args @dots{}
[POSIX]
Terminates the current process with the exit code @var{code}.
@var{Code} must be zero or positive exact integer.
When a string is given to @var{fmtstr}, it is passed to
@code{format} (@xref{Output}), with the rest arguments @var{args},
to produce a message to the standard error port
(@emph{not} the current error port; see @ref{Common port operations}).

In fact, the exitting procedure is a bit more complicated.
The precise steps of exitting is as follow.

@enumerate 
@item
The value of parameter @code{exit-handler} is checked.  
If it is not @code{#f}, the value is called as a procedure
with three arguments: @var{code}, @var{fmtstr}, and a list of rest
arguments.  It is the default procedure of @code{exit-handler}
that prints out the message to the standard error port.
If an error occurs within exit handler, it is captured and
discarded.  Other exceptions are not caught.

@item
The @var{after} thunks of the active dynamic winds are invoked.
Any exceptions raised in @var{after} thunks are captured and discarded.

@item
The clean-up handlers registered via C API @code{Scm_AddCleanupHandler}
are invoked.  These are usually responsible for under-the-hood cleanup
jobs for each application that embeds Gauche.  From the Scheme world 
there's not much to care.

@item
The unclosed output buffered ports are flushed.

@item
The process exits with @var{code} as an exit code, via @code{exit(3)}.
@end enumerate

The @code{exit-handler} mechanism allows the application to hook its
exit operation.   Note that it is not for simple cleanup jobs; 
@code{dynamic-wind}, @code{guard} or @code{unwind-protect} are more appropriate.   
@code{exit-handler} is for more specific use just upon application exit.
For example, GUI applications may want to post a dialog
instead of printing to stderr.

For this reason, the library code shouldn't change @code{exit-handler};
only the application knows what to do when it exits.

Another useful case is when you
want to call a third-party code which calls @code{exit} inside.  In
that case you may swap the @code{exit-handler} for the one
that raises a non-error exception while calling the third-party code.
Non-error exception isn't caught in @code{exit}, effectivelly
interrupts the steps explained above.   (Yet the @var{after} thunks
of dynamic handlers are processed just like normal exception 
handling case.)
Your appication code can then capture the exception.
You can use @code{parameterize}
to swap @code{exit-handler} dynamically
and thread-safely (@xref{Parameters}).

@example
(guard (e [(eq? e 'exit-called) (handle-exit-as-desired)])
  (parameterize ((exit-handler (lambda (c f a) (raise 'exit-called))))
    (call-third-party-library)))
@end example

Generally, calling @code{exit} while other threads are running
should be avoided, since it only rewinds the dynamic handlers active
in the calling threads, and other threads will be killed abruptly.
If you have to do so for some reason,
you may be able to use @code{exit-handler} to tell to other threads
that the application is exitting.  (There's no general way, and
Gauche doesn't even have a list of all running threads; it's application's
responsibility).

Note on design: Some languages integrates exit handling
into exception handling, treating exit as a kind of exception.
It is a tempting idea, so much that we've tried it.  It didn't
work out well in Gauche; a big annoyance was that when 
an @var{after} thunk raised an exception during
rewinding @code{dynamic-wind}s, it shadowed the original
@emph{exit} exception.
@end defun

@defun exit-handler &optional new-handler
When called without argument, returns the value of the current exit
handler.  When called with an argument, sets @var{new-handler} as the
value of the exit handler, and returns the previous value of the
exit handler.    @var{new-handler} must be a procedure that takes
three arguments, or @code{#f}.

The value of exit handler is thread-specific, and the default value
is inherited from the value of the current exit handler of the parent
thread.  @code{exit-handler} can be used as if it's a parameter
in the @code{parameterize} macro (@xref{Parameters}).
@end defun



@defun sys-exit code
[POSIX]
Terminates the current process with the exit code @var{code}.
@var{Code} must be zero or positive exact integer.
This procedure calls @code{_exit(2)} directly.
No cleanup is done.  Unflushed file output is discarded.
@end defun

@defun sys-abort
[POSIX]
Calls POSIX abort().  This usually terminates the running process 
and dumps core.  No cleanup is done.
@end defun

@node Environment Inquiry, Filesystems, Program termination, System interface
@subsection Environment Inquiry
@c NODE 環境の問い合わせ

@defun sys-getenv name
[POSIX]
Returns the value of the environment variable @var{name} as a string,
or @code{#f} if the environment variable is not defined.
@end defun

@defun sys-environ
Returns the current environment as a list of strings.  Each string
is a form of @code{NAME=VALUE}, where @code{NAME} is the name of
the environment variable and @code{VALUE} is its value.  @code{NAME}
never contains a character @code{#\=}.  This is useful when you want
to obtail the all enviroment variables of the current process.
Use @code{sys-getenv} if you want to query a specific environment
variable.
@end defun

@defun sys-environ->alist &optional envlist
A convenience procedure for @code{sys-environ}.  When the list of
environment strings (like what @code{sys-environ} returns) is given
to @var{envlist}, this procedure splits name and value of
each environment variable and returns an assoc list.

When @var{envlist} is omitted, this procedure calls @code{sys-environ}
to get the current environment variables.

@example
(sys-environ->alist '("A=B" "C=D=E"))
  => (("A" . "B") ("C" . "D=E"))
@end example
@end defun


@defun sys-putenv name value
Add environment variable @var{name} with @var{value} to the current
process's environment.  If the system doesn't support putenv(3),
this function signals an error.
@end defun

@defun gauche-version
@defunx gauche-architecture
@defunx gauche-library-directory
@defunx gauche-architecture-directory
@defunx gauche-site-library-directory
@defunx gauche-site-architecture-directory
These functions returns a string that tells information about Gauche
interpreter itself.
@end defun

@node Filesystems, Unix groups and users, Environment Inquiry, System interface
@subsection Filesystems
@c NODE ファイルシステム

System calls that deal with filesystems.
See also @ref{Filesystem utilities}, which defines high-level APIs
on top of the procedures described here.

@menu
* Directories::                 
* Directory manipulation::      
* Pathnames::                   
* File stats::                  
* Other file operations::       
@end menu

@node Directories, Directory manipulation, Filesystems, Filesystems
@subsubsection Directories
@c NODE ディレクトリ

See also @ref{Directory utilities} for high-level API.

@defun sys-readdir path
@var{path} must be a string that denotes valid pathname of an existing
directory.  This function returns a list of strings of the directory
entries.  The returned list is not sorted.  An error is signalled
if @var{path} doesn't exists or is not a directory.
@end defun

@defun glob pattern &keyword separator folder
@defunx sys-glob pattern &keyword separator folder
Provides a traditional Unix glob(3) functionality;
returns a list of pathnames that matches the given @var{pattern}.

This feature used to be a wrapper of system-provided @code{glob} function,
hence it was named @code{sys-glob}.  However, as of Gauche version 0.8.12,
it was reimplemented in Scheme on top of other system calls, to overcome
incompatibilies between platforms and for the opportunity to put
more functionalities.  So we renamed it @code{glob}.
The old name @code{sys-glob} is kept for compatibility, but new
programs should use @code{glob}.

The @var{pattern} argument may be a single @emph{glob pattern}, or
a list of glob patterns.  If a list is given, pathnames that matches
any one of the pattern are returned.  If you're a unix user,
you already know how it works.

@example
gosh> (glob "*.scm")
("test.scm" "ext.scm")
gosh> (glob "src/*.[ch]")
("src/ext.c" "src/ext.h")
gosh> (glob '("*.scm" "src/*.c"))
("src/ext.c" "test.scm" "ext.scm")
@end example

Unlike shell's glob, if there's no matching pathnames, @code{()} is returned.

In fact, globbing is a very useful tool to search hierarchical
data structure in general, not limited to the filesystems.
So the @code{glob} function is implemented separately from
the filesystem.  Using keyword arguments,
you can glob from any kind of tree data structure.
It is just that their default values are set to look at
the filesystems.

The @var{separator} argument should be a char-set, and used
to split the @var{pattern} into components.  Its default is
@code{#[/]}.  It is not used to the actual pathnames to match.

The @var{folder} is a procedure that walks through the data
structure.  It is called with five arguments:

@example
(folder @var{proc} @var{seed} @var{parent} @var{regexp} @var{non-leaf?})
@end example

@var{proc} is a procedure that takes two arguments.  The @var{folder}
should call @var{proc} with every node in the @var{parent} whose
component name matches @var{regexp}, passing around the seed value
just like @code{fold}.  It should return the final value returned
by @var{proc}.  For example, if @code{cons} is given to @var{proc}
and @code{()} is given to @var{seed}, the return value of the folder
is a list of nodes that matches the @var{regexp}.

The representation of a node is up to the implementation of
@var{folder}.  It can be a
pathname, or some sort of objects, or anything.  The @code{glob}
procedure does not care what it is; the @code{glob} procedure
merely passes the node to subsequent call to @code{folder} as
@var{parent} argument, or returns a list of nodes as the result.

The @var{parent} argument is basically a node, and
@var{folder} traverses its children to find the match.
The exception is the initial call of @var{folder}---
at the beginning @code{glob} knows nothing about each node.
When @code{glob} needs to match an absolute path, it
passes @code{#t}, and when @code{glob} needs to match a relative path,
it passes @code{#f}, as the initial @var{parent} value.

The @var{regexp} argument is used to filter the child nodes.
It should be matched against the component name of the child,
not including its directory names.  As a special case, it can
be a symbol @code{dir}; if that's the case, the folder should
return @var{node} itself, but it may indicate @var{node}
@emph{as a directory}; e.g. if @var{node} is represented as a pathname,
the folder returns a pathname with trailing directory separator.
As special cases,
if @var{node} is a boolean value and @var{regexp} is @code{dir},
the folder should return the node representing root node or
current node, respectively; e.g. if @var{node} is represented
as a pathname, the folder may return @code{"/"} and @code{"./"}
for those cases.

The @var{non-leaf} argument is a boolean flag.  If it is true,
the filter should omit the leaf nodes from the result (e.g. only
include the directories).

Now, here's the precise spec of glob pattern matching.

Each glob pattern is a string to match pathname-like strings.

A pathname-like string is a string consists of one or more
@emph{components}, separated by @emph{separator}s.
The default separator is @code{#[/]}; you can change it
with @var{separator} keyword argument.
A component cannot contain separators, and cannot
be a null string.  Consecutive separators are
regarded as a single separator.  A pathname-like
string optionally begins with, and/or ends with a separator character.

A glob pattern is also consists of components and separator
characters.  In a component, following characters/syntax have special
meanings.

@table @code
@item *
When it appears at the beginning of a component, it matches
zero or more characters except a period (@code{.}).  And it
won't match if the component of the input string begins with 
a period.

Otherwise, it matches zero or more sequence of any characters.

@item **
If a component is just @code{**}, it matches zero or more
number of components that match @code{*}.  For example, @code{src/**/*.h}
matches all of the following patterns.
@example
src/*.h
src/*/*.h
src/*/*/*.h
src/*/*/*/*.h
...
@end example

@item ?
When it appears at the beginning of a component, it matches
a character except a period (@code{.}).  Othewrise, it matches
any single character.

@item [@i{chars}]
Specifies a character set.  Matches any one of the set.
The syntax of @i{chars} is the same as Gauche's character set
syntax (@xref{Character set}).  For the compatibility of the
traditional glob, the @code{!} character can be used to complement
the character set, e.g. @code{[!abc]} is the same as @code{[^abc]}.
@end table
@end defun

@defun glob-fold pattern proc seed &keyword separator folder
This is actually a low-level construct of the glob function.
Actually, @var{glob} is simply written like this:
@example
(define (glob patterns . opts)
  (apply glob-fold patterns cons '() opts))
@end example

The meaning of @var{pattern}, @var{separator} and @var{folder}
is the same as explained above.  

For each pathname that matches @var{pattern}, @code{glob-fold}
calls @var{proc} with the pathname and a seed value.  The initial
seed value is @var{seed}, and the value @var{proc} returns becomes
the next seed value.  The result of the last call to @var{proc} 
becomes the result of @code{glob-fold}.  If there's no matching
pathnames, @var{proc} is never called and @var{seed} is returned.
@end defun

@defun make-glob-fs-fold &keyword root-path current-path
This is a utility function to generate a procedure suitable to
pass the @var{folder} keyword argument of @code{glob-fold} and @code{glob}.
Without arguments, this returns the same procedure which is used
in @code{glob-fold} and @code{glob} by default.

The keyword arguments @var{root-path} and @var{current-path} specify
the paths where @code{glob-fold} starts to search.

@example
gosh> (glob "/tmp/*.scm")
("/tmp/x.scm" "/tmp/y.scm")
gosh> (glob "/*.scm" 
            :folder (make-glob-fs-fold :root-path "/tmp"))
("/tmp/x.scm" "/tmp/y.scm")
gosh> (glob "*.scm" 
            :folder (make-glob-fs-fold :current-path "/tmp"))
("/tmp/x.scm" "/tmp/y.scm")
@end example
@end defun

@xref{File stats}, to check if a path is actually a directory.

@node Directory manipulation, Pathnames, Directories, Filesystems
@subsubsection Directory manipulation
@c NODE ディレクトリ操作

@defun sys-remove filename
[POSIX] 
If @var{filename} is a file it is removed.
On some systems this may also work on an empty directory,
but portable scripts shouldn't depend on it.
@end defun

@defun sys-rename old new
[POSIX]
Renames a file @var{old} to @var{new}.  The new name
can be in different directory from the old name, but both paths
must be on the same device.
@end defun

@defun sys-tmpnam
[POSIX]
Creates a file name which is supposedly unique, and returns it.
This is in POSIX, but its use is discouraged because of potential
security risk.  Use @code{sys-mkstemp} below if possible.
@end defun

@defun sys-mkstemp template
Creates and opens a file that has unique name, and returns two values;
opened port and the created filename.  The file is created exclusively,
avoiding race conditions.   @var{tmpname} is used as the prefix
of the file.  Unlike Unix's mkstemp, you don't need padding characters.
The file is opened for writing, and its permission is set to 600.
@end defun

@defun sys-link existing new
[POSIX] 
Creates a hard link named @var{new} to the existing file @var{existing}.
@end defun

@defun sys-unlink pathname
[POSIX]
Removes @var{pathname}.  It can't be a directory.
Returns @code{#t} if it is successfully removed, or
@var{#f} if @var{pathname} doesn't exist.
An error is signalled otherwise.
@end defun

@defun sys-symlink existing new
Creates a symbolic link named @var{new} to the pathname @var{existing}.
On systems that doesn't support symbolic links,
this function is unbound.
@end defun

@defun sys-readlink path
If a file specified by @var{path} is a symbolic link, its content is
returned.  If @var{path} doesn't exist or is not a symbolic link, an
error is signalled.
On systems that don't support symbolic links,
this function is unbound.
@end defun

@defun sys-mkdir pathname mode
[POSIX] 
Makes a directory @var{pathname} with mode @var{mode}.
(Note that @var{mode} is masked by the current umask;
see @code{sys-umask} below).
The parent directory of @var{pathname} must exist and be writable
by the process.  To create intermediate directories at once, use
@code{make-directory*} in @code{file.util} (@ref{Directory utilities}).
@end defun

@defun sys-rmdir pathname
[POSIX]
Removes a directory @var{pathname}.  The directory must be empty.
To remove a directory with its contents, use @code{remove-directory*}
in @code{file.util} (@ref{Directory utilities}).
@end defun

@defun sys-umask &optional mode
[POSIX] 
Sets umask setting to @var{mode}.  Returns previous umask setting.
If @var{mode} is omitted or @code{#f}, just returns the current umask without
changing it.
See @code{man umask} for more details.
@end defun

@node Pathnames, File stats, Directory manipulation, Filesystems
@subsubsection Pathnames
@c NODE パス名

See also @ref{Pathname utilities}, for high-level APIs.

@defun sys-normalize-pathname pathname &keyword absolute expand canonicalize
Converts @var{pathname} according to the way specified by keyword arguments.
More than one keyword argument can be specified.
@table @code
@item absolute
  If this keyword argument is given and true, and @var{pathname} is not
  an absolute pathname, it is converted to an absolute pathname by
  appending the current working directory in front of @var{pathname}.
@item expand
  If this keyword argument is given and true, and @var{pathname} begins
  with `@code{~}', it is expanded as follows:
@itemize @bullet
@item
    If @var{pathname} is consisted entirely by ``@code{~}'', or begins
    with ``@code{~/}'', then the character ``@code{~}'' is replaced
    for the pathname of the current user's home directory.
@item
    Otherwise, characters following `@code{~}' until either `@code{/}' or
    the end of @var{pathname} are taken as a user name, and the user's
    home directory is replaced in place of it.  If there's no such
    user, an error is signalled.
@end itemize
@item canonicalize
  Tries to remove pathname components ``@code{.}'' and ``@code{..}''.
  The pathname interpretation is done purely in textural level, i.e.
  it doesn't access filesystem to see the conversion reflects the
  real files.  It may be a problem if there's a symbolic links to
  other directory in the path.
@end table
@end defun

@defun sys-basename pathname
@defunx sys-dirname pathname
@code{sys-basename} returns a basename, that is the last component of
@var{pathname}.  @code{sys-dirname} returns the components of @var{pathname}
but the last one.   If @var{pathname} has a trailing `@code{/}', 
it is simply ignored.
@example
(sys-basename "foo/bar/bar.z") @result{} "bar.z"
(sys-basename "coo.scm") @result{} "coo.scm"
(sys-basename "x/y/") @result{} "y"
(sys-dirname "foo/bar/bar.z") @result{} "foo/bar"
(sys-dirname "coo.scm") @result{} "."
(sys-dirname "x/y/") @result{} "x"
@end example
These functions doesn't check if @var{pathname} really exists.

Some boundary cases:
@example
(sys-basename "") @result{} ""
(sys-dirname "") @result{} "."

(sys-basename "/") @result{} ""
(sys-dirname "/") @result{} "/"
@end example
Note: The above behavior is the same as Perl's @code{basename} and
@code{dirname}.   On some implementations, the command @code{basename}
may return @code{"/"} for the argument @code{"/"}, and
@code{"."} for the argument @code{"."}.
@end defun

@defun sys-realpath pathname
@code{sys-realpath} returns an absolute pathname of @var{pathname}
that does not include ``@code{.}'', ``@code{..}'' or symbolic links.
If the system does not support realpath(3), this function signals an
error.
@end defun

@node File stats, Other file operations, Pathnames, Filesystems
@subsubsection File stats
@c NODE ファイルの状態

See also @ref{File attribute utilities}, for high-level APIs.

@defun file-exists? path
@defunx file-is-regular? path
@defunx file-is-directory? path
Returns true if @var{path} exists, is a regular file, or is a directory,
respectively.   The latter two returns false if @var{path} doesn't
exist at all.

These functions are built on top of primitive
system interfaces described below; I provide these for convenience
and compatibility (STk has the same functions).
@end defun

@deftp {Builtin Class} <sys-stat>
@clindex sys-stat
An object that represents @code{struct stat}, attributes of an
entry in the filesystem.   It has the following read-only slots.

@defivar <sys-stat> type
A symbol represents the type of the file.
@multitable {aaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item @code{regular} @tab a regular file
@item @code{directory} @tab a directory
@item @code{character} @tab a character device
@item @code{block} @tab a block device
@item @code{fifo} @tab a fifo
@item @code{symlink} @tab a symbolic link
@item @code{socket} @tab a socket
@end multitable
If the file type is none of the above, @code{#f} is returned.

Note: Some operating systems don't have the @code{socket} file type
and returns @code{fifo} for socket files.   Portable programs should
check both possibilities to see if the given file is a socket.
@end defivar

@defivar <sys-stat> perm
An exact integer for permission bits of @code{struct stat}.
It is the same as lower 9-bits of "mode" slot; provided for the convenience.
@end defivar

@defivar <sys-stat> mode
@defivarx <sys-stat> ino
@defivarx <sys-stat> dev
@defivarx <sys-stat> rdev
@defivarx <sys-stat> nlink
@defivarx <sys-stat> uid
@defivarx <sys-stat> gid
@defivarx <sys-stat> size
An exact integer for those information of @code{struct stat}.
@end defivar

@defivar <sys-stat> atime
@defivarx <sys-stat> mtime
@defivarx <sys-stat> ctime
A number of seconds since Unix Epoch for those information of @code{struct stat}.
@end defivar
@end deftp

@defun sys-stat path
@defunx sys-fstat port-or-fd
[POSIX]
Returns a @code{<sys-stat>} object of @var{path}, or
the underlying file of @var{port-or-fd}, which 
may be a port or a positive exact integer file descriptor, respectively.

If @var{path} is a symbolic link, a stat of the file the link points
to is returned from @code{sys-stat}.

If @var{port-or-fd} is not associated to a file, @code{sys-fstat} returns
@code{#f}.
@end defun

@defun sys-lstat path
Like @code{sys-stat}, but it returns a stat of a symbolic link
if @var{path} is a symbolic link.
@end defun

@example
gosh> (describe (sys-stat "gauche.h"))
#<<sys-stat> 0x815af70> is an instance of class <sys-stat>
slots:
  type      : regular
  perm      : 420
  mode      : 33188
  ino       : 845140
  dev       : 774
  rdev      : 0
  nlink     : 1
  uid       : 400
  gid       : 100
  size      : 79549
  atime     : 1020155914
  mtime     : 1020152005
  ctime     : 1020152005
@end example

@defun sys-stat->mode stat
@defunx sys-stat->ino stat
@defunx sys-stat->dev stat
@defunx sys-stat->rdev stat
@defunx sys-stat->nlink stat
@defunx sys-stat->size stat
@defunx sys-stat->uid stat
@defunx sys-stat->gid stat
@defunx sys-stat->atime stat
@defunx sys-stat->mtime stat
@defunx sys-stat->ctime stat
@defunx sys-stat->file-type stat
@strong{Deprecated}.
Use @code{slot-ref} to access information of @code{<sys-stat>} object.
@end defun

@defun sys-access pathname amode
[POSIX]
Returns a boolean value of indicating whether access of @var{pathname}
is allowed in @var{amode}.   This procedure signals an error
if used in a suid/sgid program (see the note below).
@var{amode} can be a combinations (logical or) of
following predefined flags.
@table @code
@item R_OK
@vindex R_OK
Checks whether @var{pathname} is readable by the current user.
@item W_OK
@vindex W_OK
Checks whether @var{pathname} is writable by the current user.
@item X_OK
@vindex X_OK
Checks whether @var{pathname} is executable (or searchable in case
@var{pathname} is a directory) by the current user.
@item F_OK
@vindex F_OK
Checks whether @var{pathname} exists or not, regardless of
the access permissions of @var{pathname}.  (But you need to have
access permissions of the directories containing @var{pathname}).
@end table

@emph{Note:} Access(2) is known to be a security hole if used
in suid/sgid program to check the real user's priviledge of
accessing the file.
@end defun

@defun sys-chmod path mode
@defunx sys-fchmod port-or-fd mode
Change the mode of the file named @var{path} or an opened
file specified by @var{port-or-fd} to @var{mode}.
@var{mode} must be a small positive integer whose lower 9 bits
specifies POSIX style permission.
@end defun

@defun sys-chown path owner-id group-id
Change the owner and/or group of the file named @var{path}
to @var{owner-id} and @var{group-id} respectively.
@var{owner-id} and @var{group-id} must be an exact integer.
If either of them is -1, the corresponding ownership is not changed.
@end defun

@defun sys-utime path &optional atime mtime
Change the file's access time and modification time to @var{atime}
and @var{mtime}, respectively.   If @var{atime} and @var{mtime} is
omitted, they are set to the current time.
See also @code{touch-file} (@xref{File operations}).
@end defun

@node Other file operations,  , File stats, Filesystems
@subsubsection Other file operations
@c NODE 他のファイル操作

@defun sys-chdir dir
[POSIX]
An interface to @code{chdir(2)}. 
See also @code{current-directory} (@xref{Directory utilities}).
@end defun

@defun sys-pipe &keyword (buffering :line)
[POSIX] Creates a pipe, and returns two ports.
The first returned port is an input port and the second is an output port.
The data put to the output port can be read from the input port.

@var{Buffering} can be @code{:full}, @code{:line} or @code{:none}, 
and specifies the buffering mode of the ports opened on the pipe.
@xref{File ports}, for details of the buffering mode.
The default mode is sufficient for typical cases.

@example
(receive (in out) (sys-pipe)
  (display "abc\n" out)
  (flush out)
  (read-line in)) @result{} "abc"
@end example

Note: the returned value is changed from version 0.3.15, in which
@code{sys-pipe} returned a list of two ports.
@end defun

@defun sys-mkfifo path mode
[POSIX] creates a fifo (named pipe) with a name @var{path} and mode
@var{mode}.  @var{Mode} must be a positive exact integer to represent
the file mode.
@end defun

@defun sys-isatty port-or-fd
[POSIX] @var{port-or-fd} may be a port or an integer file descriptor.
Returns @code{#t} if the port is connected to the console, @code{#f}
otherwise.
@end defun

@defun sys-ttyname port-or-fd
[POSIX] @var{port-or-fd} may be a port or an integer file descriptor.
Returns the name of the terminal connected to the port,
or @code{#f} if the port is not connected to a terminal.
@end defun

@defun sys-truncate path length
@defunx sys-ftruncate port-or-fd length
[POSIX]
Truncates a regular file named by @var{path} or referenced by @var{port-or-fd}
to a size of @var{length} bytes.
If the file is larger than @var{length} bytes, the extra data is discarded.
If the file is smaller than that, zero is padded.
@end defun

@node Unix groups and users, Locale, Filesystems, System interface
@subsection Unix groups and users
@c NODE Unixのグループとユーザ

@subsubheading Unix groups

@deftp {Builtin Class} <sys-group>
@clindex sys-group
Unix group information.  Has following slots.

@defivar <sys-group> name
Group name.
@end defivar

@defivar <sys-group> gid
Group id.
@end defivar

@defivar <sys-group> passwd
Group password.
@end defivar

@defivar <sys-group> mem
List of user names who are in this group.
@end defivar

@end deftp

@defun sys-getgrgid gid
@defunx sys-getgrnam name
[POSIX]
Returns @code{<sys-group>} object from an integer group id @var{gid}
or a group name @var{name}, respectively.
If the specified group doesn't exist, @code{#f} is returned.
@end defun

@defun sys-gid->group-name gid
@defunx sys-group-name->gid name
Convenience function to convert between group id and group name.
@end defun

@subsubheading Unix users

@deftp {Builtin Class} <sys-passwd>
@clindex sys-passwd
Unix user information.  Has following slots.

@defivar <sys-passwd> name
User name.
@end defivar

@defivar <sys-passwd> uid
User ID.
@end defivar

@defivar <sys-passwd> gid
User's primary group id.
@end defivar

@defivar <sys-passwd> passwd
User's (encrypted) password.  If the system uses the shadow password file,
you just get obscure string like "x".
@end defivar

@defivar <sys-passwd> gecos
Gecos field.
@end defivar

@defivar <sys-passwd> dir
User's home directory.
@end defivar

@defivar <sys-passwd> shell
User's login shell.
@end defivar

@defivar <sys-passwd> class
User's class (only available on some systems).
@end defivar

@end deftp

@defun sys-getpwuid uid
@defunx sys-getpwnam name
[POSIX]
Returns @code{<sys-passwd>} object from an integer user id @var{uid}
or a user name @var{name}, respectively.
If the specified user doesn't exist, @code{#f} is returned.
@end defun

@defun sys-uid->user-name uid
@defunx sys-user-name->uid name
Convenience functions to convert between user id and user name.
@end defun


@subsubheading Password encryption

@defun sys-crypt key salt
This is the interface to @code{crypt(3)}.   @var{Key} and @var{salt}
must be a string, and an encrypted string is returned.
On systems where @code{crypt(3)} is not available, call to this
function signals an error.
@end defun

@node Locale, Signal, Unix groups and users, System interface
@subsection Locale
@c NODE ロケール

@defun sys-setlocale category locale
[POSIX]
Sets the locale of the category @var{category} to the locale @var{locale}.
@var{category} must be an exact integer; the following pre-defined
variables are available.  @var{locale} must be a string locale name.
Returns the locale name on success, or @code{#f} if the system
couldn't change the locale.
@end defun

@defvar  LC_ALL
@defvarx LC_COLLATE
@defvarx LC_CTYPE
@defvarx LC_MONETARY
@defvarx LC_NUMERIC
@defvarx LC_TIME
Predefined variables for possible @var{category} value of
@code{sys-setlocale}.
@end defvar

@defun sys-localeconv
[POSIX]
Returns an assoc list of various information for formatting numbers
in the current locale.
@end defun

An example session.  It may differ on your system settings.
@example
(sys-localeconv)
 @result{}
   ((decimal_point . ".") (thousands_sep . "")
    (grouping . "") (int_curr_symbol . "")
    (currency_symbol . "") (mon_decimal_point . "")
    (mon_thousands_sep . "") (mon_grouping . "")
    (positive_sign . "") (negative_sign . "")
    (int_frac_digits . 127) (frac_digits . 127)
    (p_cs_precedes . #t) (p_sep_by_space . #t)
    (n_cs_precedes . #t) (n_sep_by_space . #t)
    (p_sign_posn . 127) (n_sign_posn . 127))

(sys-setlocale LC_ALL "fr_FR")
 @result{} "fr_FR"

(sys-localeconv)
 @result{}
  ((decimal_point . ",") (thousands_sep . "")
   (grouping . "") (int_curr_symbol . "FRF ")
   (currency_symbol . "F") (mon_decimal_point . ",")
   (mon_thousands_sep . " ") (mon_grouping . "\x03\x03")
   (positive_sign . "") (negative_sign . "-")
   (int_frac_digits . 2) (frac_digits . 2)
   (p_cs_precedes . #f) (p_sep_by_space . #t)
   (n_cs_precedes . #f) (n_sep_by_space . #t)
   (p_sign_posn . 1) (n_sign_posn . 1))
@end example

@node Signal, System inquiry, Locale, System interface
@subsection Signal
@c NODE  シグナル

Gauche can send out operating system's signals to the other processes
(including itself) and can handle the incoming signals.

In multithread environment, all threads share the signal
handlers, and each thread has its own signal mask.
See @ref{Signals and threads}, for details.

When a system call is interrupted by a signal,
and a programmer defines a handler for the signal that doesn't transfer
control to other context, the system call is restarted after
the handler returns.  

@menu
* Signals and signal sets::     
* Sending signals::             
* Handling signals::            
* Masking and waiting signals::  
* Signals and threads::         
@end menu

@node Signals and signal sets, Sending signals, Signal, Signal
@subsubsection Signals and signal sets
@c NODE シグナルとシグナルセット

Each signal is referred by its signal number (a small integer)
defined on the underlying operating system.
Variables are pre-defined to the system's signal number.
System's signal numbers may be architecture dependent, so you should
use those variables rather than using literal integers.

@defvar  SIGABRT
@defvarx SIGALRM
@defvarx SIGCHLD
@defvarx SIGCONT
@defvarx SIGFPE
@defvarx SIGHUP
@defvarx SIGILL
@defvarx SIGINT
@defvarx SIGKILL
@defvarx SIGPIPE
@defvarx SIGQUIT
@defvarx SIGSEGV
@defvarx SIGSTOP
@defvarx SIGTERM
@defvarx SIGTSTP
@defvarx SIGTTIN
@defvarx SIGTTOU
@defvarx SIGUSR1
@defvarx SIGUSR2
These variables are bound to the signal numbers of POSIX signals.
@end defvar

@defvar  SIGTRAP
@defvarx SIGIOT
@defvarx SIGBUS
@defvarx SIGSTKFLT
@defvarx SIGURG
@defvarx SIGXCPU
@defvarx SIGXFSZ
@defvarx SIGVTALRM
@defvarx SIGPROF
@defvarx SIGWINCH
@defvarx SIGPOLL
@defvarx SIGIO
@defvarx SIGPWR
These variables are bound to the signal numbers of system-dependent
signals.  Not all of them may be defined on some systems.
@end defvar

Besides each signal numbers, you can refer to a set of signals
using a @code{<sys-sigset>} object.
It can be used to manipulate the signal mask, and to install a signal
handler to a set of signals at once.

@deftp {Class} <sys-sigset>
@clindex sys-sigset
A set of signals.   An empty sigset can be created by
@example
(make <sys-sigset>) @result{} #<sys-sigset []>
@end example
@end deftp

@defun sys-sigset signal @dots{}
Creates and returns an instance of @code{<sys-sigset>}
with members @var{signal} @dots{}.  Each @var{signal} 
may be either a signal number, another @code{<sys-sigset>}
object, or @code{#t} for all available signals.

@example
(sys-sigset SIGHUP SIGINT) @result{} #<sys-sigset [HUP|INT]>
@end example
@end defun

@defun sys-sigset-add! sigset signal @dots{}
@defunx sys-sigset-delete! sigset signal @dots{}
@var{Sigset} must be a @code{<sys-sigset>} object.
Those procedures adds and removes the specified signals from
@var{sigset} respectively, and returns the result.  @var{sigset} itself
is also modified.

@var{signal} may be either a signal number, another @code{<sys-sigset>}
object, or @code{#t} for all available signals.
@end defun

@defun sys-sigset-fill! sigset
@defunx sys-sigset-empty! sigset
Fills @var{sigset} by all available signals, or empties @var{sigset}.
@end defun

@defun sys-signal-name signal
Returns the human-readable name of the given signal number.
(Note that signal numbers are system-dependent.)

@example
(sys-signal-name 2) @result{} "SIGINT"
@end example
@end defun

@node Sending signals, Handling signals, Signals and signal sets, Signal
@subsubsection Sending signals
@c NODE シグナルの送出

To send a signal, you can use @code{sys-kill} which works like
@code{kill(2)}.

@defun sys-kill pid sig
[POSIX]
Sends a signal @var{sig} to the specified process(es).  @var{Sig}
must be a positive exact integer.  @var{pid} is an exact integer and
specifies the target process(es):
@itemize @bullet
@item
If @var{pid} is positive, it is the target process id.
@item
If @var{pid} is zero, the signal is sent to every process in the process
group of the current process.
@item
If @var{pid} is less than -1, the signal is sent to every process in
the process group @var{-pid}.
@end itemize
@end defun

There's no Scheme equivalence for @code{raise()}, but you can use
@code{(sys-kill (sys-getpid) @var{sig})}.

@node Handling signals, Masking and waiting signals, Sending signals, Signal
@subsubsection Handling signals
@c NODE シグナルの処理

You can register signal handling procedures in Scheme.
(In multithread environment, signal handlers are shared by all
threads; see @ref{Signals and threads} for details).

When a signal is delivered to the Scheme process, the VM just records it
and processes it later at a 'safe point' where the state of VM is consistent.
We call the signal is @emph{pending} when it is registered by the VM
but not processed yet.

(Note that this makes handling of some signals such as @code{SIGILL}
useless, for the process can't continue sensible execution after
recording the signal).

If the same signal is delivered more than once before VM processes
the first one, the second one and later have no effect.  (This is consistent
to the traditioncal Unix signal model.)  In other words,
for each VM loop a signal handler can be invoked at most once per
each signal.

When too many signals of the same kind are pending, 
Gauche assumes something has
gone wrong (e.g. infinite loop inside C-routine) and aborts the
process.  The default of this limit is set rather low (3), to allow
unresponsive interactive script to be terminated by typing Ctrl-C
three times.  Note that the counter is individual for each signal;
Gauche won't abort if one @code{SIGHUP} and two @code{SIGINT}s are
pending, for example.  You can change this limit by 
@code{set-signal-pending-limit} described below.

When you're using the @code{gosh} interpreter, the default
behavior for each signal is as in the following table.

@table @code
@item SIGABRT, SIGILL, SIGKILL, SIGCONT, SIGSTOP, SIGSEGV, SIGBUS
Cannot be handled in Scheme.  @code{Gosh} follows the system's
default behavior.
@item SIGCHLD, SIGTSTP, SIGTTIN, SIGTTOU, SIGWINCH
No signal handles are installed for these signals by @code{gosh},
       so the process follows the system's default behavior.
       Scheme programs can install its own signal handler if necessary.
@item SIGHUP, SIGQUIT, SIGTERM
@code{Gosh} installs a signal handler for these signals
       that exits from the application with code 0.
@item SIGPWR, SIGXCPU, SIGUSR1, SIGUSR2
On Linux platforms with thread support, these signals are used
       by the system and not available for Scheme.  On other systems,
       these signals behaves the same as described below.
@item other signals
@code{Gosh} installs the default signal handler, which raises
@code{<unhandled-signal-error>} condition (see @ref{Conditions}).
Scheme programs can override it by its own signal handler.
@end table

If you're using Gauche embedded in some other application,
it may redefine the default behavior.

Use the following procedures to get/set signal handlers from Scheme.

@defun set-signal-handler! signals handler &optional sigmask
@var{Signals} may be a single signal number or a @code{<sys-sigset>}
object, and @var{handler} should be either @code{#t}, @code{#f}
or a procedure that takes one argument.
If @var{handler} is a procedure, it will be called when the process
receives one of specified signal(s), with the received signal
number as an argument.

By default, the signals in @var{signals} are blocked
(in addition to the signal mask in effect at that time) during
@var{handler} is executed, so that @var{handler} won't be
reentered by the same signal(s).  You can provide 
a @code{<sys-sigset>} object to the @var{sigmask} arg
to specify the signals to be blocked explicitly.
Note that the signal mask
is per-thread; if more than one thread unblocks a signal, the handler
may still be invoked during execution of the handler (in other thread)
even if you specify @var{sigmask}.  You have to set the threads'
signal mask properly to avoid such situation.

It is safe to do anything in @var{handler}, including throwing
an error or invoking continuation captured elsewhere.  (However,
continuations captured inside @var{handler} will be invalid
once you return from @var{handler}).

If @var{handler} is @code{#t}, the operating system's default 
behavior is set to the specified signal(s).  If @var{handler}
is @code{#f}, the specified signals(s) will be ignored.

Note that signal handler setting is shared among threads in
multithread enviornment.  The handler is called from the thread
which is received the signal.  See @ref{Signals and threads}
for details.
@end defun

@defun get-signal-handler signum
@defunx get-signal-handler-mask signum
Returns the handler setting, or signal mask setting, of a signal @var{signum},
respectively.
@end defun

@defun get-signal-handlers
Returns an associative list of all signal handler settings.
Car of each element of returned list is a @code{<sys-sigset>} object,
and cdr of it is the handler (a procedure or a boolean value)
of the signals in the set.
@end defun

@defun get-signal-pending-limit
@defunx set-signal-pending-limit limit
Gets/sets the maximum number of pending signals per each signal type.
If the number of pending signals exceeds this limit, Gauche aborts
the process.  See the explanation at the beginning of this section
for the details.  @var{Limit} must be a nonnegative exact integer.
In the current implementaiton the maximum number of @var{limit} is 255.
Setting limit to zero makes the number of pending signals unlimited.
@end defun


@defmac with-signal-handlers (handler-clause @dots{}) thunk
A convenience macro to install signal handlers temporarily
during execution of @var{thunk}.
(Note: though this is convenient, this has certain dangerous
properties described below.  Use with caution.)

Each @var{Handler-clause} may be one of the following forms.
@table @code
@item (@var{signals} @var{expr} @dots{})
@var{Signals} must be an expression that will yield either a signal,
a list of signals, or a @code{<sys-sigset>} object.
Installs a signal handler for @var{signals} that evaluates
@var{expr} @dots{} when one of the signals in @var{signals} is delivered.

@item (@var{signals} => @var{handler})
This form sets the handler of @var{signals} to @var{handler},
where @var{handler} should be either @code{#t}, @code{#f}
or a procedure that takes one argument.

If @var{handler} is a procedure, it will be called when the process
receives one of specified signal(s), with the received signal
number as an argument.
If @var{handler} is @code{#t}, the operating system's default 
behavior is set to the specified signal(s).  If @var{handler}
is @code{#f}, the specified signals(s) will be ignored.
@end table

When the control exits from @var{thunk}, the signal handler setting
before @code{with-signal-handlers} are recovered.

@emph{CAVEAT:} If you're setting more than one signal handlers,
they are installed in serial.  If a signal is delivered before
all the handlers are installed, the signal handler state may be
left inconsistent.  Also note that the handler setting is a global state;
you can't set "thread local" handler by @code{with-signal-handlers},
although the form may be misleading.
@end defmac

@node Masking and waiting signals, Signals and threads, Handling signals, Signal
@subsubsection Masking and waiting signals
@c NODE シグナルのマスクと待機

A Scheme program can set a signal mask, which is a set of signals
to be blocked from delivery.   If a signal is delivered
which is completely blocked in the process, the signal becomes
"pending".  The pending signal may be delivered once the signal
mask is changed not to block the specified signal.
(However, it depends on the operating system whether the pending
signals are queued or not.)

In multithread environment, each thread has its own signal mask.

@defun sys-sigmask how mask
Modifies the current thread's signal mask, and returns the previous
signal mask.   @var{Mask} should be a @code{<sys-sigset>} object
to specify the new mask, or @code{#f} if you just want to query
the current mask without modifying one.

If you give @code{<sys-sigset>} object to @var{mask},
@var{how} argument should be one of the following
integer constants:
@table @code
@item SIG_SETMASK
Sets @var{mask} as the thread's signal mask.
@item SIG_BLOCK
Adds signals in @var{mask} to the thread's signal mask.
@item SIG_UNBLOCK
Removes signals in @var{mask} from the thread's signal mask.
@end table
@end defun

@defun sys-sigsuspend mask
Atomically sets thread's signal mask to @var{mask} and
suspends the calling thread.  When a signal that is not blocked
and has a signal handler installed is delivered, the associated
handler is called, then @code{sys-sigsuspend} returns.
@end defun

@defun sys-sigwait mask
[POSIX]
@var{Mask} must be a @code{<sys-sigset>} object.
If any of signals in @var{mask} is/are pending in the OS,
atomically clears one of them and returns the signal number
of the cleared one.   If there's no signal in @var{mask}
pending, @code{sys-sigwait} blocks until any of the signals
in @var{mask} arrives.

You have to block all signals in @var{mask} in all threads
before calling @code{sys-sigwait}.  If there's a thread
that doesn't block the signals, the behavior of 
@code{sys-sigwait} is undefined.

Note: @code{Sys-sigwait} uses system's @code{sigwait} function,
whose behavior is not defined if there's a signal
handler on the signals it waits.  To avoid complication,
@code{sys-sigwait} resets the handlers set to the signals
included in @var{mask} before calling @code{sigwait} to @code{SIG_DFL},
and restores them after @code{sigwait} returns.  If another thread
changes signal handlers while @code{sys-sigwait} is waiting,
the behavior is undefined; you shouldn't do that.
@end defun

@node Signals and threads,  , Masking and waiting signals, Signal
@subsubsection Signals and threads
@c NODE シグナルとスレッド

The semantics of signals looks a bit complicated in the multithread
environment.   Nevertheless, it is pretty comprehensible once
you remember a small number of rules.  Besides,
Gauche sets up the default behavior easy to use,
while allowing programmers to do tricky stuff.

If you don't want to be bothered by the details, just remember
one thing, with one sidenote.
@strong{By default}, signals are handled by the
primordial (main) thread.  However, if the main thread
is suspended on mutex or condition variable,
the signal may not be handled at all, so be careful.

Now, if you are curious about the details, here are the rules:
@itemize @bullet
@item
The signal handler setting is shared by all threads.
@item
The signal mask is thread-specific.
@item
If a process receives an asynchronous signal (think it as a signal
delivered from other processes), one thread is chosen, out of
threads which don't block that signal.
@item
The signal handler is run on the chosen thread.
However, if the chosen thread is waiting for acquiring a mutex lock
or a condition variable, the handling of signal will be delayed
until the thread is restarted.   Signal delivery itself doesn't
restart the thread.
@end itemize

Now, these rules have several implications.

If there are more than one thread that don't block a particular
signal, you can't know which thread receives the signal.
Such a situation is much less useful in Gauche than C programs
because of the fact that the signal handling can be delayed indefinitely
if the receiver thread is waiting on mutex or condition variable.
So, it is recommended to make sure, for each signal, there is only one
thread that can receive it.

In Gauche, all threads created by @code{make-thread}
(@xref{Thread procedures}) blocks all the signals by default
(except the reserved ones).   This lets all the signals
to be directed to the primordial (main) thread.

Another strategy is to create a thread dedicated for handling
signals.  To do so, you have to block the signals in the
primordial thread, then create the signal-handling thread,
and within that thread you unblock all the signals.
Such a thread can just loop on @code{sys-pause}.

@example
(thread-start!
  (make-thread
    (lambda ()
      (sys-sigmask SIG_SETMASK (make <sys-sigset>)) ;;empty mask
      (let loop () (sys-pause) (loop)))))
@end example

Complicated application may want to control per-thread signal
handling precisely.   You can do so, just make sure that
at any moment only the designated thread unblocks the desired
signal.

@node System inquiry, Time, Signal, System interface
@subsection System inquiry
@c NODE システムへの問い合わせ

@defun sys-uname
[POSIX] Returns a list of five elements,
@code{(@var{sysname} @var{nodename} @var{release} @var{version} @var{machine})}.
@end defun

@defun sys-gethostname
Returns the host name.  If the system doesn't have gethostname(),
the second element of the list returned by @code{sys-uname} is used.
@end defun

@defun sys-getdomainname
Returns the domain name.  If the system doesn't have getdomainname(),
@code{"localdomain"} is returned.
@end defun

@defun sys-getcwd
[POSIX] Returns the current working directory by a string.
If the current working directory couldn't be obtained from the system,
an error is signalled.   See also @code{sys-chdir}
 (@xref{Other file operations}), @code{current-directory}
(@xref{Directory utilities}).
@end defun

@defun sys-getgid
@defunx sys-getegid
[POSIX] Returns integer value of real and effective group id of the
current process, respectively.
Use @code{sys-gid->group-name} or @code{sys-getgrgid} to obtain 
the group's name and other information associated to the returned
group id (@xref{Unix groups and users}).
@end defun

@defun sys-setgid gid
[POSIX] Sets the effective group id of the current process.
@end defun

@defun sys-getuid
@defunx sys-geteuid
[POSIX] Returns integer value of real and effective user id of the
current process, respectively.
Use @code{sys-uid->user-name} or @code{sys-getpwuid} to obtain 
the user's name and other information associated to the returned
user id (@xref{Unix groups and users}).
@end defun

@defun sys-setuid uid
[POSIX] Sets the effective user id of the current process.
@end defun

@defun sys-getgroups
[POSIX] Returns a list of integer ids of supplementary groups.
@end defun

@defun sys-getlogin
[POSIX] Returns a string of the name of the user logged in on the
controlling terminal of the current process.
If the system can't determine the information, @code{#f} is returned.
@end defun

@defun sys-getpgrp
[POSIX] Returns a process group id of the current process.
@end defun

@c @defun sys-setpgrp
@c Sets the process group id of the current process to the current
@c process id.   Equivalent to @code{sys-setpgid(0, 0)}.
@c @end defun

@defun sys-getpgid pid
Returns a process group id of the process specified by @var{pid}.
If @var{pid} is zero, the current process is used.

Note that @code{getpgid()} call is not in POSIX.  If the system
doesn't have @var{getpgid()}, @var{sys-getpgid} still works if
@var{pid} is zero (it just calls @code{sys-getpgrp}), but signals
an error if @var{pid} is not zero.
@end defun

@defun sys-setpgid pid pgid
[POSIX] Sets the process group id of the process @var{pid} to @var{pgid}.
If @var{pid} is zero, the process ID of the
current process is used.  If @var{pgid} is zero, the process ID
of the process specified by @code{pid} is used.  (Hence
@code{sys-setpgid(0, 0)} sets the process group id of the
current process to the current process id).
@end defun

@defun sys-setsid
[POSIX] Creates a new session if the calling process is
not a process group leader.
@end defun

@defun sys-getpid
@defunx sys-getppid
[POSIX] Returns the current process id and the parent process id,
respectively.
@end defun

@defun sys-times
[POSIX]
@end defun

@defun sys-ctermid
[POSIX]  Returns the name of the controlling terminal of the process.
This may be just a @code{"/dev/tty"}.   See also @code{sys-ttyname}.
@end defun

@defun sys-getrlimit resource
@defunx sys-setrlimit resource current &optional maximum
[POSIX] Get and set resource limits respectively.
@var{Resource} is an integer constant to specify the resource
of concern.  The following constants are defined.
(The constants marked as bsd and/or linux indicates that they
are not defined in POSIX but defined in BSD and/or Linux.
Other systems may or may not have them.  Consult @code{getrlimit}
manpage of your system for the details.)

@example
RLIMIT_AS                      RLIMIT_CORE
RLIMIT_CPU                     RLIMIT_DATA
RLIMIT_FSIZE                   RLIMIT_LOCKS
RLIMIT_MEMLOCK (bsd/linux)     RLIMIT_MSGQUEUE (linux)
RLIMIT_NICE (linux)            RLIMIT_NOFILE
RLIMIT_NPROC (bsd/linux)       RLIMIT_RSS (bsd/linux)
RLIMIT_RTPRIO (linux)          RLIMIT_SIGPENDING (linux)
RLIMIT_SBSIZE                  RLIMIT_STACK
RLIMIT_OFILE
@end example
@end defun


@defun sys-strerror errno
@var{Errno} must be an exact nonnegative integer representing
a system error number.  This function returns a string describing
the error.

To represent @var{errno}, the following constants are defined.
Each constant is bound to an exact integer representing the system's
error number.  Note that the actual value may differ among systems,
and some of these constants may not be defined on some systems.

@example
E2BIG             EHOSTDOWN         ENETDOWN          ENXIO
EACCES            EHOSTUNREACH      ENETRESET         EOPNOTSUPP
EADDRINUSE        EIDRM             ENETUNREACH       EOVERFLOW
EADDRNOTAVAIL     EILSEQ            ENFILE            EPERM
EADV              EINPROGRESS       ENOANO            EPFNOSUPPORT
EAFNOSUPPORT      EINTR             ENOBUFS           EPIPE
EAGAIN            EINVAL            ENOCSI            EPROTO
EALREADY          EIO               ENODATA           EPROTONOSUPPORT
EBADE             EISCONN           ENODEV            EPROTOTYPE
EBADF             EISDIR            ENOENT            ERANGE
EBADFD            EISNAM            ENOEXEC           EREMCHG
EBADMSG           EKEYEXPIRED       ENOKEY            EREMOTE
EBADR             EKEYREJECTED      ENOLCK            EREMOTEIO
EBADRQC           EKEYREVOKED       ENOLINK           ERESTART
EBADSLT           EL2HLT            ENOMEDIUM         EROFS
EBFONT            EL2NSYNC          ENOMEM            ESHUTDOWN
EBUSY             EL3HLT            ENOMSG            ESOCKTNOSUPPORT
ECANCELED         EL3RST            ENONET            ESPIPE
ECHILD            ELIBACC           ENOPKG            ESRCH
ECHRNG            ELIBBAD           ENOPROTOOPT       ESRMNT
ECOMM             ELIBEXEC          ENOSPC            ESTALE
ECONNABORTED      ELIBMAX           ENOSR             ESTRPIPE
ECONNREFUSED      ELIBSCN           ENOSTR            ETIME
ECONNRESET        ELNRNG            ENOSYS            ETIMEDOUT
EDEADLK           ELOOP             ENOTBLK           ETOOMANYREFS
EDEADLOCK         EMEDIUMTYPE       ENOTCONN          ETXTBSY
EDESTADDRREQ      EMFILE            ENOTDIR           EUCLEAN
EDOM              EMLINK            ENOTEMPTY         EUNATCH
EDOTDOT           EMSGSIZE          ENOTNAM           EUSERS
EDQUOT            EMULTIHOP         ENOTSOCK          EWOULDBLOCK
EEXIST            ENAMETOOLONG      ENOTTY            EXDEV
EFAULT            ENAVAIL           ENOTUNIQ          EXFULL
EFBIG
@end example
@end defun

@node Time, Unix process management, System inquiry, System interface
@subsection Time
@c NODE 時間

Gauche has two representations of time, one is compatible to POSIX API,
and the other is compatible to SRFI-18, SRFI-19 and SRFI-21.
Most procedures accept both representations; if not, the representation
the procedure accepts is indicated as either 'POSIX time' or 'SRFI time'.

POSIX time is represented by a real number which is a number of seconds
since Unix Epoch (Jan 1, 1970, 0:00:00GMT).
Procedure @code{sys-time}, which corresponds to POSIX @code{time(2)},
returns this time representation.

SRFI-compatible time is represented by an object of @code{<time>} class,
which keeps seconds and nanoseconds, as well as the type of the time
(UTC, TAI, duration, process time, etc).
@code{Current-time} returns this representation.

@subsubheading POSIX time

@defun sys-time
[POSIX] Returns the current time in POSIX time
(the time since Epoch (00:00:00 UTC, January 1, 1970),
measured in seconds).  It may be a non-integral number, depending on
the architecture.

Note that POSIX's definition of ``seconds since the Epoch'' doesn't
take leap seconds into account.
@end defun

@defun sys-gettimeofday
Returns two values.  The first value is a number of seconds,
and the second value is a fraction in a number of microseconds,
since 1970/1/1 0:00:00 UTC.   If the system doesn't have
@code{gettimeofday} call, this function calls @code{time()};
in that case, microseconds portion is always zero.
@end defun

@deftp {Builtin Class} <sys-tm>
@clindex sys-tm
Represents @code{struct tm}, a calendar date.  It has the following slots.
@defivar <sys-tm> sec
Seconds. 0-61.
@end defivar
@defivar <sys-tm> min
Minutes. 0-59.
@end defivar
@defivar <sys-tm> hour
Hours.  0-23.
@end defivar
@defivar <sys-tm> mday
Day of the month, counting from 1.  1-31.
@end defivar
@defivar <sys-tm> mon
Month, counting from 0.  0-11.
@end defivar
@defivar <sys-tm> year
Years since 1900, e.g. 102 for the year 2002.
@end defivar
@defivar <sys-tm> wday
Day of the week.  Sunday = 0 .. Saturday = 6.
@end defivar
@defivar <sys-tm> yday
Day of the year.  January 1 = 0 .. December 31 = 364 or 365.
@end defivar
@defivar <sys-tm> isdst
A flag that indicates if the daylight saving time is in effect.
Positive if DST is in effect, zero if not, or negative if unknown.
@end defivar
@end deftp

@defun sys-gmtime time
@defunx sys-localtime time
[POSIX] Converts @var{time} to @code{<sys-tm>} object, represented in GMT
or local timezone, respectively.   @var{Time} can be either POSIX-time or
SRFI-time.
@end defun

@defun sys-ctime time
[POSIX] Converts @var{time} to it string representation, using POSIX ctime().
@var{Time} can be either POSIX-time or SRFI-time.
@end defun

@defun sys-difftime time1 time0
[POSIX] Returns the difference of two times in the real number of seconds.
@var{Time0} and @var{time1} can be either POSIX-time or SRFI-time.
@end defun

@defun sys-asctime tm
[POSIX] Converts @code{<sys-tm>} object @var{tm} to a string representation.
@end defun

@defun sys-strftime format tm
[POSIX] Converts @code{<sys-tm>} object @var{tm} to a string representation,
according to a format string @var{format}.
@end defun

@defun sys-mktime tm
[POSIX] Converts @code{<sys-tm>} object @var{tm}, expressed as local time,
to the POSIX-time (number of seconds since Epoch).
@end defun

@defun sys-tm->alist tm
(Deprecated function)
@end defun


@subsubheading SRFI time

@deftp {Builtin Class} <time>
The @code{<time>} object also represents a point of time.

@clindex time
@defivar <time> type
Indicates time type.  @code{time-utc} is the default, and that
represents the number of seconds since Unix Epoch.
SRFI-19 (@xref{Time data types and procedures}) adds more types.
@end defivar
@defivar <time> second
Second part of the time.
@end defivar
@defivar <time> nanosecond
Nanosecond part of the time.
@end defivar
@end deftp

@defun current-time
[SRFI-18][SRFI-21]
Returns the @code{<time>} object representing the current time in
@code{time-utc}.   @xref{Time data types and procedures}, for
it redefines @code{current-time} to allow optional argument to
specify time type.
@end defun

@defun time? obj
[SRFI-18][SRFI-19][SRFI-21]
Returns @code{#t} if @var{obj} is a time object.
@end defun

@defun time->seconds time
@defunx seconds->time seconds
[SRFI-18][SRFI-21]
Converts between time object and the number of seconds (POSIX-time).
@var{Time} argument of @code{time->seconds} has to be a @code{<time>} object.
@end defun


@node Unix process management, I/O multiplexing, Time, System interface
@subsection Unix process management
@c NODE Unixのプロセス管理

The following procedures provide pretty raw, direct interface
to the system calls.
See also @ref{High Level Process Interface}, which provides
more convenient process handling on top of these primitives.

@subsubheading Fork and exec

@defun sys-system command
[POSIX]
Runs @var{command} in a subprocess.   @var{command} is usually passed
to @code{sh}, so the shell metacharacters are interpreted.

This function returns an integer value @code{system()} returned.
Since POSIX doesn't define what @code{system()} returns, you can't
interpret the returned value in a portable way.
@end defun

@defun sys-fork
[POSIX]
Fork the current process.  Returns 0 if you're in the child process,
and a child process' pid if you're in the parent process.
All the opened file descriptors are shared between the parent and
the child.  See @code{fork(2)} of your system for details.

If the child process runs some Scheme code and exits instead of
calling @code{sys-exec}, it should call @code{sys-exit} 
instead of @code{exit} to terminate itself.
Normal exit call tries to flush the file
buffers, and on some OS it messes up the parent's file buffers.

It should be noted that @code{sys-fork} is not safe when 
multiple threads are running.  Because @code{fork(2)} copies
the process' memory image which includes any mutex state,
a mutex which is locked by another thread at the time of @code{sys-fork}
remains locked in the child process, nevertheless the child process
doesn't have the thread that unlock it!
(This applies to the internal mutexes as well, so even you don't
use Scheme mutex explicitly, this situation can always happen.)

If what you want is to spawn another program in a multi-threaded application,
use @code{sys-fork-and-exec} explained below.
If you absolutely need to run Scheme code in the
child process, a typical technique is that you fork a manager process
at the beginning of application, and whenever you need a new process
you ask the manager process to fork one for you.
@end defun

@defun sys-exec command args &keyword iomap sigmask
[POSIX+]
Execute @var{command} with @var{args}, a list of arguments.
The current process image is replaced by @var{command},
so this function never returns.

All elements of @var{args} must be strings.  The first element of
@var{args} is used as @code{argv[0]}, i.e. the program name.

The @var{iomap} keyword argument, when provided, specifies how the
open file descriptors are treated.  It must be the following format:
@example
((@i{to-fd} . @i{from-port-or-fd}) @dots{})
@end example
@i{To-fd} must be an integer,
and @i{from-port-or-fd} must be an integer file descriptor or a port.
Each element of the list makes the file descriptor of @i{from-port-or-fd}
of the current process be mapped to the file descriptor @i{to-fd}
in the executed process.

If @var{iomap} is provided,
any file descriptors other than specified in the iomap list will be closed
before @code{exec()}.  Otherwise, all file descriptors in the current
process remain open.

@example
(sys-exec "ls" '("ls" "-l")) @result{} ;; ls is executed.

(let ((out (open-output-file "ls.out")))
  (sys-exec "ls" '("ls" "-l") :iomap `((2 . 1) (1 . ,out)))
   @result{}
  ;; ls is executed, with its stderr redirected
  ;; to the current process's stdout, and its
  ;; stdout redirected to the file "ls.out".
@end example

The @var{sigmask} keyword argument can be an instance of @code{<sys-sigset>}
or @code{#f} (@xref{Signal}, for the details of signal masks).
If it is an instance of @code{<sys-sigset>}, the signal mask of calling
thread is replaced by it just before @code{exec(2)} is called.
It is useful, for example, to run an external program from a thread where
all signals are blocked (which is the default; see @ref{Signals and threads}).
Without setting @var{sigmask}, the @code{exec}ed process inherits 
calling thread's signal mask and become a process that blocks all signals,
which is not very convenient in most cases.

When @code{sys-exec}
encounters an error, most of the time it raises an error condition.
Once the file descriptors are permuted, however, it would be impractical
to handle errors in reasonable way (you don't even know stderr is still
available!), so Gauche simply exits on the error.
@end defun

@defun sys-fork-and-exec command args &keyword iomap sigmask
Like @code{sys-exec}, but executes @code{fork(2)} just before
remapping I/O, altering signal mask and call @code{execvp(2)}.
Returns child's process id.  The meanings of arguments are
the same as @code{sys-exec}.

It is strongly recommended to use this procedure instead of
@code{sys-fork} and @code{sys-exec} combination when you need
to spawn another program while other threads are running.
No memory allocation nor lock acquisition is done between
@code{fork(2)} and @code{execvp(2)},
so it's pretty safe in the multithreaded environment.
@end defun

@subsubheading Wait

@defun sys-wait
[POSIX] Calls system's @code{wait(2)}.  The process suspends its execution
until one of the child terminates.  Returns two exact integer values,
the first one is the child's process id, and the second is a status code.
The status code can be interpreted by the following functions.
@end defun

@defun sys-waitpid pid &keyword nohang untraced
[POSIX] This is an interface to @code{waitpid(3)}, an extended version of
wait.

@var{pid} is an exact integer specifying which child(ren) to be waited.
If it is a positive integer,
it waits fot that specific child.  If it is zero, it waits for any
member of this process group.  If it is -1, it waits for any child process.
If it is less than -1, it waits for any child process whose process group
id is equal to the absolute value of @var{pid}.

If there's no child process to wait, or a specific @var{pid} is
given but it's not a child process of the current process,
an error (@code{<system-error>}, @code{ECHILD}) is signalled.


The calling process suspends until one of those child process is terminated,
unless true is specified to the keyword argument @var{nohang}.

If true is specified to the keyword argument @var{untraced},
the status of stopped child process can be also returned.

The return values are two exact integers, the first one is the child
process id, and the second is a status code.  If @var{nohang} is true and
no child process status is available, the first value is zero.
@end defun

@defun sys-wait-exited? status
@defunx sys-wait-exit-status status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-wait} or @code{sys-waitpid}.
@code{sys-wait-exited?} returns @code{#t} if the child process is 
terminated normally.   @code{sys-wait-exit-status} returns the exit
code the child process passed to @code{exit(2)}, or the return value
of @code{main()}.
@end defun

@defun sys-wait-signaled? status
@defunx sys-wait-termsig status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-wait} or @code{sys-waitpid}.
@code{sys-wait-signaled?} returns @code{#t} if the child process
is terminated by an uncaught signal.
@code{sys-wait-termsig} returns the signal number that terminated the child.
@end defun

@defun sys-wait-stopped? status
@defunx sys-wait-stopsig status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-waitpid}.
@code{sys-wait-stopped?} returns @code{#t} if the child process is
stopped.   This status can be caught only by @code{sys-waitpid} with
true @var{untraced} argument.  @code{sys-wait-stopsig} returns the
signum number that stopped the child.
@end defun

@node I/O multiplexing, Miscellaneous system calls, Unix process management, System interface
@subsection I/O multiplexing
@c NODE I/Oの多重化

The interface functions for @code{select(2)}.
The higher level interface is provided on top of these
primitives; see @ref{Simple dispatcher}.

@deftp {Builtin Class} <sys-fdset>
@clindex sys-fdset
Represents @code{fd_set}, a set of file descriptors.  You can make
an empty file descriptor set by make method:
@example
(make <sys-fdset>)
@end example
@end deftp

@defun sys-fdset elt @dots{}
Creates a new @code{<sys-fdset>} instance with file descriptors
specified by @var{elt} @dots{}.  Each @var{elt} can be an
integer file descriptor, a port, or a @code{<sys-fdset>} instance.
In the last case, the descriptors in the given fdset is copied
to the new fdset.
@end defun

@defun sys-fdset-ref fdset port-or-fd
@defunx sys-fdset-set! fdset port-or-fd flag
Gets and sets specific file descriptor bit of @var{fdset}.
@var{port-or-fd} may be a port or an integer file descriptor.
If @var{port-or-fd} is a port that doesn't have associated file descriptor,
@code{sys-fdset-ref} returns @code{#f}, and @code{sys-fdset-set!} doesn't
modify @var{fdset}.  @var{flag} must be a boolean value.

You can use generic setter of @code{sys-fdset-ref} as this:
@example
(set! (sys-fdset-ref fdset port-or-fd) flag)
  @equiv{} (sys-fdset-set! fdset port-or-fd flag)
@end example
@end defun

@defun sys-fdset-copy! dest-fdset src-fdset
Copies the content of @var{src-fdset} into @var{dest-fdset}.
Returns @var{dest-fdset}.
@end defun

@defun sys-fdset-clear! fdset
Empties and returns @var{fdset}.
@end defun

@defun sys-fdset->list fdset
@defunx list->sys-fdset fds
Converts an fdset to a list of integer file descriptors and vice versa.
In fact, @code{list->sys-fdset} works just like
@code{(lambda (fds) (apply sys-fdset fds))}, so it accepts ports
and other fdsets as well as integer file descriptors.
@end defun

@defun sys-fdset-max-fd fdset
Returns the maximum file descriptor number in @var{fdset}.
@end defun

@defun sys-select readfds writefds exceptfds &optional timeout
@defunx sys-select! readfds writefds exceptfds &optional timeout
Waits for a set of file descriptors to change status.
@var{readfds}, @var{writefds}, and @var{exceptfds} are @code{<fdset>}
objects to represent a set of file descriptors to watch.
File descriptors in @var{readfds} are watched to see if characters
are ready to be read.   File descriptors in @var{writefds} are
watched if writing to them is ok.  File descriptors in @var{exceptfds}
are watched for exceptions.  You can pass @code{#f} to one or more
of those arguments if you don't care about watching the condition.

@var{timeout} specifies maximum time @code{sys-select} waits for
the condition change.  It can be a real number, for number of microseconds,
or a list of two integers, the first is the number of seconds and
the second is the number of microseconds.  If you pass @code{#f},
@code{sys-select} waits indefinitely.

@code{sys-select} returns four values.  The first value is a number
of descriptors it detected status change.  It may be zero if 
timeout expired.  The second, third and fourth values are @code{<fdset>}
object that contains a set of descriptors that changed status
for reading, writing, and exception, respectively.
If you passed @code{#f} to one or more of @var{readfds},
@var{writefds} and @var{exceptfds}, the corresponding return value
is @code{#f}.

@code{sys-select!} variant works the same as @code{sys-select}, except
it modifies the passed @code{<fdset>} arguments.
@code{sys-select} creates new @code{<fdset>} objects and
doesn't modify its arguments.
@end defun


@node Miscellaneous system calls,  , I/O multiplexing, System interface
@subsection Miscellaneous system calls
@c NODE その他のシステムコール

@defun sys-pause
[POSIX]
Suspends the process until it receives a signal whose
action is to either execute a signal-catching function or to terminate
the process.  This function only returns when the signal-catching
function returns.  The returned value is undefined.

Note that just calling @code{pause()} doesn't suffice the above semantics
in Scheme-level.  Internally this procedure calls @code{sigsuspend()}
with the current signal mask.
@end defun

@defun sys-alarm seconds
[POSIX] Arranges a SIGALRM signal to be delivered after @var{seconds}.
The previous settings of the alarm clock is cancelled.  Passing zero
to @var{seconds} doesn't schedule new alarm.
Returns the number of seconds remaining until previously scheduled
alarm was due to be delivered (or zero if no alarm is active).
@end defun

@defun sys-sleep seconds
[POSIX] Suspends the process until the specified number of seconds elapses,
or the process receives a signal.  Returns zero if it sleeps well,
or the number of unslept seconds if it is woke up by a signal.

To be portable across POSIX implementation, keep @var{seconds} less than
65536.
@end defun

@defun sys-nanosleep nanoseconds
[POSIX] 
Suspends the process until the specified number of nanoseconds elapses,
or the process receives a signal.  The argument @var{nanoseconds} can be
a @code{<time>} object (@xref{Time}), or a real number.
Returns @code{#f} if @var{nanoseconds} elapsed, or a @code{<time>}
object that indicates the remaining time if @code{sys-nanosleep}
is interrupted by a signal.

@example
;@r{wait for 0.5 sec}
(sys-nanosleep 500000000)

;@r{wait for 1.3 sec}
(sys-nanosleep (make <time> :second 1 :nanosecond 300000000))
@end example
@end defun

@defun sys-random
@defunx sys-srandom seed
A pseudo random number generator.
@code{sys-random} returns a random number between 0 and a positive
integer @var{rand_max}, inclusive.  This is a straightforward
interface to @code{random(3)}.  If the underlying system doesn't have
@code{random(3)}, @code{lrand48(3)} is used.

@code{sys-srandom} sets the seed of the random number generator.
It uses either @code{srandom(3)} or @code{srand48(3)}, depending on
the system.

The intention of these functions are to provide an off-the-stock handy
random number generator (RNG) for applications that doesn't
sensitive to the quality and/or speed of RNG.  For serious statistics
analysis, use Mersenne Twister RNG in @code{math.mt-random}
module (@xref{Mersenne-Twister random number generator}).
@end defun

@defvar RAND_MAX
Bound to a positive integer that @code{sys-random} may return.
@end defvar

@c ----------------------------------------------------------------------
@node Development helper API,  , System interface, Core library
@section Development helper API
@c NODE 開発補助API

Gauche has some basic built-in APIs to help developers
to analyze the program.

@menu
* Debugging aid::               
* Profiler API::                
@end menu

@node Debugging aid, Profiler API, Development helper API, Development helper API
@subsection Debugging aid
@c NODE デバッグ補助

@defmac debug-print expr
This macro prints @var{expr} in a source form, then evaluates it,
then prints out the result(s), and returns them.

The special reader syntax @code{#?=@var{expr}} is expanded into
@code{(debug-print @var{expr})}.  See @ref{Debugging}, for the
details.
@end defmac

@deffn {Parameter} debug-print-width
This parameter specifies the maximum width of information to be 
printed by @code{debug-print}.  If the information takes more
columns than the value of this parameter, it is truncated.

To show all the information, set @code{#f} to this parameter.
@end deffn

@defun debug-source-info obj
Retrieves source information attached to @var{obj}.
The source information is returned as a list of source file name
and an integer line number.  If no source information is available
in @var{obj}, @code{#f} is returned.
@end defun


@defun disasm closure
Disassemble the compiled body of @var{closure} and print it.
It may not be very useful unless you're tracking a compiler bug, 
or trying to tune the program to its limit.

If you're reading the disassembler output, keep in mind that
the compiled code vector may have some dead code; they are produced
by the jump optimization, but the compiler doesn't bother to eliminate
them.
@end defun

@node Profiler API,  , Debugging aid, Development helper API
@subsection Profiler API
@c NODE プロファイラAPI

These are the functions to control Gauche's built-in profiler.
See @ref{Using profiler} for the explanation of the profiler.

Note that the profiler doesn't work correctly yet in multi-threaded
program.

@defun profiler-start
Starts the sampling profiler.   If the profiler is already started,
nothing is done.
@end defun

@defun profiler-stop
Stop the sampling profiler, and save the sampled data into
the internal structure.   If there are already saved sampled data,
the newly obtained data is added to it.
If the profiler isn't running, nothing is done.
@end defun

@defun profiler-reset
Stop the profiler if it is running.  Then discard the
saved sampled data.
@end defun

@defun profiler-show &keyword sort-by max-rows
Show the saved sampled data.  

The keyword argument @var{sort-by} may be one of the symbols
@code{time}, @code{count}, or @code{time-per-call}, to specify
how the result should be sorted.  The default is @code{time}.

The keyword argument @var{max-rows} specifies the max number of
rows to be shown.  If it is @code{#f}, all the data is shown.
@end defun
@node Object system, Library modules - Overview, Core library, Top
@chapter Object system
@c NODE オブジェクトシステム

Gauche's object system design is largely inspired by
STklos, whose design has come from TinyCLOS.
It supports multiple inheritance, multimethods,
and metaobject protocol.

The type system is integrated to the object system,
that is, a string is an instance of the class @code{<string>},
and so on.

@c ----------------------------------------------------------------------
@menu
* Introduction to the object system::  
* General Inquiry::             
* Class::                       
* Instance::                    
* Generic function and method::  
* Metaobject protocol::         
@end menu

@node Introduction to the object system, General Inquiry, Object system, Object system
@section  Introduction to the object system
@c NODE オブジェクトシステムの紹介

This section briefly explains the basic structure of
Gauche's object system.   It is strongly influenced
by CLOS (Common-Lisp Object System).
If you have experience in CLOS or related systems
such as TinyCLOS, STklos or Guile's object system,
you may skip to the next section.

Three concepts play the central role in CLOS-like object systems:
A @emph{class}, a @emph{generic function}, and a @emph{method}.

A @emph{class} specifies a structure of object.
It also defines a datatype (strictly speaking,
it's not the same thing as a datatype,
but let's skip the complicated part for now).

For example, a point in 2D space can be represented by 
x and y coordinates.
A point class can be defined using @code{define-class} macro.
In the shortest form, it can be defined like this:

@example
(define-class <2d-point> () (x y))
@end example

(You can find the code of definitions in the examples of this section
in @code{examples/oointro.scm} of Gauche's source distribution.)

The symbol @code{<2d-point>} is the name of the class, and also
the global variable @code{<2d-point>} is bound to a class object.
Surrounding a class name by @code{<} and @code{>} is just a
convention; you can pass any symbol to @code{define-class}.

The second argument of @code{define-class} is a list of
direct superclasses, which specifies inheritance of the class.
We'll come back to it later.

The third argument of @code{define-class} is a list of
@emph{slots}.  A slot is a storage space, usually in each object,
where you can store a value.  It is something similar to
what is called a field or an instance variable in other
object-oriented languages; but slots can be configured more
than just a per-object storage space.

Now we defined a 2D point class, so we can create an instance
of a point.  You can pass a class to a generic function @code{make}
to create an instance.  (Don't worry about what generic function
is---think it as a special type of function, just for now).

@example
(define a-point (make <2d-point>))

a-point  @result{} #<<2d-point> 0x8117570>
@end example

If you are using @code{gosh} interactively, you can use
a generic function @code{describe} to inspect the internal
of an instance.
A short alias, @code{d}, is defined to @code{describe} for
the convenience.  (See @ref{Interactive session}
for the details).

@example
gosh> (d a-point)
#<<2d-point> 0x8117570> is an instance of class <2d-point>
slots:
  x         : #<unbound>
  y         : #<unbound>
@end example

In order to access or modify the value of the slot, you can use
@code{slot-ref} and @code{slot-set!}, respectively.
These names are taken from STklos.

@example
(slot-ref a-point 'x)  ;; access to the slot x of a-point
  @result{} @r{error, since slot 'x doesn't have a value yet}

(slot-set! a-point 'x 10.0)  ;; set 10.0 to the slot x of a-point

(slot-ref a-point 'x)
  @result{} 10.0
@end example

Gauche also provides a shorter name, @code{ref}, which can also
be used in srfi-17's generalized @code{set!} syntax:
@example
(ref a-point 'x) @result{} 10.0

(set! (ref a-point 'y) 20.0)

(ref a-point 'y) @result{} 20.0
@end example

Now you can see slot values are set.
@example
gosh> (d a-point)
#<<2d-point> 0x8117570> is an instance of class <2d-point>
slots:
  x         : 10.0
  y         : 20.0
@end example

In practice, it is usually convenient if you can specify the default
value for a slot, or give values for slots when you create an instance.
Such information can be specified by @emph{slot options}.
Let's modify the definition of @code{<2d-point>} like this:

@example
(define-class <2d-point> ()
  ((x :init-value 0.0 :init-keyword :x :accessor x-of)
   (y :init-value 0.0 :init-keyword :y :accessor y-of)))
@end example

Note that each slot specification is now a list, instead of just
a symbol as in the previous example.
The list's car now specifies the slot name, and its cdr
gives various information.   The value after @code{:init-value}
defines the default value of the slot.  The keyword after @code{:init-keyword}
defines the keyword argument which can be passed to @code{make} to
initialize the slot at creation time.
The name after keyword @code{:accessor} is bound to a generic
function that can be used to access/modify the slot, instead of
using @code{slot-ref}/@code{slot-set!}.

Let's see some interactive session.  You create an instance
of the new @code{<2d-point>} class, and you can see the slots are
initialized by the default values.
@example
gosh> (define a-point (make <2d-point>))
a-point
gosh> (d a-point)
#<<2d-point> 0x8148680> is an instance of class <2d-point>
slots:
  x         : 0.0
  y         : 0.0
@end example

You create another instance, this time giving initialization values
by keyword arguments.
@example
gosh> (define b-point (make <2d-point> :x 50.0 :y -10.0))
b-point
gosh> (d b-point)
#<<2d-point> 0x8155b80> is an instance of class <2d-point>
slots:
  x         : 50.0
  y         : -10.0
@end example

Accessors are less verbose than @code{slot-ref}/@code{slot-set!}, thus
convenient.
@example
gosh> (x-of a-point)
0.0
gosh> (x-of b-point)
50.0
gosh> (set! (y-of a-point) 3.33)
#<undef>
gosh> (y-of a-point)
3.33
@end example

The full list of available slot options is described in 
@ref{Defining class}.  At a first grance,
the declarations of such slot options may look verbose.
The system might have provide a static way to define
init-keywords or accessor names automatically; however,
CLOS-like systems prefer flexibility.
Using a mechanism called metaobject protocol, you can customize
how these slot options are interpreted, and you can add
your own slot options as well.
See @ref{Metaobject protocol}, for details.

We can also have @code{<2d-vector>} class in similar fashion.

@example
(define-class <2d-vector> ()
  ((x :init-value 0.0 :init-keyword :x :accessor x-of)
   (y :init-value 0.0 :init-keyword :y :accessor y-of)))
@end example

Yes, we can use the same accessor name like @code{x-of}, and
it is effectively overloaded.

If you are familiar with mainstream object-oriented languages,
you may wonder where methods are.  Here they are.
The following form defines a method @code{move-by!} of
three arguments, @var{pt}, @var{dx}, @var{dy}, where @var{pt} is
an instance of @code{<2d-point>}.

@example
(define-method move-by! ((pt <2d-point>) dx dy)
  (inc! (x-of pt) dx)
  (inc! (y-of pt) dy))
@end example

The second argument of @code{define-method} macro specifies a
@emph{method specializer list}.  It indicates the first argument must be
an instance of @code{<2d-point>}, and the second and third
can be any type.   The syntax to call a method is just like
the one to call an ordinary function.

@example
gosh> (move-by! b-point 1.4 2.5)
#<undef>
gosh> (d b-point)
#<<2d-point> 0x8155b80> is an instance of class <2d-point>
slots:
  x         : 51.4
  y         : -7.5
@end example

You can overload the method by different specializers; here
you can move a point using a vector.
@example
(define-method move-by! ((pt <2d-point>) (delta <2d-vector>))
  (move-by! pt (x-of delta) (y-of delta)))
@end example

Specialization isn't limited to a user-defined classes.
You can also specialize a method using Gauche's built-in type.
@example
(define-method move-by! ((pt <2d-point>) (c <complex>))
  (move-by! pt (real-part c) (imag-part c)))
@end example

And here's the example session:
@example
gosh> (define d-vector (make <2d-vector> :x -9.0 :y 7.25))
d-vector
gosh> (move-by! b-point d-vector)
#<undef>
gosh> (d b-point)
#<<2d-point> 0x8155b80> is an instance of class <2d-point>
slots:
  x         : 42.4
  y         : -0.25
gosh> (move-by! b-point 3+2i)
#<undef>
gosh> (d b-point)
#<<2d-point> 0x8155b80> is an instance of class <2d-point>
slots:
  x         : 45.4
  y         : -2.25
@end example

You see that a method is dispatched not only by its primary
receiver (@code{<2d-point>}), but also other arguments.
In fact, the first argument is no more special than the rest.
In CLOS-like system a method does not belong to
a particular class.

So what is actually a method?  Inspecting @code{move-by!}
reveals that it is an instance of @code{<generic>}, a generic function.
(Note that @code{describe} truncates the printed value in @code{methods}
slot for the sake of readability).
@example
gosh> move-by!
#<generic move-by! (3)>
gosh> (d move-by!)
#<generic move-by! (3)> is an instance of class <generic>
slots:
  name      : move-by!
  methods   : (#<method (move-by! <2d-point> <complex>)> #<method (move-
gosh> (ref move-by! 'methods)
(#<method (move-by! <2d-point> <complex>)>
 #<method (move-by! <2d-point> <2d-vector>)> 
 #<method (move-by! <2d-point> <top> <top>)>)
@end example

I said a generic function is a special type of function.
It is recognized by Gauche as an applicable object, but
when applied, it selects appropriate method(s) according to
its arguments and calls the selected method(s).

What the @code{define-method} macro actually does is (1) to create
a generic function of the given name if it does not exist yet,
(2) to create a method object with the given specializers
and the body, and (3) to add the method object to the generic function.

The accessors are also generic functions, created implicitly by the
@code{define-class} macro.
@example
gosh> (d x-of)
#<generic x-of (2)> is an instance of class <generic>
slots:
  name      : x-of
  methods   : (#<method (x-of <2d-vector>)> #<method (x-of <2d-point>)>)
@end example

In the mainstream dynamic object-oriented languages, a class
has many roles; it defines a structure and a type, creates a
namespace for its slots and methods, and is responsible for
method dispatch.  In Gauche, namespace is managed by modules,
and method dispatch is handled by generic functions.

The default printed representation of object is not very user-friendly.
Gauche's @code{write} and @code{display} function call a generic
function @code{write-object} when they encounter an instance
they don't know how to print.  You can define its method
specialized to your class to customize how the instance is
printed.
@example
(define-method write-object ((pt <2d-point>) port)
  (format port "[[~a, ~a]]" (x-of pt) (y-of pt)))

(define-method write-object ((vec <2d-vector>) port)
  (format port "<<~a, ~a>>" (x-of vec) (y-of vec)))
@end example

And what you'll get is:
@example
gosh> a-point
[[0.0, 3.33]]
gosh> d-vector
<<-9.0, 7.25>>
@end example

If you customize the printed representation to conform srfi-10
format, and define a corresponding read-time constructor,
you can make your instances to be written-out and read-back
just like built-in objects.  See @ref{Read-time constructor} for
the details.

Several built-in functions have similar way to extend their
functionality for user-defined objects.  For example, if
you specialize a generic function @code{object-equal?}, 
you can compare the instances by @code{equal?}:
@example
(define-method object-equal? ((a <2d-point>) (b <2d-point>))
  (and (equal? (x-of a) (x-of b))
       (equal? (y-of a) (y-of b))))

(equal? (make <2d-point> :x 1 :y 2) (make <2d-point> :x 1 :y 2))
  @result{} #t

(equal? (make <2d-point> :x 1 :y 2) (make <2d-point> :x 2 :y 1))
  @result{} #f

(equal? (make <2d-point> :x 1 :y 2) 'a)
  @result{} #f

(equal? (list (make <2d-point> :x 1 :y 2)
              (make <2d-point> :x 3 :y 4))
        (list (make <2d-point> :x 1 :y 2)
              (make <2d-point> :x 3 :y 4)))
  @result{} #t
@end example

Let's proceed to more interesting examples.
Think of a class @code{<shape>}, 
which is an entity that can be drawn.
As a base class, it keeps
common attributes such as a color and line thickness in its slots.
@example
(define-class <shape> ()
  ((color     :init-value '(0 0 0) :init-keyword :color)
   (thickness :init-value 2 init-keyword :thickness)))
@end example

When an instance is created, @code{make} calls a generic function
@code{initialize}, which takes care of initializing slots
such as processing init-keywords and init-values.
You can customize the initialization behavior by specializing
the @code{initialize} method.   The @code{initialize} method
is called with two arguments, one is a newly created instance,
and another is a list of arguments passed to @code{make}.

We define a @code{initialize} method for @code{<shape>} class,
so that the created shape will be automatically recorded in a global
list.   Note that we don't want to replace system's
@code{initialize} behavior completely,
since we still need the init-keywords to be handled.

@example
(define *shapes* '())  ;; global shape list

(define-method initialize ((self <shape>) initargs)
  (next-method)  ;; let the system to handle slot initialization
  (push! *shapes* self)) ;; record myself to the global list
@end example
The trick is a special method, @code{next-method}.  It can only be
used inside a method body, and calls @emph{less specific method}
of the same generic function---typically, it means you call the
same method of superclass.
Most object-oriented languages have the concept of calling
superclass's method.  Because of multiple-argument
dispatching and multiple inheritance, @code{next-method} is
a little bit more complicated, but the basic idea is the same.

So, what's the superclass of @code{<shape>}?  In fact, all 
Scheme-defined class inherits a class called @code{<object>}.
And it is @code{<object>}'s initialize method which takes care
of slot initialization.  After calling @code{next-method}
within your @code{initialize} method, you can assume all
the slots are properly initialized.  So it is generally the
first thing in your @code{initialize} method to call @code{next-method}.

Let's inspect the above code.  When you call
@code{(make <shape> args @dots{})}, the system allocates
memory for an instance of @code{<shape>}, and calls
@code{initialize} generic function with the instance and
@code{args @dots{}}.  It is dispatched to the @code{initialize}
method you just defined.  In it, you call @code{next-method},
which in turn calls @code{<object>} class's @code{initialize}
method.  It initializes the instance with init-values and init-keywords.
After it returns, you register the new @code{<shape>} instance
to the global shape list @code{*shapes*}.

The @code{<shape>} class represents just an abstract concept of
shape.  Now we define some concrete drawable shapes, by
@emph{subclassing} the @code{<shape>} class.
@example
(define-class <point-shape> (<shape>)
  ((point  :init-form (make <2d-point>) :init-keyword :point)))

(define-class <polyline-shape> (<shape>)
  ((points :init-value '() :init-keyword :points)
   (closed :init-value #f  :init-keyword :closed)))
@end example

Note the second argument passed to @code{define-class}.
It indicates that @code{<point-shape>} and @code{<polyline-shape>}
inherit slots of @code{<shape>} class, and also instances of
those subclasses can be accepted wherever an instance of 
@code{<shape>} class is accepted.

The @code{<point-shape>} adds one slot, @code{point}, which
contains an instance of @code{<2d-point>} defined in the beginning
of this section.  The @code{<polyline-shape>} class stores
a list of points, and a flag, which specifies whether the end
point of the polyline is connected to its starting point or not.

Inheritance is a powerful mechanism that should be used with care,
or it easily result a code which is untractable
("Object-oriented programming offers a sustainable way to
write spaghetti code.", as Paul Graham says in his article
"The Hundred-Year Language").
The rule of thumb is to make a subclass when you need a subtype.
The inheritance of slots is just something that comes with,
but it shouldn't be the main reason to do subclassing.
You can always "include" the substructure, as is done in
@code{<point-shape>} class.

There appeared a new slot option in @code{<point-shape>} class.
The @code{:init-form} slot option specifies the default value of
the slot when init-keyword is not given to @code{make} method.
However, unlike @code{:init-value}, with which the value is
evaluated at the time the class is defined, 
the value with @code{:init-form} is evaluated when the system
actually needs the value.  So, in the @code{<point-shape>} instance,
the default @code{<2d-point>} instance is only created if the
@code{<point-shape>} instance is created without having @code{:point}
init-keyword argument.

A shape may be drawn in different formats for different devices.
For now, we just consider a PostScript output.  To make the @code{draw}
method polymorphic, we define a postscript output device class,
@code{<ps-device>}.

@example
(define-class <ps-device> () ())
@end example

Then we can write a @code{draw} method, specialized for
both @code{<shape>} and @code{<ps-device>}.
@example
(define-method draw ((self <shape>) (device <ps-device>))
  (format #t "gsave\n")
  (draw-path self device)
  (apply format #t "~a ~a ~a setrgbcolor\n" (ref self 'color))
  (format #t "~a setlinewidth\n" (ref self 'thickness))
  (format #t "stroke\n")
  (format #t "grestore\n"))
@end example

In this code, the @var{device} argument isn't
used within the method body.  It is just used for method dispatching.
If we eventually have different output devices, we can add
a @code{draw} method that is specialized for such devices.

The above @code{draw} method does the common work, but actual
drawing must be done in specialized way for each subclasses.
@example
(define-method draw-path ((self <point-shape>) (device <ps-device>))
  (apply format #t "newpath ~a ~a 1 0 360 arc closepath\n"
         (point->list (ref self 'point))))

(define-method draw-path ((self <polyline-shape>) (device <ps-device>))
  (let ((pts (ref self 'points)))
    (when (>= (length pts) 2)
      (format #t "newpath\n")
      (apply format #t "~a ~a moveto\n" (point->list (car pts)))
      (for-each (lambda (pt)
                  (apply format #t "~a ~a lineto\n" (point->list pt)))
                (cdr pts))
      (when (ref self 'closed)
        (apply format #t "~a ~a lineto\n" (point->list (car pts))))
      (format #t "closepath\n"))))

;; utility method
(define-method point->list ((pt <2d-point>))
  (list (x-of pt) (y-of pt)))
@end example

Finally, we do a little hack.  Let @code{draw} method work on
the list of shapes, so that we can draw multiple shapes within a page
in batch.
@example
(define-method draw ((shapes <list>) (device <ps-device>))
  (format #t "%%\n")
  (for-each (cut draw <> device) shapes)
  (format #t "showpage\n"))
@end example

Then we can write some simple figures @dots{}.
@example
(use srfi-1)      ;; for iota
(use math.const)  ;; for constant pi

(define (shape-sample)

  ;; creates 5 corner points of pentagon
  (define (make-corners scale)
    (map (lambda (i)
           (let ((pt (make <2d-point>)))
             (move-by! pt (make-polar scale (* i 2/5 pi)))
             (move-by! pt 200 200)
             pt))
         (iota 5)))

  (set! *shapes* '())  ;; clear the shape list
  (let* ((corners (make-corners 100)))
    ;; a pentagon in green
    (make <polyline-shape>
      :color '(0 1 0) :closed #t
      :points corners)
    ;; a star-shape in red
    (make <polyline-shape>
      :color '(1 0 0) :closed #t
      :points (list (list-ref corners 0)
                    (list-ref corners 2)
                    (list-ref corners 4)
                    (list-ref corners 1)
                    (list-ref corners 3)))
    ;; put dots in each corner of the star
    (for-each (cut make <point-shape> :point <>)
              (make-corners 90))
    ;; draw the shapes
    (draw *shapes* (make <ps-device>)))
  )
@end example

The function @code{shape-sample} writes out a PostScript code of
simple drawing to the current output port.  You can write it out
to file by the following expression, and then view the result
by PostScript viewer such as GhostScript.
@example
(with-output-to-file "oointro.ps" shape-sampe)
@end example


@c ----------------------------------------------------------------------
@node General Inquiry, Class, Introduction to the object system, Object system
@section  General Inquiry
@c NODE 一般的な問い合わせ

@defun class-of obj
Returns a class metaobject of @var{obj}.

@example
(class-of 3)         @result{} #<class <integer>>
(class-of "foo")     @result{} #<class <string>>
(class-of <integer>) @result{} #<class <class>>
@end example
@end defun

@defun is-a? obj class
Returns true if @var{obj} is an instance of @var{class} or an instance
of descendants of @var{class}.

@example
(is-a? 3 <integer>)   @result{} #t
(is-a? 3 <real>)      @result{} #t
(is-a? 5+3i <real>)   @result{} #f
(is-a? :foo <symbol>) @result{} #f
@end example
@end defun

If @var{obj}'s class has been redefined, these procedures
first updates @var{obj} to change its class to the new class.
So @code{class-of} always returns the new class.
This behavior is different from stklos 0.55, in which @code{class-of}
returns an old class if @var{obj} hasn't been updated.
If you need to get the old class, you should use @code{current-class-of}
below.  
See @ref{Class redefinition} for the details of the semantics
of redefined class.

@defun current-class-of obj
Returns a class metaobject of @var{obj}.  If @var{obj}'s class
has been redefined, but @var{obj} is not updated for the change,
then this procedure returns the original class of @var{obj}
without updating @var{obj}.

You need this procedure in rare occasions, such as within
@code{change-class} method, in which you don't want to trigger
updating @var{obj} (which would cause infinite loop).
@end defun

@c ----------------------------------------------------------------------
@node Class, Instance, General Inquiry, Object system
@section Class
@c NODE クラス

In this section, a class in Gauche is explained in detail.

@menu
* Defining class::              
* Inheritance::                 
* Class object::                
* Slot definition object::      
* Class redefinition::          
* Class definition examples::   
@end menu

@node Defining class, Inheritance, Class, Class
@subsection Defining class
@c NODE クラスの定義

To define a class, use a macro @code{define-class}.

@defmac define-class name supers (slot-spec @dots{}) option @dots{}
Creates a class object according to the arguments, and globally
bind it to a variable @var{name}.   This macro should be used at toplevel.

@var{Supers} is a list of direct superclasses from which this class
inherits.   You can use multiple inheritance.
All Scheme-defined classes implicitly inherits @code{<object>}.
It is implicitly added to the right of @var{supers} list, so you
don't need to specify it.
See @ref{Inheritance}, for the details about inheritance.

@var{Slot-spec} is a specification of a "slot", sometimes known as 
a "field" or an "instance variable" (but you can specify "class variable"
in @var{slot-spec} as well). 
The simplest form of @var{slot-spec} is just a symbol, which names
the slot.  Or you can give a list, whose first element is a symbol
and whose rest is an interleaved list of keywords and values.
The list form not only defines a name of the slot but specifies
behavior of the slot.  It is explained below.

Finally, @var{option} @dots{} is an interleaved list of keywords
and values, specifies how class object should be created.
This macro recognizes one keyword, @code{:metaclass}, whose
corresponding value is used for metaclass (class that instantiates
another class).   Other options are passed to the @code{make}
method to create the class object.  @xref{Class instantiation},
for the usage of metaclass.
@end defmac

If a slot specification is a list, it should be in the following form:

@example
(@var{slot-name} :option1 value1 :option2 value2 @dots{})
@end example

Each keyword (@code{option1} etc.) gives a @emph{slot option}.
By default, the following slot options are recognized.
You can add more slot options by defining metaclass.

@table @code

@item :allocation
Specifies an allocation type of this slot, which specifies how the
value for this slot is stored.  The following keyword values are
recognized by the standard class.  A programmer can define his own
metaclass to extend the class to recognize other allocation types.
@table @code
@item :instance
A slot is allocated for each instance, so that every instance can have
distinct value.  This realizes so-called "instance variable" behavior.
If @code{:allocation} slot option is omitted, this is the default.
@item :class
A slot is allocated in this class object, so that every instance will
share the same value for this slot.  This realizes so-called
"class variable" behavior.  The slot value is also shared by all
subclasses (unless a subclass definition shadows the slot).
@item :each-subclass
Similar to @code{class} allocation, but a slot is allocated for each
class; that is, it is shared by every instance of the class, but
not shared by the instances of its subclasses.
@item :virtual
No storage is allocated for this type of slot.  Accessing the slot
calls procedures given in @code{:slot-ref} and @code{:slot-set!} options
described below.  In other words, you can make a procedural slot.
If a slot's allocation is specified as virtual, at least
@code{:slot-ref} option has to be specified as well, or @code{define-class}
raises an error.
@item :builtin
This type of allocation only appears in built-in classes, and
you can't specify it in Scheme-defined class.
@end table

@item :init-keyword
A keyword value given to this slot option can be used to pass an
initial value to @code{make} method when an instance is created.

@item :init-value
Gives an initial value of the slot, if the slot is not initialized
by the keyword argument at the creation time.   The value is
evaluated when @code{define-class} is evaluated.

@item :init-form
Like @code{init-value}, but the value given is wrapped in a thunk,
and evaluated each time when the value is required.
If both @code{init-value} and @code{init-form} are given, @code{init-form}
is ignored.   Actually, @code{:init-form @var{expr}} is converted
to @code{:init-thunk (lambda () @var{expr})} by @code{define-class} macro.

@item :initform
A synonym of @code{init-form}.  This is kept for compatibility to
STk, and shouldn't be used in the new code.

@item :init-thunk
Gives a thunk, which will be evaluated to obtain an initial value
of the slot, if the slot is not initialized by the keyword argument
at the creation time.  To give a value to @code{:init-form}
is equivalent to give @code{(lambda () value)} to @code{:init-thunk}.

@item :getter
Takes a symbol, and a getter method is created and bound to the
generic function of that name.  The getter method takes an instance
of the class and returns the value of the slot.

@item :setter
Takes a symbol, and a setter method is created and bound to
the generic function of that name.  The setter method takes an instance
of the class and a value, and sets the value to the slot of the instance.

@item :accessor
Takes a symbol, and create two methods; a getter method and a setter method.
A getter method is bound to the generic function of the given name,
and a setter method is added as the @emph{setter} of that generic function
(see @ref{Assignments} for generic setters).

@item :slot-ref
Specifies a value that evaluates to a procedure which takes one argument,
an instance.  This slot option must be specified if the allocation of
the slot is @code{virtual}.  Whenever a program tries to get the value
of the slot, either using @code{slot-ref} or the getter method,
the specified procedure is called, and its result is returned as
the value of the slot.  The procedure can return an undef value
(the return value of @code{undefined}) to indicate the slot doesn't
have a value.
If the slot allocation is not @code{virtual} this slot option is ignored.

@item :slot-set!
Specifies a value that evaluates to a procedure which takes two arguments,
an instance and a value.  Whenever a program tries
to set the value of the slot, either using @code{slot-set!} or the
setter method, the specified procedure is called with the value to be set.
If the slot allocation is not @code{virtual} this slot option is ignored.
If this option isn't given to a virtual slot, the slot becomes read-only.

@item :slot-bound?
Specifies a value that evaluates to a procedure which takes one argument,
an instance.  This slot option is only meaningful when the slot allocation
is @code{virtual}.  Whenever a program tries to determine whether
the slot has a value, this procedure is called.  It should return
a true value if the slot has a value, or @code{#f} otherwise.
If this slot option is omitted for a virtual slot, the system
calls the procedure given to @code{slot-ref} instead, and see whether
its return value is @code{#<undef>} or not.
@end table

@node Inheritance, Class object, Defining class, Class
@subsection Inheritance
@c NODE 継承

Inheritance has two roles.  First, you can @emph{extend} the existing
class by adding more slots.  Second, you can @emph{specialize} the
methods related to the existing class so that those methods will
do a little more specific task than the original methods.

Let's define some terms.  When a class @code{<T>} inherits a 
class @code{<S>}, we call @code{<T>} a @emph{subclass} of @code{<S>},
and @code{<S>} a @emph{superclass} of @code{<T>}.  This relation
is transitive: @code{<T>}'s subclasses are also @code{<S>}'s subclasses,
and @code{<S>}'s superclasses are also @code{<T>}'s superclasses.
Specifically, if @code{<T>} directly inherits @code{<S>}, that is,
@code{<S>} appeared in the superclass list when @code{<T>} is defined,
then @code{<S>} is a @emph{direct superclass} of @code{<T>}, 
and @code{<T>} is a @emph{direct subclass} of @code{<S>}.

When a class is defined, it and its superclasses are ordered from
subclasses to superclasses, and a list of classes is created in such
order.   It is called @emph{class precedence list}, or CPL.
Every class has its own CPL.
A CPL of a class always begins with the class itself, and ends with
@code{<top>}.

You can query a class's CPL by a procedure @code{class-precedence-list}:

@example
gosh> (class-precedence-list <boolean>)
(#<class <boolean>> #<class <top>>)
gosh> (class-precedence-list <string>)
(#<class <string>> #<class <sequence>> #<class <collection>> #<class <top>>)
@end example

As you see, all classes inherits a class named @code{<top>}.
Some built-in classes have several abstract classes in its CPL
between itself and @code{<top>}; the above example shows @code{<string>}
class inherits @code{<sequence>} and @code{<collection>}.
That means a string can behave both as a sequence and a collection.

@example
gosh> (is-a? "abc" <string>)
#t
gosh> (is-a? "abc" <sequence>)
#t
gosh> (is-a? "abc" <collection>)
#t
@end example

How about inheritance of Scheme-defined classes?
If there's only single inheritance, its CPL is straightforward:
you can just follow the class's super, its super's super, its
super's super's super, @dots{}, until you reach @code{<top>}.
See the example:

@example
gosh> (define-class <a> () ())
<a>
gosh> (define-class <b> (<a>) ())
<b>
gosh> (class-precedence-list <b>)
(#<class <b>> #<class <a>> #<class <object>> #<class <top>>)
@end example

Scheme-defined class always inherits @code{<object>}.
It is automatically inserted by the system.

When multiple inheritance is involved, a story becomes a bit
complicated.  We have to merge multiple CPLs of the superclasses
into one CPL.  It is called @emph{linearization}, and there are
several known linealization strategies.  By default, Gauche uses
an algorithm called @emph{C3 linearization},
which is consistent with the local precedence order,
monotonicity, and the extended precedence graph.
We don't go into the details here; as a general rule,
the order of superclasses in a class's CPL is always
consistent to the order of direct superclasses of
the class, the order of CPL of each superclasses,
and the order of direct superclasses of each superclass,
and so on.   See @ref{dylan,[Dylan],Dylan} for the precise
description.

If a class inherits superclasses in a way that its CPL can't
be constructed with satisfying consistencies, an error is reported.

Here's a simple example of multiple inheritance.

@example
(define-class <grid-layout> () ())

(define-class <horizontal-grid> (<grid-layout>) ())

(define-class <vertical-grid> (<grid-layout>) ())

(define-class <hv-grid> (<horizontal-grid> <vertical-grid>) ())

(map class-name (class-precedence-list <hv-grid>))
 @result{} (<hv-grid> <horizontal-grid> <vertical-grid> 
     <grid-layout> <object> <top>)
@end example

Note that the order of direct superclasses of @code{<hv-grid>}
(@code{<horizontal-grid>} and @code{<vertical-grid>}) is kept.

The following is a little twisted example:

@example
(define-class <pane> () ())

(define-class <scrolling-mixin> () ())

(define-class <scrollable-pane> (<pane> <scrolling-mixin>) ())

(define-class <editing-mixin> () ())

(define-class <editable-pane> (<pane> <editing-mixin>) ())

(define-class <editable-scrollable-pane>
   (<scrollable-pane> <editable-pane>) ())

(map class-name (class-precedence-list <editable-scrollable-pane>))
 @result{} (<editable-scrollable-pane> <scrollable-pane> 
     <editable-pane> <pane> <scrolling-mixin> <editing-mixin> 
     <object> <top>)
@end example

Once the class precedence order is determined,
the slots of defined class is calculated as follows:
the slot definitions are collected in the direction from superclasss
to subclass in CPL.  If a subclass has a slot definition of the same
name of the one in superclass, then the slot definition of the subclass
is taken and superclass's is discarded.    Suppose a class @code{<S>}
defines slots @code{a}, @code{b}, and @code{c}, a class @code{<T>}
defines slots @code{c}, @code{d}, and @code{e}, and a class @code{<U>}
defines slots @code{b} and @code{e}.  When @code{<U>}'s CPL is
@code{(<U> <T> <S> <object> <top>)}, then @code{<U>}'s slots is
calculated as the chart below; that is, @code{<U>} gets five slots,
of which @code{b} and @code{e}'s definitions come from @code{<U>}'s
definitions, @code{c} and @code{d}'s come from @code{<T>}, and
@code{a}'s comes from @code{<S>}.

@example
   CPL      | slot definitions
            |  () indicates shadowed slot
 -----------+-------------------
   <top>    |
   <object> |
   <S>      | a  (b) (c)
   <T>      |         c   d  (e)
   <U>      |     b           e
 -----------+--------------------
 <U>'s slots| a   b   c   d   e
@end example

You can get a list of slot definitions of a class object using
@code{class-slots} function.

Note that the behavior described above is mere a default behavior.
You can customize how the CPL is computed, or how slot definitions
are inherited, by defining metaclass.  For example,
you can write a metaclass that allows you to merge slot options
of the same slot names, instead of the one shadowing the other.
Or you can write a metaclass that forbids a subclass shadows
the superclass's slot.

@node Class object, Slot definition object, Inheritance, Class
@subsection Class object
@c NODE クラスオブジェクト

What is a class?  In Gauche, a class is just an object that implements
a specific feature: to instantiate an object.
Because of that, you can introspect the class by just
looking into the slot values.  There are some procedures provided
for the convenience of such introspection.
Note that if those procedures return a list, it belongs to
the class and you shouldn't modify it.

@defun class-name class
Returns the name of @var{class}.

@example
(class-name <string>) @result{} <string>
@end example
@end defun

@defun class-precedence-list class
Returns the class precedence list of @var{class}.

@example
(class-precedence-list <string>)
  @result{} (#<class <string>>
      #<class <sequence>>
      #<class <collection>>
      #<class <top>>)
@end example
@end defun

@defun class-direct-supers class
Returns a list of direct superclasses of @var{class}.
A direct superclass is a class from which
@var{class} inherits directly.

@example
(class-direct-supers <string>)
  @result{} (#<class <sequence>>)
@end example
@end defun

@defun class-direct-subclasses class
Returns a list of direct subclasses of @var{class}.
A direct subclass is a class that directly inherits
@var{class}.  If @code{<T>} is a direct subclass of @code{<S>},
then @code{<S>} is a direct superclass of @code{<T>}.
@end defun

@defun class-slots class
Returns a list of @emph{slot definitions} of @var{class}.
A slot definition is a list whose car is the name of the slot
and whose cdr is a keyword-value list that specifies slot options.
You can further inspect a slot definition to know what characteristics
the slot has.  See @ref{Slot definition object} for the details.

The standard way to get a list of slot names of a given class
is @code{(map slot-definition-name (class-slots class))}.
@end defun

@defun class-slot-definition class slot-name
Returns a slot definition of a slot specified by @var{slot-name} in
a class @var{class}.  If @var{class} doesn't have a named slot,
@code{#f} is returned.
@end defun

@defun class-direct-slots class
Returns a list of slot definitions that are directly defined
in this class (i.e. not inherited from superclasses).
This information is used to calculate slot inheritance
during class initialization.
@end defun

@defun class-direct-methods class
Returns a list of methods that has @var{class} in its specializer.
@end defun

@defun class-slot-accessor class slot-name
Returns a slot accessor object of the slot specified by @var{slot-name}
in @var{class}.
A slot accessor object is an internal object that encapsulates
the information how to access, modify, and initialize the given slot.

You don't usually need to deal with slot accessor objects unless
you are defining some special slots using metaobject protocol.
@end defun

@node Slot definition object, Class redefinition, Class object, Class
@subsection Slot definition object
@c NODE スロット定義オブジェクト

A slot definition object, returned by @code{class-slots},
@code{class-direct-slots} and @code{class-slot-definition},
keeps information about a slot.
Currently Gauche uses a list to represent the slot definition,
as STklos and TinyCLOS do.  However, it is not guaranteed that
Gauche keeps such a structure in future; you should use the
following dedicated accessor methods to obtain information
of a slot definition object.

@defun slot-definition-name slot-def
Returns the name of a slot given by a slot definition object @var{slot-def}.
@end defun

@defun slot-definition-options slot-def
Returns a keyword-value list of slot options of @var{slot-def}.
@end defun

@defun slot-definition-allocation slot-def
Returns the value of @code{:allocation} option of @var{slot-def}.
@end defun

@defun slot-definition-getter slot-def
@defunx slot-definition-setter slot-def
@defunx slot-definition-accessor slot-def
Returns the value of @code{:getter}, @code{:setter} and @code{:accessor}
slot options of @var{slot-def}, respectively.
@end defun

@defun slot-definition-option slot-def option &optional default
Returns the value of slot option @var{option} of @var{slot-def}.
If there's no such an option, @var{default} is returned
if given, or an error is signalled otherwise.
@end defun

@node Class redefinition, Class definition examples, Slot definition object, Class
@subsection Class redefinition
@c NODE クラスの再定義

If the specified class name is bound to a class when @code{define-class}
is used, it is regarded as @emph{redefinition} of the original class.

Redefinition of a class means the following operations:
@itemize @bullet
@item
A new class object is created based on the new definition,
and bound to the variable given to @code{define-class}.

@item 
Methods defined on the original class (i.e. methods that have
the original class in their specializers) are changed so that
they are defined on the new class.

@item
The direct-subclasses link of the direct superclasses of the
original class is modified so that they will point to the new class.

@item
All the subclasses of the original class are redefined recursively
so that they reflect the changes of the class.
Each class remembers its initialization arguments, and
each redefined subclass gets the same initialization arguments
as the original subclass. 

@item
The original class is marked @emph{redefined}.
@end itemize

Note that the original class and the new class are different objects.
The original class object remembers which variable in which module
it is originally bound, and replaces the binding to a new class.
If you keep the direct reference to the original class somewhere else,
it still refers to the original class; you might want to take extra
care.  You can customize class redefinition behavior by
defining the @code{class-redefinition} method; see 
@ref{Metaobject protocol} for the details.

If there are instances of the original class, such instances
are automatically @emph{updated} when it is about to be accessed or modified
via @code{class-of}, @code{is-a?}, @code{slot-ref},
@code{slot-set!}, @code{ref}, a getter method, or a setter method.  

Updating an instance means that the class of the instance
is changed (from the old class to the new class).
By default, the values of the slots that are common in the original
class and the new class are carried over, and the slots added
by the new class are initialized according to the slot specification
of the new class, and the values of the slots that are
removed from the original class are discarded.
You can customize this behavior by writing the @code{change-class} method.
See @ref{Changing classes}, for the details.

@subsubheading Notes on thread safety

Class redefinition process is non-local operation with full of side-effects.
It is difficult to guarantee that two threads safely run
class redefinition protocol simultaneously.   So Gauche uses
a process-wide lock to limit only one thread to enter the
class redefinition protocol at a time.  

If a thread tries to redefine a class while another thread is in
the redefinition protocol, the thread is blocked, even if
it is redefining a class different from the one that are
being redefined; because redefinition affects all the
subclasses, and all the methods and generic functions that
are related to the class and subclasses, it is not trivial
to determine two classes are completely independent or not.

If a thread tries to access an instance whose class
is being redefined by another thread, also the thread
is blocked until the redefinition is finished.

Note that the instance update protocol isn't serialized.
If two threads try to access an instance whose
class has been redefined, both trigger the instance
update protocol, which would cause an undesired race condition.
It is the application's responsibility to ensure
such a case won't happen.  It is natural since the
instance access isn't serialized by the system anyway.
However, an extra care is required to have mutex within
an instance; just accessing the mutex in it may trigger
the instance update protocol.

@subsubheading Notes on compatibility

Class redefinition protocols subtlety differ among CLOS-like
Scheme systems.   Gauche's is very similar to STklos's, except
that STklos 0.56 doesn't replace bindings of redefined subclasses,
and also it doesn't remember initialization arguments so the
redefined subclass may lose some of the information that the original
subclass has.  Guile's object system swaps identities of the original
class and the redefined class at the end of class redefinition
protocol, so the reference to the original class object
will turn to the redefined class.
As far as the author knows, class redefinition is not thread-safe
in both STklos 0.56 and Guile 1.6.4.

@node Class definition examples,  , Class redefinition, Class
@subsection Class definition examples
@c NODE クラスの定義例

Let's see some examples.  Suppose you are defining a graphical
toolkit.  A @code{<window>} is a rectangle region on
the screen, so it has width and height.  It can be organized
hierarchically, i.e. a window can be placed within another window;
so it has a pointer to the parent window.  And we specify the
window's position, x, y, by the coordinate relative to its
parent window.  Finally, we create a "root" window that
covers entire screen.  It also serves the default parent window.
So far, what we get is something like this:

@example
;; The first version
(define-class <window> ()
  (;; Pointer to the parent window.
   (parent      :init-keyword :parent :init-form *root-window*)
   ;; Sizes of the window
   (width       :init-keyword :width  :init-value 1)
   (height      :init-keyword :height :init-value 1)
   ;; Position of the window relative to the parent.
   (x           :init-keyword :x :init-value 0)
   (y           :init-keyword :y :init-value 0)
   ))

(define *screen-width* 1280)
(define *screen-height* 1024)

(define *root-window*
  (make <window> :parent #f :width *screen-width* :height *screen-height*))
@end example

Note the usage of @code{:init-value} and @code{:init-form}.
When the @code{<window>} class is defined, we haven't bound
@code{*root-window*} yet, so we can't use @code{:init-value} here.

@example
gosh> *root-window*
#<<window> 0x80db1d0>
gosh> (define window-a (make <window> :width 100 :height 100))
window-a
gosh> (d window-a)
#<<window> 0x80db1b0> is an instance of class <window>
slots:
  parent    : #<<window> 0x80db1d0>
  width     : 100
  height    : 100
  x         : 0
  y         : 0
gosh> (define window-b
        (make <window> :parent window-a :width 50 :height 20 :x 10 :y 5))
window-b
gosh> (d window-b)
#<<window> 0x80db140> is an instance of class <window>
slots:
  parent    : #<<window> 0x80db1b0>
  width     : 50
  height    : 20
  x         : 10
  y         : 5
@end example

If you're like me, you don't want to expose a global variable
such as @code{*root-window*} for users of your toolkit.
One way to encapsulate it (to certain extent) is to keep
the pointer to the root window in a class variable.
Add the following slot option to the definition of @code{<window>},
and the slot @code{root-window} of the @code{<window>} class
refers to the same storage space.

@example
(define-class <window> ()
  (...
   ...
   (root-window :allocation :class)
   ...))
@end example

You can use @code{slot-ref} and @code{slot-set!} on an instance
of @code{<window>},
or use @code{class-slot-ref} and @code{class-slot-set!} on the
@code{<window>} class itself,
to get/set the value of the @code{root-window} slot.

The users of the toolkit may want to get the absolute position
of the window (the coordinates in the root window) instead of
the relative position.  You may provide virtual slots that
returns the absolute positions, like the following:

@example
(define-class <window> ()
  (...
   ...
   (root-x :allocation :virtual
           :slot-ref  (lambda (o)
                        (if (ref o 'parent)
                            (+ (ref (ref o 'parent) 'root-x)
                               (ref o 'x))
                            (ref o 'x)))
           :slot-set! (lambda (o v)
                        (set! (ref o 'x)
                              (if (ref o 'parent)
                                  (- v (ref (ref o 'parent) 'root-x))
                                  v)))
            )
    ...))
@end example

Whether providing such interface via methods or virtual slots is
somewhat a matter of taste.   Using virtual slots has an advantage
of being able to hide the change of implementation, i.e. you can
change to keep @code{root-x} in a real slot and make @code{x} a virtual
slot later without breaking the code using @code{<window>}.
(In the mainstream object-oriented languages,
such kind of "hiding implementation" is usually achieved
by hiding instance variables and exposing methods.  In Gauche
and other CLOS-like systems, slots are always visible to the
users, so the situation is a bit different.

@c ----------------------------------------------------------------------
@node Instance, Generic function and method, Class, Object system
@section Instance
@c NODE インスタンス

In this section, we explain how to create and use an instance.

@menu
* Creating instance::           
* Accessing instance::          
* Changing classes::            
@end menu

@node Creating instance, Accessing instance, Instance, Instance
@subsection Creating instance
@c NODE インスタンスの作成

Using class object, you can create an instance of the class
by a generic function @code{make}.
A specialized method for standard @code{<class>} is defined:

@deffn {Generic Function} make
@deffnx {Method} make (class <class>) arg @dots{}
Creates an instance of @var{class} and returns it.
@var{Arg} @dots{} is typically a keyword-value list
to initialize the instance.
@end deffn

Conceptually, the default @code{make} method is defined
as follows:

@example
(define-method make ((class <class>) . initargs)
  (let ((obj (allocate-instance class initargs)))
    (initialize obj initargs)
    obj))
@end example

That is, first it allocates memory for @var{class}'s instance,
then initialize it with the @code{initialize} method.

@deffn {Generic Function} allocate-instance
@deffnx {Method} allocate-instance (class <class>) initargs
Returns a newly-allocated uninitialized instance of @var{class}.
@end deffn

@deffn {Generic Function} initialize
@deffnx {Method} initialize (obj <object>) initargs
The default initialize method for @code{<object>} works as follows:

@itemize @bullet
@item
For each initializable slot of the class
@itemize @bullet
@item
If (the slot has the :init-keyword slot option
AND the keyword appears in @var{initargs}):
Then the corresponding value is used to initialize the slot
@item
Else if the slot has :init-value slot option:
Then the value given to the slot option is used to initialize the slot
@item
Else if the slot has :init-thunk slot option:
Then the thunk is called, and the returned value is used to initialize
the slot.
@item
Else: The slot is left unbound.
@end itemize
@end itemize

Among the default slot allocation classes, only
instance-allocated slots are initializable and are handled by
the above sequence.   Class-allocated slots (e.g. its
slot allocation is either @code{:class} or @code{:each-subclass})
are initialized when the class object is created, if
@code{:init-value} or @code{:init-form} slot option is given.
Virtual slots aren't initialized at all.

An user-defined allocation class can be
configured either initializable or not initializable; see
@ref{Metaobject protocol} for the details.

If you specialize @code{initialize} method, make sure to call
@code{next-method} so that the slots are properly initialized
by the default sequence, before accessing any slot of the
newly created instance.
@end deffn

Typically you specialize @code{initialize} method for
your class to customize how the instance is initialized.

It is not common to specialize @code{allocate-instance} method.
However, knowing that how @code{make} works, you can specialize
@code{make} itself to avoid allocation of instance in
some circumstances (e.g. using pre-allocated instances).

@node Accessing instance, Changing classes, Creating instance, Instance
@subsection Accessing instance
@c NODE インスタンスへのアクセス

@subsubheading Standard accessors

@defun slot-ref obj slot
Returns a value of the slot @var{slot} of object @var{obj}.

If the specified slot is not bound to any value, a generic function
@code{slot-unbound} is called with three arguments, @var{obj}'s class,
@var{obj}, and @var{slot}.  The default behavior of @code{slot-unbound}
is to signal an error.

If the object doesn't have the specified slot,
a generic function @code{slot-missing} is called with three
arguments, @var{obj}'s class,
@var{obj}, and @var{slot}.  The default behavior of @code{slot-missing}
is to signal an error.
@end defun

@defun slot-set! obj slot value
Alters the value of the slot @var{slot} of object @var{obj} to
the value @var{value}.

If the object doesn't have the specified slot, a generic function
@code{slot-missing} is called with four arguments,
@var{obj}'s class, @var{obj}, @var{slot}, @var{value}.
@end defun

@defun slot-bound? obj slot
Returns true if object @var{obj}'s slot @var{slot} is bound, 
otherwise returns false.

If the object doesn't have the specified slot, a generic function
@code{slot-missing} is called with three arguments,
@var{obj}'s class, @var{obj}, @var{slot}.
@end defun

@defun slot-exists? obj slot
Returns true if @var{obj} has the slot named @var{slot}.
@end defun

@defun slot-push! obj slot value
This function implements the common idiom.
It can be defined like the following code
(but it may be optimized in the future versions).
@example
(define (slot-push! obj slot value)
  (slot-set! obj slot (cons value (slot-ref obj slot))))
@end example
@end defun

@deffn {Method} ref (obj <object>) (slot <symbol>)
@deffnx {Method} {(setter ref)} (obj <object>) (slot <symbol>) value
These methods just calls @code{slot-ref} and @code{slot-set!}, respectively.
They are slightly less efficient than directly calling @code{slot-ref}
and @code{slot-set!}, but more compact in the program code.
@end deffn

@subsubheading Fallback methods

@deffn {Generic Function} slot-unbound
@deffnx {Method} slot-unbound (class <class>) obj slot
This generic function is called when an unbound slot value is
retrieved.  The return value of this generic function will be
returned to the caller that tried to get the value.

The default method just signals an error.
@end deffn

@deffn {Generic Function} slot-missing
@deffnx {Method} slot-missing (class <class>) obj slot &optional value
This generic function is called when a non-existent slot
value is retrieved or set.  The return value of this generic
function will be returned to the caller that tried to get the value.

The default method just signals an error.
@end deffn

@subsubheading Special accessors

@defun class-slot-ref class slot-name
@defunx class-slot-set! class slot-name obj
@defunx class-slot-bound? class slot-name obj
When slot's @code{:allocation} option is either @code{:class}
or @code{:each-subclass}, these procedures allow you to
get/set the value of the slot without having an instance.
@end defun

@deffn {Method} slot-ref-using-class (class <class>) (obj <object>) slot-name
@deffnx {Method} slot-set-using-class! (class <class>) (obj <object>) slot-name value
@deffnx {Method} slot-bound-using-class? (class <class>) (obj <object>) slot-name
Generic function version of @code{slot-ref}, @code{slot-set!} and
@code{slot-bound?}.   @var{Class} must be the class of @var{obj}.

Besides being generic, these functions are different from
their procedural versions that they don't trigger class
redefinition when @var{obj}'s class has been redefined
(i.e. in which case, @var{class} should be the original class
of @var{obj}).

Note: Unlike CLOS, @code{slot-ref} etc. don't call the generic
function version in it, so you can't customize the behavior
of @code{slot-ref} by specializing @code{slot-ref-using-class}.
So the primary purpose of those generic functions are to be
used within @code{change-class} method; especially, @code{slot-ref} etc.
can't be used during @var{obj}'s being redefined, since they
trigger class redefinition again (see @ref{Changing classes} for details).
@end deffn

@node Changing classes,  , Accessing instance, Instance
@subsection Changing classes
@c NODE クラスの変更

@subsubheading Class change protocol

An unique feature of CLOS-family object system is that
you can change classes of an existing instance.  The two
classes doesn't need to be related; you can change a sewing
machine into an umbrella, if you like.

@deffn {Generic Function} change-class
@deffnx {Method} change-class (obj <object>) (new-class <class>)
Changes an object @var{obj}'s class to @var{new-class}.
The default method just calls @code{change-object-class} procedure.
@end deffn

@defun change-object-class obj orig-class new-class
Changes an object @var{obj}'s class from @var{orig-class} to
@var{new-class}.  This isn't a generic function---changing object's
class needs some secret magic, and this procedure encapsulates it.

The precise steps of changing class are as follow:

@enumerate
@item
A new instance of @var{new-class} is allocated by @code{allocate-instance}.

@item
For each slot of @var{new-class}:
@enumerate
@item
If the slot also exists in @var{old-class}, and is bound in @var{obj},
the value is retrieved from @var{obj} and set to the new instance.
(The slot is @emph{carried over}).
@item
Otherwise, the slot of the new instance is initialized by standard
slot initialization protocol, as described in @ref{Creating instance}.
@end enumerate

@item
Finally, the content of the new instance is @emph{transplanted} to
the @var{obj}---that is, @var{obj} becomes the instance of @var{new-class}
without changing its identity.
@end enumerate

Note that @code{initialize} method of @var{new-class} 
isn't called on @var{obj}.
If you desire, you can call it by your own @code{change-class} method.

@code{Change-object-class} returns @var{obj}.
@end defun

Usually a user is not supposed to call @code{change-object-class} directly.
Instead, she can define a specialized @code{change-class}.  For example,
if she wants to carry over the slot @code{x} of old class to the
slot @code{y} of new class, she may write something like this:

@example
(define-method change-class ((obj <old-class>) <new-class>)
  (let ((old-val (slot-ref obj 'x)))
    (next-method)               ;; calls default change-class
    (slot-set! obj 'y old-val)  ;; here, obj's class is already <new-class>.
    obj))
@end example

@subsubheading Customizing instance update

Updating an instance for a redefined class is also handled
as class change.  When an object is accessed via normal
slot accessor/modifier, its class is checked whether
it has been redefined.  And if it has indeed been redefined,
@code{change-class} is called with the
redefined class as @var{new-class}; that is, updating
an instance is regarded as changing object's class from
the original one to the redefined one.

By specializing @code{change-class}, you can customize the
way an instance is updated for a redefined class.
However, you need a special care to write @code{change-class}
for class redefinition.

First, the redefinition changes global binding of the class object.
So you need to keep the reference to the old class before
redefining the class, and use the old class to specialize 
@code{change-class} method:

@example
;; save old <myclass>
(define <old-myclass> <myclass>)

;; redefine <myclass>
(define-class <myclass> ()
  ...)

;; define customized change-class method
(define-method change-class ((obj <old-myclass>) <myclass>)
  ...
  (next-method)
  ...)
@end example

Next, note that the above @code{change-class} method may be
triggered implicitly when you access to @var{obj} via
@code{slot-ref}, @code{slot-set!}, @code{class-of}, etc.
If you use such procedures like @code{slot-ref} on @var{obj}
again within @code{change-class}, it would trigger the
instance update protocol recursively, which would cause
an infinite loop.
You can only use the methods that doesn't trigger
instance update, that is, @code{slot-ref-using-class},
@code{slot-set-using-class!}, @code{slot-bound-using-class?}
and @code{current-class-of}.

If you want to carry over a slot whose value is calculated
procedurally, such as a virtual slot, then @code{slot-ref} etc.
might be called implicitly on @var{obj} during calculating the
slot value.  Actually @code{change-object-class} has a
special protection to detect such a recursion.  If that
happens, @code{change-object-class} gives up to retrieve
the slot value and just initializes the slot of the new instance
as if the old slot were unbound.

Customizing instance update is highly tricky business,
although very powerful.   You can find some nontrivial
cases in the test program of Gauche source code;
take a look at @code{test/object.scm}.

@c ----------------------------------------------------------------------
@node Generic function and method, Metaobject protocol, Instance, Object system
@section Generic function and method
@c NODE ジェネリックファンクションとメソッド

@subheading Defining methods

@defmac define-generic name &keyword class
Creates a generic function and bind it to @var{name}.

You don't usually need to use this, since the @code{define-method}
macro implicitly creates a generic function if it doesn't exist yet.

You can pass a subclass of @code{<generic>} to the @var{class}
keyword argument so that the created generic function will be the
instance of the passed class, instead of the default @code{<generic>} class.
It is useful when you defined a subclass of @code{<generic>} to customize
generic function application behavior.
@end defmac

@defmac define-method name specs body
Defines a method whose name is @var{name}.  If there's already
a generic function object globally bound to @var{name}, the created
method is added to the generic function.  If @var{name} is unbound,
or bound to an object except a generic function, then a new generic
function is created, bound to @var{name}, then a new method is
added to it.

@var{Specs} specifies the arguments and their types for this method.
It's like the argument list of lambda form, except you can specify
the type of each argument.

@example
@i{specs} : ( @i{arg} @dots{} )
      | ( @i{arg} @dots{} . @i{symbol} )
      | @i{symbol}

@i{arg}   : ( @i{symbol} @i{class} )
      | @i{symbol}
@end example

@i{Class} specifies the class that the argument has to belong to.
If @code{@i{arg}} is just a symbol, it is equivalent to 
@code{(@i{arg} <top>)}.  You can't specify the type for
the "rest" argument, for it is always bound to a list.

The list of classes of the argument list is called
@emph{method specializer list}, based on which the generic
function will select appropriate methods(s).
Here are some examples of @var{specs} and the corresponding 
specializer list:

@example
specs:        ((self <myclass>) (index <integer>) value)
specializers: (<myclas> <integer> <top>)

specs:        ((self <myclass>) obj . options)
specializers: (<myclas> <top> . <top>)

specs:        (obj (attr <string>))
specializers: (<top> <string>)

specs:        args
specializers: <top>
@end example

If you define a method on @var{name} whose specializer list matches with
one in the generic function's methods, then the existing method is
replaced by the newly defined one.
@end defmac

@subheading Applying generic function

When a generic function is applied, first it selects
methods whose specializer list matches the given arguments.
For example, suppose a generic function @code{foo} has
three methods, whose specializer lists are 
@code{(<string> <top>)}, @code{(<string> <string>)}, 
and @code{(<top> <top>)}, respectively.
When @code{foo} is applied like @code{(foo "abc" 3)},
the first and the third method will be selected.

Then the selected methods are sorted from the most
@emph{specific} method to the least specific method.
It is calculated as follows:

@itemize
@item
Suppose we have a method @code{a} that has 
specializers @code{(A1 A2 @dots{})}, and
a method @code{b} that has @code{(B1 B2 @dots{})}.

@item
Find the minimum @var{n} where the classes @code{An} and @code{Bn}
differ.   Then the class of @var{n}-th argument is taken,
and its class precedence list is checked.
If @code{An} comes before @code{Bn} in the CPL, then
method @code{a} is more specific than @code{b}.
Otherwise, @code{b} is more specific than @code{a}.

@item
If all the specializers of @code{a} and @code{b} are the same,
except that one has an improper tail ("rest" argument)
and another doesn't, then the method that doesn't have an improper
tail is more specific than the one that has.
@end itemize

Once methods are sorted, the body of the first method is
called with the actual argument.

Within the method body, a special local variable @code{next-method}
is bound implicitly.

@deffn {Next method} next-method 
@deffnx {Next method} next-method args @dots{}
This variable is bound within a method body
to a special object that encapsulates
the next method in the sorted method list.

Calling without arguments invokes the next method with
the same arguments as this method is called with.
Passing @var{args} @dots{} explicitly invokes the next method
with the passed arguments.

If @code{next-method} is called in the least specific method,
i.e. there's no "next method", an error is signalled.
@end deffn

@c ----------------------------------------------------------------------
@node Metaobject protocol,  , Generic function and method, Object system
@section Metaobject protocol
@c NODE メタオブジェクトプロトコル

In CLOS-like object systems, the object system is built on
top of itself---that is, things such as the structure of the class,
how a class is created, how an instance is created and initialized,
and how a method is dispatched and called, are all defined in terms
of the object system.  For example, a class is just an instance of
the class @code{<class>} that defines a generic structure and behavior 
of standard classes.  If you subclass @code{<class>}, then you can
create your own set of classes that behaves differently than the
default behavior; in effect, you are creating your own object system.

@emph{Metaobject protocols} are the definitions of APIs concerning
about how the object systems are built---building-block classes,
and the names and orders of generic functions to be called
during operations of the object system.  Subclassing these classes
and specializing these methods are the means of customizing object
system behaviors.

@menu
* Class instantiation::         
* Customizing slot access::     
* Method instantiation::        
* Customizing method application::  
@end menu


@node Class instantiation, Customizing slot access, Metaobject protocol, Metaobject protocol
@subsection Class instantiation
@c NODE クラスのインスタンシエーション

Every class is an instance of a group of special classes.
A class that can be a class of another class is called @emph{metaclass}.
In Gauche, only the @code{<class>} class or its subclasses
can be a metaclass.

@subsubheading Expansion of @code{define-class}

The @code{define-class} macro is basically a wrapper of
the code that creates an instance of @code{<class>} 
(or specified metaclass) and bind it to the given name.
Suppose you have the following @code{define-class} form.
@example
(define-class @var{name} (@var{supers})
  @var{slot-specs}
  @var{options} @dots{})
@end example

It is expanded into a form like this (you can see the exact form 
by looking at the definition of @code{define-class} macro in
@file{`gauche-config --syslibdir`/gauche/object.scm}).
@example
(define @var{name}
  (let ((tmp1 (make @var{metaclass} 
                 :name '@var{name} :supers (list @var{supers})
                 :slots (map @var{process-slot-definitions}
                             @var{slot-specs})
                 :defined-modules (list (current-module))
                 @var{options} @dots{})))
    @dots{} @var{check class redefinition} @dots{}
    @dots{} @var{registering accessor methods} @dots{}
    tmp1))
@end example

The created class's class, i.e. @var{metaclass}, 
is determined by the following rules.

@enumerate
@item
If @code{:metaclass} option is given to the @code{define-class}
macro, its value is used.  The value must be the @code{<class>}
class or its descendants.
@item
Otherwise, the metaclasses of the classes in the class precedence list
is examined.
@itemize @bullet
@item
If all the metaclasses are @code{<class>}, then
the created class's metaclass is also @code{<class>}. 
@item
If all the metaclasses are either @code{<class>} or another metaclass
@code{A}, then the created class' metaclass is @code{A}.
@item
If the set of metaclasses contains more than one metaclass
(@code{A}, @code{B}, @code{C} @dots{}) other than @code{<class>},
then the created class' metaclass
is a metaclass that inherits all of those metaclasses
@code{A}, @code{B}, @code{C} @dots{}.
@end itemize
@end enumerate

The class's name, superclasses, and slot definitions are passed
as the initialization arguments to the @code{make} generic function,
with other arguments passed to @code{define-class}.
The initialization argument @code{defined-modules} is passed to
remember which module the class is defined, for the redefinition of
this class.

The slot specifications @var{slot-specs} are processed
by internal method @var{process-slot-definitions}
(which can't be directly called) to be turned
into slot definitions.  Specifically, an @code{:init-form} slot
option is turned into an @code{:init-thunk} option, and
@code{:getter}, @code{:setter} and @code{:accessor} slot
options are quoted.

After the class (an instance of @var{metaclass}) is created,
the global binding of @var{name} is checked.  If it is bound
to a class, then the class redefinition protocol is invoked
(see @ref{Class redefinition}).

Then, the methods given to @code{:getter}, @code{:setter} 
and @code{:accessor} slot options in @var{slot-spec} are
collected and registered to the corresponding generic functions.

@subsubheading Class structure

@deftp {Class} <class>
@clindex class
The base class of all metaclasses, @code{<class>}, has
the following slots.  Note that these slots are for internal management,
and users shouldn't change their values after
the class is initialized.  It is recommended to obtain information
about a class by procedures described in @ref{Class object}, instead
of directly accessing those slots.

@defivar <class> name
The name of the class; the symbol given to @code{define-class} macro.
@code{class-name} returns this value.
@end defivar

@defivar <class> cpl
Class precedence list.  @code{class-precedence-list} returns this value.
@end defivar

@defivar <class> direct-supers
The list of direct superclasses.
@code{class-direct-supers} returns this value.
@end defivar

@defivar <class> accessors
An assoc list of slot accessors---it encapsulates how each slot
should be accessed.
@end defivar

@defivar <class> slots
A list of slot definitions.  @code{class-slots} returns this value.
See @ref{Slot definition object}, for the details of slot definitions.
@end defivar

@defivar <class> direct-slots
A list of slot definitions that is directly specified in this
class definition (i.e. not inherited).
@code{class-direct-slots} returns this value.
@end defivar

@defivar <class> num-instance-slots
The number of instance allocated slots.
@end defivar

@defivar <class> direct-subclasses
A list of classes that directly inherits this class.
@code{class-direct-subclasses} returns this value.
@end defivar

@defivar <class> direct-methods
A list of methods that has this class in its specializer list.
@code{class-direct-methods} returns this value.
@end defivar

@defivar <class> initargs
The initialization argument list when this class is created.
The information is used to initialize redefined class
(see @ref{Class redefinition}).
@end defivar

@defivar <class> defined-modules
A list of modules where this class has a global binding.
@end defivar

@defivar <class> redefined
If this class has been redefined, this slot contains a reference
to the new class.  Otherwise, this slot has @code{#f}.
@end defivar

@defivar <class> category
The value of this slot indicates how this class is created.
Scheme defined class has a symbol @code{scheme}.  Other values
are for internal use.
@end defivar
@end deftp

@subsubheading The make method for @code{<class>}

@deffn {Method} make (class <class>) &rest initargs
@end deffn


@node Customizing slot access, Method instantiation, Class instantiation, Metaobject protocol
@subsection Customizing slot access
@c NODE スロットアクセスのカスタマイズ


@deffn {Generic Function} compute-slots
@end deffn

@deffn {Generic Function} compute-get-n-set
@end deffn

@defun slot-ref-using-accessor obj slot-accessor
@defunx slot-set-using-accessor obj slot-accessor value
@end defun

@node Method instantiation, Customizing method application, Customizing slot access, Metaobject protocol
@subsection Method instantiation
@c NODE メソッドのインスタンシエーション

@deffn {Method} make (class <method>) &rest initargs
@end deffn

@node Customizing method application,  , Method instantiation, Metaobject protocol
@subsection Customizing method application
@c NODE メソッド適用のカスタマイズ

@deffn {Generic Function} apply-generic gf args
@end deffn

@deffn {Generic Function} sort-applicable-methods gf methods args
@end deffn

@deffn {Generic Function} method-more-specific? method1 method2 classes
@end deffn

@deffn {Generic Function} apply-methods gf methods args
@end deffn

@deffn {Generic Function} apply-method gf method build-next args
@end deffn
@node Library modules - Overview, Library modules - Gauche extensions, Object system, Top
@chapter Library modules - Overview
@c NODE ライブラリモジュール - 概要

In the following chapters, we explain library modules bundled with Gauche's
distribution.
These modules should generally be loaded and imported (usually using @code{use}
- @xref{Using modules}, for details), unless otherwise noted.

Some modules are described as "autoloaded".  That means you don't need
to @code{load} or @code{use} the module explicitly; at the first time
the bindings are used in the program, the module is automatically
loaded and imported.  See @ref{Autoload}, for the details of autoloading.

As the number of bundled libraries grows, it becomes harder
to find the one you need.  If you feel lost, check
out the section @ref{Finding libraries you need}, in which
we categorize libraries by their purposes.

The following three chapters describe bundled modules,
grouped by their names.  
@ref{Library modules - Gauche extensions} contains a description of
@code{gauche.*} modules, which are more or less considered
the core features of Gauche but separated since less frequently used.
(Some modules are rather ad-hoc, but here for historical reasons).
@ref{Library modules - SRFIs} describes the modules which
provide SRFI functionalities.  They have the names beginning
with @code{srfi-}.
Note that some of SRFI features are built in Gauche core and
not listed here.  @xref{Standard conformance}, for the entire list
of supported SRFIs.
@ref{Library modules - Utilities} describes other modules
---including database interface, filesystem utilities,
network protocol utilities, and more.

There are a few procedures that help your program to check
the existence of certain modules or libraries at run-time.
See @ref{Operations on libraries}, for the details.

@menu
* Finding libraries you need::  
* Naming convention of libraries::  
@end menu

@node Finding libraries you need, Naming convention of libraries, Library modules - Overview, Library modules - Overview
@section Finding libraries you need
@c NODE 必要なライブラリの探し方

Each module is named more or less after what it implements
rather than what it is implemented @emph{for}.  If the module solves
one problem, both are the same.  However, sometimes there
are multiple ways to solve a problem, or one implementation
of an algorithm can solve multiple different problems; thus
it is difficult to name the modules in problem-oriented
(or purpose-oriented) way.

Because of this, it may not be straightforward for a newcomer
to Gauche to find an appropriate Gauche module to solve her problem,
since there may be multiple algorithms to do the job,
and each algorithm can be implemented in different modules.

The modules are also designed in layers; some low-level modules
provide direct interface to the system calls, while some
higher-level ones provide more abstract, easy-to-use interface, possibly
built on top of more than one low-level modules.   Which one
should you use?  Generally you want to use the highest level,
for the very purpose of libraries are to provide easy, abstract
interface.  However there are times that you have to break
the abstraction and to go down to tweak the machinery in
the basement; then you need to use low-level modules directly.

The purpose of this section is to group the libraries by
their purposes.  Each category lists relevant modules with
brief descriptions.

@menu
* Library directory - data containers::  
* Library directory - strings and characters::  
* Library directory - data exchange::  
* Library directory - files::   
* Library directory - processes::  
* Library directory - networking::  
* Library directory - input and output::  
* Library directory - time::    
* Library directory - bits and bytes::  
@end menu

@node Library directory - data containers, Library directory - strings and characters, Finding libraries you need, Finding libraries you need
@subsection Library directory - data containers
@c NODE ライブラリディレクトリ - データコンテナ

@subsubheading Generic container operations

Some data containers have similar properties; for example,
lists, vectors and hash tables can be seen as a collection
of data.  So it is handy to have generic operators, such
as applying a procedure to all the elements.

Gauche provides such mechanism to a certain degree, mainly using
its object system.

@itemize @bullet
@item
@emph{Collection} - Generic functions applicable for unordered
set of values.  @xref{Collection framework}.
@item
@emph{Sequence} - Generic functions applicable for ordered set
of values.  @xref{Sequence framework}.
@item
@emph{Relation} - Generic functions to handle relations
(in a sense of Codd's definition).  @xref{Relation framework}.
@item
@emph{Comprehension} - This is a collection of macros very handy
to construct and traverse collections/sequences in concise code.
@xref{Eager comprehensions}.
@end itemize

@subsubheading Container implementations
@itemize @bullet
@item
@emph{List} - the universal data structure.  You want to check
@ref{Pairs and Lists}, @ref{List library}, 
and @ref{Additional list library}.
@item
@emph{Vector} - a one-dimensional array of arbitrary Scheme values.
See @ref{Vectors} and @ref{Vector library}.
@item
@emph{Uniform vector} - a special kind of vectors that can hold
limited types of values (e.g. integers representable in 8bits).
It tends to be used in performance
sensitive applications, such as graphics.  See @ref{Uniform vectors}.
@item
@emph{Array} - multi-dimensional arrays that can hold
arbitrary Scheme values.  See @ref{Arrays}.
@item
@emph{Uniform array} - multi-dimensional arrays that can hold
limited types of values.  This is also supported by @ref{Arrays}.
@item
@emph{String} - a sequence of characters.  See @ref{Strings}
and @ref{String library}.  Gauche handles multibyte strings---
see @ref{Multibyte Strings} for the defatils.
@item
@emph{Character set} - a set of characters.  See @ref{Character set}
and @ref{Character-set library}.
@item
@emph{Hash table} - hash tables.  See @ref{Hashtables}.  There are
also some conversion functions in @ref{Additional list library}.
@item
@emph{Queue} - a simple queue is provided in @ref{Queue}.
@item
@emph{Record} - a simple data structure.  Although Gauche's object
system can be used to define arbitrary data structures, you might
want to look at @ref{Record types} and @ref{SLIB-compatible record type},
for they are more portable and potentially more efficient.
@item
@emph{Stream} - you can implement cool lazy algorithms with it.
See @ref{Stream library}.
@item
@emph{Balanced tree} - Red-black tree implementation is available.
See @ref{Treemaps}.
@item
@emph{Trie} - Another tree structure for efficient common-prefix
search.  See @ref{Trie}.
@item
@emph{Database interface} - dbm interface can be used as a
persistent hash table; see @ref{Generic DBM interface}.
For generic RDBMS interface, see @ref{Database independent access layer}.
@end itemize

@node Library directory - strings and characters, Library directory - data exchange, Library directory - data containers, Finding libraries you need
@subsection Library directory - string and character
@c NODE ライブラリディレクトリ - 文字列と文字

Basic string operations are covered in
@ref{Strings} and @ref{String library}.
A string is also a sequence of characters, so you can
apply methods in @ref{Collection framework} and
@ref{Sequence framework}.

Character and character set operations are covered in
@ref{Characters}, @ref{Character set}, and @ref{Character-set library}.

If you scan or build strings sequentially, do not use index
access.  String ports (see @ref{String ports}) provides more efficient,
and elegant way.

You can use regular expressions to search and extract
character sequences from strings; see @ref{Regular expression}.

If you need to deal with low-level (i.e. byte-level)
representation of strings, @ref{Uniform vectors} has some
tools to convert strings and byte vectors back and forth.

Are you dealing with a structure higher than a mere sequence
of characters?  Then take a look at  @code{text.*} modules.
@ref{Parsing input stream} has some basic
scanners.  @ref{Transliterate characters} implements a
feature similar to Unix's @code{tr(1)}.  
You can take @code{diff} of two texts; see
@ref{Calculate difference of text streams}.
And if you want to construct large text from string fragments,
do not use @code{string-append}---see @ref{Lazy text construction}.

Last but not least, Gauche has support of various character
encoding schemes.  See @ref{Character code conversion} for
the basic utilities.  Most higher-level functions such as
@code{open-input-file} can take @code{:encoding} keyword argument
to perform character conversion implicitly.  Also see 
@ref{Multibyte scripts} if you write Scheme program in
non-ASCII characters.  If you want to process Gauche source code
which may contain "encoding" magic comment, see @ref{Coding-aware ports}.
Gauche also has GNU gettext compatible module (@ref{Localized messages})
if you need localization.


@node Library directory - data exchange, Library directory - files, Library directory - strings and characters, Finding libraries you need
@subsection Library directory - data exchange
@c NODE ライブラリディレクトリ - データ交換

Most useful programs need to communicate with outside world
(other programs or humans).  That involves reading the external data
into your program understanding whatever format the data is in, and
also writing the data in the format the others can understand.

Lots of network-related external formats are defined in RFC,
and there are corresponding @code{rfc.*} module that handle 
some of them.  See @ref{RFC822 message parsing}, for example,
to handle the pervasive RFC2822 message format.

When you exchange table-formatted data, one of the easiest way
may be the plain text, one row per line, and columns are separeted
by some specific characters (e.g. comma).  See @ref{CSV tables} for
basic parser/writer for them.

Oh, and nowadays every business user wants XML, right?  You know
they are just S-expressions with extra redundancy and pointy
parentheses.  So why don't you read XML as if they're S-exprs,
process them with familiar cars and cdrs and maps, then write them
out with extra redundancy and pointy parens?
Module @code{sxml.ssax} (@ref{Functional XML parser})
implements SAX XML parser, with which you
can parse XML and process them on the fly, or convert it to
SXML, S-expression XML.  You can query SXML using
SXPath, an XPath counterparts of S-expression (@ref{SXML Query Language}).
You can output all kinds of XML and HTML using the SXML serializer
(@ref{Serializing XML and HTML from SXML}).

It is planned that various file format handling routines would
be available as @code{file.*} modules, though we have none ready
yet.  If you plan to write one, please go ahead and let us know!

@node Library directory - files, Library directory - processes, Library directory - data exchange, Finding libraries you need
@subsection Library directory - files
@c NODE ライブラリディレクトリ - ファイル

Files and directories.  Roughly speaking, there are two places
you want to look at.

@ref{Filesystems}, in the core, has
routines close to the underlying OS provides.  If you have
experience with Unix system programming you'll find familiar
function names there.   The @code{fcntl} functionality is
splitted to @code{gauche.fcntl} (@ref{Low-level file operations}), FYI.

Also you definitely want to look at @code{file.util}
(@ref{Filesystem utilities}), which implements higher-level
routines on top of system-level ones.


@node Library directory - processes, Library directory - networking, Library directory - files, Finding libraries you need
@subsection Library directory - processes
@c NODE ライブラリディレクトリ - プロセス

Process-related routines also come in two levels.

The @code{gauche.process} module provides
high-level routines (@ref{High Level Process Interface}); 
you can pipe the data into and out of child processes easily, for example.

Gauche core provides the primitive @code{fork} and @code{exec} interface
as well as the convenient @code{system} call
(see @ref{Unix process management}).  Use them when you want a precise
control over what you're doing.

@node Library directory - networking, Library directory - input and output, Library directory - processes, Finding libraries you need
@subsection Library directory - networking
@c NODE ライブラリディレクトリ - ネットワーク

We have multi-layer abstraction here.  At the bottom, we have
APIs corresponding to socket-level system calls.  In the middle,
a convenience library that automates host name lookups, connection
and shutdown, etc.  On top of them we have several modules that
handles specific protocols (e.g. http).

The @code{gauche.net} module (@ref{Networking}) provides the bottom
and middle layer.  For the top layer, look for @code{rfc.*} modules,
e.g. @code{rfc.http} (@ref{HTTP}).
More protocol support is coming (there are @code{rfc.ftp} and
@code{rfc.imap4} written by users, which are waiting for being
integrated into Gauche---maybe in next release).

There's a plan of even higher level of libraries, under the name
@code{net.*}, which will abstract more than one network protocols.
The planned ones include sending emails, or
universal resource access by uri.  Code contributions are welcome.

@node Library directory - input and output, Library directory - time, Library directory - networking, Finding libraries you need
@subsection Library directory - input and output
@c NODE ライブラリディレクトリ - 入出力

@node Library directory - time, Library directory - bits and bytes, Library directory - input and output, Finding libraries you need
@subsection Library directory - time
@c NODE ライブラリディレクトリ - 時間

@node Library directory - bits and bytes,  , Library directory - time, Finding libraries you need
@subsection Library directory - bits and bytes
@c NODE ライブラリディレクトリ - ビットとバイト

@subsubheading Binary I/O

As the bottom level,
Gauche includes primitive byte I/O (@code{read-byte}, @code{write-byte})
as well as block I/O (@code{read-block!}, @code{write-block}) in its core.
(See @ref{Reading data}, @ref{Output}, and @ref{Uvector block I/O}).

As the middle level, the module @code{binary.io}
(@ref{Binary I/O}) has routines to retrieve specific datatype
with optional endian specification.

And as the top level, the module @code{binary.pack}
(@ref{Packing Binary Data}) allows packing and unpacking structured
binary data, a la Perl's @code{pack}/@code{unpack}.

@subsubheading Bit manipulation

Gauche core provides bitshift and mask operations. 
See @ref{Bitwise operations}.

@node Naming convention of libraries, ,Finding libraries you need, Library modules - Overview
@section Naming convention of libraries
@c NODE ライブラリの命名規則

The following table summarizes naming categories of the modules,
including external ones and planned ones.

@table @code
@item binary.*
Utilities to treat binary data.

@item compat.*
Provides compatibility layers.

@item dbi.*, dbd.*
Database independent interface layer and drivers.

@item dbm.*
DBM interface

@item gauche.*
Stuffs more or less considered as Gauche core features.

@item gl.*
OpenGL binding and related libraries (external package).

@item gtk.*
GTk+ binding and related libraries (external package).

@item file.*
Manipulating files and directories.

@item lang.*
Language-related libraries, artificial and/or natural (planned).

@item math.*
Mathematics.

@item compat.*
Compatibility libraries

@item rfc.*
Implementations of net protocols defined in RFC's.

@item srfi-*
SRFI implementations.

@item sxml.*
SXML libraries.

@item text.*
Libraries dealing with text data.

@item util.*
Generic implementations of various algorithms.

@item www.*
Implementations of various protocols and formats mainly used in WWW.
@end table

@node Library modules - Gauche extensions, Library modules - SRFIs, Library modules - Overview, Top
@chapter Library modules - Gauche extensions
@c NODE ライブラリモジュール - Gauche拡張モジュール

@c ----------------------------------------------------------------------
@menu
* Arrays::                      gauche.array
* Character code conversion::   gauche.charconv
* Collection framework::        gauche.collection
* Configuration parameters::    gauche.config
* Dictionary framework::        gauche.dictionary
* Low-level file operations::   gauche.fcntl
* Hooks::                       gauche.hook
* Interactive session::         gauche.interactive
* Listener::                    gauche.listener
* User-level logging::          gauche.logger
* Singleton::                   gauche.mop.singleton
* Slot with validator::         gauche.mop.validator
* Networking::                  gauche.net
* Parameters::                  gauche.parameter
* Parsing command-line options::  gauche.parseopt
* High Level Process Interface::  gauche.process
* Reloading modules::           gauche.reload
* Simple dispatcher::           gauche.selector
* Sequence framework::          gauche.sequence
* Syslog::                      gauche.syslog
* Termios::                     gauche.termios
* Unit testing::                gauche.test
* Threads::                     gauche.threads
* Measure timings::             gauche.time
* Uniform vectors::             gauche.uvector
* Comparing version numbers::   gauche.version
* Virtual ports::               gauche.vport
@end menu

@node Arrays, Character code conversion, Library modules - Gauche extensions, Library modules - Gauche extensions
@section @code{gauche.array} - Arrays
@c NODE 配列, @code{gauche.array} - 配列

@deftp {Module} gauche.array
@mdindex gauche.array
This module provides multi-dimensional array data type and operations.
The primitive API follows SRFI-25. 
Besides a generic srfi-25 array that can store any Scheme objects,
this module also provides array classes that stores numeric objects
efficiently, backed up by
homogeneous numeric vectors (@xref{Uniform vectors}).
An external representation of arrays, using SRFI-10 mechanism,
is also provided.

Each element of an @var{N}-dimensional array can be accessed
by @var{N} integer indices,
@code{[ @var{i_0} @var{i_1} @dots{} @var{i_N-1} ]}.
An array has associated @var{shape} that knows lower-bound @var{s_k} and
upper-bound @var{e_k} of index of each dimension, where
@var{s_k} <= @var{e_k}, and the index @var{i_k} must satisfy
@var{s_k} <= @var{i_k} < @var{e_k}.
(Note: it is allowed to have @var{s_k} == @var{e_k}, but such array can't
store any data.  It is also allowed to have zero-dimensional array,
that can store a single data.).
The shape itself is a [ @var{D} x 2 ] array, where @var{D} is the
dimension of the array which the shape represents.

You can pass index(es) to array access primitives in a few ways;
each index can be passed as individual argument,
or can be 'packed' in a vector or one-dimensional array.
In the latter case, such a vector or an array is called an "index object".
Using a vector is efficient in Gauche when you iterate over the elements
by changing the vector elements, for it won't involve memory allocation.

Arrays can be compared by the @code{equal?} procedure.
@code{Equal?} returns @code{#t} if two arrays have the same
shape and their corresponding elements are the same
in the sense of @code{equal?}.

Internally, an array consists of a backing storage and a mapping procedure.
A backing storage is an object of aggregate type that can be accessed
by an integer index.  A mapping procedure takes
multi-dimensional indices (or index object) and 
returns a scalar index into the backing storage.
@end deftp

@deftp {Class} <array-base>
@clindex array-base
An abstract base class of array types, that implements generic operations
on the array.   To create an array instance,
you should use one of the following concrete array classes.
@end deftp

@deftp {Class} <array>
@deftpx {Class} <u8array>
@deftpx {Class} <s8array>
@deftpx {Class} <u16array>
@deftpx {Class} <s16array>
@deftpx {Class} <u32array>
@deftpx {Class} <s32array>
@deftpx {Class} <u64array>
@deftpx {Class} <s64array>
@deftpx {Class} <f16array>
@deftpx {Class} <f32array>
@deftpx {Class} <f64array>
@clindex array
@clindex u8array
@clindex s8array
@clindex u16array
@clindex s16array
@clindex u32array
@clindex s32array
@clindex u64array
@clindex s64array
@clindex f16array
@clindex f32array
@clindex f64array
Concrete array classes.  The @code{<array>} class implements srfi-25
compatible array, i.e. an array that can store any Scheme objects.
The @code{<u8array>} class through @code{<f64array>} classes uses
a @code{<u8vector>} through @code{<f64vector>} as a backing storage,
and can only store a limited range of integers or inexact real numbers,
but they are space efficient.
@end deftp


@deftp {Reader syntax} @code{#,(<array> @var{shape} @var{obj} @dots{})}
An array is written out in this format.  (Substitute @code{<array>} for
@code{<u8array>} if the array is @code{<u8array>}, etc.)
@var{shape} is a list
of even number of integers, and each 2@var{n}-th integer
and 2@var{n}+1-th integer specifies the
inclusive lower-bound and exclusive upper-bound of @var{n}-th dimension,
respectively.  The following @var{obj} @dots{} are the values in the array
listed in row-major order.

When read back, this syntax is read as an array with the same shape
and content, so it is @code{equal?} to the original array.

@example
; an array such that:
;   8 3 4
;   1 5 9
;   6 7 2
#,(<array> (0 3 0 3) 8 3 4 1 5 9 6 7 2)

; a 4x4 identity matrix
#,(<array> (0 4 0 4) 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1)
@end example
@end deftp

@defun array? obj
[SRFI-25]
Returns @code{#t} if @var{obj} is an array, @var{#f} otherwise.
It is equivalent to @code{(is-a? obj <array-base>)}.
@end defun

@defun make-array shape &optional init
[SRFI-25]
Creates an array of shape @var{shape}.
@var{Shape} must be a [ @var{D} x 2 ] array, and for each @var{k}
(0 <= @var{k} < @var{D}), the [ @var{k} 0 ] element must be less than or
equal to the [ @var{k} 1] element.
If @var{init} is given, all the elements are initialized by it.
Otherwise, the initial value of the elements are undefined.

@example
(make-array (shape 0 2 0 2 0 2) 5)
 @result{} #,(<array> (0 2 0 2 0 2) 5 5 5 5 5 5 5 5)
@end example
@end defun

@defun make-u8array shape &optional init
@defunx make-s8array shape &optional init
@findex make-u16array
@findex make-s16array
@findex make-u32array
@findex make-s32array
@findex make-u64array
@findex make-s64array
@dots{}
@end defun
@defun make-f32array shape &optional init
@defunx make-f64array shape &optional init
Like @code{make-array}, but creates and returns an uniform numeric array.
@end defun

@defun shape bound @dots{}
[SRFI-25]
Takes even number of exact integer arguments, and returns
a two-dimensional array that is suitable for representing the shape
of an array.

@example
(shape 0 2 1 3 3 5)
 @result{} #,(<array> (0 3 0 2) 0 2 1 3 3 5)

(shape)
 @result{} #,(<array> (0 0 0 2))
@end example
@end defun

@defun array shape init @dots{}
[SRFI-25]
Creates an array of shape @var{shape}, initializing its elements by
@var{init} @dots{}.

@example
(array (shape 0 2 1 3) 'a 'b 'c 'd)
 @result{} #,(<array> (0 2 1 3) a b c d)
@end example
@end defun

@defun array-rank array
[SRFI-25]
Returns the number of dimensions of an array @var{array}.

@example
(array-rank (make-array (shape 0 2 0 2 0 2))) @result{} 3
(array-rank (make-array (shape))) @result{} 0
@end example
@end defun

@defun array-shape array
Returns a shape array of @var{array}.
@end defun

@defun array-start array dim
@defunx array-end array dim
@defunx array-length array dim
[SRFI-25+]
@code{Array-start} returns the inclusive lower bound of index of
@var{dim}-th dimension of an array @var{array}.
@code{Array-end} returns the exclusive upper bound.
And @code{array-length} returns the difference between two.
@code{Array-start} and @code{array-end} are defined in SRFI-25.

@example
(define a (make-array (shape 1 5 0 2)))

(array-start a 0)  @result{} 1
(array-end a 0)    @result{} 5
(array-length a 0) @result{} 4
(array-start a 1)  @result{} 0
(array-end a 1)    @result{} 2
(array-length a 1) @result{} 2
@end example
@end defun

@defun array-size array
Returns the total number of elements in the array @var{array}.

@example
(array-size (make-array (shape 5 9 1 3))) @result{} 8
(array-size (make-array (shape))) @result{} 1
(array-size (make-array (shape 0 0 0 2))) @result{} 0
@end example
@end defun

@defun array-ref array k @dots{}
@defunx array-ref array index
[SRFI-25]
Gets the element of array @code{array}.  In the first form,
the element is specified by indices @var{k} @dots{}.
In the second form, the element is specified by an index object
@var{index}, which must be a vector or an one-dimensional array.
@end defun

@defun array-set! array k @dots{} value
@defunx array-set! array index value
[SRFI-25]
Sets the element of array @var{array} to @var{value}.  In the first form,
the element is specified by indices @var{k} @dots{}.
In the second form, the element is specified by an index object
@var{index}, which must be a vector or an one-dimensional array.
@end defun

@defun share-array array shape proc
[SRFI-25]
Creates and returns a new array of shape @var{shape}, that shares
the backing storage with the given array @var{array}.
The procedure @var{proc} maps the indices of the new array to
the indices to the original array, i.e. @var{proc} must be a @var{n}-ary
procedure that returns @var{m} values, where @var{n} is the dimension
of the new array and @var{m} is the one of the original array.
Furthermore, @var{proc} must be an affine function; each mapping
has to be a linear combination of input arguments plus optional constant.
(@code{Share-array} optimizes the mapping function based on the affinity
assumption, so @var{proc} won't be called every time the new array
is accessed).
@end defun

@defun array-for-each-index array proc &optional index
@end defun

@defun shape-for-each shape proc &optional index
@end defun

@defun tabulate-array shape proc &optional index
@end defun

@defun array-retabulate! array shape proc &optional index
@defunx array-retabulate! array proc &optional index
@end defun

@defun array-map! array shape proc array0 array1 @dots{}
@defunx array-map! array proc array0 array1 @dots{}
@end defun

@defun array-map shape proc array0 array1 @dots{}
@defunx array-map proc array0 array1 @dots{}
@end defun

@defun array->vector array
@defunx array->list array
@end defun

@defun array-concatenate a b &optional dimension
@end defun

@defun array-transpose array &optional dim1 dim2
@end defun

@defun array-rotate-90 array &optional dim1 dim2
@end defun

@defun array-flip array &optional dimension
@defunx array-flip! array &optional dimension
@end defun

@defun identity-array dimension &optional class
@end defun

@defun array-inverse array
@end defun

@defun determinant array
@defunx determinant! array
@end defun

@defun array-mul a b
@end defun

@defun array-expt array pow
@end defun

@defun array-div-left a b
@defunx array-div-right a b
@end defun

@defun array-add-elements array array-or-scalar @dots{}
@defunx array-add-elements! array array-or-scalar @dots{}
@end defun

@defun array-sub-elements array array-or-scalar @dots{}
@defunx array-sub-elements! array array-or-scalar @dots{}
@defunx array-mul-elements array array-or-scalar @dots{}
@defunx array-mul-elements! array array-or-scalar @dots{}
@defunx array-div-elements array array-or-scalar @dots{}
@defunx array-div-elements! array array-or-scalar @dots{}
@end defun

@c ----------------------------------------------------------------------
@node Character code conversion, Collection framework, Arrays, Library modules - Gauche extensions
@section @code{gauche.charconv} - Character Code Conversion
@c NODE 文字コード変換, @code{gauche.charconv} - 文字コード変換

@deftp {Module} gauche.charconv
@mdindex gauche.charconv
This module defines a set of functions that converts character encoding
schemes (CES) of the given data stream.
This module also overloads Gauche's file stream creating functions
(such as @code{open-input-file} and @code{call-with-output-file})
so that they accept @code{:encoding} keyword argument.

As of release 0.5.6, Gauche natively supports conversions between
typical Japanese character encodings: ISO2022JP, ISO2022JP-3,
EUC-JP (EUC-JISX0213), Shift_JISX0213, UTF-8 (Unicode 3.2).
Conversions between other encodings are handled by @code{iconv(3)}.
@xref{Supported character encoding schemes}, for details.
@end deftp

@menu
* Supported character encoding schemes::  
* Autodetecting the encoding scheme::  
* Conversion ports::            
* Extended port procedures::    
@end menu

@node Supported character encoding schemes, Autodetecting the encoding scheme, Character code conversion, Character code conversion
@subsection Supported character encoding schemes
@c NODE サポートされる文字エンコーディング

A CES is represented by its name as a string or a symbol.
Case is ignored.  There may be several aliases defined for a single encoding.

A CES name "none" is special.  When Gauche's native encoding is @code{none},
Gauche just treats a string as a byte sequence, and it's up to the application
to interpret the sequence in an appropriate encoding.  So, conversion
to and from CES "none" does nothing.

You can check whether the specific conversion is supported on
your system or not, by the following function.

@defun ces-conversion-supported? from-ces to-ces
Returns @code{#t} if conversion from the character encoding scheme
(CES) @var{from-ces} to @var{to-ces} is supported in this system.

Note that this procedure may return true even if system only supports
partial conversion between @var{from-ces} and @var{to-ces}.
In such case, actual conversion might lose information by coercing
characters in @var{from-ces} which are not supported in @var{to-ces}.
(For example, conversion from Unicode to EUC-JP is "supported",
although Unicode has characters that are not in EUC-JP).

Also note that this procedure always returns @code{#t} 
if @var{from-ces} and/or @var{to-ces} is "none",
for conversion to/from CES "none" always succeeds (in fact, it does nothing).

@example
;; see if you can convert the internal encoding to EUC-JP
(ces-conversion-supported? (gauche-character-encoding) "euc-jp")
@end example
@end defun

Also there are two useful procedures to deal with CES names.

@defun ces-equivalent? ces-a ces-b &optional unknown-value
Returns true if two CESes @var{ces-a} and @var{ces-b} are equivalent
to the knowledge of the system.  Returns false if they are not.
If the system doesn't know about equivalency, @var{unknown-value}
is returned, whose default is @code{#f}.

CES "none" works like a wild card; it is "equivalent" to any CES.
(Thus, @code{ces-equivalent?} is not transitive.  
The intended use of @code{ces-equivalent?}
is to compare two given CES names and see if conversion is required or not).

@example
(ces-equivalent? 'eucjp "EUC-JP")            @result{} #t
(ces-equivalent? 'shift_jis "EUC-JP")        @result{} #f
(ces-equivalent? "NoSuchEncoding" 'utf-8 '?) @result{} ?
@end example
@end defun

@defun ces-upper-compatible? ces-a ces-b &optional unknown-value
Returns true if a string encoded in CES @var{ces-b} can also
be regarded as a string encoded in @var{ces-a} without conversion,
to the knowledge of the system.  
Returns false if not.  Returns @var{unknown-value}
if the system can't determine which is the case.

Like @code{ces-equivalent?}, CES "none" works like a wildcard.
It is upper-compatible to any CES, and any CES is upper-compatible to
"none".

@example
(ces-upper-compatible? "eucjp" "ASCII")             @result{} #t
(ces-upper-compatible? "eucjp" "utf-8")             @result{} #f
(ces-upper-compatible? "utf-8" "NoSuchEncoding" '?) @result{} ?
@end example
@end defun

Conversion between common japanese CESes (EUC_JP, Shift JIS, UTF-8
and ISO2022-JP) of the character set JIS X 0201 and JIS X 0213
is handled by Gauche's built-in algorithm (see below for details).
When other CES name is given, Gauche uses
@code{iconv(3)} if it is linked.

When Gauche's conversion routine encounters a character that can't
be mapped, it replaces the character for "geta mark" (U+3013)
if it's a multibyte character in the input encoding, or for '?' if it's
a singlebyte character in the input encoding.
If that happens in iconv, handling of such character depends
on iconv implementation (glibc implementation returns an error).

If the conversion routine encounters an input sequence that
is illegal in the input CES, an error is signalled.

@strong{Details of Gauche's native conversion algorithm:}
Between EUC_JP, Shift JIS and ISO2022JP, Gauche uses arithmetic
conversion whenever possible.  This even maps the undefined codepoint
properly.  Between Unicode (UTF-8) and EUC_JP, Gauche uses lookup tables.
Between Unicode and Shift JIS or ISO2022JP, Gauche converts the
input CES to EUC_JP, then convert it to the output CES.
If the same CES is specified for input and output, Gauche's conversion
routine just copies input characters to output characters, without 
checking the validity of the encodings.

@table @code
@item EUC_JP, EUCJP, EUCJ, EUC_JISX0213
Covers ASCII, JIS X 0201 kana, JIS X 0212 and JIS X 0213 character sets.
JIS X 0212 character set is supported merely because it uses
the code region JIS X 0213 doesn't use, and JIS X 0212 characters
are not converted properly to Shift JIS and UTF-8.
Use JIS X 0213.

@item SHIFT_JIS, SHIFTJIS, SJIS
Covers Shift_JISX0213, except that 0x5c and 0x7e is mapped to ASCII
character set (REVERSE SOLIDUS and TILDE),
instead of JIS X 0201 Roman (YEN SIGN and OVERLINE).

@item UTF-8, UTF8
Unicode 3.2.  Note that some JIS X 0213 characters are mapped to Extension B
(U+20000 and up).
Some JIS X 0213 characters are mapped to two
unicode characters (one base character plus a combining character).

@item ISO2022JP, CSISO2022JP, ISO2022JP-1, ISO2022JP-2, ISO2022JP-3
These encodings differ a bit
(except ISO2022JP and CSISO2022JP, which are synonyms), but
Gauche handles them same.  If one of these CES is specified as input,
Gauche recognizes escape sequences of any of CES.
ISO2022JP-2 defines several non-Japanese escape sequences, and
they are recognized by Gauche, but mapped to substitution character
('?' or geta mark).

For output, Gauche assumes ISO2022JP first, and uses ISO2022JP-1
escape sequence to put JIS X 0212 character, or uses ISO2022JP-3
escape sequence to put JIS X 0213 plane 2 character.
Thus, if the string contains only JIS X 0208 characters, 
the output is compatible to ISO2022JP.
Precisely speaking, JIS X 0213 specifies some characters in JIS X 0208
codepoint that shouldn't be mixed with JIS X 0208 characters;
Gauche output those characters as JIS X 0208 for compatibility.
(This is the same policy as Emacs-Mule's iso2022jp-3-compatible mode).
@end table

@node Autodetecting the encoding scheme, Conversion ports, Supported character encoding schemes, Character code conversion
@subsection Autodetecting the encoding scheme
@c NODE 文字エンコーディングの自動判定

There are cases that you don't know the CES of the input, but
you know it is one of several possible encodings.
The charconv module has a mechanism
to guess the input encoding.  There can be multiple algorithms,
and each algorithm has the name.  Right now, there's only one
algorithm implemented:
@table @code
@item "*JP"
To guess the character encoding from japanese text, among either
ISO2022-JP(-1,2,3), EUCJP, SHIFT_JIS or UTF-8.
@end table

This name can be used in place of CES name for some conversion functions.


@defun ces-guess-from-string string scheme
Guesses the CES of @var{string} by the character guessing scheme
@var{scheme} (e.g. "*JP").  Returns CES name that can be used
by other charconv functions.   It may return @code{#f} if the
guessing scheme finds no possible encoding in @var{string}.
Note that if there may be more than one possible encoding in
@var{string}, the guessing scheme returns one of them,
usually in favor of the native CES.
@end defun


@node Conversion ports, Extended port procedures, Autodetecting the encoding scheme, Character code conversion
@subsection Conversion ports
@c NODE 変換ポート

@defun open-input-conversion-port source from-code &keyword to-code buffer-size owner?
Takes an input port @var{source}, which feeds characters
encoded in @var{from-code}, and returns another input port,
from which you can read characters encoded in @var{to-code}.

If @var{to-code} is omitted, the native CES is assumed.

@var{buffer-size} is used to allocate internal buffer size for
conversion.  The default size is about 1 kilobytes and it's suitable
for typical cases.

If you don't know the @var{source}'s CES, you can specify
CES guessing scheme, such as @code{"*JP"}, in place of @var{from-code}.
The conversion port tries to guess the encoding, by prefetching
the data from @var{source} up to the buffer size.  It signals an error
if the code guessing routine finds no appropriate CES.
If the guessing routine finds ambiguous input, however, it silently
assume one of possible CES's, in favor of the native CES.
Hence it is possible that the guessing is wrong if the buffer
size is too small.  The default size is usually enough for most
text documents, but it may fail if the large text contains mostly ASCII
characters and multibyte characters appear only at the very end of
the document.
To be sure for the worst case,
you have to specify the buffer size large enough to
hold entire text.

By default, @code{open-input-conversion-port} leaves @var{source} open.
If you specify true value to @var{owner?}, the function closes
@var{source} after it reads EOF from the port.

For example, the following code copies a file @file{unknown.txt} to a file
@file{eucjp.txt}, converting unknown japanese CES to EUC-JP.
@example
(call-with-output-file "eucjp.txt"
  (lambda (out)
    (copy-port (open-input-conversion-port
                 (open-input-file "unknown.txt")
                 "*jp"             ;@r{guess code}
                 :to-code "eucjp"
                 :owner? #t)       ;@r{close unknown.txt afterwards}
               out)))
@end example
@end defun


@defun open-output-conversion-port sink to-code &keyword from-code buffer-size owner?
Creates and returns an output port that converts
given characters from @var{from-code} to @var{to-code}
and feed to an output port @var{sink}.
If @var{from-code} is omitted, the native CES is assumed.
You can't specify a character guessing scheme (such as "*JP") to
neither @var{from-code} nor @var{to-code}.

@var{buffer-size} specifies the size of internal conversion buffer.
The characters put to the returned port may stay in the buffer,
until the port is explicity flushed (by @code{flush}) or
the port is closed.

By default, the returned port doesn't closes @var{sink} when
itself is closed.  If a keyword argument @var{owner?} is provided
and true, however, it closes @var{sink} when it is closed.
@end defun

@defun ces-convert string from-code &optional to-code
Convert @var{string}'s character encoding from @var{from-code}
to @var{to-code}, and returns the converted string.
The returned string may be a byte-string if @var{to-code}
is different from the native CES.

@var{from-code} can be a name of character guessing scheme
(e.g. "*JP").  when @var{to-code} is omitted, the native CES is
assumed.
@end defun

@defun call-with-input-conversion iport proc &keyword encoding conversion-buffer-size
@defunx call-with-output-conversion oport proc &keyword encoding conversion-buffer-size
These procedures can be used to perform character I/O with
different encoding temporary from the original port's encoding.

@code{call-with-input-conversion} takes an input port @var{iport}
which uses the character encoding @var{encoding}, and
calls @var{proc} with one argument, a conversion input port. 
From the port, @var{proc} can read characters in
Gauche's internal encoding. 
Note that once @var{proc} is called, it has to read all the 
characters until EOF; see the note below.

@code{call-with-output-conversion} takes an output port @var{oport}
which expects the character encoding @var{encoding}, and
calls @var{proc} with one argument,
a temporary conversion output port.  
To the port, @var{proc} can write characters in
Gauche's internal encoding.  
When @var{proc} returns, or it exits with an error, 
the temporary conversion output port is flushed and closed.  
The caller of @code{call-with-output-conversion}
can continue to use @var{oport} with original encoding afterwards.

Both procedure returns the value(s) that @var{proc} returns.
The default value of @var{encoding} is Gauche's internal
encoding.  Those procedures don't create a conversion port
when it is not necessary.   If @var{conversion-buffer-size} is given, 
it is used as the @var{buffer-size} argument when the conversion
port is open.

You shouldn't use @var{iport}/@var{oport} directly
while @var{proc} is active---character encoding is a
stateful process, and mixing I/O from/to the conversion port and
the underlying port will screw up the state.

@emph{Note:} for the @code{call-with-input-conversion}, you can't
use @var{iport} again unless @var{proc} reads EOF from it.
It's because a conversion port needs to buffer the input, and
there's no way to undo the buffered input to @var{iport}
when @var{proc} returns.
@end defun

@defun with-input-conversion iport thunk &keyword encoding conversion-buffer-size
@defunx with-output-conversion oport thunk &keyword encoding conversion-buffer-size
Similar to @code{call-with-*-conversion},
but these procedures call @var{thunk} without arguments,
while the conversion port is set as the current input or output port,
respectively.
The meaning of keyword arguments are the same as @code{call-with-*-conversion}.
@end defun

@defun wrap-with-input-conversion port from-code &keyword to-code owner? buffer-size
@defunx wrap-with-output-conversion port to-code &keyword from-code owner? buffer-size
Convenient procedures to avoid adding unnecessary conversion port.
Each procedure works like @code{open-input-conversion-port}
and @code{open-output-conversion-port}, respectively,
except if system knows no conversion is needed,
no conversion port is created and @var{port} is returned as is.

When a conversion port is created, @var{port} is always owned by the port.
When you want to close the port, always close the port returned
by @code{wrap-with-*-conversion}, instead the original @var{port}.
If you close the original @var{port} first, the pending conversion
won't be flushed.  (Some conversion requires trailing sequence that
is generated only when the conversion port is closing, so simply
calling @code{flush} isn't enough.)

The @var{buffer-size} argument is passed to 
the @code{open-*-conversion-port}.
@end defun

@node Extended port procedures,  , Conversion ports, Character code conversion
@subsection Extended port procedures
@c NODE 拡張されたポート手続き


@defun open-input-file filename &keyword encoding conversion-buffer-size @dots{}
@defunx call-with-input-file filename proc &keyword encoding conversion-buffer-size @dots{}
@defunx with-input-from-file filename thunk &keyword encoding conversion-buffer-size @dots{}
@defunx open-output-file filename &keyword encoding conversion-buffer-size @dots{}
@defunx call-with-output-file filename proc &keyword encoding conversion-buffer-size @dots{}
@defunx with-output-to-file filename thunk &keyword encoding conversion-buffer-size @dots{}
These Gauche built-in procedures are extended to accept two extra
keyword arguments, @var{encoding} and @var{conversion-buffer-size}.
(@xref{File ports}, for their default behavior).

You can give a CES of the file @var{filename} to @var{encoding},
and the port automatically converts the file CES to the Gauche's
native CES.  You can use a CES guessing algorithm name for
input file port.

The keyword argument @var{conversion-buffer-size} has the same
meaning as @var{buffer-size} of @code{open-input-conversion-port}.
@end defun



@c ----------------------------------------------------------------------
@node Collection framework, Configuration parameters, Character code conversion, Library modules - Gauche extensions
@section @code{gauche.collection} - Collection framework
@c NODE コレクションフレームワーク, @code{gauche.collection} - コレクションフレームワーク

@deftp {Module} gauche.collection
@mdindex gauche.collection
This module provides a set of generic functions (GFs) that iterate over
various collections.   The Scheme standard [R5RS] has some iterative
primitives such as @code{map} and @code{for-each},
and SRFI-1 (@xref{List library} adds a rich set of such functions,
but they work only on lists.

Using the method dispatch of the object system, this module
efficiently extends those
functions for other collection classes such as vectors and hash tables.
It also provides a simple way for user-defined class to adapt
those operations.
So far, the following operations are defined.

@table @asis
@item Mapping
@code{fold}, @code{fold2}, @code{fold3}, 
@code{map}, @code{map-to}, @code{map-accumf, }@code{for-each}
@item Selection and searching
@code{find}, @code{find-min}, @code{find-max}, @code{find-min&max},
@code{filter}, @code{filter-to},
@code{remove}, @code{remove-to}, @code{partition}, @code{partition-to}
@code{group-collection}
@item Conversion
@code{coerce-to}
@item Miscellaneous
@code{size-of}, @code{lazy-size-of}
@item Fundamental iterator creator
@code{call-with-iterator}, @code{call-with-builder},
@code{with-iterator}, @code{with-builder}, @code{call-with-iterators}.
@end table

Those operations work on @emph{collections} and its subclass,
@emph{sequences}.  A collection is a certain form of a set
of objects that you can traverse all the object in it in a certain way.
A sequence is a collection that all its elements are ordered, so that
you can retrieve its element by index.

The following Gauche built-in objects are treated as collections and/or
sequences.
@table @code
@item <list>
A sequence.
@item <vector>
A sequence.
@item <string>
A sequence (of characters)
@item <hash-table>
A collection.  Each element is a pair of a key and a value.
@item <s8vector>, <u8vector>, @dots{} <f64vector>
A sequence (methods defined in @code{srfi-4} module,
@xref{Homogeneous vectors}).
@end table

@xref{Sequence framework}, for it adds more sequence specific
methods.

The methods that needs to return a set of objects, i.e. 
@code{map}, @code{filter}, @code{remove} and @code{partition}.
returns a list (or lists).  The corresponding ``-to'' variant
(@code{map-to}, @code{filter-to}, @code{remove-to} and @code{partition-to}.
takes a collection class argument and returns the collection of the class.
@end deftp

@menu
* Mapping over collection::     
* Selection and searching in collection::  
* Miscellaneous operations on collection::  
* Fundamental iterator creators::  
* Implementing collections::    
@end menu

@node Mapping over collection, Selection and searching in collection, Collection framework, Collection framework
@subsection Mapping over collection
@c NODE コレクションに対するマッピング

These generic functions extends the standard mapping procedures.
See also @ref{Mapping over sequences}, if you care the index
as well as elements.

@deffn {Generic function} fold proc knil coll coll2 @dots{}
This is a natural extension of @var{fold} in SRFI-1 (@xref{SRFI-1 Fold}).

For each element @var{Ei} in the collection @var{coll}, @var{proc} is
called as (@var{proc} @var{Ei} @var{Ri-1}), where @var{Ri-1} is the 
result of (@var{i}-1)-th invocation of @var{proc} for @var{i} > 0, 
and @var{R0} is @var{knil}.  Returns the last invocation of @var{proc}.
@example
(fold + 0 '#(1 2 3 4)) @result{} 10
(fold cons '() "abc")  @result{} (#\c #\b #\a)
@end example

If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.

Note: We don't provide @code{fold-right} on collections, since the order
of elements doesn't matter, so only @code{fold} is sufficient for 
meaningful traversal.
However, sequences do have @code{fold-right};
see @ref{Mapping over sequences}.

You can fold more than one collection, although it doesn't make
much sense unless all of the collections are sequences.
Suppose @var{E(k, i)} for @var{i}-th element
of @var{k}-th collection.  @var{proc} is called as
@example
(@var{proc} @var{E(0,i)} @var{E(1,i)} @dots{} @var{E(K-1,i)} @var{Ri-1})
@end example

Different types of collections can be mixed together.

@example
(fold acons '() "abc" '#(1 2 3))
  @result{} ((#\c 3) (#\b 2) (#\a 1))

;; @r{calculates dot product of two vectors}
(fold (lambda (a b r) (+ (* a b) r)) 0
      '#(3 5 7) '#(2 4 6))
  @result{} 68
@end example

When more than one collection is given, @code{fold} terminates
as soon as at least one of the collections exhausted.
@end deffn

@deffn {Generic function} fold2 proc knil1 knil2 coll coll2 @dots{}
@deffnx {Generic function} fold3 proc knil1 knil2 knil3 coll coll2 @dots{}
Like @code{fold}, but they can carry two and three state values
instead of one, respectively.  The state values are
initialized by @var{knilN}.  The procedure @var{proc} is called
with each element of @var{collN}, and the state values.  It must return
two (@code{fold2}) or three (@code{fold3}) values, which will be used
as the state values of next iteration.  The values returned in the
last iteration will be the return values of @code{fold2} and @code{fold3}.

@example
(fold2 (lambda (elt a b) (values (min elt a) (max elt b)))
       256 0 '#u8(33 12 142 1 74 98 12 5 99))
 @result{} 1 and 142  ;; find minimum and maximum values
@end example

See also @code{map-accum} below.
@end deffn


@deffn {Generic function} map proc coll coll2 @dots{}
This extends the built-in @code{map} (@xref{Procedures}).
Apply @var{proc} for each element in the collection @var{coll}, and
returns a list of the results.

If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.

If more than one collection is passed, @var{proc} is called with
elements for each collection.  In such case, @code{map} terminates
as soon as at least one of the collection is exhausted.  Note that passing
more than one collection doesn't make much sense unless
all the collections are sequences.

@example
(map (lambda (x) (* x 2)) '#(1 2 3))
  @result{} #(2 4 6)

(map char-upcase "abc")
  @result{} (#\A #\B #\C)

(map + '#(1 2 3) '#(4 5 6))
  @result{} (5 7 9)
@end example

@code{map} @emph{always} returns a list.  If you want to get the result
in a different type of collection, use @code{map-to} described below.
If you wonder why @code{(map char-upcase "abc")} doesn't return
@code{"ABC"}, read the discussion in the bottom of this subsection.
@end deffn

@deffn {Generic function} map-to class proc coll coll2 @dots{}
This works the same as @code{map}, except the result is returned
in a collection of class @var{class}.   @code{Class} must be a
collection class and have a builder interface
(@xref{Fundamental iterator creators}).

@example
(map-to <vector> + '#(1 2 3) '#(4 5 6))
  @result{} #(5 7 9)

(map-to <string> char-upcase "def")
  @result{} "DEF"

(map-to <vector> char=? "bed" "pet")
  @result{} #(#f #t #f)
@end example
@end deffn

@deffn {Generic function} map-accum proc seed coll1 coll2 @dots{}
Collects results of @var{proc} over collections, while passing
a state value.  @var{proc} is called like this:
@example
(@var{proc} @var{elt1} @var{elt2} @dots{} @var{seed})
@end example
Where @var{elt1} @var{elt2} @dots{} are the elements of 
@var{coll1} @var{coll2} @dots{}.
It must return two values; the first value is collected into
a list (like @code{map}), while the second value is passed as
@var{seed} to the next call of @var{proc}.  

When one of the collections is exhausted, @code{map-accum} returns
two values, the list of the first return values from @var{proc},
and the second return value of the last call of @var{proc}.

If the given collections are sequences, it is guaranteed that
@var{proc} is applied in order of the sequence.

This is similar to Haskell's @code{mapAccumL}, but note that
the order of @code{proc}'s argument and return values are
reversed.
@end deffn


@deffn {Generic function} for-each proc coll coll2 @dots{}
Extension of built-in @code{for-each} (@xref{Procedures}).
Applies @var{proc} for each elements in the collection(s).
The result of @var{proc} is discarded.  The return value of
@code{for-each} is undefined.

If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.

If more than one collection is passed, @var{proc} is called with
elements for each collection.  In such case, @code{for-each} terminates
as soon as one of the collection is exhausted.  Note that passing
more than one collection doesn't make much sense unless
all the collections are sequences.
@end deffn


@deffn {Generic Function} fold$ proc
@deffnx {Generic Function} fold$ proc knil
@deffnx {Generic Function} map$ proc
@deffnx {Generic Function} for-each$ proc
Partial-application version of @code{fold}, @code{map} and @code{for-each}.
@end deffn


@emph{Discussion:}  It is debatable what type of collection @code{map}
should return when it operates on the collections other than lists.
It may seem more ``natural'' if @code{(map * '#(1 2) '#(3 4))}
returns a vector, and @code{(map char-upcase "abc")} returns a string.

Although such interface seems work for simple cases, it'll become
problematic for more general cases.  What type of collection should
be returned if a string and a vector are passed?  Furthermore,
some collection may only have iterator interface but no builder
interface, so that the result can't be coerced to the argument type
(suppose you're mapping over database records, for example).
And Scheme programmers are used to think @code{map} returns a list,
and the result of @code{map} are applied to the procedures that
takes list everywhere.

So I decided to add another method, @code{map-to}, to specify
the return type explicitly
The idea of passing the return type is taken from CommonLisp's @code{map}
function, but taking a class metaobject, @code{map-to} is much flexible
to extend using method dispatch.
This protocol (``-to'' variant takes a class metaobject
for the result collection) is used thoughout the collection framework.

@node Selection and searching in collection, Miscellaneous operations on collection, Mapping over collection, Collection framework
@subsection Selection and searching in collection
@c NODE コレクションからの選択と探索

@deffn {Generic function} find pred coll
Applies @var{pred} for each element of a collection @var{coll} until
@var{pred} returns a true value.  Returns the element on which @var{pred}
returned a true value, or @code{#f} if no element satisfies @var{pred}.

If @var{coll} is a sequence, it is guaranteed that @var{pred} is
applied in order.  Otherwise the order of application is undefined.

@example
(find char-upper-case? "abcDe") @result{} #\D
(find even? '#(1 3 4 6)) @result{} 4
(find even? '(1 3 5 7))  @result{} #F
@end example
@end deffn

@deffn {Generic function} find-min coll &keyword key compare default
@deffnx {Generic function} find-max coll &keyword key compare default
Returns a minimum or maximum element in the collection @var{coll}.

A one-argument procedure @var{key}, whose default is @code{identity},
is applied for each element to obtain a comparison value.
Then a compaison value is compared by a two-argument procedure
@var{compare}, whose default is @code{<}.
If the collection has zero or one element, the @var{compare} procedure
is never called.

When the collection is empty, a value given to @var{default} is
returned, whose default is @code{#f}.

@example
(find-min '((a . 3) (b . 9) (c . -1) (d . 7)) :key cdr) @result{} (c . -1)
@end example
@end deffn

@deffn {Generic function} find-min&max coll &keyword key compare default default-min default-max
Does @code{find-min} and @code{find-max} simultaneously, and returns
two values, the minimum element and the maximum element.
The keyword arguments @var{key}, @var{compare}, and @var{default} are
the same as @code{find-min} and @code{find-max}.  Alternatively
you can give default values for minimum and maximum separately,
by @var{default-min} and @var{default-max}.
@end deffn

@deffn {Generic function} filter pred coll
Returns a list of elements of collection @var{coll} that satisfies
the predicate @var{pred}.   If the collection is a sequence,
the order is preserved in the result.

@example
(filter char-upper-case? "Hello, World")
  @result{} (#\H #\W)
(filter even? '#(1 2 3 4)) @result{} (2 4)
@end example
@end deffn

@deffn {Generic function} filter-to class pred coll
Same as @code{filter}, but the result is returned 
as a collection of class @var{class}.

@example
(filter-to <vector> even? '#(1 2 3 4)) @result{} #(2 4)
(filter-to <string> char-upper-case? "Hello, World") 
  @result{} "HW"
@end example
@end deffn

@deffn {Generic function} remove pred coll
Returns a list of elements of collection @var{coll} that does not
satisfy the predicate @var{pred}.   If the collection is a sequence,
the order is preserved in the result.

@example
(remove char-upper-case? "Hello, World")
  @result{} (#\e #\l #\l #\o #\, #\space #\o #\r #\l #\d)
(remove even? '#(1 2 3 4)) @result{} (1 3)
@end example
@end deffn

@deffn {Generic function} remove-to class pred coll
Same as @code{remove}, but the result is returned 
as a collection of class @var{class}.

@example
(remove-to <vector> even? '#(1 2 3 4)) @result{} #(1 3)
(remove-to <string> char-upper-case? "Hello, World") 
  @result{} "ello, orld"
@end example
@end deffn

@deffn {Generic function} partition pred coll
Does @code{filter} and @code{remove} the same time.
Returns two lists, the first consists of elements of the collection
@var{coll} that satisfies the predicate @var{pred}, and the second
consists of elements that doesn't.

@example
(partition char-upper-case? "PuPu")
  @result{} (#\P #\P) @r{and} (#\u #\u)
(partition even? '#(1 2 3 4))
  @result{} (2 4) @r{and} (1 3)
@end example
@end deffn

@deffn {Generic function} partition-to class pred coll
Same as @code{partition}, except the results are returned
in the collections of class @var{class}.

@example
(partition-to <string> char-upper-case? "PuPu")
  @result{} "PP" @r{and} "uu"
(partition-to <vector> even? '#(1 2 3 4))
  @result{} #(2 4) @r{and} #(1 3)
@end example
@end deffn

@deffn {Generic function} group-collection coll &keyword key test
Generalized @code{partition}.  Groups elements in @var{coll}
into those who has the same key value, and returns the groups as
of lists.  Key values are calculated by applying the procedure @var{key}
to each element of @var{coll}.  The default value of @var{key} is
@code{identity}.   For each element of @var{coll}, @var{key} is applied
exactly once.
The equal-ness of keys are compared by
@var{test} procedure, whose default is @code{eqv?}.

If @var{coll} is a sequence, then the order of elements in each group
of the result is the same order in @var{coll}.

@example
(group-collection '(1 2 3 2 3 1 2 1 2 3 2 3))
  @result{} ((1 1 1) (2 2 2 2 2) (3 3 3 3))

(group-collection '(1 2 3 2 3 1 2 1 2 3 2 3) :key odd?)
  @result{} ((1 3 3 1 1 3 3) (2 2 2 2 2))

(group-collection '(("a" 2) ("b" 5) ("c" 1) ("b" 3) ("a" 6))
  :key car :test string=?)
  @result{} ((("a" 2) ("a" 6)) (("b" 5) ("b" 3)) (("c" 1)))
@end example

See also @code{group-sequence} in @code{gauche.sequence}
(@xref{Other operations over sequences}),
which only groups adjacent elements.
@end deffn


@node Miscellaneous operations on collection, Fundamental iterator creators, Selection and searching in collection, Collection framework
@subsection Miscellaneous operations on collection
@c NODE コレクションに対する様々な操作

@deffn {Generic function} size-of coll
Returns the number of elements in the collection.  Default method iterates over
the collection to calculate the size, which is not very efficient
and may diverge if the collection is infinite.
Some collection classes overload the method for faster calculation.
@end deffn

@deffn {Generic function} lazy-size-of coll
Returns either the size of the collection, or a promise to
calculate it.  The intent of this method is to avoid
size calculation if it is expensive.  In some cases, the caller
wants to have size just for optimization, and it is not desirable
to spend time to calculate the size.  Such caller uses this method
and just discards the information if it is a promise.
@end deffn

@deffn {Generic function} coerce-to class coll
Convert a collection @var{coll} to another collection
which is an instance of @var{class}.
If @var{coll} is a sequence and @var{class} is a sequence class,
the order is preserved.

@example
(coerce-to <vector> '(1 2 3 4))
  @result{} #(1 2 3 4)

(coerce-to <string> '#(#\a #\b #\c))
  @result{} "abc"
@end example
@end deffn

@node Fundamental iterator creators, Implementing collections, Miscellaneous operations on collection, Collection framework
@subsection Fundamental iterator creators
@c NODE 基礎的なイテレータ構築メソッド

These are fundamental methods on which all the rest of
iterative method are built.  The method interface is not intended
to be called from general code, but suitable for building
other iterator construct.   The reason why I chose this interface
as fundamental methods are explained at the bottom of this subsection.

@deffn {Generic function} call-with-iterator collection proc &keyword start
A fundamental iterator creator.   This creates two procedures
from @var{collection}, both take no argument, and then call
@var{proc} with those two procedures.   The first procedure is
terminate predicate, which returns @code{#t} if the iteration
is exhausted, or @code{#f} if there are still elements to be visited.
The second procedure is an incrementer,
which returns one element from the collection and sets the
internal pointer to the next element.
The behavior is undefined if you call the incrementer after
the terminate predicate returns @code{#t}.

If the collection is actually a sequence, the incrementer is guaranteed
to return elements in order, from 0-th element to the last element.
If a keyword argument @var{start} is given, however, the iteration
begins from @var{start}-th element and ends at the last element.
If the collection is not a sequence, the iteration order is
arbtrary, and @var{start} argument has no effect.

An implementation of @var{call-with-iterator} method may
limit the extent of the iterator inside the dynamic scope of the method.
For example, it allocates some resource (e.g. connect to a database)
before calling @var{proc}, and deallocates it (e.g. disconnect from a database)
after @var{proc} returns.

This method returns the value(s) @var{proc} returns.

@example
(call-with-iterator '(1 2 3 4 5)
  (lambda (end? next)
    (do ((odd-nums 0))
        ((end?) odd-nums)
      (when (odd? (next)) (inc! odd-nums)))))
 @result{} 3
@end example

See also @code{with-iterator} macro below, for it is easier to use.
@end deffn

@deffn {Macro} with-iterator (collection end? next args @dots{}) body @dots{}
A convenience macro to call @code{call-with-iterator}.
@example
(with-iterator (coll end? next args @dots{}) body @dots{})
 @equiv{}
(call-with-iterator coll
  (lambda (end? next) body @dots{})
   args @dots{})
@end example
@end deffn

@defun call-with-iterators collections proc
A helper function to write n-ary iterator method.
This function applies @code{call-with-iterator} for each @var{collection}s,
and makes two lists, the first consists of terminate predicates
and the second of incrementers.  Then @var{proc} is called
with those two lists.  Returns whatever @var{proc} returns.
@end defun

@deffn {Generic function} call-with-builder collection-class proc &keyword size
A fundamental builder creator.  Builder is a way to construct
a collection incrementally.  Not all collection classes provide
this method.

@var{Collection-class} is a class of the collection to be built.
This method creates two procedures, adder and getter, then calls
@var{proc} with those procedures.
Adder procedure takes one argument and adds it to the collection
being built.  Getter takes no argument and returns a built collection object.
The effect is undefined if adder is called after getter is called.

A keyword argument @var{size} may be specified if the size of
the result collection is known.  Certain collections may be
built much more efficiently if the size is known; other collections
may just ignore it.   The behavior is undefined if more than
@var{size} elements are added, or the collection is retrieved before
@var{size} elements are accumulated.

If the collection class is actually a sequence class,
adder is guaranteed to add elements in order.  Otherwise,
the order of elements are insignificant.

Some collection class may take more keyword arguments to
initialize the collection.

This method returns the value(s) @var{proc} returned.

@example
(call-with-builder <list>
  (lambda (add! get)
    (add! 'a) (add! 'b) (add! 'c) (get)))
 @result{} (a b c)

(call-with-builder <vector>
  (lambda (add! get)
    (add! 'a) (add! 'b) (add! 'c) (get)))
 @result{} #(a b c)
@end example

See also @code{with-builder} macro below, for it is much easier to use.
@end deffn

@deffn {Macro} with-builder (collection add! get args @dots{}) body @dots{}
A convenience macro to call @code{call-with-builder}.
@example
(with-builder (coll add! get args @dots{}) body @dots{})
 @equiv{}
(call-with-builder coll
  (lambda (add! get) body @dots{})
  args @dots{})
@end example
@end deffn

@emph{Discussion}:
Other iterator methods are built on top of call-with-iterator and
call-with-builder.
By implementing those methods, you can easily adapt your own collection
class to all of those iterative
operations.   Optionally you can overload some of higher-level
methods for efficiency.

It is debatable that which set of operations should be primitives.
I chose call-with-iterator style for efficiency of the applications
I see most.   The following is a discussion of other possible
primitive iterators.

@table @asis
@item @code{fold}
It is possible to make @code{fold} a primitive method, and
build other iterator method on top of it.
Collection-specific iterating states can be kept in the
stack of @code{fold}, thus it runs efficiently.  The method
to optimize a procedure that uses @code{fold} as a basic
iterator construct.
However, it is rather cumbersome to derive
generator-style interface from it.   It is also tricky
to iterate irregularly over more than one collections.

@item CPS
Passes iteratee the continuation procedure that continues
the iteration.   The iteratee just returns when it want
to terminate the iteration.
It has resource management problem described in
Oleg Kiselyov's article (@ref{oleg2,,OLEG2}).

@item Iterator object
Like C++ iterator or Common Lisp generator.
Easy to write loop.   The problem is that every call of
checking termination or getting next element must be dispatched.

@item Series
Common Lisp's series can be very efficient if the compiler can statically
analyze the usage of series.  Unfortunately it is not the case in
Gauche.  Even if it could, the extension mechanism doesn't blend well
with Gauche's object system.

@item Macros
Iterator can be implemented as macros, and that will be very efficient;
e.g. Scheme48's iterator macro.  It uses macros to extend, however,
and that doesn't blend well with Gauche's object system.
@end table

The current implementation is close to the iterator object approach,
but using closures instead of iterator objects so that avoiding
dispatching in the inner loop.  Also it allows the iterator
implementator to take care of the resource problem.

@node Implementing collections,  , Fundamental iterator creators, Collection framework
@subsection Implementing collections
@c NODE コレクションの実装

The minimum requirements of the collection class implementation
is as follow:
@itemize @bullet
@item
The class inherits @code{<collection>} abstract class.
@item
A method @code{call-with-iterator} is implemented.
@end itemize

This makes iterator methods such as @code{map}, @code{for-each},
@code{find} and @code{filter} to work.

In order to make the constructive methods (e.g. @code{map-to} to
create your collection), you have to implement @code{call-with-builder}
method as well.  Note that @code{call-with-builder} method must work
a sort of class method, dispatched by class, rather than normal method
dispatched by instance.   In Gauche, you can implement it by using a
metaclass.   Then the minimal code will look like this:

@example
(define-class <your-collection-meta> (<class>) ())

(define-class <your-collection> (<collection>)
 (...) ;; @r{slots}
 :metaclass <your-collection-meta>)

(define-method call-with-iterator
    ((coll <your-collection>) proc . options)
  @dots{}
  )

(define-method call-with-builder
     ((coll <your-collection-meta>) proc . options)
  @dots{}
  )
@end example

Optionally, you can overload other generic functions to optimize
performance.

@c ----------------------------------------------------------------------
@node Configuration parameters, Dictionary framework, Collection framework, Library modules - Gauche extensions
@section @code{gauche.config} - Configuration parameters
@c NODE コンフィグレーション情報, @code{gauche.config} - コンフィグレーション情報

@deftp {Module} gauche.config
@mdindex gauche.config
This module allows the Scheme program to access the configuration information
the same as you can get from the @code{gauche-config} program.
@end deftp

@defun gauche-config option
Returns the configured value of the @var{option}.

See the manpage of @code{gauche-config}, or run @code{gauche-config}
without any argument from the shell, to find out the valid options.
@example
(gauche-config "--cc")
  @result{} "gcc"
(gauche-config "-L")
  @result{} "-L/usr/lib/gauche/0.6.5/i686-pc-linux-gnu"
(gauche-config "-l")
  @result{} "-ldl -lcrypt -lm -lpthread"
@end example
@end defun

@c ----------------------------------------------------------------------
@node Dictionary framework, Low-level file operations, Configuration parameters, Library modules - Gauche extensions
@section @code{gauche.dictionary} - Dictionary framework
@c NODE @code{gauche.dictionary} - ディクショナリフレームワーク

@deftp {Module} gauche.dictionary
@mdindex gauche.dictionary
A dictionary is an abstract class for objects that can
map a key to a value.  This module provides some useful generic
functions for dictionaries.
@end deftp

@deffn {Generic function} dict-fold (dict @code{<dictionary>}) proc seed
Calls a procedure @var{proc} over each entry in a dictionary @var{dict},
passing a seed value.  Three arguments are given to @var{proc}; 
an entry's key, an entry's value, and a seed value.  Initial
seed value is @var{seed}.  The value returned from @var{proc} is used
for the seed value of the next call of @var{proc}.  The result of the
last call of @var{proc} is returned from @var{dict-fold}.

If @var{dict} is @code{<ordered-dictionary>}, @var{proc} is called
in the way to keep the following associative order, where
the key is ordered from @var{K0} (minimum) to @var{Kn} (maximum), and
the corresponding values is from @var{V0} to @var{Vn}:
@example
(proc Kn Vn (proc Kn-1 Vn-1 ... (proc K0 V0 seed)))
@end example
@end deffn

@deffn {Generic function} dict-fold-right (dict @code{<ordered-dictionary>}) proc seed
Like @code{dict-fold}, but the associative order of applying @var{proc}
is reversed as follows:
@example
(proc K0 V0 (proc K1 V1 ... (proc Kn Vn seed)))
@end example

This generic function is only defined on @code{<ordered-dictionary>}.
@end deffn

@deffn {Generic function} dict-for-each (dict @code{<dictionary>}) proc
Calls @var{proc} with a key and a value of every entry in
the dictionary @var{dict}.  For ordered dictionaries, @var{proc}
is guaranteed to be called in the increasing order of keys.
@end deffn

@deffn {Generic function} dict-map (dict @code{<dictionary>}) proc
Calls @var{proc} with a key and a value of every entry in
the dictionary @var{dict}, and gathers the result into a list 
and returns it.  For ordered dictionaries, the result is in
the increasing order of keys (it doesn't necessarily mean @var{proc}
is called in that order).
@end deffn

@deffn {Generic function} dict-keys (dict @code{<dictionary>})
@deffnx {Generic function} dict-values (dict @code{<dictionary>})
Returns a list of all keys or values of a dictionary @var{dict}, 
respectively.  For ordered dictionaries, the returned list is
in the increasing order of keys.
@end deffn

@c ----------------------------------------------------------------------
@node Low-level file operations, Hooks, Dictionary framework, Library modules - Gauche extensions
@section @code{gauche.fcntl} - Low-level file operations
@c NODE 低レベルファイル操作, @code{gauche.fcntl} - 低レベルファイル操作

@deftp {Module} gauche.fcntl
@mdindex gauche.fcntl
Provides an interface to @code{fcntl(2)}, including
advisory file locking.
@end deftp

@defun sys-fcntl port-or-fd operation &optional arg
Performs certain operation on the file specified by @var{port-or-fd},
which should be a port object or an integer
that specifies a system file descriptor.  If it is a port, it must
be associated to the opened file (i.e. @code{port-type}
returns @code{file}, see @ref{Common port operations}).

The operation is specified by an integer @var{operation}.
Several variables are defined for valid @var{operation}.

@table @code
@item F_GETFD
@vindex F_GETFD
@vindex FD_CLOEXEC
Returns flags associated to the file descriptor of @var{port-or-fd}.
The optional argument @var{arg} is not used.   The return value is 
an integer whose definition is system specific, except one flag,
@code{FD_CLOEXEC}, which indicates the file descriptor should be
closed on @code{exec}.  See the manual entry of @code{fcntl(2)} of
your system for the details.

@item F_SETFD
@vindex F_SETFD
Sets the file descriptor flags given as @var{arg} to @var{port-or-fd}.
For example, the portable way of setting @code{FL_CLOEXEC} flag is
as follows:
@example
(sys-fcntl port F_SETFD
          (logior FD_CLOEXEC
                  (sys-fcntl port F_GETFD)))
@end example

@item F_GETFL
@vindex F_GETFL
Returns flags associated to the open files specified by @var{port-or-fd}.
The flags includes the following information:

@itemize @bullet
@item
@vindex O_ACCMODE
@vindex O_RDONLY
@vindex O_WRONLY
@vindex O_RDWR
File access mode.  When masked by @code{O_ACCMODE}, 
it's either one of @code{O_RDONLY}, @code{O_WRONLY} or @code{O_RDWR}.
@item
@vindex O_CREAT
@vindex O_EXCL
@vindex O_TRUNC
File creation options.  @code{O_CREAT}, @code{O_EXCL} and/or
@code{O_TRUNC}.
@item
@vindex O_APPEND
Whether appending is allowed or not, by @code{O_APPEND}
@item
@vindex O_NONBLOCK
Whether I/O is blocking or non-blocking, by @code{O_NONBLOCK}.
@item
@vindex O_NOCTTY
Whether it grabs terminal control, by @code{O_NOCTTY}.
@end itemize

The system may define system-specific flags.

@item F_SETFL
@vindex F_SETFL
Sets flags to the open files specified by @var{port-or-fd}.
Among the flags listed above, only @code{O_NONBLOCK} and @code{O_APPEND}
can be changed.

Note that @code{F_GETFD}/@code{F_SETFD} concern flags associated
to the file descriptor itself, while @code{F_GETFL}/@code{F_SETFL}
concern flags associated to the opened file itself.  This makes difference
when more than one file descriptor points to the same opened file.

@item F_DUPFD
@vindex F_DUPFD
Creates new file descriptor that points to the same file referred by
@var{port-or-fd}.
An integer must be provided as @var{arg}, and that specifies
the minimum value of file descriptor to be assigned.

@item F_GETLK
@vindex F_GETLK
The third argument must be provided and be an instance of @code{<sys-flock>}
object described below.  It searches the lock information specified by
@var{arg}, and modifies @var{arg} accordingly.

@item F_SETLK
@itemx F_SETLKW
@vindex F_SETLK
@vindex F_SETLKW
The third argument must be provided and be an instance of @code{<sys-flock>}
object described below.  Sets the advisory file lock according to 
@var{arg}.   If the lock is successfully obtained, @code{#t} is returned.
If the other process has the lock conflicting the request,
@code{F_SETLK} returns @code{#f}, while @code{F_SETLKW} waits until
the lock is available.

@item F_GETOWN
@vindex F_GETOWN
Returns the process id or process group that will receive
SIGIO and SIGURG signals for events on the file descriptor.
Process group is indicated by a negative value.
This flag is only available on the systems that has this 
feature (BSD and Linux have this).

@item F_SETOWN
@vindex F_SETOWN
Sets the process id or process group that will receive SIGIO
and SIGURG signals for events on the file descriptor.
Process group is indicated by a negative value.
This flag is only available on the systems that has this 
feature (BSD and Linux have this).
Check out fcntl(2) manpage of your system for the details.

@end table

Other value for @var{operation} causes an error.
@end defun

@deftp {Builtin Class} <sys-flock>
@clindex sys-flock
A structure represents POSIX advisory record locking.
Advisory record locking means the system may not prevents the process
from operating on files that it doesn't have an appropriate lock.
All the processes are expected to use @code{fcntl} to check locks
before it operates on the files that may be shared.

The following slots are defined.

@defivar {<sys-flock>} type
An integer represents lock type.  Following variables are predefined
for the valid values:

@table @code
@item F_RDLCK
@vindex F_RDLCK
Read locking
@item F_WRLCK
@vindex F_WRLCK
Write locking
@item F_UNLCK
@vindex F_UNLCK

To remove a lock by @code{F_SETLK}, or to indicate the record is not
locked by @code{F_GETLK}.
@end table
@end defivar

@defivar {<sys-flock>} whence
Indicates from where @code{start} is measured.
@end defivar

@defivar {<sys-flock>} start
The offset of beginning of the locked region.
@end defivar

@defivar {<sys-flock>} len
The number of bytes to lock.  Zero means ``until EOF''.
@end defivar

@defivar {<sys-flock>} pid
An integer process id that holding the lock; used only by @code{F_GETLK}.
@end defivar
@end deftp

@c ----------------------------------------------------------------------
@node Hooks, Interactive session, Low-level file operations, Library modules - Gauche extensions
@section @code{gauche.hook} - Hooks
@c NODE フック, @code{gauche.hook} - フック

@deftp {Module} gauche.hook
@mdindex gauche.hook
Provides a hook object, which manages a list of closures to be
called at certain time.

This API of hooks are upper-compatible of Guile's, with the
following extensions.
@itemize @bullet
@item
Based on Gauche's object system.  Most APIs are methods
so you can extend the hook features.
@item
Hook object itself is applicable.  You don't need to use @code{run-hook}.
@item
The method to remove a procedure from a hook is called @code{delete-hook!},
for consistency with SRFI-1 and others.  @code{remove-hook!} is
defined as an alias of @code{delete-hook!} for compatibility with Guile.
@end itemize
@end deftp

@deftp {Class} <hook>
@clindex hook
A hook class, which keeps a list of procedures to be called at once.

The @code{object-apply} method is defined on @code{<hook>} class,
so you can "apply" a hook object as if it were a procedure---which
causes all the registered procedure to be invoked.
@end deftp

@defun make-hook &optional (arity 0)
Creates a new hook object with given arity, which should be a
non-negative integer.
@end defun

@defun hook? obj
Returns true if @var{obj} is a hook object.
@end defun

@defun hook-empty? hook
Returns true if @var{hook}'s procedure list is empty.
@end defun

@deffn {Method} add-hook! (hook <hook>) proc &optional (append? #f)
Adds a procedure @var{proc} to @var{hook}.  If @var{append?}
is given and true, @var{proc} is added at the end of the list.
Otherwise, @var{proc} is added at the front of the list.
The @var{proc} has to be called with the arity given 
at the @code{make-hook}.
@end deffn

@deffn {Method} delete-hook! (hook <hook>) proc
@deffnx {Method} remove-hook! (hook <hook>) proc
Removes @var{proc} from the procedure list of @var{hook}.
@code{Remove-hook!} is an alias of @code{delete-hook!} just for
compatibility with Guile.
@end deffn

@deffn {Method} reset-hook! (hook <hook>)
Empties @var{hook}'s procedure list.
@end deffn

@deffn {Method} hook->list (hook <hook>)
Returns a copy of @var{hook}'s procedure list.
@end deffn

@deffn {Method} run-hook (hook <hook>) arg @dots{}
Calls @var{hook}'s procedures in order, with arguments @var{arg} @dots{}.
The number of arguments must match the arity given at @code{make-hook}.
@end deffn

@c ----------------------------------------------------------------------
@node Interactive session, Listener, Hooks, Library modules - Gauche extensions
@section @code{gauche.interactive} - Utilities for interactive session
@c NODE インタラクティブセッション, @code{gauche.interactive} - インタラクティブセッション

@deftp {Module} gauche.interactive
@mdindex gauche.interactive
Provides useful utilities for the interactive session.

This module is automatically loaded when you run @code{gosh}
interactively.

This module also sets autoloads for functions defined in
@code{gauche.reload} module 
(see @ref{Reloading modules}), so that
those functions can be used by default in interactive development.
@end deftp

@defmac apropos pattern &optional module
Show a list of defined variables whose name matches @var{pattern}.
If you give a module or a module name @var{module}, only the variables
defined in that module are listed.  Without @var{module},
the variables "visible" from the current module are listed.

@var{pattern} may be a symbol or a regexp object.
If it is a symbol, the variables whose name contains the
substring that matches the symbol's name are listed.
If it is a regexp object, the variables whose name matches
the regexp are listed.

Some examples:
@example
;; @r{List variables that contains "string" in their name}
(apropos 'string)

;; @r{Search in srfi-14 module}
(apropos 'char 'srfi-14)
@end example
@end defmac

@deffn {Generic Function} describe obj
@deffnx {Generic Function} d obj
Prints the detail information about a Scheme object @var{obj}.
The default method shows @var{obj}'s class, and if it has
any slots, the list of slot names and their values.
You can specialize this method for customized display.
@end deffn

@defun info symbol
Displays a page of Gauche's info file that contains definition of
the function or syntax specified by @var{symbol}.
If an environment variable @code{INFOPATH} is defined,
this function searches for the info file from the directories in it.
Otherwise, this function guesses info file location from the
@code{gosh}'s library directory.   If the info file can't be
found, an error is signalled.   If the info file is found,
but @var{symbol} is not in its index, an error is signalled as well.
So this function doesn't work if you haven't installed info file.

If the current output port is a tty, the info page is displayed by
a paging software.  If an environment variable @code{PAGER} is defined,
it is used as a paging software.  Otherwise, this function looks for
@code{less} and @code{more} in this order from the directories in
@code{PATH}.  If none of them is found, or the output port is not
a tty, this function just displays the page.

The first invocation of this function in a session takes some time
to parse the info file.
@end defun

@c ----------------------------------------------------------------------
@node Listener, User-level logging, Interactive session, Library modules - Gauche extensions
@section @code{gauche.listener} - Listener
@c NODE リスナー, @code{gauche.listener} - リスナー

@deftp {Module} gauche.listener
@mdindex gauche.listener
This module provides a convenient way to enable multiple
read-eval-print loop (repl) concurrently.

An obvious way to run multiple repls is to use threads;
creating as many threads as sessions and calling
@code{read-eval-print-loop} (@xref{Eval and repl}) from each thread.
Nevertheless, sometimes single threaded implementation is preferred.
For instance, you're using a library which is not MT-safe,
or your application already uses select/poll-based dispatching mechanism.

To implement repl in the single-threaded selection-base application,
usually you register a handler that is called when data is available
in the listening port.  The handler reads the data and add them into
a buffer.  Then it examines if the data in the buffer consists a
complete expression, and if so, it reads the expression from the
buffer, evaluates it, then prints the result to the reporting port.
The @code{<listener>} class in this module provides this handler mechanism,
so all you need to do is to register the handler to your dispatching
mechanism.

Note: it may also be desirable to buffer the output sometimes,
but the current version doesn't implement it.
@end deftp

@subheading Listener API

@deftp {Class} <listener>
An object that maintains the state of a repl session.
It has many external slots to customize its behavior.
Those slot values can be set at construction time
by using the keyword of the same name as the slot,
or can be set by @code{slot-set!} afterwards.  However,
most of them should be set before calling 
@code{listener-read-hander}.

@defivar <listener> input-port
Specifies the input port from which the listener get the input.
The default value is the current input port when the object is
constructed.
@end defivar

@defivar <listener> output-port
Specifies the output port to which the listener output will go.
The default value is the current output port when the object is
constructed.
@end defivar

@defivar <listener> error-port
Specifies the output port to which the listener's error messages will go.
The default value is the current error port when the object is
constructed.
@end defivar

@defivar <listener> reader
A procedure with no arguments.  It should read a Scheme expression
from the current input port when called.
The default value is system's @code{read} procedure.
@end defivar

@defivar <listener> evaluator
A procedure that takes two arguments, a Scheme expression and
an environment specifier.  It should evaluate the expression in
the given environment and returns zero or more value(s).
The default value is system's @code{eval} procedure.
@end defivar

@defivar <listener> printer
A procedure that takes zero or more argument(s) and prints them
out to the current output port.  The default value is a procedure
that prints each value by @code{write}, followed by a newline.
@end defivar

@defivar <listener> prompter
A procedure with no arguments.  It should prints a prompt
to the current output port.  The output is flushed by the listener
object so this procedure doesn't need to care about it.
The default procedure prints @code{"listener> "}.
@end defivar

@defivar <listener> environment
An environment specifier where the expressions will be
evaluated.  The default value is the value returned by
@code{(interaction-environment)}.
@end defivar

@defivar <listener> finalizer
A thunk that will be called when EOF is read from @code{input-port}.
During the execution of @var{finalizer}, the current input, output
and error ports are restored to the ones when
@code{listener-read-handler} is called.

It can be @code{#f} if no such procedure is needed.
The default value is @code{#f}.
@end defivar

@defivar <listener> error-handler
A procedure that takes one argument, an error exception.  It is
called when an error occurs during read-eval-print stage,
with the same dynamic environment as the error is signalled.
The default value is a procedure that simply prints the
error exception by @code{report-error}.
@end defivar

@defivar <listener> fatal-handler
A procedure that takes one argument, an error exception.
It is called when a @emph{fatal} error occurred (see below
for the precise definition).  If this handler is
called, you should assume you can no longer continue the listener
session safely, even write messages to the client.  This handler
is to log such condition or to clean up the listener.
During the execution of @var{fatal-handler}, the current input, output
and error ports are restored to the ones when
@code{listener-read-handler} is called.

If @var{fatal-handler} returns @code{#f}, @var{finalizer} is
called afterwards.  With this, you can implement a common
cleanup work in @var{finalizer}.  If @var{fatal-handler} returns
a true value, @var{finalizer} will not be called.

@end defivar

@end deftp


@deffn {Method} listener-read-handler (listener <listener>)
Returns a thunk that is to be called when a data is available
from @code{input-port} of the listener.

The returned thunk (read handler) does the following steps.
Note that the first prompt is @emph{not} printed by this
procedure.  See @code{listener-show-prompt} below.
@enumerate
@item
Reads available data from @code{input-port} and appends it to the
listener's internal buffer.
@item
Scans the buffer to see if it has a complete S-expression.
If not, returns.
@item
Reads the S-expression from the buffer.
The read data is removed from the buffer.
@item
Evaluates the S-expression, then prints the result to
@code{output-port}.
@item
Prints the prompt by prompter procedure to @code{output-port},
then flush @code{output-port}.
@item
Repeats from 2.
@end enumerate
@end deffn

@deffn {Method} listener-show-prompt (listener <listener>)
Shows a prompt to the listener's output port, by using
listener's prompter procedure.  Usually you want to use
this procedure to print the first prompt, for instance,
when the client is connected to the listener socket.
@end deffn

@defun complete-sexp? str
Returns @code{#t} if @var{str} contains a complete S-expression.
This utility procedure is exported as well, since it might be useful
for other purposes.

Note that this procedure only checks syntax of the expressions,
and doesn't rule out erroneous expressions (such as containing
invalid character name, unregistered SRFI-10 tag, etc.).
This procedure may raise an error if the input contains
'@code{#<}' character sequence.
@end defun

@subheading Error handling

There are a few error situations the listener handles diffetently.

@itemize @bullet
@item
@emph{Fatal error} - An error situation that the listener session 
can no longer go on safely.  You cannot even tell so to the
listener client, since the connection to the client may be broken.
All you can do is to clean up the listener session (e.g. removes
the handler).   This case happens in (1) a low-level system error
occurrs during reading from @var{input-port}. (A syntax error
of the input isn't count as fatal, and handled as REPL error described
below.), (2) a @code{SIGPIPE} signal is raised during writing to
@var{output-port}, or (3) an unhandled error occurred during executing
@var{error-handler}.

When this situation happens, the @var{fatal-handler} is called
if it is given.  If @var{fatal-handler} returns @code{#f}, or
@var{fatal-handler} isn't given, @var{finalizer} is also called.

@item
@emph{Leaked error} - If an error occurrs during executing
@var{fatal-handler} or @var{finalizer}, we don't have no more
safety net.  The error is 'leaked' outside the listener handler,
and should be handled by the user of @code{gauche.listener}.

Generally this situation should be considered as a bug of
the program; you should make sure to catch foreseeable errors within
@var{fatal-handler} and @var{finalizer}.

@item
@emph{REPL error} - Other errors are handled by @var{error-handler}.
@end itemize

@subheading Listener example

The following code snippet opens a server socket, and opens
a Scheme interactive session when a client is connected.
(Note: this code is just for demonstration.  Do not run
this program on the machine accessible from outside network!)

@example
(use gauche.net)
(use gauche.selector)
(use gauche.listener)

(define (scheme-server port)
  (let ((selector (make <selector>))
        (server   (make-server-socket 'inet port :reuse-addr? #t))
        (cid      0))

    (define (accept-handler sock flag)
      (let* ((client (socket-accept server))
             (id     cid)
             (input  (socket-input-port client :buffering :none))
             (output (socket-output-port client))
             (finalize (lambda ()
                         (selector-delete! selector input #f #f)
                         (socket-close client)
                         (format #t "client #~a disconnected\n" id)))
             (listener (make <listener>
                         :input-port input
                         :output-port output
                         :error-port output
                         :prompter (lambda () (format #t "client[~a]> " id))
                         :finalizer finalize))
             (handler (listener-read-handler listener))
             )
        (format #t "client #~a from ~a\n" cid (socket-address client))
        (inc! cid)
        (listener-show-prompt listener)
        (selector-add! selector input (lambda _ (handler)) '(r))))

    (selector-add! selector
                   (socket-fd server)
                   accept-handler
                   '(r))
    (format #t "scheme server started on port ~s\n" port)
    (do () (#f) (selector-select selector))))
@end example

@c ----------------------------------------------------------------------
@node User-level logging, Singleton, Listener, Library modules - Gauche extensions
@section @code{gauche.logger} - User-level logging
@c NODE ユーザレベルのロギング, @code{gauche.logger} - ユーザレベルのロギング

@deftp {Module} gauche.logger
@mdindex gauche.logger
Provides a simple interface to log the program's activity.
The information can be written to the specified file,
or to the system logger using @code{syslog(3)}.
When a file is used, syslog-like prefix string is added
to each message, which is configurable.  It can also takes care of
locking of the file (see the description of @code{lock-policy} below).
@end deftp

@deftp {Class} <log-drain>
@clindex log-drain
Represents the destination of log messages.
There's one implicit global @code{<log-drain>} instance, which is
used by default.  However, you can create as many instances
by @code{make} method as you want, in case if you want to log
to more than one destination.

@defivar {<log-drain>} path
Path of the log file.  It can be also @code{#t}, which means 
the current error port, or @code{#f}, which makes @code{log-format}
to return the formatted message but not write to any log files,
or a symbol @code{syslog}, which means the messages are sent to
the system logger.

By default, this slot is @code{#f}.
@end defivar

@defivar {<log-drain>} prefix
Specifies the prefix string that is attached to the beginning of every
message.  If the message spans to several lines, the prefix is
attached to each line.   The value of this slot can also be a procedure
that takes @code{<log-drain>} object and returns a string to be used as
the prefix.  The procedure is called every time prefix is needed.

When the @code{path} slot is a symbol @code{syslog}, the value of this slot
is ignored.  System logger will attach an appropriate prefix.

When the value of the prefix slot is a string, the following character sequences
have special meanings and replaced by @code{log-format} for appropriate
information when written out.

@table @code
@item ~T
Current time, in the format of "Mmm DD hh:mm:ss" where "Mmm" is
an abbreviated month, "DD" is the day of month, "hh", "mm" and
"ss" are hours (in 24 hour basis), minutes and seconds, respectively.
This format is compatible with system logs.

@item ~Y
Current 4-digit year.

@item ~P
The program name.  The default value is the basename of
@code{*program-name*} (@xref{Writing Scheme scripts}), 
but you can change it by the @code{program-name}
slot described below.

@item ~$
The process id of this program.

@item ~U
The name of the effective user of the process.

@item ~H
The hostname the process is running.
@end table

The default value of this slot is "@code{~T ~P[~$]: }".  For example,
if a string "this is a log message.\nline 2\nline 3" is given as the
message, it produces something like the following log entry.

@example
Sep  1 17:30:23 myprogram[441]: this is a log message
Sep  1 17:30:23 myprogram[441]: line 2
Sep  1 17:30:23 myprogram[441]: line 3
@end example

@end defivar

@defivar {<log-drain>} program-name
Specifies the program name written by @code{~P} directive of
the prefix slot.
@end defivar

@defivar {<log-drain>} lock-policy
Specifies the way the log file should be locked.
If the value of this slot is a symbol @code{fcntl},
the log file is locked using
fcntl() (@xref{Low-level file operations}).
If the value is a symbol @code{file}, the log file is locked by
creating auxiliary lock file, whose name is generated by appending ".lock"
after the log file path.  The logging
process needs a write permission to the log file directory.
Note that if the process is killed forcibly during writing the
log file, a stale lock file may remain.  @code{Log-format}
silently removes the lock file if it is unusually old (currently 10 minutes).
If the value is @code{#f}, no locking is performed.

The default value is @code{fcntl}, except MacOSX which doesn't
support fcntl()-style locking and thus @code{file} is default.

The locking isn't performed if the destination is not a file.
@end defivar

@defivar {<log-drain>} syslog-option
@defivarx {<log-drain>} syslog-facility
@defivarx {<log-drain>} syslog-priority
The value of these slots are used when the destination of the drain
is the system logger.   @xref{Syslog}, for the detailed information
about these values.  The default values of these slots
are @code{LOG_PID}, @code{LOG_USER} and @code{LOG_INFO}, respectively.
@end defivar
@end deftp


@defun log-open path &keyword prefix program-name
Sets the destination of the default log message to the path @var{path}.
It can be a string or a boolean, as described above.
You can also set prefix and program name by corresponding keyword 
arguments.

Despite its name, this function doesn't open the specified file
immediately.  The file is opened and closed every time @code{log-format}
is called.
@end defun

@deffn {Parameter} log-default-drain
When called with no argument, returns the current default log-drain
@code{log-format} uses when the explicit drain is omitted.  
It may return @code{#f} if the default log drain hasn't been
opened by @code{log-open}.

Calling with new @code{<log-drain>} object or
@code{#f} alters the default log-drain.
You can also use @code{parameterize} (@ref{Parameters}) to change
the log drain temporary.
@end deffn


@deffn {Method} log-format (format <string>) arg @dots{}
@deffnx {Method} log-format (drain <log-drain>) (format <string>) arg @dots{}
Formats a log message by @var{format} and @var{arg @dots{}}, by using
@code{format} (@xref{Output}).    In the first form, the output goes
to the default destination.  In the second form, the output goes to
the specfied drain.

The file is opened and closed every time.  You can safely move
the log file while your program that touches the log file is running.
Also @code{log-format} acquires a write lock of the log file by
@code{sys-fcntl} (@xref{Low-level file operations}).

If the first form of @code{log-format} is called before @code{log-open}
is called, @code{log-format} does nothing.
It is useful to embed debug stubs in your code; once your code is
past the debugging stage, you just comment out @code{log-open} and
the code runs without logging.
@end deffn

@c ----------------------------------------------------------------------
@node Singleton, Slot with validator, User-level logging, Library modules - Gauche extensions
@section @code{gauche.mop.singleton} - Singleton
@c NODE シングルトン, @code{gauche.mop.singleton} - シングルトン

@deftp {Module} gauche.mop.singleton
@mdindex gauche.mop.singleton
Provides a metaclass to define a singleton class.
@end deftp

@deftp {Class} <singleton-meta>
@clindex singleton-meta
Creates a singleton class.  A singleton class is a class that is
guaranteed to create only one instance.
The first invocation of @code{make} creates the single instance,
and further attempt of creation returns the same instance.
@example
(define-class single () () :metaclass <singleton-meta>)

(define a (make single))
(define b (make single))

(eq? a b) @result{} #t
@end example

The slots of the instance are initialized at the first invocation
of @code{make}.  Initargs of @code{make} are effective only in the
fist invocation, and ignored in the subsequent invocation.
@end deftp

@deffn {Method} instance-of (class <singleton-meta>) &rest initargs
This method just calls @code{make} with the passed arguments.
It is more obvious in the program that you're dealing with singleton.
@end deffn

@deftp {Class} <singleton-mixin>
@clindex singleton-mixin
An instance of @code{<singleton-meta>}.  Instead of specifying
@code{<singleton-meta>} as the @code{:metaclass} argument of
@code{define-class}, you can inherit this class to give your
class the property of singleton.
@end deftp

@c ----------------------------------------------------------------------
@node Slot with validator, Networking, Singleton, Library modules - Gauche extensions
@section @code{gauche.mop.validator} - Slot with validator
@c NODE Validator付きスロット, @code{gauche.mop.validator} - Validator付きスロット

@deftp {Module} gauche.mop.validator
@mdindex gauche.mop.validator
Provides a metaclass that adds @code{:validator} and @code{:observer}
slot options.
@end deftp

@deftp {Class} <validator-meta>
@clindex validator-meta
This metaclass adds a feature that you can specify callbacks that are
called before and after the slot value is set.
For example, if you want to guarantee
that a certain slot always holds a string value, you can make a procedure
be called before the slot is modified, either by @code{slot-ref} or
by a setter method.  In the procedure you can either rejects a
value except string, or coerce the value to a string.

A @emph{validator} procedure is a callback procedure that is called
before the slot value is set.   It can be specified by @code{:validator}
slot option.  The procedure takes two values, the instance and
the value to be set.  Whatever the procedure returns is set to
the actual slot value.

A @emph{observer} procedure is a callback procedure that is called
after the slot value is set.  It can be specified by @code{:observer}
slot option.  The procedure also takes two values, the instance
and the new value.  Result of the observer procedure is discarded.

See the following example:

@example
(define-class <v> ()
  ((a :accessor a-of
      :validator (lambda (obj value) (x->string value)))
   (b :accessor b-of
      :validator (lambda (obj value)
                   (if (integer? value)
                       value
                       (error "integer required for slot b")))))
  :metaclass <validator-meta>)

(define v (make <v>))
(slot-set! v 'a 'foo)
(slot-ref v 'a) @result{} "foo"

(set! (a-of v) 1234)
(a-of v) @result{} "1234"

(slot-set! v 'b 55)
(slot-ref v 'b) @result{} 55

(slot-set! v 'b 3.4) @result{} @r{error}
(set! (b-of v) 3.4)  @result{} @r{error}
@end example

You can specify default slot value (@code{:init-value} etc.) with
@code{:validator}.  In that case, the initialization method of the
instance calls the validator with the specified default value,
if :init-keyword is not given.

@example
(define-class <v> ()
  ((a :initform 'foo :init-keyword :a
      :validator (lambda (obj value) (x->string value)))))

(slot-ref (make <v>) 'a)        @result{} "foo"
(slot-ref (make <v> :a 555) 'a) @result{} "555"
@end example

It looks similar to the virtual slot, but note that a slot with
validator has an actual storage in the instance, while a virtual
slot doesn't.

It is also a good example of customizing how the slots are accessed
using the metaobject protocol.  This feature is implemented by
only a couple of dozen lines of code.
@end deftp

@c ----------------------------------------------------------------------
@node Networking, Parameters, Slot with validator, Library modules - Gauche extensions
@section @code{gauche.net} - Networking
@c NODE ネットワーキング, @code{gauche.net} - ネットワーキング

@deftp {Module} gauche.net
@mdindex gauche.net
Provides a set of functions necessary for network communications
based on BSD socket interface.

The API is provided in two different levels.  Lower level routines
reflect traditional BSD socket interface, such as @code{bind(2)}.
Higher level routines provides more convenient way to create
typical connection-oriented server/client sockets.

This module also provides APIs to obtain various information
about hostnames, service ports, and protocols.

Gauche can handle IPv6 if it is compiled 
with the @code{--enable-ipv6} configuration option.
To check whether IPv6 is enabled or not, 
you can use @code{cond-expand} with
@code{gauche.net.ipv6} feature identifier
after loading @code{gauche.net}, as shown below.

@example
(use gauche.net)
(cond-expand
  (gauche.net.ipv6
    ... code to use ipv6 ...)
  (else
    ... ipv4 only code ...))
@end example

See @ref{Feature conditional} for the details of @code{cond-expand}.

@end deftp


@menu
* Socket address::              
* High-level network functions::  
* Low-level socket interface::  
* Netdb interface::             
@end menu

@node Socket address, High-level network functions, Networking, Networking
@subsection Socket address
@c NODE ソケットアドレス

@subsubheading Socket address objects

@deftp {Builtin Class} <sockaddr>
@clindex sockaddr
An abstract base class of socket addresses.  Each socket address family
is implemented as a subclass of this class.

Although socket addresses are built-in classes, you can use
@code{make} method to create an instance of a
specific socket address family.
@end deftp

@deffn {Generic Function} sockaddr-family addr
Returns a symbol that indicates the family of the socket address
@var{addr}.
@end deffn

@deffn {Generic Function} sockaddr-name addr
Returns a string which represents the content of the socket address
@var{addr}.
@end deffn

@deftp {Builtin Class} <sockaddr-in>
@clindex sockaddr-in
AF_INET family socket address.  To create an instance of this class,
use @code{make} method as follows:
@example
(make <sockaddr-in> :host @var{host} :port @var{port})
@end example
@var{host} can be a string, an integer IP address, a
@code{u8vector} IP address, or one of the keywords
@code{:any}, @code{:broadcast}, @code{:none} or @code{:loopback}.
If it is a string, it is either a host name or a dotted IP notation.
Gauche uses @code{gethostbyname(3)} to obtain the actual IP address from
@var{host} parameter.  If it is a keyword @code{:any}, 
or @code{:broadcast}, the address
uses @code{INADDR_ANY}, or @code{INADDR_BROADCAST}
respectively.  The keyword @code{:loopback} is a synonym to the
IPv4 loopback address "127.0.0.1".

@var{port} must be a positive integer indicating the port number.
See also @code{make-sockaddrs} below, to create multiple
socket addresses on the machine which may have more than one
protocol stack.
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-in>)
Returns a symbol @code{inet}.
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-in>)
Returns a string in the form "@var{a}.@var{b}.@var{c}.@var{d}:@var{port}",
 where "@var{a}.@var{b}.@var{c}.@var{d}" is dotted decimal notion of
the IP address and @var{port} is the port number.
@end deffn

@deffn {Method} sockaddr-addr (addr <sockaddr-in>)
@deffnx {Method} sockaddr-port (addr <sockaddr-in>)
Returns the IP address and the port number as an integer, respectively.
@end deffn

@deftp {Builtin Class} <sockaddr-un>
@clindex sockaddr-un
AF_UNIX family socket address.  To create an instance of this class,
use @code{make} method as follows:
@example
(make <sockaddr-un> :path @var{path})
@end example
@var{path} must be a string specifying pathname of the socket.
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-un>)
Returns a symbol @code{unix}.
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-un>)
Returns a pathname of the socket address.
@end deffn

@deftp {Builtin Class} <sockaddr-in6>
@clindex sockaddr-in6
AF_INET6 family socket address.  This is only available if
gauche is configured with --enable-ipv6 configure option.
The constructor and the slots are the same as @code{<sockaddr-in>}.
See also @code{make-sockaddrs} below, to create multiple
socket addresses on the machine which may have more than one
protocol stack.
@end deftp

@defun make-sockaddrs host port &optional proto
This is a higher-level utility procedure to create all possible
inet domain socket addresses that point to @code{@var{host}:@var{port}}
of protocol @var{proto}.  Particularly, if the specified host has
both IPv4 and IPv6 addresses, and the running system supports both,
then both IPv4 and IPv6 socket addresses are returned.   If @var{host} has
multiple IP addresses, socket addresses are created for each of these
IP address.   You can make your network application much more portable
among different network stack configurations.

Passing @code{#f} to @var{host} creates the local
(server) address.  You can also pass a service name (e.g. @code{"http"})
instead of an integer, to the @var{port} argument.
The value of @var{proto} can be either a symbol @code{tcp} or @code{udp},
and the default is @code{tcp}.

It always returns a list of socket addresses.  If the lookup of @var{host}
is failed, null list is returned.
@end defun

@subsubheading Address and string conversion

@defun inet-string->address address
Converts string representating of the internet address @var{address}
to an integer address.  If @var{address} is parsed successfully,
returns two values: the integer address value and the recognized
protocol (the constant value @code{2} (= @code{AF_INET})
for IPv4 addresses, and @code{10} (= @code{AF_INET6}) 
for IPv6 addresses).  If @var{address} can't be
parsed, @code{#f} and @code{#f} are returned.

@example
(inet-string->address "192.168.1.1")
 @result{} 3232235777 and 2
(inet-string->address "::1")
 @result{} 1 and 10
(inet-string->address "::192.168.1.1")
 @result{} 3232235777 and 10
(inet-string->address "ffe0::1")
 @result{} 340116213421465348979261631549233168385 and 10
(inet-string->address "::192.168.1.1")
 @result{} 3232235777 and 10
@end example
@end defun

@defun inet-string->address! address buf
Like @code{inet-string->address}, but fills the given u8vector
@var{buf} by the parsed address instead of returning it as
an integer value.  The integer representation of inet addresses 
is likely to be a bignum, and you can avoid creating bignums
with this function.  The given u8vector @var{buf} must be mutable.
Returns the protocol on success, or @code{#f} on failure.

The caller must provide big enough buffer.  If @var{buf}
is larger than required, the result is filled from the top
of the u8vector and the rest of the vector remains intact.

@example
(let* ((buf (make-u8vector 16 0))
       (proto (inet-string->address! "192.168.1.1" buf)))
  (list proto buf))
 @result{} (2 #u8(192 168 1 1 0 0 0 0 0 0 0 0 0 0 0 0))
@end example
@end defun


@defun inet-address->string address protocol
Converts the given @var{address} to its string representation
of the protocol @var{protocol}, which can be either
@code{2} (the constant @code{AF_INET}) or @code{10}
(the constant @code{AF_INET6}).
An integer or a u8vector can be used as @var{address}.  If it is
a u8vector, only the necessary portion of the vector is read; i.e.
the vector can be longer than the required length.

@example
(inet-address->string 3232235777 AF_INET)
  @result{} "192.168.1.1"

(inet-address->string '#u8(192 168 1 1) AF_INET)
  @result{} "192.168.1.1"

(inet-address->string 3232235777 AF_INET6)
  @result{} "::c0a8:101"
@end example
@end defun


@node High-level network functions, Low-level socket interface, Socket address, Networking
@subsection High-level network functions
@c NODE 高レベルネットワーク手続き

@deftp {Builtin Class} <socket>
@clindex socket
Abstracts a socket, a communication endpoint.

For a connection-oriented socket, you can access the communication
channel by two ports associated to the socket, one for input and
another for output.  @code{socket-input-port} and @code{socket-output-port}
returns those ports, respectively.
@end deftp

The following three functions are convenient ways to create
a connection-oriented socket.  Those functions
are to provide an easy methods for typical cases,
but have less control.  If you need more than these functions
provide, use low-level interface.

@defun make-client-socket &optional address-spec @dots{}
Creates and returns a client socket, connected to the address
specified by @var{address-spec} @dots{}.

@table @code
@item (make-client-socket 'unix @var{path})
The client socket is connected to the unix domain server socket
of address @var{path}.
@item (make-client-socket 'inet @var{host} @var{port})
The client socket is connected to the inet domain server socket
with hostname @var{host} and port @var{port}.   TCP protocol is
assumed.   @var{host} can be either a hostname, or
a dotted decimal notation of IPv4 address.
If gauche is compiled with --enable-ipv6, IPv6 address notation
can also be used.  @var{Port} must be an exact integer specifying
a port number, or a string service name (e.g. @code{"http"}).

If gauche is compiled with --enable-ipv6, and the hostname is given,
and the hostname has both IPv6 and IPv4 addresses, then
IPv6 connection is tried first, and IPv4 is used when IPv6 fails.
@item (make-client-socket @var{host} @var{port})
This works the same as above.  This form is for compatibility with STk.
@item (make-client-socket @var{sockaddr})
If an instance of @code{<sockaddr>} is passed,
a socket suitable for @var{sockaddr} is opened and then connected
to the given address.
@end table

This function raises an error if it cannot create a socket,
or cannot connect to the specified address.

@example
(make-client-socket 'inet "www.w3.com" 80)
  @result{} ;@r{a socket connected to www.w3.com, port 80}
(make-client-socket "127.0.0.1" 23)
  @result{} ;@r{a socket connected to localhost, port 23}
(make-client-socket 'unix "/tmp/.sock"
  @result{} ;@r{a socket connected to a unix domain socket "/tmp/.sock"}
@end example
@end defun

@defun make-server-socket &optional address-spec @dots{}
Creates and returns a server socket, listening the address
specified by @var{address-spec}.

@table @code
@item (make-server-socket 'unix @var{path} [:backlog @var{num}])
The socket is bound to a unix domain socket with a name @var{path}.
The keyword argument @var{backlog} is passed to @code{socket-listen}
to specify the maximum number of connection request the server can keep
befor accepting them.  The default is 5.  If your server is very busy
and you see "connection refused" often, you might want to increase it.
@item (make-server-socket 'inet @var{port} [:reuse-addr? @var{flag}] [:sock-init @var{proc}] [:backlog @var{num}])
The socket is bound to an inet domain TCP socket, listening
port @var{port}, which must be a non-negative exact integer
or a string service name (e.g. @code{"http"}).
If @var{port} is zero, the system assigns one of available port numbers.
If a keyword argument @var{reuse-addr?} is given and true,
@code{SO_REUSEADDR} option is set to the socket before bound to
the port.  This allows the process to bind the server socket
immediately after other process releases the port.

If keyword argument @code{sock-init} is given, it should be a procedure
that takes two arguments, a created socket and the socket address.
The procedure is called just after the socket is created.  It is
useful to set some special socket options.
The keyword argument @var{backlog} is the same as in unix sockets;
see the description above.
@item (make-server-socket @var{port} [:reuse-addr? @var{flag}] [:sock-init @var{proc}][:backlog @var{num}])
This is a synonym to the above form (except @var{port} must be 
an integer).  This form is backward-compatible
with STk's @code{make-server-socket}.
@item (make-server-socket @var{sockaddr} [:reuse-addr? @var{flag}][:sock-init @var{proc}][:backlog @var{num}])
This form explicitly specifies the socket address to listen
by an instance of @code{<sockaddr>}.
@end table

@example
(make-server-socket 'inet 8080)
  @result{} #<socket (listen "0.0.0.0:8080")>
(make-server-socket 8080)
  @result{} #<socket (listen "0.0.0.0:8080")>
(make-server-socket 'inet 0)
  @result{} #<socket (listen "0.0.0.0:35628")>
(make-server-socket 'unix "/tmp/.sock")
  @result{} #<socket (listen "/tmp/.sock")>
@end example
@end defun

@defun make-server-sockets host port &keyword reuse-addr? sock-init
Creates one or more sockets that listen at @var{port}
on all available network interfaces of @var{host}.
You can specify a service name (such as "@code{http}") to
@var{port}, as well as an integer port number.
Returns a list of opened, bound and listened sockets.

This procedure is particularly useful when the host
has multiple protocol stacks, such as IPv4 and IPv6.

The meaning of keyword arguments are the same as of @code{make-server-socket}.
@end defun

Several accessors are available on the returned socket object.

@defun socket-address socket
Returns a socket address associated with @var{socket}.
If no address has been associated to the socket, @code{#f} is returned.
@end defun

@defun socket-input-port socket &keyword (buffering @code{:modest})
@defunx socket-output-port socket &keyword (buffering @code{:line})
Returns an input and output port associated with @var{socket},
respectively.

The keyword argument @var{buffering} specifies the buffering mode
of the port.  @xref{File ports}, for explanation of the
buffering mode.
@end defun

@defun socket-close socket
Closes @var{socket}.  All the ports associated to
@var{socket} are closed as well.
Note: as of release 0.7.2, this procedure does not shutdown
the connection.  It is because @var{socket} may be referenced
by forked process(es) and you might want to close it without
interfering the existing connection.   You can call
@code{socket-shutdown} to shutdown the connection explicitly.
@end defun

@defun call-with-client-socket socket proc
@var{socket} must be a connected client socket.  @var{proc} is called
with two arguments, an input port that reads from the socket
and an output port that writes to the socket.
The socket is closed after @var{proc} returns or @var{proc}
raises an error.
@end defun

This is an example of usage of high-level socket functions,
a very simple http client.

@example
#!/usr/bin/env gosh
(use gauche.net)

(define (usage)
  (display "Usage: swget url\n" (current-error-port))
  (exit 1))

;; Returns three values: host, port, and path.
(define (parse-url url)
  (rxmatch-let (rxmatch #/^http:\/\/([-A-Za-z\d.]+)(:(\d+))?(\/.*)?/ url)
      (#f host #f port path)
    (values host port path)))

(define (get url)
  (receive (host port path) (parse-url url)
    (call-with-client-socket
        (make-client-socket 'inet host (string->number (or port "80")))
      (lambda (in out)
        (format out "GET ~a HTTP/1.0\r\n" path)
        (format out "host: ~a\r\n\r\n" host)
        (flush out)
        (copy-port in (current-output-port))))))

(define (main args)
  (if (= (length args) 2)
      (get (cadr args))
      (usage))
  0)
@end example


@node Low-level socket interface, Netdb interface, High-level network functions, Networking
@subsection Low-level socket interface
@c NODE 低レベルソケットインタフェース

These functions provide APIs similar to the system calls.
Those who are familiar to programming with socket APIs will
find these functions useful since you can have more detailed control over
the sockets.

@defun make-socket domain type &optional protocol
Returns a socket with specified parameters.
@end defun

@defvr {Constant} PF_UNIX
@defvrx {Constant} PF_INET
@defvrx {Constant} PF_INET6
These constants are bound to the system's constants
@code{PF_UNIX}, @code{PF_INET} and @code{PF_INET6}.
You can use those values for @var{domain} argument of @code{make-socket}.

(@code{PF_INET6} is defined only if the underlying operating
system supports IPv6.)
@end defvr

@defvr {Constant} AF_UNIX
@defvrx {Constant} AF_INET
@defvrx {Constant} AF_INET6
These constants are bound to @code{AF_UNIX}, 
@code{AF_INET} and @code{AF_INET6}.

(@code{AF_INET6} is defined only if the underlying operating
system supports IPv6.)
@end defvr

@defvr {Constant} SOCK_STREAM
@defvrx {Constant} SOCK_DGRAM
@defvrx {Constant} SOCK_RAW
These constants are bound to @code{SOCK_STREAM}, @code{SOCK_DGRAM}
and @code{SOCK_RAW}, and suitable to pass to the @var{type} argument
of @code{make-socket}.
@end defvr

@defun socket-fd socket
Returns an integer system file descriptor of the underlying socket.
@end defun


@defun socket-status socket
Returns a internal status of @var{socket}, by one of the following
symbols.
@multitable {aaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item none
@tab The socket is just created.
@item bound
@tab The socket is bound to an address by @code{socket-bind}
@item listening
@tab The socket is listening a connection by @code{socket-listen}
@item connected 
@tab The socket is connected by @code{socket-connect} or @code{socket-accept}.
@item shutdown
@tab The socket is shutdown by @code{socket-shutdown}
@item closed
@tab The socket is closed by @code{socket-close}.
@end multitable
@end defun

@defun socket-bind socket address
Binds @var{socket} to the local network address @var{address}.
It is usually used to associate specific address to the server port.
If binding failed, an error is signalled (most likely the address is
already in use).

For the inet domain address, you can pass @var{address} with port=0;
the system assigns the port number and sets the actual address to
the @code{address} slot of @var{socket}.
@end defun

@defun socket-listen socket backlog
Listens @var{socket}.  The socket must be already bound to some
address.  @var{backlog} specifies maximum number of connection
requests to be queued.
@end defun

@defun socket-accept socket
Accepts a connection request coming to @var{socket}.
Returns a new socket that is connected to the remote entity.
The original @var{socket} keeps waiting for further connections.
If there's no connection requests, this call waits for one to come.

You can use @code{sys-select} to check if there's a pending connection
request.
@end defun

@defun socket-connect socket address
Connects @var{socket} to the remote address @var{address}.
This is the way for a client socket to connect to the remote entity.
@end defun

@defun socket-shutdown socket how
Shuts down connection of @var{socket}.  If @var{how} is @code{SHUT_RD} (or 0),
the receive channel of @var{socket} is disallowed.
If @var{how} is @code{SHUT_WR} (or 1), the send channel of
@var{socket} is disallowed.
If @var{how} is @code{SHUT_RDWR} (or 2), both receive and send channels are
disallowed.  It is an error to call this function on a non-connected socket.

If you shut down the send channel of the socket, the remote peer
sees EOF from its receive channel.  This is useful if the remote peer
expects EOF before sending something back to you.
@end defun

@defun socket-getsockname socket
Returns a @code{<sockaddr>} instance that is the local address of
@var{socket}.
@end defun

@defun socket-getpeername socket
Returns a @code{<sockaddr>} instance that is the peer address of
@var{socket}.
@end defun

@defun socket-send socket msg &optional flags
@defunx socket-sendto socket msg to-address &optional flags.
Interfaces to @code{send(2)} and @code{sendto(2)}, respectively.
Transmits the content of @var{msg} through @var{socket}.
@var{msg} can be either a string or a uniform vector; if you send
binary packets, uniform vectors are recommended.

When @code{socket-send} is used, @var{socket} must already be connected.
On the other hand, @code{socket-setdto} can be used for non-connected
socket, and the destination address is specified by 
a @code{<sockaddr>} instance @var{to-address}.

The optional @var{flags} can be a bitwise OR of the integer
constants @code{MSG_*}.  See the system's manpage of @code{send(2)}
and @code{sendto(2)} for the details.
@end defun

@defun socket-recv! socket buf &optional flags
Interface to @code{recv(2)}.  Receives a message from @var{socket},
and stores it into @var{buf}, which must be a mutable uniform vector.
Returns the number of bytes actually written.   @var{socket} must
be already connected.  If the size of @var{buf} isn't enough to
store the entire message, the rest may be discarded depending on
the type of @var{socket}.

The optional @var{flags} can be a bitwise OR of the integer
constants @code{MSG_*}.  See the system's manpage of @code{recv(2)}
for the details.
@end defun

@defun socket-recvfrom! socket buf addrs &optional flags
Interface to @code{recvfrom(2)}.  Receives a message from
@var{socket}, which may be unconnected, and stores it to
a mutable uniform vector @var{buf}.  Like @var{socket-recv},
if the size of @var{buf} isn't enough to store the entire message, 
the rest may be discarded depending on the type of @var{socket}.

Returns two values; the number of bytes actually written into
@var{buf}, and an instance of a subclass of @code{<sys-sockaddr>}
which shows the sender's address.

The @var{addrs} argument must be a list of instances of socket
addresses, optionally its last cdr being @code{#t} (as a special
case, if there's zero addresses to pass, just @code{#t} may be given).
The content of each address doesn't matter; if the protocol family
of one of them matches the sender's address, the sender's address
is written into the passed sockaddr object.  By listing sockaddrs
of possible families, you can count on @code{socket-recvfrom!}
to allocate no memory on successful operation.  It is useful if
you call @code{socket-recvfrom!} in a speed-sensitive inner loop.

If the sender's address family doesn't match any of the addresses
given to @var{addrs}, the behavior depends on whether the list is
terminated by @code{()} or @code{#t}.  If it is terminated by @code{()},
(i.e. @var{addrs} is a proper list), the sender's address is simply
discarded and @code{socket-recvfrom!} returns @code{#f} as the
second value.  If the list is terminated by @code{#t}, 
@code{socket-recvfrom!} allocates a fresh sockaddr object and
returns it as the second value.  

Two simple cases: If you pass @code{()} to @var{addrs}, the sender's
address is always discarded, which is useful if @var{socket} is
connected (that is, you already know your sender's address).
If you pass @code{#t} to @var{addrs}, a new socket address
object is always allocated for the sender's address,
which is convenient if you don't mind memory allocation.

The optional @var{flags} can be a bitwise OR of the integer
constants @code{MSG_*}.  See the system's manpage of @code{recvfrom(2)}
for the details.
@end defun


@defun socket-recv socket bytes &optional flags
@defunx socket-recvfrom socket bytes &optional flags
Like @code{socket-recv!} and @code{socket-recvfrom!}, but
these returns the received message as a (possibly incomplete)
string, up to @var{bytes} size.  Additionally,
@code{socket-recvfrom} always allocates a socket address
object for the sender's address.

The use of these procedures are discouraged, since they
often returns incomplete strings for binary messages.
Using strings for binary data creates many pitfalls.
Uniform vectors (especially @code{u8vector}s) are for binary data.
(The reason these procedures return strings is merely historical.)
@end defun

@defvar MSG_CTRUNC
@defvarx MSG_DONTROUTE
@defvarx MSG_EOR
@defvarx MSG_OOB
@defvarx MSG_PEEK
@defvarx MSG_TRUNC
@defvarx MSG_WAITALL
Pre-defined integer constants to be used as @var{flags} values
for @code{socket-send}, @code{socket-sendto}, @code{socket-recv}
and @code{socket-recvfrom}.   Some of these constants may not be
defined if the underlying operating system doesn't provide them.
@end defvar

Further control over sockets and protocol layers is possible
by getsockopt/setsockopt interface, as described below.

@defun socket-setsockopt socket level option value
@defunx socket-getsockopt socket level option rsize
These are the interface to setsockopt() and getsockopt() calls.
The interface is a bit clumsy, in order to allow full access to
those low-level calls.

@var{socket} must be a non-closed socket object.
@var{level} and @var{option} is an exact integer to specify
the level of protocol stack and the option you want to deal with.
There are several variables pre-bound to system constants listed below.

To set the socket option, you can pass either an exact integer or
a string to @var{value}.  If it is an integer, the value is passed
to setsockopt(2) as C @code{int} value.  If it is a string, the
byte sequence is passed as is.  The required type of value depends on
the option, and Gauche can't know if the value you passed is expected
by setsockopt(2); it is your responsibility to pass the correct values.

To get the socket option, you need to tell the maximum length of expected
result by @var{rsize} parameter, for Gauche doesn't know the amount
of data each option returns.
@code{socket-getsockopt} returns the option value as a byte string.
If you know the option value is an integer, you can pass 0 to @var{rsize};
in that case @code{socket-getsockopt} returns the value as an exact integer.

Note about the name: I tempted to name these function socket-@{set|get@}opt
or socket-@{set|get@}-option,
but I rather took the naming consistency.  Hence duplicated "sock"s.


@end defun

The following predefined variables are provided.
Note that some of them are not available on all platforms.
See manpages @code{socket(7)}, @code{tcp(7)} or @code{ip(7)} of
your system to find out exact specification of those values.

For ``level'' argument:
@defvar SOL_SOCKET
@defvarx SOL_TCP
@defvarx SOL_IP
These variables are bound to @code{SOL_SOCKET}, @code{SOL_TCP} and
@code{SOL_IP}, respectively.
@end defvar

For ``option'' argument:
@defvar SO_KEEPALIVE
Expects integer value.  If it is not zero, enables sending  of
keep-alive messages on connection-oriented sockets.
@end defvar

@defvar SO_OOBINLINE
Expects integer value.  If it is not zero, out-of-band data is
directly placed into the receive data stream.  Otherwise
out-of-band  data  is  only passed when the
MSG_OOB flag is set during receiving.
@end defvar

@defvar SO_REUSEADDR
Expects integer value.  If it is not zero, @code{socket-bind}
allows to reuse local addresses, unless an active listening
socket bound to the address.
@end defvar

@defvar SO_TYPE
Gets the socket type as an integer (like @code{sock_stream}).
Can be only used with @code{socket-getsockopt}.
@end defvar

@defvar SO_BROADCAST
Expects integer value.  If it is not zero, datagram sockets
are allowed to send/receive broadcast packets.
@end defvar

@defvar SO_PRIORITY
Expects integer value, specifying the protocol-defined priority
for all packets to be sent on this socket.
@end defvar

@defvar SO_ERROR
Gets and clears the pending socket error as an integer.
Can be only used with @code{socket-getsockopt}.
@end defvar


@defun inet-checksum packet size
Calculates one's complement of Internet Checksum (RFC1071) of the
@var{packet}, which must be given as a uniform vector.  First
@var{size} bytes of @var{packet} are used for calculation.
Returned value is in network byte order (big-endian).
It is an error if @var{size} is greater than the size of @var{packet}.

Note: The used algorithm assumes @var{packet} is not too big (< 64K).
@end defun


@node Netdb interface,  , Low-level socket interface, Networking
@subsection  Netdb interface
@c NODE Netdbインタフェース




@deftp {Builtin Class} <sys-hostent>
@clindex sys-hostent
A class of objects for network hosts.  Corresponding to
@code{struct hostent} in C.  The following slots are available read-only.

@defivar {<sys-hostent>} name
The formal name of the host (string).
@end defivar
@defivar {<sys-hostent>} aliases
A list of alias names of the host (list of strings).
@end defivar
@defivar {<sys-hostent>} addresses
A list of addresses (list of strings).  Only ipv4 address is 
supported currently.  Each address is represented by dotted decimal
notation.
@end defivar
@end deftp

@defun sys-gethostbyname name
Looks up a host named @var{name}.
If found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@example
(let ((host (sys-gethostbyname "www.w3c.org")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses)))
  @result{} ("www.w3.org" ("www.w3c.org") ("18.29.1.34" "18.29.1.35"))
@end example
@end defun

@defun sys-gethostbyaddr addr proto
Looks up a host that has an address @var{addr} of protocol @var{proto}.
@var{addr} is a natural string representation of the address;
for ipv4, it is a dotted decimal notation.  @var{proto} is a
protocol number; only @code{AF_INET} is supported currently.
If the host is found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@example
(let ((host (sys-gethostbyaddr "127.0.0.1" AF_INET)))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses))
  @result{} ("localhost" ("localhost.localdomain") ("127.0.0.1"))
@end example
@end defun

@deftp {Builtin Class} <sys-servent>
@clindex sys-servent
An entry of the network service database.  Corresponding to
@code{struct servent} in C.  The following slots are available read-only.

@defivar {<sys-servent>} name
The formal name of the service (string).
@end defivar
@defivar {<sys-servent>} aliases
A list of alias names of the service (list of strings).
@end defivar
@defivar {<sys-servent>} port
A port number registered for this service (exact integer).
@end defivar
@defivar {<sys-servent>} proto
A protocol name for this service (string).
@end defivar
@end deftp

@defun sys-getservbyname name proto
Looks up the network service database with a service name @var{name} and
a protocol @var{proto}.  Both @var{name} and @var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((serv (sys-getservbyname "http" "tcp")))
  (list (slot-ref serv 'name)
        (slot-ref serv 'aliases)
        (slot-ref serv 'port)
        (slot-ref serv 'proto)))
  @result{} ("http" () 80 "tcp")
@end example
@end defun

@defun sys-getservbyport port proto
Looks up the network service database with a service port @var{port} and
a protocol @var{proto}.  @var{port} must be an exact integer, and
@var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((serv (sys-getservbyport 6000 "tcp")))
  (list (slot-ref serv 'name)
        (slot-ref serv 'aliases)
        (slot-ref serv 'port)
        (slot-ref serv 'proto)))
  @result{} ("x-server" () 6000 "tcp")
@end example
@end defun

@deftp {Builtin Class} <sys-protoent>
@clindex sys-protoent
An entry of the protocol database.   Corresponds to @code{struct protoent}
in C.   The following slots are available read-only.

@defivar {<sys-servent>} name
The formal name of the protocol (string).
@end defivar
@defivar {<sys-servent>} aliases
A list of alias names of the protocol (list of strings).
@end defivar
@defivar {<sys-servent>} proto
A protocol number (exact integer).
@end defivar
@end deftp

@defun sys-getprotobyname name
Looks up the network protocol database with a name @var{name},
which must be a string.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((proto (sys-getprotobyname "icmp")))
  (list (slot-ref proto 'name)
        (slot-ref proto 'aliases)
        (slot-ref proto 'proto)))
  @result{} ("icmp" ("ICMP") 1)
@end example
@end defun

@defun sys-getprotobynumber number
Looks up the network protocol database with a protocol number @var{number},
which must be an exact integer.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((proto (sys-getprotobynumber 17)))
  (list (slot-ref proto 'name)
        (slot-ref proto 'aliases)
        (slot-ref proto 'proto)))
  @result{} ("udp" ("UDP") 17)
@end example
@end defun

@deftp {Builtin Class} <sys-addrinfo>
@clindex sys-addrinfo
The new interface to keep address information.
Corresponds to @code{struct addrinfo} in C.
This is only available if gauche is configured with --enable-ipv6 option.
The following slots are provided.

@defivar {<sys-addrinfo>} flags
@end defivar
@defivar {<sys-addrinfo>} family
@end defivar
@defivar {<sys-addrinfo>} socktype
@end defivar
@defivar {<sys-addrinfo>} protocol
@end defivar
@defivar {<sys-addrinfo>} addrlen
@end defivar
@defivar {<sys-addrinfo>} addr
@end defivar
@end deftp

@defun sys-getaddrinfo nodename servname hints
Returns @code{<sys-addrinfo>} instance from the given @var{nodename},
@var{servname} and @var{hints}.
This is only available if gauche is compiled with --enable-ipv6 option.
@end defun

@defun sys-ntohs integer
@defunx sys-ntohl integer
@defunx sys-htons integer
@defunx sys-htonl integer
Utility functions to convert 16bit (@code{s}) or 32bit (@code{l}) integers
between @emph{network} byte order (@code{n}) and @emph{host} byte order
(@code{h}).

Scheme API to the netdb interface calls those byte order conversion
functions internally, so you don't usually need them so much as in C 
programs.  However, it may be useful when you're constructing or
analyzing binary packets.  See also @ref{Packing Binary Data} to handle
binary data.
@end defun

@c ----------------------------------------------------------------------
@node Parameters, Parsing command-line options, Networking, Library modules - Gauche extensions
@section @code{gauche.parameter} - Parameters
@c NODE パラメータ, @code{gauche.parameter} - パラメータ

@deftp {Module} gauche.parameter
@mdindex gauche.parameter
A @emph{parameter} is something like a stateful procedure that takes zero or
one argument.
If no argument is given, the parameter returns the current value it is keeping.
If single argument is given, it will be the current value of the parameter.
A parameter has several advantages over global variables to store
states.

Value of parameters are kept for each thread, so you can use
a parameter as a thread-local storage.  When a new thread is
created, it inherits a copy of parameters from its creator thread.

You can give a "filter procedure" that checks the new
value before setting it as the parameter value,
so that you can guarantee the value of the parameter is always sane.

With the macro @code{parameterize}, you can change the parameter's
value within certain dynamic scope.   It can effectively
replace dynamically scoped variables.

You can also register callback procedures to be called whenever
the value of the parameter is changed.   It can effectively
replace so-called "traced variables"

The basic parameter object feature is defined in SRFI-39.
It also can be found in other Scheme implementations,
including ChezScheme, Chicken and MzScheme.
Gauche's one is upper compatible to SRFI-39.
@end deftp

@deftp {Class} <parameter>
@clindex parameter
A parameter class.  A @code{object-apply} method is defined
so that a parameter can be used as if it were a procedure.
@end deftp

@defun make-parameter value &optional filter
[SRFI-39]
Creates a parameter whose initial value is @var{value}.
If an optional argument @var{filter} is given, it must be
a procedure that takes one argument and returns one value;
whenever the parameter's value is about to change, the procedure
is called with the given value, and the value the procedure
returns will be the parameter's value.  The filter procedure
can raise an error or reject to change the parameter's value.
@end defun

@defmac parameterize ((param value) @dots{}) body @dots{}
[SRFI-39]
Evaluages @var{body} @dots{}, with
change parameter @var{param}'s value to the given @var{value} within
the dynamic scope of @var{body} @dots{}.
Returns the value(s) of the result of the last @var{body}.
@end defmac

Some examples:
@example
(define a (make-parameter 1))
(a) @result{} 1
(a 2) @result{} 1
(a) @result{} 2
(parameterize ((a 3))
  (a)) @result{} 3
(a) @result{} 2
@end example

@deffn {Method} parameter-observer-add! (p <parameter>) proc &optional when where
Adds @var{proc} to "observer" procedures of a parameter @var{p}.
Observer procedures are called either (1) just before
a new value is set to the parameter, or (2) just after the new value
is set to the parameter.   In case of (1), a filter procedure is
already applied before a callback is called.
In either case, observer procedures are called with two arguments,
the old value and the new value.  The return value(s) of observer
procedures are discarded.

The optional @var{when} argument must be either a symbol @code{before}
or @code{after}, to specify whether @var{proc} should be called
before or after the value is changed.   If omitted, @code{after} is
assumed.

The optional @var{where} argument must be either a symbol
@code{append} or @code{prepend}, to specify whether @var{proc} should
be prepended or appended to the existing observer procedure list.
If omitted, @code{append} is assumed.

@emph{Note}: Although the parameter value itself is thread-local,
the observer list is shared by all threads.
@end deffn

@deffn {Method} parameter-observer-delete! (p <parameter>) proc &optional when
Deletes @var{proc} from observer procedure list of a parameter @var{p}.
If @var{proc} is not in the list, nothing happens.
You can give either a symbol @code{before} or @code{after} to
@var{when} argument to specify from which list @var{proc} should be
deleted.  If @var{when} argument is omitted, @var{proc} is deleted
from both lists.
@end deffn

@deffn {Method} parameter-pre-observers (p <parameter>)
@deffnx {Method} parameter-post-observers (p <parameter>)
Returns a hook object (@xref{Hooks}) that keeps
"before" or "after" observers, respectively.

@emph{Note}: Although the parameter value itself is thread-local,
these hook objects are shared by all threads.
@end deffn

@c ----------------------------------------------------------------------
@node Parsing command-line options, High Level Process Interface, Parameters, Library modules - Gauche extensions
@section @code{gauche.parseopt} - Parsing command-line options
@c NODE コマンドライン引数の解析, @code{gauche.parseopt} - コマンドライン引数の解析

@deftp {Module} gauche.parseopt
@mdindex gauche.parseopt
This module defines a convenient way to parse command-line options.
The interface is hinted by Perl, and conveniently handles long-format
options with multiple option arguments.

Actually, you have a few choices to parse command-line
options in Gauche.
SRFI-37 (@xref{A program argument processor}) provides
functional interface to parse POSIX/GNU compatible argument syntax.
SLIB has @code{getopt}-compatible utility.
Required features may differ from application to application,
so choose whichever fits your requirement.
@end deftp

@subheading High-level API

@defmac let-args args (bind-spec @dots{} [. rest]) body @dots{}
This macro captures the most common pattern of argument processing.
It takes a list of arguments, @var{args}, and scans it to find
Unix-style command-line options and binds their values to local
variables according to @var{bind-spec}, then executes @var{body} @dots{}.

Let's look at a simple example first, which gives you a good idea of
what this form does. (See the ``Examples'' section below for more
examples).

@example
(define (main args)
  (let-args (cdr args)
      ((verbose     "v|verbose")
       (outfile     "o|outfile=s")
       (debug-level "d|debug-level=i" 0)
       (help        "h|help" => (cut show-help (car args)))
       . restargs
      )
    ....))

(define (show-help progname)
  ...)
@end example

The local variable @var{verbose} will be bound to @code{#t} if
a command-line argument @code{-v} or @code{--verbose} is given, 
and to @code{#f} otherwise.
The variable @var{output} is specified to take one option argument;
if the command-line arguments are given like @code{-o out.txt}, 
@var{outfile} receives
@code{"out.txt"}.  The @var{debug-level} one is similar, but the
option argument is coerced to an integer, and also it has default
value 0 when the option isn't given.  The @var{help} clause
invokes an action rather than merely binding the value.

(Note: Currently @code{let-args} does not distinguish so-called 
short and long options, e.g. @code{-v} and @code{--v} have the same
effect, so as @code{-verbose} and @code{--verbose}.  In future we
may add an option to make it compatible with @code{getopt_long(3)}.)

The final @var{restargs} variable after the dot receives a list of
non-optional command-line arguments.

Let's look at @var{bind-spec} in detail.  
It must be one of the following forms.

@example
1. (@var{var} @var{option-spec})
2. (@var{var} @var{option-spec} @var{default})
3. (@var{var} @var{option-spec} => @var{callback})
4. (@var{var} @var{option-spec} @var{default} => @var{callback})

5. (else => @var{handler})
6. (else @var{formals} @var{body} ...)
@end example

A list of command-line arguments passed to @var{args} are parsed
according to @var{option-spec}s.  If the corresponding option
is given, a variable @var{var} is bound to a value as follows:

@example
(a) If the @var{bind-spec} is 1. or 2., then
  (a1) If @var{option-spec} doesn't require an argument, then @code{#t}:
  (a2) If @var{option-spec} requires one argument, then the value of
       the argument:
  (a3) If @var{option-spec} requires more than one argument,
       the list of the values of the arguments.
(b) If the @var{bind-spec} is 3. or 4., then @var{callback} is called with
  the value(s) of arguments, and its return value.
@end example

We'll explain the details of @var{option-spec} later.

As a special case, @var{var} can be @code{#f}, in which case
the value is ignored.  It is only useful for side effects in
@var{callback}.

If the corresponding option is not given in @var{args},
@var{var} is bound to @var{default} if it is given, or
@code{#f} otherwise.

The last @var{bind-spec} may be the form 5 or 6. in which case
the clause is selected when no other @var{option-spec} matches
a given command-line option.  
In the form 5, @var{handler} will be called with three arguments;
the given option, a list of remaining command-line arguments,
and a continuation procedure.  The @var{handler}
is supposed to handle the given option, and it may call the
continuation procedure with the remaining arguments to continue
processing, or it may return a list of arguments which will
be treated as non-optional command-line arguments.
The form 6 is a shorthand notion of 
@code{(else => (lambda @var{formals} @var{body} ...))}.

The @var{bind-spec} list can be an improper list, whose last cdr is
a symbol.  In which case, a list of the rest of the command-line arguments
is bound to the variable named by the symbol.

Note that the @var{default}, @var{callback}, and forms in @code{else}
clause is evaluated outside of the scope of binding of @var{var}s
(as the name @code{let-args} implies).

Unlike typical @code{getopt} or @code{getopt_long} implementation in C,
@code{let-args} does not permute the given command-line arguments.
It stops parsing when it encounters a non-option argument (argument without
starting with a minus sign).

If the parser encounters an argument with only two minus signs `@code{--}',
it stops argument parsing and returns a list of arguments after `@code{--}'.


After all the bindings is done, @var{body} @dots{} are evaluated.
@var{Body} may began with internal define forms.
@end defmac

@subheading Option spec

@var{option-spec} is a string that specifies the name of the option and
how the option takes the arguments.  An alphanumeric characters, underscore,
plus and minus sign is allowed for option's names, except that
minus sign can't be the first character, i.e. the valid option name
matches a regexp @code{#/[\w+][-\w+]*/}.

If the option takes argument(s), it can be specified by attaching 
equal character and a character (or characters) that represents
the type of the argument(s) after the name.  The option
can take more than one arguments.
The following characters are recognized as a type specifier of
the option's argument.

@table @code
@item s
String.
@item n
Number.
@item f
Real number (coerced to flonum).
@item i
Exact integer.
@item e
S-expression.
@item y
Symbol (argument is converted by @code{string->symbol}).
@end table

Let's see some examples of @var{option-spec}:

@table @code
@item "@var{name}"
Specifies option @var{name}, that doesn't take any argument.

@item "@var{name}=s"
Option @var{name} takes one argument, and it is passed as a string.

@item "@var{name}=i"
Option @var{name} takes one argument, and it is passed as an exact integer.

@item "@var{name}=ss"
Option @var{name} takes two arguments, both string.

@item "@var{name}=iii"
Option @var{name} takes three integer arguments.

@item "@var{name}=sf"
Option @var{name} takes two arguments, the first is a string and the
second is a number.
@end table

If the option has alternative names, they can be concatenated by "|".
For example, an option spec @code{"h|help"} will match both
"h" and "help".

In the command line, the option may appear with preceding
single or double minus signs.  The option's argument may be combined
by the option itself with an equal sign.  For example, all the following
command line arguments match an option spec @code{"prefix=s"}.
@example
-prefix /home/shiro
-prefix=/home/shiro
--prefix /home/shiro
--prefix=/home/shiro
@end example

@subheading Examples

This example is taken from @code{gauche-install} script.  
The @var{mode} option takes numbers in octal, so it 
uses the callback procedure to convert it.
See also the @code{else} clause how to handle unrecognized option.

@example
  (let-args (cdr args)
      ((#f      "c")        ;; ignore for historical reason
       (mkdir   "d|directory")
       (mode    "m|mode=s" #o755 => (cut string->number <> 8))
       (owner   "o|owner=s")
       (group   "g|group=s")
       (srcdir  "S|srcdir=s")
       (target  "T|target=s")
       (utarget "U|uninstall=s")
       (shebang "shebang=s")
       (verb    "v")
       (dry     "n|dry-run")
       (#f      "h|help" => usage)
       (else (opt . _) (print "Unknown option : " opt) (usage))
       . args)
    ...)
@end example

The next example is a small test program to show the usage of
@code{else} clause.  It gathers all options into the variable @var{r},
except that when it sees @code{-c} it stops argument processing and
binds the rest of the arguments to @var{restargs}.

@example
(use gauche.parseopt)

(define (main args)
  (let1 r '()
    (let-args (cdr args)
      ((else (opt rest cont) 
         (cond [(equal? opt "c") rest]
               [else (push! r opt) (cont rest)]))
       . restargs)
     (print "options: " (reverse r))
     (print "restargs: " restargs)
     0)))
@end example

Sample session of the above script (suppose it is saved as @file{example}).

@example
$ ./example -a -b -c -d -e foo
options: (a b)
restargs: (-d -e foo)
$ ./example -a -b -d -e foo
options: (a b d e)
restargs: (foo)
@end example


@subheading Low-level API

The followings are lower-level API used to build @code{let-args}
macro.  


@defmac parse-options args (option-clause @dots{})
@var{args} is an expression that contains a list of command-line arguments.
This macro scans the command-line options (an argument that begins with
`@code{-}') and processes it as specified in @var{option-clause}s, then
returns the remaining arguments.

Each @var{option-clause} is consisted by a pair of @var{option-spec}
and its action.

If a given command-line option matches one of @var{option-spec}, then
the associated action is evaluated.  An action can be one of the
following forms.

@table @code
@item @var{bind-spec} @var{body} @dots{}
@var{bind-spec} is a proper or dotted list of variables like lambda-list.
The option's arguments are bound to @var{bind-spec}, then
then @var{body} @dots{} is evaluated. 

@item => @var{proc}
If a command-line option matches @var{option-spec}, calls a procedure
@var{proc} with a list of the option's arguments.
@end table

If a symbol @code{else} is at the position of @var{option-spec},
the clause is selected when no other option clause matches a given
command-line option.  Three ``arguments'' are associated to
the clause; the unmatched option, the rest of arguments, and
a procedure that represents the option parser.

@end defmac

@defmac make-option-parser (option-clause @dots{})
This is a lower-level interface.  @var{option-clause}s are the
same as @code{parse-options}.  This macro returns a procedure
that can be used later to parse the command line options.

The returned procedure takes one required argument and one
optional argument.  The required argument is a list of strings,
for given command-line arguments.  The optional argument may
be a procedure that takes more than three arguments, and if given,
the procedure is used as if it is the body of @code{else} option clause.
@end defmac

@c ----------------------------------------------------------------------
@node High Level Process Interface, Reloading modules, Parsing command-line options, Library modules - Gauche extensions
@section @code{gauche.process} - High Level Process Interface
@c NODE 高レベルプロセスインタフェース, @code{gauche.process} - 高レベルプロセスインタフェース

@deftp {Module} gauche.process
@mdindex gauche.process
This module provides a higher-level API of Unix process control,
implemented on top of low-level system calls such as @code{sys-fork}
and @code{sys-exec}.   This module also provides ``process ports'', 
a convenient way to send/receive information to/from subprocesses.
@end deftp

@menu
* Process object::              
* Process ports::               
@end menu

@node Process object, Process ports, High Level Process Interface, High Level Process Interface
@subsection Process object

@deftp {Class} <process>
@clindex process
An object to keep the status of a child process.  You can create
the process object by @code{run-process} procedure described below.
The process ports explained in the next section also use process objects.

The @code{<process>} class keeps track of
the child processes spawned by high-level APIs such
as @code{run-process} or @code{open-input-process}.
The exit status of such children must be collected by
@code{process-wait} or @code{process-wait-any} calls,
which also do some bookkeeping.   Using
the low-level process calls such as @code{sys-wait} or
@code{sys-waitpid} directly will cause inconsistent state.
@end deftp

@deftp {Class} <process-abnormal-exit>
@clindex process-abnormal-exit
A condition type mainly used by the process port utility procedures.
Inherits @code{<error>}.  This type of condition is thrown when
the high-level process port utilities detect the child proces exitted
with non-zero status code.

@defivar {<process-abnormal-exit>} process
A process object.
@end defivar

Note: In Unix terms, exitting a process by calling @code{exit(2)} or 
returning from @code{main()} is a normal exit, regardless of the
exit status.  Some commands do use non-zero exit status
to tell one of the normal results of execution (such as @code{grep(1)}).  
However, large number of commands uses non-zero exit status to
indicate that they couldn't carry out the required operation,
so we treat them as exceptional situations.
@end deftp


@defun run-process cmd/args &keyword input output error fork wait host sigmask
Runs a command with arguments given to @var{cmd/args} in a subprocess
and returns a @code{<process>} object.
The @var{cmd/args} argument must be a list, whose car specifies
the command name and whose cdr is the command-line arguments.

If the command name contains a slash, it is taken as the
pathname of the executable.  Otherwise the named command
is searched from the directories in the @code{PATH} environment variable.

Each element in @var{cmd/args} are converted to a string
by @code{x->string}, for the convenience.

The following keyword arguments are recognized:
@table @code
@item :input @var{file}
@itemx :output @var{file}
@itemx :error @var{file}
These arguments controls the subprocess' standard i/o.
@var{file} may be either a string or a keyword @code{:pipe}.
If it is a string, the process' standard input, output, or error goes
to the named file.   If it is @code{:pipe}, the process'
corresponding standard i/o is connected to a pipe, 
and the other side of the pipe is available for the calling process.

@item :wait @var{flag}
If @var{flag} is true, @code{run-process} waits until the
subprocess terminates.  Othewise the subprocess runs asynchronously
and @code{run-process} returns immediately, which is the default behavior.
Note that if the subprocess is running asynchronously, it is the
caller's responsibility to call @code{process-wait} at certain
timing to collect its exit status.

@item :fork @var{flag}
If @var{flag} is true, @code{run-process} forks to run
the subprocess, which is the default behavior.  If @var{flag} is
false, @code{run-process} directly calls @code{sys-exec}, so
it never returns.

@item :host @var{hostspec}
This argument is used to execute @var{command} on the remote host.
The full syntax of @var{hostspec} is @code{protocol:user@@hostname:port},
where @var{protocol:}, @var{user@@}, or @var{:port} part can be
omitted.  The @var{protocol} part specifies the protocol to commnucate
with the remote host; currently only @code{ssh} is supported, and
it is also the default when @var{protocol} is omitted.
The @var{user} part specifies the login name of the remote host.
The @var{hostname} specifies the remote host name, and the
@var{port} part specifies the alternative port number which
@var{protocol} connects to.

@item :sigmask @var{mask}
@var{Mask} must be either an instance of @code{<sys-sigset>},
a list of integers, or 
@code{#f}.  If an instance of @code{<sys-sigset>} is given, the
signal mask of executed process is set to it.   A list of integers
are treated as a list of signals to mask.  It is important
to set an appropriate mask if you call @code{run-process} from
multithreaded application.
See the description of @code{sys-exec} (@ref{Unix process management})
for the details.

If the @var{host} keyword argument is specified, this argument
merely sets the signal mask of the local process (@code{ssh}).
@end table

The following example runs @code{ls -al} synchronously.
@example
(run-process '(ls -al) :wait #t)
@end example

Note that @code{-i} is read as an imaginary number,
so be careful to pass @code{-i} as a command-line
argument; you should use a string, or write @code{|-i|} to make it
a symbol.
@example
(run-process '(ls "-i") :wait #t)
@end example

Note: Old version of this procedure took arguments differently,
like @code{(run-process "ls" "-al" :wait #t)}, which was compatible
to STk.  This is still supported but deprecated.
@end defun

@defun process? obj
@equiv{} @code{(is-a? @var{obj} <process>)}
@end defun

@deffn {Method} process-pid (process <process>)
Returns the process ID of the subprocess @var{process}.
@end deffn

@deffn {Method} process-command (process <process>)
Returns the command invoked in the subprocess @var{process}.
@end deffn

@deffn {Method} process-input (process <process>)
@deffnx {Method} process-output (process <process>)
@deffnx {Method} process-error (process <process>)
If the process' standard input, output or error is connected to
a pipe, returns another end of the pipe, i.e. @code{process-input}
returns an output port that can feed data to @var{process}' stdin,
@code{process-output} returns an input port that can read data from
@var{process}' stdout, and @code{process-error} returns an input port that
can read data from @code{process}' stderr.
If the corresponding i/o is not connected to the pipe,
the function returns @code{#f}.

@example
(let* ((process (run-process '("date") :output :pipe))
       (line (read-line (process-output process))))
  (process-wait process)
  line)
 @result{} "Fri Jun 22 22:22:22 HST 2001"
@end example
@end deffn

@defun process-alive? process
Returns true if @var{process} is alive.  Note that Gauche can't
know the subprocess' status until it is explicitly checked by
@code{process-wait}.
@end defun

@defun process-list
Returns a list of active processes.  The process remains active
until its exit status is explicitly collected by @code{process-wait}.
Once the process's exit status is collected and its state changed
to inactive, it is removed from the list @code{process-list} returns.
@end defun

@defun process-wait process &optional nohang error-on-nonzero-status
Obtains the exit status of the subprocess @var{process}, and stores it
to @var{process}'s status slot.  The status can be obtained by
@code{process-exit-status}.

This suspends execution until @var{process} exits by default.
However, if a true value is given to the optional argument @var{nohang},
it returns immediately if @var{process} hasn't exit.

If a true value is given to the optional argument
@var{error-on-nonzero-status}, and the obtained status code is not zero,
this procedure raises @code{<process-abnormal-exit>} error.

Returns @code{#t} if this call actually obtains the exit status,
or @code{#f} otherwise.
@end defun

@defun process-wait-any &optional nohang
Obtains the exit status of any of the subprocesses created by
@code{run-process}.
Returns a process object whose exit status is collected.

If a true value is given to the optional argument @var{nohang}, this procedure
returns @code{#f }immediately even if no child process has exit.
If @var{nohang} is omitted or
@code{#f}, this procedure waits for any of children exits.

If there's no child processes, this procedure immediately returns @code{#f}.
@end defun


@defun process-exit-status process
Returns exit status of @var{process} retrieved by @code{process-wait}.
If this is called before @code{process-wait} is called on @var{process},
the result is undefined.
@end defun

@defun process-send-signal process signal
Sends a signal @var{signal} to the subprocess @var{process}.
@var{signal} must be an exact integer for signal number.
@xref{Signal}, for predefined variables of signals.
@end defun

@defun process-kill process
@defunx process-stop process
@defunx process-continue process
Sends SIGKILL, SIGSTOP and SIGCONT to @var{process}, respectively.
@end defun

@node Process ports,  , Process object, High Level Process Interface
@subsection Process ports

@defun open-input-process-port command &keyword input error encoding conversion-buffer-size
Runs @var{command} asynchronously in a subprocess.  Returns
two values, an input port which is connected to the stdout of the
running subprocess, and a process object.  

@var{Command} can be a string or a list.

If it is a string, it is passed to @code{/bin/sh}.
You can use shell metacharacters in this form, such as
environment variable interpolation, globbing, and redirections.
If you create the command line by concatenating strings,
it's your responsibility to ensure escaping special characters
if you don't want the shell to interpret them.  
The @code{shell-escape-string} function described below might
be a help.

If @var{command} is a list, each element is converted to a
string by @code{x->string} and then passed directly to @code{sys-exec}
(the @code{car} of the list is used as both the command path
and the first element of argv, i.e. @code{argv[0]}).
Use this form if you want to avoid the shell from interfering;
i.e. you don't need to escape special characters.

The subprocess's stdin is redirected from @code{/dev/null}, 
and its stderr shares the calling process's stderr by default.
You can change these by giving file pathnames to @var{input} and
@var{error} keyword arguments, respectively.

You can also give the @var{encoding} keyword argument
to specify character encoding of the process output.  If it differs
from the Gauche's internal encoding format,
@code{open-input-process-port} inserts a character encoding
conversion port.  
If @var{encoding} is given, the @var{conversion-buffer-size} keyword
argument can control the conversion buffer size.
See @ref{Character code conversion}, for
the details of character encoding conversions.
@example
(receive (port process) (open-input-process-port "ls -l Makefile")
  (begin0 (read-line port)
          (process-wait process)))
 @result{} "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

(receive (port process) (open-input-process-port '(ls -l "Makefile"))
  (begin0 (read-line port)
          (process-wait process)))
 @result{} "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

(open-input-process-port "command 2>&1")
 @result{} ;@r{the port reads both stdout and stderr}

(open-input-process-port "command 2>&1 1>/dev/null")
 @result{} ;@r{the port reads stderr}
@end example
The exit status of subprocess is not automatically collected.
It is the caller's responsibility to issue @code{process-wait},
or the subprocess remains in a zombie state.  If it bothers you,
you can use one of the following functions.
@end defun

@defun call-with-input-process command proc &keyword input error encoding conversion-buffer-size on-abnormal-exit
Runs @var{command} in a subprocess and pipes its stdout
to an input port, then call @var{proc} with the port as an argument.
When @var{proc} returns, it collects its exit status,
then returns the result @var{proc} returned.
The cleanup is done even if @var{proc} raises an error.

The keyword argument @var{on-abnormal-exit} specifies what happens
when the child process exits with non-zero status code.
It can be either @code{:error} (default), @code{:ignore}, or
a procedure that takes one argument.  If it is @code{:error},
a @code{<process-abnormal-exit>} error condition is thrown by
non-zero exit status; the @code{process} slot of the condition
holds the process object.  If it is @code{:ignore}, nothing is done
for non-zero exit status.  If it is a procedure, it is called with
a process object; when the procedure returns, @code{call-with-input-process}
returns normally.

The semantics of @var{command} and other keyword arguments are the same
as @code{open-input-process-port} above.
@example
(call-with-input-process "ls -l *"
  (lambda (p) (read-line p)))
@end example
@end defun

@defun with-input-from-process command thunk &keyword input error encoding conversion-buffer-size on-abnormal-exit
Runs @var{command} in a subprocess, and calls @var{thunk}
with its current input port connected to the command's stdout.
The command is terminated and its exit status is collected,
after @var{thunk} returns or raises an error.

The semantics of @var{command} and keyword arguments are the same
as @code{call-with-input-process} above.
@example
(with-input-from-process "ls -l *" read-line)
@end example
@end defun

@defun open-output-process-port command &keyword output error encoding conversion-buffer-size
Runs @code{command} in a subprocess asynchronously.  Returns two values,
an output port which is connected to the stdin of the subprocess.
and the process object.

The semantics of @var{command} is the same as
@code{open-input-process-port}.  The semantics of
@var{encoding} and @var{conversion-buffer-size} are also the same.

The subprocess's stdout is redirected to @code{/dev/null} by default,
and its stderr shares the calling process's stderr.
You can change these by giving file pathnames to @var{output} and
@var{error} keyword arguments, respectively.

The exit status of the subprocess is not automatically collected.
The caller should call @code{process-wait} on the subprocess
at appropriate time.
@end defun

@defun call-with-output-process command proc &keyword output error encoding conversion-buffer-size on-abnormal-exit
Runs @code{command} in a subprocess, and calls @var{proc} 
with an output port which is connected to the stdin of the command.
The exit status of the command is collected after either @var{proc}
returns or raises an error.

The semantics of keyword arguments are the same as
@code{open-output-process-port}, except @var{on-abnormal-exit},
which is the same as described in @code{call-with-input-process}.
@example
(call-with-output-process "/usr/sbin/sendmail"
  (lambda (out) (display mail-body out)))
@end example
@end defun

@defun with-output-to-process command thunk &keyword output error encoding conversion-buffer-size on-abnormal-exit
Same as @code{call-with-output-process}, except that the
output port which is connected to the stdin of the command
is set to the current output port while executing @var{thunk}.
@end defun

@defun call-with-process-io command proc &keyword error encoding conversion-buffer-size on-abnormal-exit
Runs @var{command} in a subprocess, and calls @var{proc}
with two arguments; the first argument is an input port which
is connected to the command's stdout, and the second is an output
port connected to the command's stdin.  The error output from
the command is shared by the calling process's, unless
an alternative pathname is given to the @var{error} keyword argument.

The exit status of the command is collected when @var{proc}
returns or raises an error.
@end defun

@defun process-output->string command &keyword error encoding conversion-buffer-size on-abnormal-exit
@defunx process-output->string-list command &keyword error encoding conversion-buffer-size on-abnormal-exit
Runs @var{command} and collects its output (to stdout) and returns them.
@code{process-output->string} concatenates all the output from @var{command}
to one string, replacing any sequence of whitespace characters to
single space.   The action is similar to ``command substitution''
in shell scripts.
@code{process-output->string-list} collects the output from
@var{command} line-by-line and returns the list of them.  Newline
characters are stripped.

Internally, @var{command} is run by @code{call-with-input-process},
to which keyword arguments are passed.
@example
(process-output->string '(uname -smp))
  @result{} "Linux i686 unknown"

(process-output->string '(ls))
  @result{} "a.out foo.c foo.c~ foo.o"

(process-output->string-list '(ls))
  @result{} ("a.out" "foo.c" "foo.c~" "foo.o")
@end example

@end defun

@defun shell-escape-string arg
If @var{arg} contains characters that affects shell's command-line
argument parsing, escape @var{arg} to avoid shell's interpretation.
Otherwise, returns @var{arg} itself.

Use this procedure when you need to build a command-line string by yourself.
(If you pass a command-line argument list, instead of a single
command-line string, you don't need to escape them since we
bypass the shell.)

On Windows native build, this procedure is compatible to
the argument parsing convention of Windows standard C runtime.
@end defun

@c ----------------------------------------------------------------------
@node Reloading modules, Simple dispatcher, High Level Process Interface, Library modules - Gauche extensions
@section @code{gauche.reload} - Reloading modules
@c NODE モジュールの再ロード, @code{gauche.reload} - モジュールの再ロード

@deftp {Module} gauche.reload
@mdindex gauche.reload
In the development cycle, you often have to reload modules frequently.
This module supports it.

Note that some part of semantics of the program depends on
the order of loading modules, so reloading arbitrary modules
may change the program behavior unexpectedly.  This module
is for developers who knows what they are doing.

@strong{Redefinition rules}: Reloading a module resets all
the binding in the module by default.
Sometimes it is not desirable, however.  For example,
you might want to keep an intermediate results in some variable.
You can specify rules for the reloading procedure to determine
which binding to keep.

The rule is described in the following syntax.
@example
  <module-rules> : (<module-rule> @dots{})
  <module-rule>  : (<module-pattern> <rule> @dots{})
  <module-pattern> : @r{a symbol module name, or a symbol containing glob pattern}
  <rule>         : @r{procedure} | @r{symbol} | @r{regexp}
                 | (and <rule> @dots{})
                 | (or  <rule> @dots{})
                 | (not <rule>)
@end example

@code{<module-rules>} is the global rule to determine per-module
rules.  @code{<module-pattern>} is either a symbol module name
or a symbol that contains glob pattern (e.g. @code{mylib.*}).
If @code{<rule>} is a procedure, it is used as a predicate
and the bindings whose value satisfies the predicate are kept from
redefinition.   If @code{<rule>} is a symbol, the binding of
the variable whose name is the symbol is kept.  If @code{<rule>}
is a regexp, the bindings of the variable whose name matches the
regexp are kept.

Note that the mechanism to prevent redefinition is kind of ad-hoc
hack and semantically unclean.  Especially, the right-hand expressions
of @code{define}s are still evaluated, so any side effects they have
will be in effect (e.g. @code{define-class} would still redefine a class).
It's just for your convenience.
Take a look at the code if you want to know the exact behavior.
@end deftp

@defun reload module-name &optional rule @dots{}
Reloads the specified module.   You can optionally specify
redefinition rules by @var{rule} @dots{},
where each @var{rule} is the term @code{<rule>} defined above.
@end defun

@defun reload-modified-modules &optional module-rules
Reloads module(s) that have been modified since they are loaded
last time.  If optional @var{module-rules} is given, it is
used to determine the redefinition rules for reloaded modules.
If @var{module-rules} is omitted, the current rules are used.
The default of current rules is empty.   You can set the current
rules by @code{module-reload-rules}.
@end defun

@defun module-reload-rules &optional module-rules
This is a parameter (@xref{Parameters}) that keeps
the default module rules for @code{reload-modified-modules}.
If called without arguments, returns the current module rules.
If called with @var{module-rules}, sets the argument to the
current module rules.
@end defun

@defun reload-verbose &optional flag
This is a parameter to control verbosity of the reloading procedures.
If called without arguments, returns the current verbosity flag.
If called with @var{flag}, it is set to the current verbosity flag.
@end defun

@c ----------------------------------------------------------------------
@node Simple dispatcher, Sequence framework, Reloading modules, Library modules - Gauche extensions
@section @code{gauche.selector} - Simple dispatcher
@c NODE 簡単なディスパッチャ, @code{gauche.selector} - 簡単なディスパッチャ

@deftp {Module} gauche.selector
@mdindex gauche.selector
This module provides a simple interface to dispatch I/O events to
registered handlers, based on @code{sys-select} (@xref{I/O multiplexing}).
@end deftp

@deftp {Class} <selector>
@clindex selector
A dispatcher instance that keeps watching I/O ports with associated
handlers.  A new instance can be created by @code{make} method.
@end deftp


@deffn {Method} selector-add! (self <selector>) port-or-fd proc flags
Add a handler @var{proc} to the selector.  @var{proc} is called
when @var{port-or-fd}, which should be a port object or an integer
that specifies a system file descriptor,  meets a certain condition
specified by @var{flags}.
@var{flags} must be a list of one or more of the following symbols.
@table @code
@item r
Calls @var{proc} when data is available at @var{port-or-fd} to read.
@item w
Calls @var{proc} when @var{port-or-fd} is ready to be written.
@item x
Calls @var{proc} when an exceptional condition occurs on @var{port-or-fd}.
@end table

@var{proc} is called with two arguments.  The first one is @var{port-or-fd}
itself, and the second one is a symbol @code{r}, @code{w} or @code{x},
indicating the condition.

If a handler is already associated with @var{port-or-fd} under the
same condition, the previous handler is replaced by @var{proc}.
@end deffn

@deffn {Method} selector-delete! (self <selector>) port-or-fd proc flags
Deletes the handler entries that matches @var{port-or-fd}, @var{proc}
and @var{flags}.   One or more of the arguments may be @code{#f},
meaning ``don't care''.  For example,
@example
(selector-delete! selector the-port #f #f)
@end example
deletes all the handlers associated to @var{the-port}, and
@example
(selector-delete! selector #f #f '(w))
@end example
deletes all the handlers waiting for writable condition.
@end deffn


@deffn {Method} selector-select (self <selector>) &optional (timeout #f)
Dispatcher body.  Waits for the conditions registered in @var{self},
and when it occurs, calls the associated handler.
If the @var{timeout} argument is omitted or false, this method waits
indefinitely.  Alternatively you can give a timeout value, that can
be a real number in microseconds, or a list of two integers that
represents seconds and microseconds.

Returns the number of handlers called.  Zero means the selector has been
timed out.

It is safe to modify @var{self} inside handler.  The change will be
effective from the next call of @code{selector-select}
@end deffn

This is a simple example of "echo" server:

@example
(use gauche.net)
(use gauche.selector)

(define (echo-server port)
  (let ((selector (make <selector>))
        (server   (make-server-socket 'inet port :reuse-addr? #t)))

    (define (accept-handler sock flag)
      (let* ((client (socket-accept server))
             (output (socket-output-port client)))
        (selector-add! selector
                       (socket-input-port client :buffering #f)
                       (lambda (input flag)
                         (echo client input output))
                       '(r))))

    (define (echo client input output)
      (let ((str (read-block 4096 input)))
        (if (eof-object? str)
            (begin (selector-delete! selector input #f #f)
                   (socket-close client))
            (begin (display str output)
                   (flush output)))))

    (selector-add! selector
                   (socket-fd server)
                   accept-handler
                   '(r))
    (do () (#f) (selector-select selector))))
@end example

@c ----------------------------------------------------------------------
@node Sequence framework, Syslog, Simple dispatcher, Library modules - Gauche extensions
@section @code{gauche.sequence} - Sequence framework
@c NODE シーケンスフレームワーク, @code{gauche.sequence} - シーケンスフレームワーク

@deftp {Module} gauche.sequence
@mdindex gauche.sequence
Provides a generic operations on @emph{sequences}.
A sequence is a collection with ordered elements.
Besides all the operations applicable on collections,
you can associate integer index to each element,
and apply order-aware operations on the elements.

This module inherits @code{gauche.collection} (@xref{Collection framework}).
All the collection generic operations can be applied to a sequence as well.

Among Gauche builtin class, lists, vectors and strings are sequences
and the specialized methods are defined for them.   Other extension
types, such as SRFI-4 uniform vector, have the methods as well.
@end deftp

@menu
* Fundamental sequence accessors::  
* Slicing sequence::            
* Mapping over sequences::      
* Other operations over sequences::  
* Implementing sequence::       
@end menu

@node Fundamental sequence accessors, Slicing sequence, Sequence framework, Sequence framework
@subsection Fundamental sequence accessors
@c NODE 基本的なシーケンスのアクセサ

@deffn {Method} ref (seq <sequence>) index &optional fallback
Returns @var{index}-th element of the sequence @var{seq}.
This method enables uniform access for any sequence types.

When @var{index} is less than zero, or greater than or equal to the
size of the sequence, @var{fallback} is returned if provided, or
an error is signalled if not.

@example
(ref '(a b c) 1)  @result{} b
(ref '#(a b c) 1) @result{} b
(ref "abc" 1)     @result{} #\b
@end example
@end deffn

@deffn {Method} {(setter ref)} (seq <sequence>) index value
Sets @var{value} to the @var{index}-th element of the sequence @var{seq}.
This is the uniform sequence modifier.

Note: Some sequences may not support arbitrary modification by index.
For example, if you have a sequence representing a set of sorted integers,
you cannot modify @var{i}-th element with arbitrary value.  Yet such
sequence may provide other means of modification, such as inserting
or deleting elements.

@example
(let ((x (list 'a 'b 'c)))
  (set! (ref x 1) 'z)
  x) @result{} (a z c)

(let ((x (vector 'a 'b 'c)))
  (set! (ref x 1) 'z)
  x) @result{} #(a z c)

(let ((x (string #\a #\b #\c)))
  (set! (ref x 1) #\z)
  x) @result{} "azc"
@end example
@end deffn

@deffn {Method} referencer (seq <sequence>)
@end deffn

@deffn {Method} modifier (seq <sequence>)
@end deffn

@node Slicing sequence, Mapping over sequences, Fundamental sequence accessors, Sequence framework
@subsection Slicing sequence
@c NODE シーケンスのスライス

@deffn {Method} subseq (seq <sequence>) &optional start end
Retrieve a subsequence of the sequence @var{seq}, from
@var{start}-th element (inclusive) to @var{end}-th element (exclusive).
If @var{end} is omitted, up to the end of sequence is taken.
The type of the returned sequence is the same as @var{seq}.

@example
(subseq '(a b c d e) 1 4)   @result{} (b c d)
(subseq '#(a b c d e) 1 4)  @result{} #(b c d)
(subseq "abcde" 1 4)        @result{} "bcd"

(subseq '(a b c d e) 3)     @result{} (d e)
@end example
@end deffn

@deffn {Method} {(setter subseq)} (seq <sequence>) start end value-seq
@deffnx {Method} {(setter subseq)} (seq <sequence>) start value-seq
Sets the elements of @var{value-seq} from the @var{start}-th element
(inclusive) to the @var{end}-th element (exclusive) of the sequence @var{seq}.
@var{Value-seq} can be any sequence, but its size
must be larger than (@var{end} - @var{start}).

In the second form, @var{end} is figured out by the length of @var{value-seq}.

@example
(define s (vector 'a 'b 'c 'd 'e))
(set! (subseq s 1 4) '(4 5 6))
s @result{} #(a 4 5 6 e)
(set! (subseq s 0)   "ab")
s @result{} #(#\a #\b 5 6 e)
@end example
@end deffn

@node Mapping over sequences, Other operations over sequences, Slicing sequence, Sequence framework
@subsection Mapping over sequences
@c NODE シーケンス上のマップ

You can use extended @code{fold}, @code{map}, @code{for-each} and other
generic functions on sequences, since a sequence is also a collection.
However, sometimes you want to have index as well as the element itself
during iteration.   There are several generic functions for it.

@deffn {Method} fold-with-index kons knil (seq <sequence>) @dots{}
Like generic @code{fold}, except @var{kons} is given
the index within @var{seq}, as the first argument,
as well as each element from @var{seq}s and the accrued value.

@example
(fold-with-index acons '() '(a b c))
  @result{} ((2 . c) (1 . b) (0 . a))
@end example
@end deffn

@deffn {Method} map-with-index proc (seq <sequence>) @dots{}
@deffnx {Method} map-to-with-index class proc (seq <sequence>) @dots{}
@deffnx {Method} for-each-with-index proc (seq <sequence>) @dots{}
Like @code{map}, @code{map-to} and @code{for-each}, except @var{proc}
receives the index as the first argument.

@example
(map-with-index list '(a b c d) '(e f g h))
  @result{} ((0 a e) (1 b f) (2 c g) (3 d h))

(map-to-with-index <vector> cons '(a b c d))
  @result{} #((0 . a) (1 . b) (2 . c) (3 . d))
@end example
@end deffn

@deffn {Method} find-with-index pred (seq <sequence>)
Finds the first element in @var{seq} that satisfies @var{pred}
like @code{find}, but returns two values, the index of the element
and the element itself.   If no element satisfies @var{pred},
two @code{#f}'s are returned.

@example
(find-with-index char-upper-case? "abraCadabra")
  @result{} 4 and #\C

(find-with-index char-numeric? "abraCadabra")
  @result{} #f and #f
@end example
@end deffn

@deffn {Method} find-index pred (seq <sequence>)
Like @code{find}, but returns the index of the first element
that satisfies @var{pred} in @var{seq}, instead of the element itself.
If no element in @var{seq} satisfies @var{pred}, @code{#f} is returned.

@example
(find-index char-upper-case? "abraCadabra")
  @result{} 4 

(find-index char-numeric? "abraCadabra")
  @result{} #f
@end example

See also @code{list-index} in SRFI-1 (@xref{SRFI-1 Searching}).
@end deffn

@deffn {Method} fold-right kons knil (seq <sequence>) @dots{}
Generalization of @code{fold-right} on lists.
Like @code{fold}, this method applies a higher-order function
@var{kons} over given sequence(s), passing the "seed" value
whose default is @var{knil}.  The difference between @code{fold}
and @code{fold-right} is the associative order of elements on
which @var{kons} is applied.

When we have one sequence, @code{[E0, E1, ..., En]}, @code{fold}
and @code{fold-right} work as follows, respectively.

@example
fold:
  (kons En (kons En-1 (kons ... (kons E1 (kons E1 knil)) ...)))

fold-right
  (kons E0 (kons E1 (kons ... (kons En-1 (kons En knil)) ...)))
@end example

This method isn't defined on @code{<collection>}, since
collections don't care the order of elements.
@end deffn


@node Other operations over sequences, Implementing sequence, Mapping over sequences, Sequence framework
@subsection Other operations over sequences
@c NODE その他のシーケンス上の操作

@subsubheading Selection and searching

Note that selection and searching methods for collections 
can also be applied to sequences.
See @ref{Selection and searching in collection}.

@subsubheading Grouping

@deffn {Generic function} group-sequence seq &keyword key test
Groups consecutive elements in a sequence @var{seq} which
have the common key value.  A key value of an element is
obtained by applying the procedure @var{key} to the element;
the default procedure is @code{identity}.
For each element in @var{seq}, @var{key} is applied exactly once.
The equal-ness of keys are compared by @var{test} procedure,
whose default is @code{eqv?}.

@example
(group-sequence '(1 1 1 2 3 4 4 2 2 3 1 1 3))
  @result{} ((1 1 1) (2) (3) (4 4) (2 2) (3) (1 1) (3))

(group-sequence '(1 1 1 2 3 4 4 2 2 3 1 1 3) 
                :key (cut modulo <> 2)))
  @result{} ((1 1 1) (2) (3) (4 4 2 2) (3 1 1 3))

(group-sequence '#("a" "a" "b" "b" "c" "d" "d") 
                :test string=?)
  @result{} (("a" "a") ("b" "b") ("c") ("d" "d"))

(group-sequence "aabbcdd"
                :test char=?)
  @result{} ((#\a #\a) (#\b #\b) (#\c) (#\d #\d))
@end example

This method is similar to Haskell's @code{group}.
If you want to group elements that are not adjacent, 
use @code{group-collection} 
(@xref{Selection and searching in collection}).
@end deffn


@subsubheading Permutation and shuffling

@deffn {Generic function} permute (src <sequence>) (permuter <sequence>) &optional fallback
Returns a newly created sequence of the same type as @var{src}, in which
the elements are permuted from @var{src} according to @var{permuter}.

@var{Permuter} is a sequence of exact integers.  When the @var{k}-th element
of @var{permuter} is @var{i}, the @var{k}-th element of the result
is @code{(ref @var{src} @var{i})}.   Therefore, the size of the result
sequence is the same as the size of @var{permuter}.  @var{Permuter}
can be any kind of sequence, unrelated to the type of @var{src}.

It is allowed that the same index @var{i} can appear more than once
in @var{permuter}.

@example
(permute '(a b c d) '(3 2 0 1))     @result{} (d c a b)
(permute '(a b c d) '(0 2))         @result{} (a c)
(permute '(a b c d) '(0 0 1 1 2 2)) @result{} (a a b b c c)
@end example

If an integer in @var{permuter} is out of the valid range as the index
of @var{src}, then an error is signalled unless @var{fallback} is given.
If @var{fallback} is given, what value is used depends on the result of
@code{(ref @var{src} @var{i} @var{fallback})}---which usually returns
@var{fallback} for the out-of-range index @var{i}.

@example
(permute '#(a b c) '(3 2 1 0) 'foo) @result{} #(foo c b a)

(permute "!,HWdelor" #(2 5 6 6 7 1 -1 3 7 8 6 4 0) #\space)
  @result{} "Hello, World!"
@end example
@end deffn

@deffn {Generic function} permute-to (class <class>) (src <sequence>) (permuter <sequence>) &optional fallback
Like @code{permute}, but the result will be an instance of the given @var{class}
instead of the class of @var{src}.

@example
(permute-to <string> '(#\a #\b #\c #\d #\r)
            '(0 1 4 0 2 0 3 0 1 4 0))
  @result{} "abracadabra"
@end example
@end deffn

@deffn {Generic function} permute! (src <sequence>) (permuter <sequence>) &optional fallback
Also like @code{permute}, but the result is stored back to @var{src}.
@var{Src} must be a mutable sequence, and the length of @var{src} and
@var{permuter} must be the same.
@end deffn

@deffn {Generic function} shuffle (src <sequence>) &optional random-source
Returns a new sequence of the same type and size as @var{src},
in which elements are randomly permuted.

@example
(shuffle '(a b c d e))  @result{} (e b d c a)
(shuffle "abcde")       @result{} "bacde"
@end example

This generic function uses @code{srfi-27} (@xref{Sources of random bits}).
By default it uses @code{default-random-source}, but you can pass
an alternative random source by the optional argument.
@end deffn

@deffn {Generic function} shuffle-to (class <class>) (src <sequence>) &optional random-source
Like @code{shuffle}, except that the result will be an instance of 
@var{class} instead of the class of @var{src}.
@end deffn

@deffn {Generic function} shuffle! (src <sequence>) &optional random-source
Like @code{shuffle}, but the result is stored back to @var{src}.
@var{Src} must be a mutable sequence.
@end deffn


@node Implementing sequence,  , Other operations over sequences, Sequence framework
@subsection Implementing sequence
@c NODE シーケンスを実装する



@c ----------------------------------------------------------------------
@c @node Serializer, Termios, Simple dispatcher, Library modules
@c @section @code{gauche.serializer} - Serializer

@c @deftp {Module} gauche.serializer
@c @mdindex gauche.serializer
@c @end deftp

@c ----------------------------------------------------------------------
@node  Syslog, Termios, Sequence framework, Library modules - Gauche extensions
@section @code{gauche.syslog} - Syslog
@c NODE Syslog, @code{gauche.syslog} - Syslog

@deftp {Module} gauche.syslog
@mdindex gauche.syslog
This module provides syslog(3) system logger interface.

For the common applications, you might find @code{gauche.logger} module
easier to use (@xref{User-level logging}).  This module is for those
who need direct access to the syslog API.

The procedures are only defined if the undelying system supports them.
@end deftp

@defun sys-openlog ident option facility
[POSIX]
Opens a connection to the system logger.  A string argument
@var{ident} is used for the prefix of the log, and usually is
the program name.  @var{Option} is an integer flag to control
the behavior of logging, and @var{facility} is an integer
that specify the type of the program.

The flag for @var{option} can be composed by @code{logior}-ing
one or more of the following integer constants:
@code{LOG_CONS}, @code{LOG_NDELAY}, @code{LOG_NOWAIT},
@code{LOG_ODELAY}, @code{LOG_PERROR} and @code{LOG_PID}.
(Some of the constants may not be defined if the underlying system
doesn't support them).

The @var{facility} argument can be one of the following integer
constants: @code{LOG_AUTH}, @code{LOG_AUTHPRIV}, @code{LOG_CRON},
@code{LOG_DAEMON}, @code{LOG_FTP}, @code{LOG_KERN}, @code{LOG_LOCAL0}
through @code{LOG_LOCAL7}, @code{LOG_LPR}, @code{LOG_MAIL}, @code{LOG_NEWS},
@code{LOG_SYSLOG}, @code{LOG_USER} and @code{LOG_UUCP}.
(Some of the constants may not be defined if the underlying system
doesn't support them).

See your system's manpage of openlog(3) for detail description about
these constants.
Log the string @var{message}.  Unlike syslog(3), this procedure doesn't
do formatting---you can use @code{format} (@xref{Output}) to create
a formatted message, or use higher-level routine @code{log-format}
(@xref{User-level logging}).

An integer argument @var{priority} can be composed by @code{logior}-ing
one of the @var{facility} constants described above and
the @var{level} constants: @code{LOG_EMERG}, @code{LOG_ALERT},
@code{LOG_CRIT}, @code{LOG_ERR}, @code{LOG_WARNING}, @code{LOG_NOTICE},
@code{LOG_INFO}, @code{LOG_DEBUG}.

@end defun

@defun sys-closelog
[POSIX]
Closes the connection to the logging system.
@end defun

@defun sys-setlogmask mask
[POSIX]
Sets the process's log priority mask that determines which calls to
@code{sys-syslog} may be logged.
An priority @var{mask} can be composed by @code{logior}-ing
bitmasks corresponding to the @var{level} argument of @code{sys-syslog}.
You can use @code{sys-logmask} below to obtain a bitmask
from the level.
@end defun

@defun sys-logmask level
[POSIX]
Returns an integer bitmask for @code{sys-setlogmask} from 
the log level @var{level}.
@end defun

@c ----------------------------------------------------------------------
@node Termios, Unit testing, Syslog, Library modules - Gauche extensions
@section @code{gauche.termios} - Termios
@c NODE Termios, @code{gauche.termios} - Termios

@deftp {Module} gauche.termios
@mdindex gauche.termios
This module defines POSIX termios interface, which
controls terminal attributes.  This module also provides
pseudo tty interface, if the system provides it.
@end deftp

@deftp {Builtin Class} <sys-termios>
@clindex sys-termios
POSIX termios(7) structure.

@defivar {<sys-termios>}  iflag
@end defivar
@defivar {<sys-termios>}  oflag
@end defivar
@defivar {<sys-termios>}  cflag
@end defivar
@defivar {<sys-termios>}  lflag
@end defivar
@defivar {<sys-termios>}  cc
@end defivar

The slots @code{iflag}, @code{oflag}, @code{cflag} and @code{lflag}
contains non-negative integers representing bitmasks.

The slot @code{cc} contains a @emph{copy} of @code{c_cc} array
of @code{struct termios}, as an u8vector (see @ref{Uniform vectors}
for the details about u8vector).
Since @code{cc} slot is a copy of the internal structure, you have
to @code{set!} an u8vector to the slot explicitly to make
changes to the @code{c_cc} array.

@end deftp

Throughout this section, argument @var{port-or-fd} refers to
either a port object or a small integer representing system's file 
descriptor.  If @var{port} is not associated
to the system terminal, an error is signalled.  (You can check if @var{port}
has an associated terminal by @code{sys-isatty?}.
@xref{Other file operations}).

@defun sys-tcgetattr port-or-fd
Returns terminal parameters in a @code{<sys-termios>} object,
associated to @var{port-or-fd}.
@end defun

@defun sys-tcsetattr port-or-fd when termios
Sets terminal parameters associated to @var{port-or-fd} by @var{termios},
which must be an instance of @code{<sys-termios>}.

An integer argument @var{when} specifies when the changes take effect.
Three variables are pre-defined for the argument:
@table @code
@item TCSANOW
@vindex TCSANOW 
The change is reflected immediately.
@item TCSADRAIN
@vindex TCSADRAIN
The change is reflected after all pending output is flushed.
@item TCSAFLUSH
@vindex TCSAFLUSH
The change is reflected after all pending output is flushed,
and all pending input is discarded.
@end table
@end defun

@defun sys-tcsendbreak port-or-fd duration
Transmits a zero stream for the specified duration
to the terminal associated to @var{port-or-fd}.
The unit of duration depends on the system; see man tcsendbreak(3) of
your system for details.
@end defun

@defun sys-tcdrain port-or-fd
Waits until all output written to @var{port-or-fd} is transmitted.
@end defun

@defun sys-tcflush port-or-fd queue
Discards data in the buffer of @var{port-or-fd}, specified by 
@var{queue}, which may be one of the following values.
@table @code
@item TCIFLUSH
@vindex TCIFLUSH
Discards data received but not read.
@item TCOFLUSH
@vindex TCOFLUSH
Discards data written but not transmitted.
@item TCIOFLUSH
@vindex TCIOFLUSH
Do both @code{TCIFLUSH} and @code{TCOFLUSH} action.
@end table
@end defun

@defun sys-tcflow port-or-fd action
Controls data flow of @var{port-or-fd} by @var{action}, which may be
one of the following values:
@table @code
@item TCOOFF
@vindex TCOOFF
Suspends output transmission.
@item TCOON
@vindex TCOON
Restarts output transmission.
@item TCIOFF
@vindex TCIOFF
Transmits a STOP character to make the terminal device stop transmitting
data to the system.
@item TCION
@vindex TCION
Transmits a START character to make the terminal device resume transmitting
data to the system.
@end table
@end defun

@defun sys-tcgetpgrp port-or-fd
Returns process group ID of the terminal associated to @var{port-or-fd}.
@end defun

@defun sys-tcsetpgrp port-or-fd pgrp
Sets process group ID of the terminal associated to @var{port-or-fd}
to @var{pgrp}.
@end defun

@defun sys-cfgetispeed termios
@defunx sys-cfsetispeed termios speed
@defunx sys-cfgetospeed termios
@defunx sys-cfsetospeed termios speed
Gets/sets input/output speed (baud rate) parameter stored in @var{termios}
object.   Speed is represented by the following predefined numbers:
@code{B0}, @code{B50}, @code{B75}, @code{B110}, @code{B134}, 
@code{B150}, @code{B200}, @code{B300}, @code{B600}, @code{B1200}, 
@code{B1800}, @code{B2400}, @code{B4800}, @code{B9600},
@code{B19200}, @code{B38400}.

Some system may support higher baud rate, such as @code{B57600},
@code{B115200} or @code{B230400}.  You can use @code{symbol-bound?}
to check these options are defined.  @code{B0} is used to
terminate the connection.
@end defun

@defun sys-openpty &optional term
Opens a pair of pseudo ttys, one for master and the other for slave,
then returns two integers which are their file descriptors.
An optional argument @var{term} must be, if passed, a @code{<sys-termios>}
object; it sets the slave pty's parameters.

You can use @code{open-input-fd-port} and/or @code{open-output-fd-port}
to create a port around the returned file descriptor (@xref{File ports}).
To obtain pseudo tty's name, use @code{sys-ttyname}
(@xref{Other file operations}).

This function is available only if the system supports @code{openpty(3)}.
@end defun

@defun sys-forkpty &optional term
Opens a pair of pseudo ttys, one for master and the other for slave,
sets the slave pty suitable for login terminal, then fork(2).

Returns two integers; the first value is a child pid for the parent process,
and 0 for the child process.  The second value is a file descriptor
of the master pty.

An optional argument @var{term} must be, if passed, a @code{<sys-termios>}
object; it sets the slave pty's parameters.

This function is available only if the system supports @code{forkpty(3)}.

Note: @code{sys-forkpty} has the same MT hazard as @code{sys-fork}
(see @ref{Unix process management}, for details).  If you're
running multiple threads, use @code{sys-forkpty-and-exec} below.
@end defun

@defun sys-forkpty-and-exec command args &keyword iomap term sigmask
Does @code{sys-forkpty}, and lets the child process
immediately @code{exec}s the specified @var{command}
with arguments @var{args}.   This function doesn't have
the hazard in multi-thread environment.

The meanings of arguments @var{command}, @var{args}, @var{iomap} and
@var{sigmask}
are the same as @code{sys-exec} (see @ref{Unix process management}).
If the keyword argument @var{term} is given, it is used to initialize
the slave pty.
@end defun

The following example shows how to get a password from the user
without echoing:

@example
(use gauche.termios)

(define (get-password prompt)
  (let* ((port (current-input-port))
         (attr (sys-tcgetattr port))
         (lflag (slot-ref attr 'lflag)))
    ;; Show prompt
    (display prompt)
    (flush)
    ;; Turn off echo during reading.
    (dynamic-wind
     (lambda ()
       (slot-set! attr 'lflag (logand lflag (lognot ECHO)))
       (sys-tcsetattr port TCSAFLUSH attr))
     (lambda ()
       (read-line port))
     (lambda ()
       (slot-set! attr 'lflag lflag)
       (sys-tcsetattr port TCSANOW attr)))))
@end example

@c ----------------------------------------------------------------------
@node Unit testing, Threads, Termios, Library modules - Gauche extensions
@section @code{gauche.test} - Unit Testing
@c NODE 単体テスト, @code{gauche.test} - 単体テスト

@deftp {Module} gauche.test
@mdindex gauche.test
Defines a set of functions to write test scripts.
A test script will look like this:
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")  ; @r{load your program}
(import my-feature)  ; @r{if your program defines a module.}

(test-module 'my-feature) ; @r{tests consistency in your module.}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
(test "feature 2-2" *test-error* (lambda () TEST-THAT-SIGNALS-ERROR))
 @dots{}

(test-end)
@end lisp

With this convention, you can run test both interactively or
in batch.   To run a test interactively, just load the file
and it reports a result of each test, as well as the summary
of failed test at the end.  To run a test in batch, it is
convenient to redirect the stdout to some file
If stdout is redirected to other than tty, all the verbose logs will go
there, and only a small amount of messages go to stderr.

It is recommended to have a "test" target always in Makefile
of your module/program, so that the user of your program can run a
test easily.  The rule may look like this:

@example
test :
        gosh my-feature-test.scm > test.log
@end example

@end deftp

@defun test name expected thunk &optional compare
Calls @var{thunk}, and compares its result with @var{expected}.
The comparison predicate is @code{equal?} by default, but you can
specify your own predicate by the argument @var{compare}.
@var{Name} is a name of the test, for logging purpose.

If @var{thunk} signals an uncaptured error, it is catched and
yields a special error object.  A global variable @code{*test-error*}
is bound to the error object, so that you can test an expected error.

The procedure @var{compare} is called as follows:
@example
(@var{compare} @var{expected} @var{result-of-thunk})
@end example
It should return @code{#t} if the given result agrees the 
expected value, or @code{#f} otherwise.
One typical usage of the custom comparison
method is to compare inexact numbers tolerating small error.

@example
(test "test 1" (/ 3.141592653589 4)
      (lambda () (atan 1))
      (lambda (expected result)
        (< (abs (- expected result)) 1.0e-10)))
@end example
@end defun

@defvar *test-error*
Bound to a special error object, which can be used as an expected
value if the test thunk is supposed to signal an error.

@example
(test "test if car signals an error" *test-error*
      (lambda () (car 5)))
@end example
@end defvar

@defvar *test-report-error*
If this variable is true, the @code{test} routine prints stack trace
to the current error port when it captures an error.  It is useful
when you got an unexpected test-error object and want to check out
where the error is occurring.

This variable is initialized by the environment variable
@code{GAUCHE_TEST_REPORT_ERROR} when the @code{gauche.test} module
is loaded.  For example, you can use the environment variable to check out
an unexpected error from your test script as follows (the value
of the environment variable doesn't matter).

@example
env GAUCHE_TEST_REPORT_ERROR=1 gosh mytest.scm
@end example
@end defvar


@defmac test* name expected expr &optional compare
A convenience macro that wraps @var{expr} by lambda.

@example
(test* name expected expr)
  @equiv{} (test name expected (lambda () expr))
@end example
@end defmac

@defun test-module module &keyword allow-undefined
@var{Module} must be a symbol module name or a module.
This procedure performs some heuristic consistency check of
the given module: (1) whether symbols set as autoload
in @var{module} can actually be loaded, (2) whether
the symbols declared in export list is actually defined
in the module, and (3) whether the global variable referenced
within functions are all defined.   Although not perfect, 
this test can catch some careless typo in symbol names.

Sometimes you have a global vaiable that may not be
defined depending on compiler options or platforms, and
you check its existence at runtime before using it.
The undefined variable reference check by @code{test-module}
doesn't follow such logic, and reports an error whenever
it finds your code referring to undefined variable.  In such case,
you can give a list of symbols to the @var{allow-undefined}
keyword argument; the test will excludes them from the check.
@end defun

@defun test-start module-name
Initializes internal state and prints a log header.
This should be called before any tests.
@var{Module-name} is used only for logging purpose.
@end defun

@defun test-section section-name
Marks beginning of the group of tests.  This is just for logging.
@end defun

@defun test-end
Prints out list of failed tests, and returns the number of failed tests.
@end defun

@c ----------------------------------------------------------------------
@node Threads, Measure timings, Unit testing, Library modules - Gauche extensions
@section @code{gauche.threads} - Threads
@c NODE スレッド, @code{gauche.threads} - スレッド

If enabled at compilation time, Gauche can use threads
built on top of POSIX threads (pthreads).

@deftp {Module} gauche.threads
@mdindex gauche.threads
Provides thread API.   You can 'use' this module regardless
whether the thread support is compiled in or not; if threads are not
supported, many thread-related procedures simply signals a 
"not supported" error.
@end deftp

To check if threads are available in the running Gauche program,
use the following procedure.

@defun gauche-thread-type
Returns a symbol that indicates the supported thread type.
In the current version, the return value may be @code{pthread}
when threads on top of POSIX threads are available, or
@code{none} when threads are not available.
@end defun

Scheme-level thread API conforms SRFI-18, "Multithreading support"
(@ref{srfi-18,,[SRFI-18]}), wrapped around Gauche's object interface.

@menu
* Thread programming tips::     
* Thread procedures::           
* Synchronization primitives::  
* Thread exceptions::           
@end menu

@node Thread programming tips, Thread procedures, Threads, Threads
@subsection Thread programming tips
@c NODE スレッドプログラミングTips

Although the surface API of threads looks simple and portable,
you need to know how the threads are implemented in order to utilize
the feature's potential.   Some languages support threads as
language's built-in construct and encourage programmers
to express the calculation in terms of threads.
However, it should be noted that in many cases there are
alternative ways than threads to implement the desired
algorithm, and you need to compare advantages and
disadvantages of using threads depending on how the threads
are realized in the underlying system.

In Gauche, the primary purpose of threads is to write programs
that @emph{require} preemptive scheduling, therefore are
difficult to express in other ways.  Preemptive threads may
be required, for example, when you have to call a module that 
does blocking I/O which you can't intercept, or may spend
nondeterministic amount of calculation time that you want
to interrupt.

For each Gauche's thread, an individual VM is allocated
and it is run by the dedicated POSIX thread.  Thus there
is not much overhead in context switch than the native
thread, but the creation of threads costs much higher than,
say, lightweight threads built on top of call/cc.
So Gauche's preemptive threads are @emph{not} designed for
applications that want to create thousands of threads
for fine-grained calculation.

The recommended usage is the technique so called "thread pool",
that you create a set of threads and keep them around for
long time and dispatch jobs to them as needed.

Preemptive threads have other difficulties
(e.g. see @ref{fairthreads,[FairThreads],FairThreads}),
and sometimes the alternatives may be a better fit
than the native preemptive threads.

@itemize @bullet
@item
If what you need is just a concurrent calculation, you
might be able to use cooperative thread technique built
on top of @code{call/cc}.   Creating call/cc-based threads
is much faster than creating native threads.

@item
If what you need is to deal with blocking I/O, and you have
all your code at hand, it is sometimes easier to use good old
@code{select}-based dispatching (@xref{Simple dispatcher},
for example).

@item
If what you need is to control the resource consumption in the
subsystem, and the subsystem works fairly independently from
the main system, you may be able to use Unix processes instead of threads.
It may sound to go backward, but Unix process does provide
higher "shield" between the subsystem and the main system
(e.g. the main system can keep running even if subsystem segfaults).

@end itemize

Of course, these technique are not mutually exclusive with
native threads.  You can use dispatcher with "thread pool" technique,
for example.   Just keep it in your mind that the native threads
are not only but one of the ways to realize those features.


@node Thread procedures, Synchronization primitives, Thread programming tips, Threads
@subsection Thread procedures
@c NODE スレッド手続き

@deftp {Builtin Class} <thread>
@clindex thread
A thread.  Each thread has an associated thunk which is evaluated by
a POSIX thread.  When thunk returns normally, the result is stored
in the internal 'result' slot, and can be retrieved by @code{thread-join!}.
When thunk terminates abnormally, either by raising an exception or
terminated by @code{thread-terminate!}, the exception condition is
stored in their internal 'result exception' slot, and will be passed
to the thread calling @code{thread-join!} on the terminated thread.

Each thread has its own dynamic environment and dynamic handler stack.
When a thread is created, its dynamic environment is initialized by
the creator's dynamic environment.  The thread's dynamic handler
stack is initially empty.

Access to the resouces shared by multiple threads must be protected
explicitly by synchronization primitives.
@xref{Synchronization primitives}.

Access to ports are serialized by Gauche. If multiple threads attempt
to write to a port, their output may be interleaved but no output
will be lost, and the state of the port is kept consistent.
If multiple threads attempt to read from a port, a single read
primitive (e.g. @code{read}, @code{read-char} or @code{read-line})
works atomically.

Signal handlers are shared by all threads, but each thread has
its own signal mask.  @xref{Signals and threads}, for details.

A thread object has the following external slots.

@defivar <thread> name
A name can be associated to a thread.
This is just for the convenience of the application.
The primordial thread has the name "@code{root}".
@end defivar

@defivar <thread> specific
A thread-local slot for use of the application.
@end defivar
@end deftp

@defun current-thread
[SRFI-18], [SRFI-21]
Returns the current thread.
@end defun

@defun thread? obj
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a thread, @code{#f} otherwise.
@end defun

@defun make-thread thunk &optional name
[SRFI-18], [SRFI-21]
Creates and returns a new thread.  To run the thread, you need to
call @code{thread-start!}.

You can provide the name of the thread by the optional argument @var{name}.

Internally, this procedure just allocates and initializes a Scheme
thread object; the POSIX thread is not created until @code{thread-start!}
is called.
@end defun

@defun thread-name thread
[SRFI-18], [SRFI-21]
Returns the value of @var{name} slot of @var{thread}.
@end defun

@defun thread-specific thread
@defunx thread-specific-set! thread value
[SRFI-18], [SRFI-21]
Gets/sets the value of the @var{thread}'s specific slot.
@end defun

@defun thread-start! thread
[SRFI-18], [SRFI-21]
Starts the @var{thread}.  It is an error if @var{thread} is already started.
Returns @var{thread}.
@end defun

@defun thread-yield!
[SRFI-18], [SRFI-21]
Suspends the execution of the calling thread and yields CPU to other
waiting runnable threads, if any.
@end defun

@defun thread-sleep! timeout
[SRFI-18], [SRFI-21]
Suspends the calling thread for the period specified by @var{timeout},
which must be either a @code{<time>} object (@xref{Time}) that
specifies absolute point of time, or a real number that specifies
relative point of time from the time this procedure is called
in number of seconds.

After the specified time passes, @code{thread-sleep!} returns with
unspecified value.

If @var{timeout} points a past time, @code{thread-sleep!} returns
immediately.
@end defun

@defun thread-terminate! thread
[SRFI-18], [SRFI-21]
Terminates the specified thread @var{thread}.
The @var{thread} is terminated and an instance of 
@code{<terminated-thread-exception>} is stored in the result exception
field of @var{thread}.

If @var{thread} is the same as the calling thread, this procedure
won't return.  Otherwise, this procedure returns unspecified value.

This procedure should be used with care, since
@var{thread} won't have a chance to call cleanup
procedures (such as 'after' thunks of @code{dynamic-wind})
If @var{thread} is in the critical section, it leaves some state
inconsistent.  However, once a thread is terminated, any mutex
that the thread has kept becomes 'abandoned' state, and an attempt
to lock such a mutex by other thread raises an 'abandoned mutex exception',
so that you will know the situation.  @xref{Synchronization primitives}.
@end defun


@defun thread-join! thread &optional timeout timeout-val
[SRFI-18], [SRFI-21]
Waits termination of @var{thread}, or until the timeout is reached
if @var{timeout} is given.

@var{Timeout} must be either a @code{<time>} object (@xref{Time})
that specifies absolute point of time, or a real number that specifies
relative point of time from the time this procedure is called
in number of seconds, or @code{#f} that indicates no timeout (default).

If @var{thread} terminates normally, @code{thread-join!} returns
a value which is stored in the result field of @var{thread}.
If @var{thread} terminates abnormally, @code{thread-join!} raises
an exception which is stored in the result exception field of @var{thread}.

If the timeout is reached, @var{thread-join!} returns @var{timeout-val}
if given, or raises @code{<join-timeout-exception>}.
@end defun

@node Synchronization primitives, Thread exceptions, Thread procedures, Threads
@subsection Synchronization primitives
@c NODE 同期プリミティブ

@deftp {Builtin Class} <mutex>
@clindex mutex
A primitive synchronization device.  It can take one of four states:
locked/owned, locked/not-owned, unlocked/abandoned and unlocked/not-abandoned.
A mutex can be locked (by @code{mutex-lock!}) only if it is in unlocked state.
An 'owned' mutex keeps a thread that owns it.
Typically an owner thread is the one that locked the mutex,
but you can make a thread other than the locking thread own a mutex.
A mutex becomes unlocked either by @code{mutex-unlock!} or the owner
thread terminates.  In the former case, a mutex becomes unlocked/not-abandoned
state.  In the latter case, a mutex becomes unlocked/abandoned state.

A mutex has the following external slots.

@defivar <mutex> name
The name of the mutex.
@end defivar

@defivar <mutex> state
The state of the mutex.  This is a read-only slot.
See the description of @code{mutex-state} below.
@end defivar

@defivar <mutex> specific
A slot an application can keep arbitrary data.  For example, an application
can implement a 'recursive' mutex using the specific field.
@end defivar
@end deftp

@defun mutex? obj
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a mutex, @code{#f} otherwise.
@end defun

@defun make-mutex &optional name
[SRFI-18], [SRFI-21]
Creates and returns a new mutex object.
When created, the mutex is in unlocked/not-abandoned state.
Optionally, you can give a name to the mutex.
@end defun

@defun mutex-name mutex
[SRFI-18], [SRFI-21]
Returns the name of the mutex.
@end defun

@defun mutex-specific mutex
@defunx mutex-specific-set! mutex value
[SRFI-18], [SRFI-21]
Gets/sets the specific value of the mutex.
@end defun

@defun mutex-state mutex
[SRFI-18], [SRFI-21]
Returns the state of @var{mutex}, which may be one of the followings:

@table @asis
@item a thread
The mutex is locked/owned, and the owner is the returned thread.
@item symbol @code{not-owned}
The mutex is locked/not-owned.
@item symbol @code{abandoned}
The mutex is unlocked/abandoned.
@item symbol @code{not-abandoned}
The mutex is unlocked/not-abandoned.
@end table
@end defun

@defun mutex-lock! mutex &optional timeout thread
[SRFI-18], [SRFI-21]
Locks @var{mutex}.  If @var{mutex} is in unlocked/not-abandoned
state, this procedure changes its state to locked state exclusively.
By default, @var{mutex} becomes locked/owned state, owned by the
calling thread.  You can give other owner thread as @var{thread} argument.
If @var{thread} argument is given and @code{#f}, the mutex becomes
locked/not-owned state.

If @var{mutex} is in unlocked/abandoned state, that is, some other
thread has been terminated without unlocking it, this procedure
signals 'abandoned mutex exception' (@xref{Thread exceptions})
after changing the state of @var{mutex}.

If @var{mutex} is in locked state and
@var{timeout} is omitted or @code{#f}, this procedure blocks until
@var{mutex} becomes unlocked.   If @var{timeout} is specified,
@code{mutex-lock!} returns when the specified time reaches in
case it couldn't obtain a lock.  You can give @var{timeout}
an absolute point of time (by @code{<time>} object, @xref{Time}),
or a relative time (by a real number).

@code{Mutex-lock!} returns @code{#t} if @var{mutex} is successfully
locked, or @code{#f} if timeout reached.

Note that @var{mutex} itself doesn't implements a 'recursive lock'
feature; that is, if a thread that has locked @var{mutex} tries to lock
@var{mutex} again, the thread blocks.  It is not difficult, however,
to implement a recursive lock semantics on top of this mutex.
The following example is taken from SRFI-18 document:

@example
(define (mutex-lock-recursively! mutex)
  (if (eq? (mutex-state mutex) (current-thread))
      (let ((n (mutex-specific mutex)))
        (mutex-specific-set! mutex (+ n 1)))
      (begin
        (mutex-lock! mutex)
        (mutex-specific-set! mutex 0))))

(define (mutex-unlock-recursively! mutex)
  (let ((n (mutex-specific mutex)))
    (if (= n 0)
        (mutex-unlock! mutex)
        (mutex-specific-set! mutex (- n 1)))))
@end example
@end defun

@defun mutex-unlock! mutex &optional condition-variable timeout
[SRFI-18], [SRFI-21]
Unlocks @var{mutex}.  The state of @var{mutex} becomes unlocked/not-abandoned.
It is allowed to unlock a mutex that is not owned by the calling thread.

If optional @var{condition-variable} is given, @code{mutex-unlock!}
serves the "condition variable wait" operation (e.g. @code{pthread_cond_wait}
in POSIX threads).   The current thread atomically wait on
@var{condition-variable} and unlocks @var{mutex}.
The thread will be unblocked when other thread signals on
@var{condition-variable} (see @code{condition-variable-signal!}
and @code{condition-variable-broadcast!} below), or @var{timeout}
reaches if it is supplied.  The @var{timeout} argument can be either
a @code{<time>} object to represent an absolute time point (@xref{Time}),
a real number to represent a relative time in seconds, or @code{#f} which
means never.  The calling thread may be unblocked prematurely,
so it should reacquire the lock of @var{mutex} and checks the
condition, as in the following example (it is taken from SRFI-18 document):

@example
(let loop ()
  (mutex-lock! m)
  (if (condition-is-true?)
      (begin
        (do-something-when-condition-is-true)
        (mutex-unlock! m))
      (begin
        (mutex-unlock! m cv)
        (loop))))
@end example

The return value of @code{mutex-unlock!} is @code{#f} when it returns
because of timeout, and @code{#t} otherwise.
@end defun

@defun with-locking-mutex mutex thunk
Calls @var{thunk} with locking a mutex @var{mutex}.  This is defined as
follows.
@example
(define (with-locking-mutex mutex thunk)
  (dynamic-wind
   (lambda () (mutex-lock! mutex))
   thunk
   (lambda () (mutex-unlock! mutex))))
@end example
@end defun

@deftp {Builtin Class} <condition-variable>
@clindex condition-variable
A condition variable keeps a set of threads that are waiting for
a certain condition to be true.  When a thread modifies the state 
of the concerned condition, it can call @code{condition-variable-signal!}
or @code{condition-variable-broadcast!}, which unblock one or more
waiting threads so that they can check if the condition is satisfied.

A condition variable object has the following slots.

@defivar <condition-variable> name
The name of the condition variable.
@end defivar

@defivar <condition-variable> specific
A slot an application can keep arbitrary data.
@end defivar

Note that SRFI-18 doesn't have a routine equivalent to pthreads'
@code{pthread_cont_wait}.  If you want to wait on condition variable,
you can pass a condition variable to @code{mutex-unlock!} as an
optional argument (see above), then acquire mutex again by
@code{mutex-lock!}.  This design is for flexibility; see 
SRFI-18 document for the details.

This is the common usage of pthreads' condition variable:
@example
while (some_condition != TRUE) @{
  pthread_cond_wait(condition_variable, mutex);
@}
@end example
And it can be translated to SRFI-18 as follows:
@example
(let loop ()
  (unless some-condition
    (mutex-unlock! mutex condition-variable)
    (mutex-lock! mutex)
    (loop)))
@end example
@end deftp

@defun condition-variable? obj
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a condition variable,
@code{#f} otherwise.
@end defun

@defun make-condition-variable &optional name
[SRFI-18], [SRFI-21]
Returns a new condition variable.  You can give its name by
optional @var{name} argument.
@end defun

@defun condition-variable-name cv
[SRFI-18], [SRFI-21]
Returns the name of the condition variable.
@end defun

@defun condition-variable-specific cv
@defunx condition-variable-specific-set! cv value
[SRFI-18], [SRFI-21]
Gets/sets the specific value of the condition variable.
@end defun

@defun condition-variable-signal! cv
[SRFI-18], [SRFI-21]
If there are threads waiting on @var{cv}, causes the scheduler to select
one of them and to make it runnable.
@end defun

@defun condition-variable-broadcast! cv
[SRFI-18], [SRFI-21]
Unblocks all the threads waiting on @var{cv}.
@end defun

@node Thread exceptions,  , Synchronization primitives, Threads
@subsection Thread exceptions
@c NODE スレッド例外

Some types of exceptions may be thrown from thread-related procedures.
These exceptions can be handled by Gauche's exception mechanism
(@xref{Exceptions}).

@deftp {Builtin Class} <thread-exception>
@clindex thread-exception
A base class of thread-related exceptions.  Inherits @code{<exception>} class.
It has one slot.

@defivar <thread-exception> thread
A thread that threw this exception.
@end defivar
@end deftp

@deftp {Builtin Class} <join-timeout-exception>
@clindex join-timeout-exception
An exception thrown by @code{thread-join!} when a timeout reaches
before the waited thread returns.  Inherits @code{<thread-exception>}.
@end deftp

@deftp {Builtin Class} <abandoned-mutex-exception>
@clindex abandoned-mutex-exception
An exception thrown by @code{mutex-lock!} when a @var{mutex} to be
locked is in unlocked/abandoned state.  Inherits @code{<thread-exception>}.
It has one additional slot.

@defivar <abandoned-mutex-exception> mutex
A mutex that caused this exception.
@end defivar
@end deftp

@deftp {Builtin Class} <terminated-thread-exception>
@clindex terminated-thread-exception
An exception thrown by @code{thread-join!} when the waited thread
is terminated abnormally (by @code{thread-terminate!}).
Inherits @code{<thread-exception>}.  It has one additional slot.

@defivar <terminated-thread-exception> terminator
A thread that terminated the thread that causes this exception.
@end defivar
@end deftp

@deftp {Builtin Class} <uncaught-exception>
@clindex uncaught-exception
An exception thrown by @code{thread-join!} when the waited thread
is terminated by an uncaught exception.
Inherits @code{<thread-exception>}.  It has one additional slot.

@defivar <uncaught-exception> reason
An exception that caused the termination of the thread.
@end defivar
@end deftp

@defun join-timeout-exception? obj
@defunx abandoned-mutex-exception? obj
@defunx terminated-thread-exception? obj
@defunx uncaught-exception? obj
[SRFI-18], [SRFI-21]
These procedures checks if @var{obj} is a certain type of exception.
Provided for the compatibility to SRFI-18.
@end defun

@defun uncaught-exception-reason exc
[SRFI-18], [SRFI-21]
Returns the value of @code{reason} slot of @code{<uncaught-exception>}
object.
Provided for the compatibility to SRFI-18.
@end defun


@c ----------------------------------------------------------------------
@node Measure timings, Uniform vectors, Threads, Library modules - Gauche extensions
@section @code{gauche.time} - Measure timings
@c NODE 時間の計測, @code{gauche.time} - 時間の計測

@deftp {Module} gauche.time
@mdindex gauche.time
Provides two simple ways to measure execution time of Scheme code.
A macro @code{time}, which is convenient for interactive use,
and @code{<time-counter>} objects which are useful to be embedded
in the program.
@end deftp

@defmac time expr expr2 @dots{}
Evaluates @var{expr} @var{expr2} @dots{} sequentially, as @code{begin},
and returns the result(s) of the last expression.
Before returning the value(s), the macro reports the elapsed (real) time
and CPU times in the user space and the kernel space to the current
error port, much like the bourne shell's time command.

The current version uses @code{sys-gettimeofday} (@xref{Time}) to
calculate the elapsed time, and @code{sys-times} (@xref{System inquiry})
to calculate user and system CPU times.  So the resolution of these numbers
depends on these underlying system calls.  Usually the CPU
time has 10ms resolution, while the elapsed time might have higher
resolution.  On the systems that doesn't have gettimeofday(2) support,
however, the elapsed time resolution can be as bad as a second.

@example
gosh> (time (length (sort (call-with-input-file "/usr/share/dict/words" port->string-list))))
;(time (length (sort (call-with-input-file "/usr/share/dict/words" port- ...
; real   0.357
; user   0.350
; sys    0.000
45427
@end example
@end defmac

@deftp {Class} <time-counter>
@clindex time-counter
An abstract class of time counters.  Time counter is a kind of timer
whose value is incremented as the time passes.  The counting
can be started and stopped any number of times.
The value of the counter can be read
when the timer is stopping.
You can have multiple time counters.  It is useful, for example,
to measure the time in two parts inside a loop independently.

The concrete subclass determines which time it is counting.
You have to instantiate one of those subclasses described below
to use the time counter.
@end deftp

@deftp {Class} <real-time-counter>
@deftpx {Class} <user-time-counter>
@deftpx {Class} <system-time-counter>
@deftpx {Class} <process-time-counter>
@clindex real-time-counter
@clindex user-time-counter
@clindex system-time-counter
@clindex process-time-counter
Classes for time counters that count real (elapsed) time, user-space CPU time,
kernel-space CPU time, and total CPU time (user + system), respectively.
@end deftp

@deffn {Method} time-counter-start! (counter <time-counter>)
@deffnx {Method} time-counter-stop! (counter <time-counter>)
Starts and stops the @var{counter}.  The time during the counter is
running is accumulated to the counter value when the counter is stopped.

Start/stop pairs can be nested,
but only the outermost pair takes the effect.  That is, if you call
@code{time-counter-start!} on the counter that is already started,
it doesn't have any effect except that to stop such a counter
you have to call @code{time-counter-stop!} one more time.  It is useful
when you want to measure the time spent in the larger block that
may already contain timer start/stop pairs.

Calling @code{time-counter-stop!} on the already stopped counter
has no effect.
@end deffn

@deffn {Method} time-counter-reset! (counter <time-counter>)
Resets the value of @var{counter}.  If @var{counter} is already
running, it is forced to stop before being reset.
@end deffn

@deffn {Method} time-counter-value (counter <time-counter>)
Returns the current value of the counter as the number of seconds,
in a real number.  The resolution depends on the source of the counter.
@end deffn

@defmac with-time-counter counter expr @dots{}
A convenience macro to run the @var{counter} while @var{expr} @dots{}
are evaluated.  Returns the result(s) of the last expression.
It is defined as follows.
@example
(define-syntax with-time-counter
  (syntax-rules ()
    ((_ counter . exprs)
     (dynamic-wind
      (lambda () (time-counter-start! counter))
      (lambda () . exprs)
      (lambda () (time-counter-stop! counter))))
    ))
@end example
@end defmac

The following example measures approximate times
spend in process-A and process-B inside a loop.

@example
(let ((ta (make <real-time-counter>))
      (tb (make <real-time-counter>)))
  (dotimes (i 100000)
    (with-time-counter ta
      (process-A))
    (with-time-counter tb
      (process-B)))
  (format #t "Time spent in process-A: ~s\n" (time-counter-value ta))
  (format #t "Time spent in process-B: ~s\n" (time-counter-value tb))
  )
@end example


@c ----------------------------------------------------------------------
@node Uniform vectors, Comparing version numbers, Measure timings, Library modules - Gauche extensions
@section @code{gauche.uvector} - Uniform vectors
@c NODE ユニフォームベクタ, @code{gauche.uvector} - ユニフォームベクタ

@deftp {Module} gauche.uvector
@mdindex gauche.uvector
Provides vectors whose elements are of the same numeric type,
as defined in SRFI-4 (@ref{srfi-4,,SRFI-4}).

Gauche's implementation is a superset of SRFI-4 in a few ways:
@itemize @bullet
@item
Some routines takes optional parameters: @code{@var{TAG}vector->list}
takes optional start and end indices, and @code{@var{TAG}vector-ref}
takes optional fallback value.
@item
Additional functions: copy procedures (@code{@var{TAG}vector-copy} and
@code{@var{TAG}vector-copy!}), conversion procedures
(@code{@var{TAG}vector->vector} and @code{vector->@var{TAG}vector}),
and some arithmetic functions (@code{@var{TAG}vector-add}, etc.)
@item
Implements the collection framework (@xref{Collection framework})
and the sequence framework (@xref{Sequence framework}).  So the
methods like @code{map}, @code{for-each}, @code{ref} or @code{subseq}
can be used on the SRFI-4 vector types.
@item
Support of @code{f16vector}, a vector of 16-bit floating point number
as used in high-dynamic range image format (1 sign bit, 5 exponent bits,
and 10 mantissa bits).
@end itemize

There are some advantages of using SRFI-4 vectors over normal
(heterogeneous) vectors.  It may be more compact than the normal
vectors.  Some operations (especially Gauche's extension of vector
arithmetic operations) can bypass type check and conversion of
individual elements, thus be more efficient.  And it is much easier
and efficient to communicate with external libraries that require
homogeneous array of numbers; for example, OpenGL binding of Gauche
uses SRFI-4 vectors extensively.
@end deftp
The following ten types of vectors are defined.
@table @emph
@item s8vector
Elements are exact integers in the range between -2^7 and 2^7-1
@item u8vector
Elements are exact integers in the range between 0 and 2^8-1
@item s16vector
Elements are exact integers in the range between -2^15 and 2^15-1
@item u16vector
Elements are exact integers in the range between 0 and 2^16-1
@item s32vector
Elements are exact integers in the range between -2^31 and 2^31-1
@item u32vector
Elements are exact integers in the range between 0 and 2^32-1
@item s64vector
Elements are exact integers in the range between -2^63 and 2^63-1
@item u64vector
Elements are exact integers in the range between 0 and 2^64-1
@item f16vector
Elements are inexact real numbers representable in 16bits float
(a.k.a half float)
@item f32vector
Elements are inexact real numbers representable in the @code{float} of
C compiler that compiles Gauche.  Usually it is a single precision
IEEE floating point number.
@item f64vector
Elements are inexact real numbers representable in the @code{double} of
C compiler that compiles Gauche.  Usually it is a double precision
IEEE floating point number.
@end table

When you try to store a number out of the range of the vector type,
an error is signalled by default.  However, some procedures take
an optional argument @var{clamp} that specifies alternative behavior
in such a case.  @var{Clamp} argument may take one of the following values.
@table @code
@item #f
Default behavior (signals an error).
@item high
Clamps high bound; i.e. if the value to be stored is beyond the higher bound
of the range, the maximum value is stored instead.
@item low
Clamps low bound; i.e. if the value to be stored is below the lower bound
of the range, the minimum value is stored instead.
@item both
Clamps both sides; does both @code{high} and @code{low}.
@end table

@example
(list->u8vector '(-1))         @result{} @r{error}
(list->u8vector '(-1) 'low)    @result{} #u8(0)
(list->u8vector '(-1) 'high)   @result{} @r{error}
(list->u8vector '(3000) 'high) @result{} #u8(255)
(list->u8vector '(-100 20 300) 'both) @result{} #u8(0 20 255)
@end example

In the following description, @code{@var{TAG}} can be replaced
for any of @code{s8}, @code{u8}, @code{s16}, @code{u16}, 
@code{s32}, @code{u32}, @code{s64}, @code{u64}, 
@code{f16}, @code{f32}, @code{f64}.

@menu
* Uvector basic operations::    
* Uvector conversion operations::  
* Uvector numeric operations::  
* Uvector block I/O::           
@end menu

@node Uvector basic operations, Uvector conversion operations, Uniform vectors, Uniform vectors
@subsection Uvector basic operations
@c NODE ユニフォームベクタの基本操作

@deftp {Builtin Class} <@var{TAG}vector>
@clindex s8vector
@clindex u8vector
@clindex s16vector
@clindex u16vector
@clindex s32vector
@clindex u32vector
@clindex s64vector
@clindex u64vector
@clindex f16vector
@clindex f32vector
@clindex f64vector
A class for @var{TAG}vector.  It inherits @code{<sequence>}.
@end deftp

@deftp {Reader Syntax} @code{#@var{TAG}(@var{n} @dots{})}
Denotes a literal homogeneous vector.
@example
#s8(3 -2 4)
#u32(4154 88357 2 323)
#f32(3.14 0.554525 -3.342)
@end example
@end deftp

@deftp {Function} {@var{TAG}vector?} @r{@var{obj}}
@findex s8vector?
@findex u8vector?
@findex s16vector?
@findex u16vector?
@findex s32vector?
@findex u32vector?
@findex s64vector?
@findex u64vector?
@findex f16vector?
@findex f32vector?
@findex f64vector?
[SRFI-4]
Returns @code{#t} if @var{obj} is a @var{TAG}vector, @code{#f} otherwise.
@end deftp

@deftp {Function} {@var{TAG}vector} @r{@var{x} @dots{}}
@findex s8vector 
@findex u8vector
@findex s16vector
@findex u16vector
@findex s32vector
@findex u32vector
@findex s64vector
@findex u64vector
@findex f16vector
@findex f32vector
@findex f64vector
[SRFI-4]
Constructs @var{TAG}vector whose elements are numbers @var{x} @dots{}.
The numbers must be exact integer for exact integer vectors, 
and in the valid range of the vector.
@example
(s8vector 1 2 3) @result{} #s8(1 2 3)
@end example
@end deftp

@deftp {Function} make-@var{TAG}vector @r{@var{len} @var{&optional} @var{fill}}
@findex make-s8vector
@findex make-u8vector
@findex make-s16vector
@findex make-u16vector
@findex make-s32vector
@findex make-u32vector
@findex make-s64vector
@findex make-u64vector
@findex make-f16vector
@findex make-f32vector
@findex make-f64vector
[SRFI-4]
Constructs a @var{TAG}vector of length @var{len}.  The elements are
initialized by a number @var{fill}.   For exact integer vectors,
@var{fill} must be an exact integer and in the valid range.
If @var{fill} is omitted, the content of the vector is undefined.
@example
(make-u8vector 4 0) @result{} #u8(0 0 0 0)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-length @r{@var{vec}}
@findex s8vector-length 
@findex u8vector-length
@findex s16vector-length
@findex u16vector-length
@findex s32vector-length
@findex u32vector-length
@findex s64vector-length
@findex u64vector-length
@findex f16vector-length
@findex f32vector-length
@findex f64vector-length
[SRFI-4]
Returns the length of the @var{TAG}vector @var{vec}.

Note that the generic function @code{size-of} can be used 
to obtain the length of @var{vec} as well,
if you import @code{gauche.collection}
(@xref{Collection framework}).
@example
(s16vector-length '#s16(111 222 333)) @result{} 3

(use gauche.collection)
(size-of '#s16(111 222 333)) @result{} 3
@end example
@end deftp

@deftp {Function} @var{TAG}vector-ref @r{@var{vec} @var{k} &optional @var{fallback}}
@findex s8vector-ref
@findex u8vector-ref
@findex s16vector-ref
@findex u16vector-ref
@findex s32vector-ref
@findex u32vector-ref
@findex s64vector-ref
@findex u64vector-ref
@findex f16vector-ref
@findex f32vector-ref
@findex f64vector-ref
[SRFI-4+]
Returns the @var{k}-th element of @var{TAG}vector @var{vec}.

If the index @var{k} is out of the valid range, an error is signalled
unless an optional argument @var{fallback} is given; in that case,
@var{fallback} is returned.

Note that the generic function @code{ref} can be used as well,
if you import @code{gauche.collection}.

@example
(u16vector-ref '#u16(111 222 333) 1) @result{} 222

(use gauche.collection)
(ref '#u16(111 222 333) 1) @result{} 222
@end example
@end deftp

@deftp {Function} @var{TAG}vector-set! @r{@var{vec} @var{k} @var{n} &optional @var{clamp}}
@findex s8vector-set!
@findex u8vector-set!
@findex s16vector-set!
@findex u16vector-set!
@findex s32vector-set!
@findex u32vector-set!
@findex s64vector-set!
@findex u64vector-set!
@findex f16vector-set!
@findex f32vector-set!
@findex f64vector-set!
[SRFI-4+]
Sets a number @var{n} to the @var{k}-th element of @var{TAG}vector @var{vec}.
Optional @var{clamp} argument specifies the behavior when
@var{n} is out of valid range.   Default is to signal an error.

Note that the setter of the generic function @code{ref} can be used as well,
if you import @code{gauche.collection}.
@example
(let ((v (s32vector -439 852 8933)))
  (s32vector-set! v 1 4)
  v)
 @result{} #s32vector(-439 4 8933)

(use gauche.collection)
(let ((v (s32vector -439 852 8933)))
  (set! (ref v 1) 4)
  v)
 @result{} #s32vector(-439 4 8933)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-fill! @r{@var{vec} @var{fill} &optional @var{start} @var{end}}
@findex s8vector-fill!
@findex u8vector-fill!
@findex s16vector-fill!
@findex u16vector-fill!
@findex s32vector-fill!
@findex u32vector-fill!
@findex s64vector-fill!
@findex u64vector-fill!
@findex f16vector-fill!
@findex f32vector-fill!
@findex f64vector-fill!
Stores @var{fill} in every element of @var{vec},
ranging from @var{start} to @var{end} of @var{vec},
if they are given. 
@end deftp

@deftp {Function} @var{TAG}vector-copy @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector-copy
@findex u8vector-copy
@findex s16vector-copy
@findex u16vector-copy
@findex s32vector-copy
@findex u32vector-copy
@findex s64vector-copy
@findex u64vector-copy
@findex f16vector-copy
@findex f32vector-copy
@findex f64vector-copy
Copies the srfi-4 vector @var{vec}.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.

@example
(u8vector-copy '#u8(1 2 3 4))     @result{} #u8(1 2 3 4)
(u8vector-copy '#u8(1 2 3 4) 2)   @result{} #u8(3 4)
(u8vector-copy '#u8(1 2 3 4) 1 3) @result{} #u8(2 3)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-copy! @r{@var{target} @var{tstart} @var{source} &optional @var{sstart} @var{send}}
@findex s8vector-copy!
@findex u8vector-copy!
@findex s16vector-copy!
@findex u16vector-copy!
@findex s32vector-copy!
@findex u32vector-copy!
@findex s64vector-copy!
@findex u64vector-copy!
@findex f16vector-copy!
@findex f32vector-copy!
@findex f64vector-copy!
Both @var{target} and @var{source} must be @i{TAG}vectors, and
@var{target} must be mutable.
This procedure copies the elements of @var{start}, beginning from index
@var{sstart} (inclusive) and up to @var{send}, into @var{target},
beginning from index @var{tstart}.  @var{Sstart} and @var{tstart}
may be omitted, and in that case 0 and the length of @var{source}
are assumed, respectively.

@example
(let ((target (u8vector 0 1 2 3 4 5 6)))
  (u8vector-copy! target 2 '#u8(10 11 12 13 14) 1 4)
  target)
 @result{} #u8(0 1 11 12 13 6)
@end example

If the number of elements in the source vector between @var{sstart}
and @var{send} is larger than the target vector beginning from @var{tstart},
the excess elements are silently discarded.

@emph{Note:} This procedure used to take just two uniform vectors, @var{target}
and @var{source}, and just copies contents of @var{source} to @var{target}.
Both vectors had to be the same type and same length.  The API is revised
to the current form to make it parallel with @code{string-copy!} (SRFI-13)
and @code{vector-copy!} (SRFI-43).  The old interface is still supported
for the backward compatibility, but it is deprecated and will be gone
in the future releases.
@end deftp

Using collection and sequence framework, you can perform
various operations on the homogeneous vectors.

@example
(use gauche.collection)
(use gauche.sequence)

(fold + 0 '#s32(1 2 3 4)) @result{} 10

(map-to <f32vector> * '#f32(3.2 1.1 4.3) '#f32(-4.3 2.2 9.4))
  @result{} #f32(-13.760001 2.420000 40.420002)

(subseq #u32(1 4 3 4 5) 2 4) @result{} #u32(3 4)
@end example


@node Uvector conversion operations, Uvector numeric operations, Uvector basic operations, Uniform vectors
@subsection Uvector conversion operations
@c NODE ユニフォームベクタの変換

@deftp {Function} @var{TAG}vector->list @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector->list
@findex u8vector->list
@findex s16vector->list
@findex u16vector->list
@findex s32vector->list
@findex u32vector->list
@findex s64vector->list
@findex u64vector->list
@findex f16vector->list
@findex f32vector->list
@findex f64vector->list
[SRFI-4+]
Converts @var{TAG}vector @var{vec} to a list.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be extracted.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@example
(u32vector->list '#u32(9 2 5)) @result{} (9 2 5)

(use gauche.collection)
(coerce-to <list> '#u32(9 2 5)) @result{} (9 2 5)
@end example
@end deftp

@deftp {Function} @var{TAG}vector->vector @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector->vector
@findex u8vector->vector
@findex s16vector->vector
@findex u16vector->vector
@findex s32vector->vector
@findex u32vector->vector
@findex s64vector->vector
@findex u64vector->vector
@findex f16vector->vector
@findex f32vector->vector
@findex f64vector->vector
Converts @var{TAG}vector @var{vec} to a vector.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@example
(f32vector->vector '#f32(9.3 2.2 5.5))   @result{} #(9.3 2.2 5.5)
(f32vector->vector '#f32(9.3 2.2 5.5) 2) @result{} #(5.5)

(use gauche.collection)
(coerce-to <vector> '#f32(9.3 2.2 5.5)) @result{} #(9.3 2.2 5.5)
@end example
@end deftp

@deftp {Function} list->@var{TAG}vector @r{@var{list} &optional @var{clamp}}
@findex list->s8vector
@findex list->u8vector
@findex list->s16vector
@findex list->u16vector
@findex list->s32vector
@findex list->u32vector
@findex list->s64vector
@findex list->u64vector
@findex list->f16vector
@findex list->f32vector
@findex list->f64vector
[SRFI-4+]
Converts a list @var{list} to a @var{TAG}vector.
Optional argument @var{clamp} specifies the behavior when
the element of @var{list} is out of the valid range.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@example
(list->s64vector '(9 2 5)) @result{} #s64(9 2 5)

(use gauche.collection)
(coerce-to <s64vector> '(9 2 5)) @result{} #s64(9 2 5)
@end example
@end deftp

@deftp {Function} vector->@var{TAG}vector @r{@var{vec} &optional @var{start} @var{end} @var{clamp}}
@findex vector->s8vector
@findex vector->u8vector
@findex vector->s16vector
@findex vector->u16vector
@findex vector->s32vector
@findex vector->u32vector
@findex vector->s64vector
@findex vector->u64vector
@findex vector->f16vector
@findex vector->f32vector
@findex vector->f64vector
Converts a vector @var{vec} to a @var{TAG}vector.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.
Optional argument @var{clamp} specifies the behavior when
the element of @var{vec} is out of the valid range.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@example
(vector->f64vector '#(3.1 5.4 3.2)) @result{} #f64(3.1 5.4 3.2)

(use gauche.collection)
(coerce-to <f64vector> '#(3.1 5.4 3.2)) @result{} #f64(3.1 5.4 3.2)
@end example
@end deftp

@defun string->s8vector string &optional start end
@defunx string->u8vector string &optional start end
Returns an s8vector or u8vector whose byte sequence is the same
as the internal representation of the given string.
Optional range arguments @var{start} and @var{end} specifies
the @emph{character position} inside @var{string} to be
converted.

These procedures are useful when you want to access byte
sequence of the string randomly.

@example
(string->u8vector "abc") @result{} #u8(97 98 99)

@end example
@end defun

@defun string->s8vector! target tstart string &optional start end
@defunx string->u8vector! target tstart string &optional start end
@var{Target} must be an s8vector or a u8vector, respectively.
@var{Target} must be mutable.
Like copies the raw byte representation of @var{string}
into @var{target} beginning from index @var{tstart}.

Returns @var{target}.

@example
(let ((target (make-u8vector 10 0)))
  (string->u8vector! target 3 "abcde"))
 @result{} #u8(0 0 0 97 98 99 100 101 0 0)
@end example

@end defun

@defun s8vector->string vec &optional start end
@defunx u8vector->string vec &optional start end
Converts a byte sequence in s8vector or u8vector to a string that
has the same byte sequence.  Optional range arguments @var{start} and
@var{end} specifies the byte position in @var{vec} to be converted.

Note that these procedure may result an incomplete string if
@var{vec} contains a byte sequence invalid as the internal encoding
of the string.
@end defun

@defun string->s32vector string &optional start end
@defunx string->u32vector string &optional start end
Returns an s32vector or u32vector whose elements are
the internal codes of the characters in the string.
Optional range arguments @var{start} and @var{end} specifies
the @emph{character position} inside @var{string} to be
converted.

These procedures are useful when you want to access
the characters in the string randomly.
@end defun

@defun s32vector->string vec &optional start end
@defunx u32vector->string vec &optional start end
Without @var{start} and @var{end}, these procedures work like this:
@example
(lambda (vec) (map-to <string> integer->char vec)))
@end example
Optional range arguments @var{start} and @var{end} limits
the range of conversion between them.
@end defun

@defun uvector-alias uvector-class vec &optional start end
This procedure creates an uvector of class @var{uvector-class}
that shares the storage of the given uniform vector @var{vec}.
If optional @var{start} and @var{end} arguments are given,
only the specified range of @var{vec} is used for the new vector.
Since the storage is shared, modification of the original vector
can be seen from the new vector, or vice versa.

The class @var{uvector-class} must be either one of the uniform
vector class, but is not necessary match the class of the
source vector @var{vec}.   In such case, the new vector looks at the same
region of @var{vec}'s memory, but interprets it differently.
For example, the following code determines whether Gauche
is running on big-endian or little-endian machine:

@example
(let ((u8v (uvector-alias <u8vector> #u32(1))))
  (if (zero? (u8vector-ref u8v 0))
      'big-endian 
      'little-endian))
@end example

If the @var{uvector-class} is other than s8vector or u8vector,
the region the new vector points has to meet the alignment
requirement.  You can assume the beginning of the source vector
is aligned suitable for any uniform vectors.  So, for example,
if you're creating u32vector from u8vector, the @var{start} and
@var{end} must be multiple of 4 (or, if they're omitted, the length
of the original u8vector must be multiple of 4).
An error is signalled when the given parameters doesn't satisfy
alignment constraint.
@end defun


@node Uvector numeric operations, Uvector block I/O, Uvector conversion operations, Uniform vectors
@subsection Uvector numeric operations
@c NODE ユニフォームベクタの数値演算

@deftp {Function} @var{TAG}vector-add @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-add! @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-sub @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-sub! @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-mul @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-mul! @r{@var{vec} @var{val} &optional @var{clamp}}
@findex s8vector-add
@findex s8vector-add!
@findex s8vector-sub
@findex s8vector-sub!
@findex s8vector-mul
@findex s8vector-mul!
@findex u8vector-add
@findex u8vector-add!
@findex u8vector-sub
@findex u8vector-sub!
@findex u8vector-mul
@findex u8vector-mul!
@findex s16vector-add
@findex s16vector-add!
@findex s16vector-sub
@findex s16vector-sub!
@findex s16vector-mul
@findex s16vector-mul!
@findex u16vector-add
@findex u16vector-add!
@findex u16vector-sub
@findex u16vector-sub!
@findex u16vector-mul
@findex u16vector-mul!
@findex s32vector-add
@findex s32vector-add!
@findex s32vector-sub
@findex s32vector-sub!
@findex s32vector-mul
@findex s32vector-mul!
@findex u32vector-add
@findex u32vector-add!
@findex u32vector-sub
@findex u32vector-sub!
@findex u32vector-mul
@findex u32vector-mul!
@findex s64vector-add
@findex s64vector-add!
@findex s64vector-sub
@findex s64vector-sub!
@findex s64vector-mul
@findex s64vector-mul!
@findex u64vector-add
@findex u64vector-add!
@findex u64vector-sub
@findex u64vector-sub!
@findex u64vector-mul
@findex u64vector-mul!
@findex f16vector-add
@findex f16vector-add!
@findex f16vector-sub
@findex f16vector-sub!
@findex f16vector-mul
@findex f16vector-mul!
@findex f32vector-add
@findex f32vector-add!
@findex f32vector-sub
@findex f32vector-sub!
@findex f32vector-mul
@findex f32vector-mul!
@findex f64vector-add
@findex f64vector-add!
@findex f64vector-sub
@findex f64vector-sub!
@findex f64vector-mul
@findex f64vector-mul!
Element-wise arithmetic.  @var{Vec} must be a @var{TAG}vector,
and @var{val} must be either a @var{TAG}vector, a vector, or a list
of the same length as @var{vec}, or a number
(an exact integer for integer vectors, 
and a real number for f32- and f64-vectors).

If @var{val} is a @var{TAG}vector, its elements are 
added to, subtracted from, or multiplied by the corresponding
elements of @var{vec}, respectively,
and the results are gathered to a @var{TAG}vector 
and returned.  The destructive version (those have bang `!' in the name)
reuses @var{vec} to store the result.
If the result of calculation goes out of the range of @var{TAG}vector's
element, the behavior is specified by @var{clamp} optional argument.
(For f32vector and f64vector, @var{clamp} argument is ignored and
the result may contain infinity).

If @var{val} is a number, it is added to, subtracted from, or
multiplied by each element of @var{vec}, respectively.

@example
(s8vector-add '#s8(1 2 3 4) '#s8(5 6 7 8)) @result{} #s8(6 8 10 12)
(u8vector-sub '#u8(1 2 3 4) '#u8(2 2 2 2)) @result{} @r{error}
(u8vector-sub '#u8(1 2 3 4) '#u8(2 2 2 2) 'both) @result{} #u8(0 0 1 2)

(f32vector-mul '#f32(3.0 2.0 1.0) 1.5) @result{} #f32(4.5 3.0 1.5)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-div @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-div! @r{@var{vec} @var{val}}
@findex f16vector-div
@findex f16vector-div!
@findex f32vector-div
@findex f32vector-div!
@findex f64vector-div
@findex f64vector-div!
Element-wise division of flonum vectors.   These are only defined
for f16, f32 and f64vector.  @var{val} must be a @var{TAG}vector,
a vector or a list of the same length as @var{vec}, or a real number.

@example
(f32vector-div '#f32(1.0 2.0 3.0) 2.0) @result{} #f32(0.5 1.0 1.5)
@end example
@end deftp


@deftp {Function} @var{TAG}vector-and @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-and! @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-ior @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-ior! @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-xor @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-xor! @r{@var{vec} @var{val}}
@findex s8vector-and
@findex s8vector-and!
@findex s8vector-ior
@findex s8vector-ior!
@findex s8vector-xor
@findex s8vector-xor!
@findex u8vector-and
@findex u8vector-and!
@findex u8vector-ior
@findex u8vector-ior!
@findex u8vector-xor
@findex u8vector-xor!
@findex s16vector-and
@findex s16vector-and!
@findex s16vector-ior
@findex s16vector-ior!
@findex s16vector-xor
@findex s16vector-xor!
@findex u16vector-and
@findex u16vector-and!
@findex u16vector-ior
@findex u16vector-ior!
@findex u16vector-xor
@findex u16vector-xor!
@findex s32vector-and
@findex s32vector-and!
@findex s32vector-ior
@findex s32vector-ior!
@findex s32vector-xor
@findex s32vector-xor!
@findex u32vector-and
@findex u32vector-and!
@findex u32vector-ior
@findex u32vector-ior!
@findex u32vector-xor
@findex u32vector-xor!
@findex s64vector-and
@findex s64vector-and!
@findex s64vector-ior
@findex s64vector-ior!
@findex s64vector-xor
@findex s64vector-xor!
@findex u64vector-and
@findex u64vector-and!
@findex u64vector-ior
@findex u64vector-ior!
@findex u64vector-xor
@findex u64vector-xor!
Element-wise logical (bitwise) operation.
These procedures are only defined for integral vectors.
@var{val} must be a @var{TAG}vector, a vector or a list
of the same length as @var{vec},
or an exact integer.  Bitwise and, inclusive or or exclusive or
is calculated between each element in @var{vec} and the corresponding
element of @var{val} (when @var{val} is a non-scalar value),
or @var{val} itself (when @var{val} is an integer).
The result is returned in a @var{TAG}vector.
The destructive version reuses @var{vec} to store the result.
@end deftp

@deftp {Function} @var{TAG}vector-dot @r{@var{vec0} @var{vec1}}
@findex s8vector-dot
@findex s16vector-dot
@findex s32vector-dot
@findex s64vector-dot
@findex u8vector-dot
@findex u16vector-dot
@findex u32vector-dot
@findex u64vector-dot
@findex f16vector-dot
@findex f32vector-dot
@findex f64vector-dot
Calculates the dot product of two @var{TAG}vectors.
The length of @var{vec0} and @var{vec1} must be the same.
@end deftp

@deftp {Function} @var{TAG}vector-range-check @r{@var{vec} @var{min} @var{max}}
@findex s8vector-range-check
@findex s16vector-range-check
@findex s32vector-range-check
@findex s64vector-range-check
@findex u8vector-range-check
@findex u16vector-range-check
@findex u32vector-range-check
@findex u64vector-range-check
@findex f16vector-range-check
@findex f32vector-range-check
@findex f64vector-range-check
@var{Vec} must be a @var{TAG}vector, and each of @var{min} and @var{max}
must be either a @var{TAG}vector, a vector or a list of the same length
as @var{vec}, or a number, or @code{#f}.

For each element in @var{vec}, this procedure checks if the value
is between @var{minval} and @var{maxval} inclusive, where
@var{minval} and @var{maxval} are the corresponding values of
@var{min} and @var{max} (when @var{min} and/or @var{max} is/are
non-scalar value) or @var{min} and @var{max} themselves (when
@var{min} and/or @var{max} is/are a number).
When @var{min} is @code{#f}, negative infinity is assumed.
When @var{max} is @code{#f}, positive infinity is assumed.

If all the elements in @var{vec} are within the range, @code{#f} is
returned.  Otherwise, the index of the leftmost element of @var{vec}
that is out of range is returned.

@example
(u8vector-range-check '#u8(3 1 0 2) 0 3)  @result{} #f
(u8vector-range-check '#u8(3 1 0 2) 1 3)  @result{} 2

(u8vector-range-check '#u8(4 32 64 98) 0 '#u8(10 40 70 90))
  @result{} 3

;; Range check in a program
(cond
 ((u8vector-range-check u8v 1 31)
  => (lambda (i)
      (errorf "~sth vector element is out of range: ~s"
              i (u8vector-ref u8v i))))
 (else (do-something u8v)))
@end example
@end deftp

@deftp {Function} @var{TAG}vector-clamp @r{@var{vec} @var{min} @var{max}}
@deftpx {Function} @var{TAG}vector-clamp! @r{@var{vec} @var{min} @var{max}}
@findex s8vector-clamp
@findex s16vector-clamp
@findex s32vector-clamp
@findex s64vector-clamp
@findex u8vector-clamp
@findex u16vector-clamp
@findex u32vector-clamp
@findex u64vector-clamp
@findex f32vector-clamp
@findex f64vector-clamp
@findex s8vector-clamp!
@findex s16vector-clamp!
@findex s32vector-clamp!
@findex s64vector-clamp!
@findex u8vector-clamp!
@findex u16vector-clamp!
@findex u32vector-clamp!
@findex u64vector-clamp!
@findex f16vector-clamp!
@findex f32vector-clamp!
@findex f64vector-clamp!
@var{Vec} must be a @var{TAG}vector, and each of @var{min} and @var{max}
must be either a @var{TAG}vector, a vector or a list of the same length
as @var{vec}, or a number, or @code{#f}.

Like @var{TAG}vector-range-check, these procedures check if
each element of @var{vec} are within the range between @var{minval}
and @var{maxval} inclusive, which are derived from @var{min} and @var{max}.
If the value is less than @var{minval}, it is replaced by @var{minval}.
If the value is grater than @var{maxval}, it is replaced by @var{maxval}.

@var{TAG}vector-clamp creates a copy of @var{vec} and do clamp
operation on it, while @var{TAG}vector-clamp! modifies @var{vec}.
Both return the clamped vector.

@example
(s8vector-clamp '#s8(8 14 -3 -22 0) -10 10) @result{} #s8(8 10 -3 -10 0)
@end example
@end deftp

@node Uvector block I/O,  , Uvector numeric operations, Uniform vectors
@subsection Uvector block I/O
@c NODE ユニフォームベクタのブロック入出力

A uniform vector can be seen as an abstraction of a chunk of memory.
So you might want to use it for binary I/O.  Yes, you can do it.

@defun read-block! vec &optional iport start end endian
Reads a chunk of data from the given input port @var{iport},
and stores it to the uniform vector @var{vec}.
You can give any uniform vector.
If optional @var{start} and @var{end}
arguments are given, they specify the index range in @var{vec}
that is to be filled, and the rest of the vector remains untouched.
Otherwise, entire vector is used.  A special value -1 for @var{end}
indicates the end of @var{vec}.
If @var{iport} is omitted, the current input port is used.

If the input reached EOF before the required region of @var{vec}
is filled, the rest of the vector is untouched.

If @var{iport} is already reached EOF when @code{read-block!} is
called, an EOF object is returned.  Otherwise,
the procedure returns the number of @emph{elements} read (not bytes).

If the @var{iport} is a buffered port with `modest' or `none'
buffering mode (@xref{File ports}), @code{read-block!} may return
before all the elements in @var{vec} is filled, even if @var{iport}
hasn't reached EOF.  The ports connected to a pipe or a network socket
behave so by default.  If you know there will be enough data arriving and
want to make sure @var{vec} is filled, change the buffering mode of
@var{iport} to `full'.

The data is read as a byte stream, so if you give uniform vectors
other than s8vector or u8vector, your result may affected by
the endian.    Suppose the input stream
has a byte sequence @code{#x01, #x02, #x03, #x04}.  If you read
it into u32vector, the first element you'll get may be
@code{#x01020304} if you're using big-endian,
or @code{#x04030201} if you're using little-endian.
By default @code{read-block!} uses the platform's native endian.
You can specify the endian by passing either symbol @code{big-endian}
or @code{little-endian} to the optional argument @var{endian}.
@end defun

(Technically there are more variations than a simple big/little endians.
See the discussion in @ref{Binary I/O}.)


@defun write-block vec &optional oport start end endian
Writes out the content of the uniform vector @var{vec} 'as is'
to the output port @var{oport}.   If @var{oport} is omitted,
the current output port is used.
If optional @var{start} and @var{end} arguments are given,
they specify the index range in @var{vec} to be written out.
A special value -1 for @var{end} indicates the end of @var{vec}.
This procedure returns an unspecified value.

If you write out a uniform vector except s8vector and u8vector, the 
care should be taken about the endianness, as in @code{read-block!}.
The number @code{#x01020304} in your u32vector may be written out
as the byte sequence @code{#x01, #x02, #x03, #x04} or
@code{#x04, #x03, #x02, #x01}, depends on the @var{endian} argument,
whose default is platform-dependent.
@end defun

@c ----------------------------------------------------------------------
@node Comparing version numbers, Virtual ports, Uniform vectors, Library modules - Gauche extensions
@section @code{gauche.version} - Comparing version numbers
@c NODE バージョン番号の比較, @code{gauche.version} - バージョン番号の比較

@deftp {Module} gauche.version
@mdindex gauche.version
This module provides a convenient procedure to compare
@emph{version numbers} or @emph{revision numbers},
such as "@code{0.5.1}", "@code{3.2-3}" or "@code{8.2pl1}".
Usually each release of software component has
a version number, and you can define order between them.
For example, version "1.2.3" is newer than "1.2" and
older than "2.1".   You can compare those version numbers like this:

@example
(version<? "2.2.3" "2.2.11")     @result{} #t
(version<? "2.3.1" "2.3")        @result{} #f
(version<? "2.3.1-1" "2.3.1-10") @result{} #t
(version<? "13a" "5b")           @result{} #f
@end example

There are no standard way to name versions, so I chose
one convention.   This won't work for all possible
variations, but I think it covers typical cases.

Strictly speaking, you can only define partial order between
version numbers, for there can be branches.   This module
uses simple measure and just assumes the version numbers
can be fully ordered.

The version number here is defined by the following syntax.
@example
 <version> : <principal-release>
           | <version> <post-subrelease>
           | <version> <pre-subrelease>
 <principal-release> : <relnum>
 <post-subrelease>   : [.-] <relnum>
 <pre-subrelease>    : _ <relnum>
 <relnum>            : [0-9A-Za-z]+
@end example

Typically @code{<relnum>} is composed by numeric part and extension part.
For example, "23a" is composed by an integer 23 and extension "a".
If @code{<relnum>} doesn't begins with digits, we assume its
numeric part is -1.

Then, the order of @code{<relnum>} is defined as follows:
@enumerate
@item
If relnum A and relnum B have different numeric part, we ignore the
extension and order them numerically, e.g.  "@code{3b}" < "@code{4a}".
@item
If relnum A and relnum B have the same numeric part, we compare
extension by alphabetically, e.g.  "@code{4c}" < "@code{4d}"
and "@code{5}" < "@code{5a}".
@end enumerate

Given the order of @code{<relnum>}, the order of version numbers
are defined as follows:
@enumerate
@item
Decompose each version number into a list of @code{<principal-release>} and
subsequence subrelease components.   We call each element of
the list "release components".
@item
If the first release component of both lists are the same,
remove it from both.  Repeat this until the head of the lists differ.
@item
Now we have the following cases.
@enumerate
@item
Both lists are empty: versions are the same.
@item
One list (A) is empty and the other list (B) has post-subrelease
at head: A is prior to B
@item
One list (A) is empty and the other list (B) has pre-subrelease
at head: B is prior to A
@item
List A's head is post-subrelease and list B's head is
pre-subrelease: B is prior to A
@item
Both lists have post-subrelease or pre-subrelease at head:
compare their relnums.
@end enumerate
@end enumerate
Here are some examples:
@example
"1" < "1.0" < "1.1" < "1.1.1" < "1.1.2" < "1.2" < "1.11"
"1.2.3" < "1.2.3-1" < "1.2.4"
"1.2.3" < "1.2.3a" < "1.2.3b"
"1.2_rc0" < "1.2_rc1" < "1.2" < "1.2-pl1" < "1.2-pl2"
"1.1-patch112" < "1.2_alpha"
@end example

The reason of having @code{<pre-subrelease>} is to allow
"release candidate" or "pre-release" version.
@end deftp

@defun version=? ver1 ver2
@defunx version<? ver1 ver2
@defunx version<=? ver1 ver2
@defunx version>? ver1 ver2
@defunx version>=? ver1 ver2
Returns a boolean value depending on the order of two version number
string @var{ver1} and @var{ver2}.  If the arguments contain invalid
strings as the defined version number, an error is signalled.
@end defun

@defun version-compare ver1 ver2
Compares two version number strings @var{ver1} and @var{ver2},
and returns either -1, 0, or 1, depending whether @var{ver1} is
prior to @var{ver2}, @var{ver1} is the same as @var{ver2}, or
@var{ver1} is after @var{ver2}, respectively.
@end defun

@defun relnum-compare rel1 rel2
This is lower-level procedure of @code{version-compare}.  Compares
two release numbers (relnums) @var{rel1} and @var{rel2}, 
and returns either -1, 0, or 1 depending whether  @var{rel1} is
prior to @var{rel2}, @var{rel1} is the same as @var{rel2}, or
@var{rel1} is after @var{rel2}, respectively.
@end defun

@c ----------------------------------------------------------------------
@node Virtual ports,  , Comparing version numbers, Library modules - Gauche extensions
@section @code{gauche.vport} - Virtual ports
@c NODE 仮想ポート, @code{gauche.vport} - 仮想ポート

@deftp {Module} gauche.vport
@mdindex gauche.vport
@emph{Virtual ports}, or procedural ports, are the ports
whose behavior can be programmed in Scheme.

This module provides two kinds of virtual ports:
Fully virtual ports, in which every I/O operation invokes
user-provided procedures, and virtual buffered ports,
in which I/O operations are done on an internal buffer and
user-provided procedures are called only when the buffer
needs to be filled or flushed.

This module also provides virtual buffered ports backed up
by a uniform vector, as an example of the feature.
@end deftp

@subsubheading Fully virtual ports

This type of virtual ports are realized by classes
@code{<virtual-input-port>} and @code{<virtual-output-port>}.
You can customize the port behavior by setting 
appropriate slots with procedures.

@deftp {Class} <virtual-input-port>
@clindex virtual-input-port
An instance of this class can be used as an input port.
The behavior of the port depends on the settings of the
instance slot values.

To work as a meaningful input port, at least either one of
@code{getb} or @code{getc} slot must be set.  Otherwise,
the port returns EOF for all input requests.

@defivar {<virtual-input-port>} getb
If set, the value must be a procedure that takes no arguments.
Every time binary input is required, the procedure is called.

The procedure must return an exact integer between 0 and 255
inclusive, or @code{#f} or an EOF object.  If it returns an
integer, it becomes the value read from the port.  If it returns
other values, the port returns EOF.

If the port is requested a character input and it doesn't have
the @code{getc} procedure, the port calls this procedure, possibly
multiple times, to construct a whole character.
@end defivar

@defivar {<virtual-input-port>} getc
If set, the value must be a procedure that takes no arguments.
Every time character input is required, the procedure is called.

The procedure must return a character,
@code{#f} or an EOF object.  If it returns a character,
it becomes the value read from the port.  If it returns
other values, the port returns EOF.

If the port is requested a binary input and it doesn't have
the @code{getb} procedure, the port calls this procedure, then converts
a character into a byte sequence, and use it as the binary
value(s) read from the port.
@end defivar

@defivar {<virtual-input-port>} gets
If set, the value must be a procedure that takes one argument,
a positive exact integer.  It is called when the block binary
input, such as @code{read-block}, is requested.
It must return a (maybe incomplete) string up to the specified size, 
or @code{#f} or EOF object.  If it returns a null string, @code{#f}
or EOF object, 
the port thinks it reached EOF.  If it returns other string,
it is used as the result of block read.
It shouldn't return a string larger than the given size
(Note: you must count size (bytes), not the number of characters).
The reason of this procedure is efficiency; if this procedure
is not provided, the port calls @code{getb} procedure repeatedly
to prepare the block of data.  In some cases, providing block input
can be much more efficient (e.g. suppose you're reading from
a block of memory chunk).

You can leave this slot unset if you don't need to take such
advantage.
@end defivar

@defivar {<virtual-input-port>} ready
If set, the value must be a procedure that takes one boolean argument.
It is called when @code{char-ready?} or @code{byte-ready?} is
called on the port.   The value returned from your procedure will
be the result of these procedures.

The boolean argument is @code{#t} if
@code{char-ready?} is called, or @code{#f} if @code{byte-ready?} is called.

If unset, @code{char-ready?} and @code{byte-ready?}
always return @code{#t} on the port
@end defivar

@defivar {<virtual-input-port>} close
If set, the value must be a procedure that takes no arguments.
It is called when the port is closed.  Return value is discarded.
You can leave this unset
if you don't need to take an action when the port is closed.

This procedure may be called from a finalizer, so you have to be
careful to write it.   See the note on finalization below.
@end defivar

@defivar {<virtual-input-port>} seek
If set, the value must be a procedure that takes two arguments,
offset and whence.  The meaning of them is the same as the arguments
to @code{port-seek} (@xref{Common port operations}).
The procedure must adjust the port's internal read pointer
so that the next read begins from the new pointer.
It should return the updated pointer (the byte offset from the
beginning of the port).

If unset, call of @code{port-seek} and @code{port-tell} on this
port will return @code{#f}.

Note that this procedure may be called for the purpose of merely
querying the current position, with 0 as @code{offset} and @code{SEEK_CUR}
as @code{whence}.  If your port knows the read pointer but cannot move it,
you can still provide this procedure, which returns the current pointer
position for such queries and returns @code{#f} for other arguments.
@end defivar

@end deftp


@deftp {Class} <virtual-output-port>
@clindex virtual-output-port
An instance of this class can be used as an output port.
The behavior of the port depends on the settings of the
instance slot values.

To work as an output port, at least either one of @code{putb} or
@code{putc} slot has to be set.

@defivar {<virtual-output-port>} putb
If set, the value must be a procedure that takes one argument,
a byte value (exact integer between 0 and 255, inclusive).
Every time binary output is required, the procedure is called.
The return value of the procedure is ignored.

If this slot is not set and binary output is requested,
the port may signal an @code{<io-unit-error>} error.
@end defivar

@defivar {<virtual-output-port>} putc
If set, the value must be a procedure that takes one argument,
a character.
Every time character output is required, the procedure is called.
The return value of the procedure is ignored.

If this slot is not set but @code{putb} slot is set,
the virtual port decomposes the character into a sequence of bytes
then calls @code{putb} procedures.
@end defivar

@defivar {<virtual-output-port>} puts
If set, the value must be a procedure that takes a
(possibly incomplete) string.
The return value of the procedure is ignored.

This is for efficiency.  If this slot is not set, the virtual port
calls @code{putb} or @code{putc} repeatedly to output a chunk of data.
But if your code can perform chunked output efficiently, 
you can provide this procedure.
@end defivar

@defivar {<virtual-output-port>} flush
If set, the value must be a procedure that takes no arguments.
It is called when flushing a port is required (e.g. @code{flush}
is called on the port, or the port is being closed).

This procedure is useful that your port does some sort of buffering,
or needs to keep some state.  If your port doesn't do stateful operation,
you can leave this unset.

This procedure may be called from a finalizer, and needs a special
care.  See notes on finalizers below.

@end defivar

@defivar {<virtual-output-port>} close
The same as @code{<virtual-input-port>}'s @code{close} slot.
@end defivar

@defivar {<virtual-output-port>} seek
The same as @code{<virtual-input-port>}'s @code{seek} slot.
@end defivar

@end deftp

@subsubheading Virtual buffered ports

This type of virtual ports are realized by classes
@code{<buffered-input-port>} and @code{<buffered-output-port>}.
You can customize the port behavior by setting 
appropriate slots with procedures.

Those ports have internal buffer and only calls Scheme procedures
when the buffer needs to be filled or flushed.  Generally it is 
far more efficient than calling Scheme procedures for every
I/O operation.   Actually, the internal buffering mechanism is
the same as Gauche's file I/O ports.

These ports uses @code{u8vector} as a buffer.  See @ref{Uniform vectors}
for the details.

@deftp {Class} <buffered-input-port>
@clindex buffered-input-port

An instance of this class behaves as an input port.
It has the following instance slots.  For a meaningful input
port, you have to set at least @code{fill} slot.

@defivar {<buffered-input-port>} fill
If set, it must be a procedure that takes one argument,
a @code{u8vector}.  It must fill the data from the
beginning of the vector.  It doesn't need to fill the entire
vector if there's not so many data.  However, if there are remaining
data, it must fill at least one byte; if the data isn't readily
available, it has to wait until some data becomes available.

The procedure must return a number of bytes it actually filled.
It may return 0 or an EOF object to indicate the port has reached EOF.
@end defivar

@defivar {<buffered-input-port>} ready
If set, it must be a procedure that takes no arguments.
The procedure must return a true value if there are some data
readily available to read, or @code{#f} otherwise.
Unlike fully virtual ports, you don't need to distinguish
binary and character I/O.

If this slot is not set, the port is regarded as it always has data ready.
@end defivar

@defivar {<buffered-input-port>} close
If set, it must be a procedure that takes no arguments.
The procedure is called when the virtual buffered port is closed.
You don't need to set this slot unless you need some cleaning up
when the port is closed.

This procedure may be called from a finalizer, and
needs special care.  See the note on finalization below.
@end defivar

@defivar {<buffered-input-port>} filenum
If set, it must be a procedure that returns underlying
file descriptor number (exact nonnegative integer).
The procedure is called when @code{port-file-number} is called
on the port.

If there's no such underlying file descriptor, you can
return @code{#f}, or you can leave this slot unset.
@end defivar

@defivar {<buffered-input-port>} seek
If set, it must be a procedure that takes two arguments,
@var{offset} and @var{whence}.
It works the same way as @code{<virtual-input-port>}'s seek procedure;
see above.

This procedure may be called from a finalizer, and
needs special care.  See the note on finalization below.
@end defivar

Besides those slot values, you can pass an exact nonnegative integer
as the @code{:buffer-size} keyword argument to the @var{make} method
to set the size of the port's internal buffer.  If @code{:buffer-size}
is omitted, or zero is passed, the system's default buffer size
(something like 8K) is used.  @code{:buffer-size} is not an instance
slot and you cannot set it after the instance of the buffered port
is created.   The following example specifies the buffered port
to use a buffer of size 64K:

@example
(make <buffered-input-port> :buffer-size 65536 :fill my-filler)
@end example
@end deftp

@deftp {Class} <buffered-output-port>
@clindex buffered-output-port

An instance of this class behaves as an output port.
It has the following instance slots.
You have to set at least @code{flush} slot.

@defivar {<buffered-output-port>} flush
If set, it must be a procedure that takes two arguments,
an @code{u8vector} buffer and a flag.
The procedure must output data in the buffer to somewhere,
and returns the number of bytes actually output.

If the flag is false, the procedure may output less
than entire buffer (but at least one byte).  If the flag
is true, the procedure must output entire buffer.
@end defivar

@defivar {<buffered-output-port>} close
Same as @code{<buffered-input-port>}'s @code{close} slot.
@end defivar

@defivar {<buffered-output-port>} filenum
Same as @code{<buffered-input-port>}'s @code{filenum} slot.
@end defivar

@defivar {<buffered-output-port>} seek
Same as @code{<buffered-input-port>}'s @code{seek} slot.
@end defivar

Besides those slot values, you can pass an exact nonnegative integer
as the @code{:buffer-size} keyword argument to the @var{make} method
to set the size of the port's internal buffer.  See the description
of @code{<buffered-input-port>} above for the details.

@end deftp

@subsubheading Uniform vector ports

The following two procedures returns a buffered input/output port
backed up by a uniform vector.    The source or destination vector
can be any type of uniform vector, but they are aliased
to @code{u8vector} (see @code{uvector-alias} in
@ref{Uvector conversion operations}).

If used together with @code{pack}/@code{unpack} 
(see @ref{Packing Binary Data}), it is useful to parse
or construct binary data structure.  It is also an
example of using virtual ports; read @file{gauche/vport.scm}
(or @file{ext/vport/vport.scm} in the source tree) if you're
curious about the implementation.

@defun open-input-uvector uvector
Returns an input port that reads the content of the given
uniform vector @var{uvector} from its beginning.  If reading
operation reaches the end of @var{uvector}, EOF is returned.
Seek operation is also implemented.
@end defun

@defun open-output-uvector uvector
Returns an output port that fills the given uvector by the
data output to the port.  If @var{uvector} is completely
filled, more data are silently discarded.
Seek operation is also implemented.
@end defun

@subsubheading Note on finalization

If an unclosed virtual port is garbage collected, its close procedure
is called (in case of virtual buffered ports, its flush procedure
may also be called before close procedure).  It is done by
a finalizer of the port.  Since it is a part of garbage-collection
process (although the Scheme procedure itself is called outside of
the garbage collector main part), it requires special care.

@itemize @bullet
@item
It is possible that the object the virtual port has a reference
may already be finalized.  For example, if a virtual port @var{X} 
holds the only reference to a @emph{sink} port @var{Y}, to which
the output goes.  @var{X}'s @code{flush} procedure sends its output to
@var{Y}.  However, if @code{flush} procedure can be called from a
finalizer, it may be possible that @var{Y}'s finalizer has already been
called and @var{Y} is closed.   So @var{X}'s @code{flush} procedure
has to check if @var{Y} has not been closed.

@item
You cannot know when and in which thread the finalizer runs.  
So if the procedure like @code{close} or @code{flush} of virtual ports
need to lock or access the global resource, it needs to take
extra care of avoiding dead lock or conflict of access.

Even in single thread programs, the finalizer can run anywhere
in Scheme programs, so effectively it should be considered as
running in a different thread.
@end itemize
@node Library modules - SRFIs, Library modules - Utilities, Library modules - Gauche extensions, Top
@chapter Library modules - SRFIs
@c NODE ライブラリモジュール - SRFI

This chapter lists modules that provides SRFI functionalities.
Note that some of SRFI features are built in Gauche core and
not listed here.  @xref{Standard conformance}, for entire list
of supported SRFIs.

@c ----------------------------------------------------------------------
@menu
* Feature conditional::         srfi-0
* List library::                srfi-1
* Homogeneous vectors::         srfi-4
* A compatible let form with signatures and rest arguments::  srfi-5
* Feature-based program configuration language::  srfi-7
* Record types::                srfi-9
* Let-values::                  srfi-11
* String library::              srfi-13
* Character-set library::       srfi-14
* Time data types and procedures::  srfi-19
* Sources of random bits::      srfi-27
* Localization::                srfi-29
* A program argument processor::  srfi-37
* Eager comprehensions::        srfi-42
* Vector library::              srfi-43
* Requiring extensions::        srfi-55
@end menu

@node Feature conditional, List library, Library modules - SRFIs, Library modules - SRFIs
@section @code{srfi-0} - Feature conditional
@c NODE 機能条件式, @code{srfi-0} - 機能条件式

@deftp {Module} srfi-0
@mdindex srfi-0
Provides SRFI-0 @code{cond-expand} macro form.
Now this module is autoloaded when @code{cond-expand} is used,
so you don't need to say @code{(use srfi-0)} explicitly.
Portable programs can't use 'use' form anyway.
@end deftp

@defmac cond-expand (feature-requirement command-or-definition @dots{}) @dots{}
[SRFI-0]
This macro expands to @var{command-or-definition} @dots{} if Gauche
supports @var{feature-requirement}.
In a way, it can be used to absorb the different feature sets supported by
different Scheme implementations.

@var{feature-requirement} must be in the following syntax:
@example
@var{feature-requirement}
  : @var{feature-identifier}
  | (and @var{feature-requirement} @dots{})
  | (or  @var{feature-requirement} @dots{})
  | (not @var{feature-requirement})
@end example

@var{feature-identifier} is a symbol that indicates a feature.
If such a feature is supported in Gauche, it satisfies the
@var{feature-requirement}.  You can do boolean combination
of @var{feature-requirement}s to compose more complex conditions.

The macro tests each @var{feature-requirement} in order, and
if one is satisfied, the macro itself expands to the
corresponding @var{command-or-definition} @dots{}.

The last clause may begin with a symbol @code{else} instead of
@var{feature-requirement}.  If no condition is fulfilled before
it, then the macro expands to the @var{command-or-definition}s
of the else clause.  If there's no else clause and no condition
is fulfilled, an error is signalled.

Currently, Gauche recognizes srfi names (e.g. @code{srfi-1})
that it supports (@xref{Standard conformance}, for the list of
supported SRFIs), and a symbol @code{gauche} as @var{feature-identifier}.

Suppose you are writing a program that requires srfi-13 (string library).
In Gauche, the standard way to use srfi-13 is like this:

@example
(use srfi-13)

;; ... your program ...
@end example

However, the 'use' macro is Gauche specific and won't work
on other Scheme implementations.  You can write instead:

@example
(cond-expand
  (srfi-13
    ;; ... your program ...
  ))
@end example

If the implementation supports @code{srfi-13}, the form expands
to your program.  Note that Gauche issues @code{(use srfi-13)}
for you in this case.

The above form signals an error if the implementation doesn't support
srfi-13.  However, you might want to run your program on such implementations
as well, by providing alternative library definitions.

@example
(cond-expand
 (srfi-13
   ;; ... your program ...
 )
 (else
   (load "my-srfi-13-implementation")
   ;; ... your program ...
 ))
@end example
@end defmac

@c ----------------------------------------------------------------------
@node List library, Homogeneous vectors, Feature conditional, Library modules - SRFIs
@section @code{srfi-1} - List library

@deftp {Module} srfi-1
@mdindex srfi-1
SRFI-1 is a rich collection of list manipulation library
(@ref{srfi-1,[SRFI-1],SRFI-1}).
It is available by saying @code{(use srfi-1)}.
The implementation is based on Olin Shivers's reference implementation.
@end deftp

@menu
* SRFI-1 List constructors::    
* SRFI-1 List predicates::      
* SRFI-1 List selectors::       
* SRFI-1 List miscellaneous routines::  
* SRFI-1 Fold::                 
* SRFI-1 Filtering & Partitioning::  
* SRFI-1 Searching::            
* SRFI-1 Deletion::             
* SRFI-1 Association lists::    
* SRFI-1 Set operations::       
@end menu

@node SRFI-1 List constructors, SRFI-1 List predicates, List library, List library
@subsection List constructors
@c NODE SRFI-1 リスト構築子, リストの構築子

@defun xcons cd ca
[SRFI-1] Equivalent to @code{(cons ca cd)}.  Useful to pass to
higher-order procedures.
@end defun

@defun cons* elt1 elt2 @dots{}
[SRFI-1] Like @code{list}, but the last argument provides the tail of
the constructed list.  This is just a synonym of Gauche built-in procedure
@code{list*}.
@example
(cons* 1 2 3 4) @result{} (1 2 3 . 4)
(cons* 1) @result{} 1
@end example
@end defun

@defun list-tabulate n init-proc
[SRFI-1] Constructs an @var{n}-element list, in which
each element is generated by @code{(@var{init-proc} @i{i})}.
@example
(list-tabulate 4 values) @result{} (0 1 2 3)
@end example
@end defun

@defun circular-list elt1 elt2 @dots{}
[SRFI-1] Constructs a circular list of the elements.
@example
(circular-list 'z 'q) @result{} (z q z q z q @dots{})
@end example
@end defun

@defun iota count &optional (start 0) (step 1)
[SRFI-1] Returns a list of numbers, starting from @var{start},
increasing by @var{step}.
@example
(iota 5) @result{} (0 1 2 3 4)
(iota 5 0 -0.1) @result{} (0 -0.1 -0.2 -0.3 -0.4)
@end example
@end defun

@node SRFI-1 List predicates, SRFI-1 List selectors, SRFI-1 List constructors, List library
@subsection List predicates
@c NODE SRFI-1 リストの述語, リストの述語

@defun proper-list? x
[SRFI-1] Returns @code{#t} if x is a proper list.
@end defun

@defun circular-list? x
[SRFI-1] Returns @code{#t} if x is a circular list.
@end defun

@defun dotted-list? x
[SRFI-1] Returns @code{#t} if x is a finite, non-nil-terminated list.
This includes non-pair, non-() values (e.g. symbols, numbers),
which are considered to be dotted lists of length 0.
@end defun

@defun null-list? list
[SRFI-1] Returns @code{#t} if @var{list} is the empty list @code{()},
and @var{#f} otherwise.
@end defun

@defun not-pair? x
[SRFI-1] @code{(lambda (x) (not (pair? x)))}.

SRFI-1 says: Provided as a procedure as it can be useful as
the termination condition for list-processing procedures that wish to
handle all finite lists, both proper and dotted. 
@end defun

@defun list= elt= list @dots{}
[SRFI-1] Determines list equality by comparing every n-th element
of given lists by the procedure @var{elt=}.

It is an error to apply @code{list=} to anything except proper lists.

The equality procedure must be consistent with @code{eq?}, i.e.
@example
(eq? x y) @result{} (elt= x y).
@end example
@end defun

@node SRFI-1 List selectors, SRFI-1 List miscellaneous routines, SRFI-1 List predicates, List library
@subsection List selectors
@c NODE SRFI-1 リスト選択子, リスト選択子

@defun  first pair
@defunx second pair
@defunx third pair
@defunx fourth pair
@defunx fifth pair
@defunx sixth pair
@defunx seventh pair
@defunx eighth pair
@defunx ninth pair
@defunx tenth pair
[SRFI-1] Returns n-th element of the (maybe improper) list.
@end defun

@defun car+cdr pair
[SRFI-1] Returns two values, @code{(car pair)} and @code{(cdr pair)}.
@end defun

@defun take x i
@defunx drop x i
[SRFI-1] @code{take} returns the first i elements of list x.
@code{drop} returns all but the first i elements of list x. 
@example
(take '(a b c d e)  2) => (a b)
(drop '(a b c d e)  2) => (c d e)
@end example
@var{x} may be any value:
@example
(take '(1 2 3 . d) 2) => (1 2)
(drop '(1 2 3 . d) 2) => (3 . d)
(drop '(1 2 3 . d) 3) => d
@end example
@code{drop} is exactly equivalent to performing @var{i} cdr operations
on @var{x}.  The returned value shares a common tail with @var{x}.
On the other hand, take always allocates a new list 
for result if the argument is a list of non-zero length.

An error is signalled if @var{i} is past the end of list @var{x}.
@xref{Additional list library}, for more tolerant version
of @code{take} and @code{drop}.

For generic subsequence extraction from any sequence, see @code{subseq}
in @ref{Slicing sequence}.
@end defun

@defun take-right flist i
@defunx drop-right flist i
[SRFI-1] @code{take-right} returns the last @var{i} elements of @var{flist}.
@code{drop-right} returns all but the last @var{i} elements of @var{flist}. 
@example
(take-right '(a b c d e) 2) => (d e)
(drop-right '(a b c d e) 2) => (a b c)
@end example
@var{flist} may be any finite list.
@example
(take-right '(1 2 3 . d) 2) => (2 3 . d)
(drop-right '(1 2 3 . d) 2) => (1)
(take-right '(1 2 3 . d) 0) => d
(drop-right '(1 2 3 . d) 0) => (1 2 3)
@end example
@code{take-right}'s return value always shares a common
tail with @var{flist}.
@code{drop-right} always allocates a new list
if the argument is a list of non-zero length.

An error is signalled if @var{i} is larger than the length of @var{flist}.
@xref{Additional list library}, for more tolerant version
of @code{take-right} and @code{drop-right}.
@end defun

@defun take! x i
@defunx drop-right! x i
[SRFI-1]  Linear update variants of @var{take} and @var{drop-right}.
Those procedures may destructively modifies @var{x}.

If @var{x} is circular, @code{take!} may return a list
shorter than expected.
@end defun

@defun split-at x i
@defunx split-at! x i
[SRFI-1] @code{split-at} splits the list @var{x} at index @var{i},
returning a list of the first @var{i} elements, and the remaining tail.
@example
(split-at '(a b c d e) 2) @result{} (a b) (c d e)
@end example
@code{split-at!} is the linear-update variant. It may destructively
modifies @var{x} to produce the result. 
@end defun

@defun last pair
[SRFI-1] Returns the last element of the non-empty, finite list @var{pair}.
It is equivalent to @code{(car (last-pair pair))}.
Note that @code{last-pair} is Gauche built-in procedure.
@end defun

@node SRFI-1 List miscellaneous routines, SRFI-1 Fold, SRFI-1 List selectors, List library
@subsection List miscellaneous routines
@c NODE 種々のリスト処理ルーチン

@defun length+ x
@ EN
[SRFI-1] If @var{x} is a proper list, returns its length.
Otherwise, returns @code{#f}.
@end defun

@defun concatenate list-of-lists
@defunx concatenate! list-of-lists!
[SRFI-1] Equivalent to @code{(apply append @var{list-of-lists})} and
@code{(apply append! @var{list-of-lists})}, respectively.
@end defun

@defun append-reverse rev-head tail
@defunx append-reverse! rev-head tail
[SRFI-1] @code{append-reverse} returns @code{(append (reverse rev-head) tail)}.
@code{append-reverse!} is the linear-update variant.
@end defun

@defun zip clist1 clist2 @dots{}
[SRFI-1] Equivalent to @code{(map list clist1 clist2 @dots{})}.
If @code{zip} is passed @var{n} lists, it returns a list as long as
the shortest of these lists, each element of which is an @var{n}-element list
comprised of the corresponding elements from the parameter lists. 
@example
(zip '(one two three) 
     '(1 2 3)
     '(odd even odd even odd even odd even))
     @result{} ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3)) @result{} ((1) (2) (3))
@end example
At least one of the argument lists must be finite: 
@example
(zip '(3 1 4 1) (circular-list #f #t)) 
     @result{} ((3 #f) (1 #t) (4 #f) (1 #t))
@end example
@end defun

@defun unzip1 list
@defunx unzip2 list
@defunx unzip3 list
@defunx unzip4 list
@defunx unzip5 list
[SRFI-1] @code{unzip1} takes a list of lists, where every list must
contain at least one element, and returns a list containing the
initial element of each such list.
@code{unzip2} takes a list of lists, where every list
must contain at least two elements, and returns two values:
a list of the first elements, and a list of the second
elements. @code{unzip3} does the same for the first
three elements of the lists, and so on.
@example
(unzip2 '((1 one) (2 two) (3 three))) @result{}
   (1 2 3) @r{and}
   (one two three)
@end example
@end defun

@defun count pred clist1 clist2 @dots{}
[SRFI-1] A procedure @var{pred} is applied to the @var{n}-th element
of given lists, from @var{n} is zero to the length of the
the shortest finite list in the given lists,
and the count of times @var{pred} returned true is returned.
@example
(count even? '(3 1 4 1 5 9 2 5 6)) @result{} 3
(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) @result{} 3
@end example
At least one of the argument lists must be finite: 
@example
(count < '(3 1 4 1) (circular-list 1 10)) @result{} 2
@end example
@end defun

@node SRFI-1 Fold, SRFI-1 Filtering & Partitioning, SRFI-1 List miscellaneous routines, List library
@subsection List fold, unfold & map
@c NODE リストの畳み込み(fold)、解きほぐし(unfold)、および写像(map)

@defun fold kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list iterator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{en} @dots{} (@var{kons} @var{e2} (@var{kons} @var{e1} @var{knil})) @dots{} ) 
@end example

If @var{n} list arguments are provided, then the @var{kons}
function must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples:
@example
(fold + 0 '(3 1 4 1 5 9)) @result{} 23 ;@r{sum up the elements}
(fold cons '() '(a b c d e)) @result{} (e d c b a) ;@r{reverse}
(fold cons* '() '(a b c) '(1 2 3 4 5))
    @result{} (c 3 b 2 a 1) ;@r{n-ary case}
@end example
@end defun

@defun fold-right kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list recursion operator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{e1} (@var{kons} @var{e2} @dots{} (@var{kons} @var{en} @var{knil})))
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples: 
@example
(fold-right cons '() '(a b c d e))
   @result{} (a b c d e) ;@r{copy list}
(fold-right cons* '() '(a b c) '(1 2 3 4 5))
   @result{} (a 1 b 2 c 3) ;@r{n-ary case}
@end example
@end defun

@defun pair-fold kons knil clist1 clist2 @dots{}
@defunx pair-fold-right kons knil clist1 clist2 @dots{}
[SRFI-1] 
Like @code{fold} and @code{fold-right}, but the procedure @var{kons}
gets each @code{cdr} of the given @var{clist}s, instead of @code{car}.
@end defun

@defun reduce f ridentity list
@defunx reduce-right f ridentity list
[SRFI-1]
Variant of @code{fold} and @code{fold-right}.   @var{f} must be a
binary operator, and @var{ridentity} is the value such that for
any value @var{x} that is valid as @var{f}'s input,
@example
 (f x ridentity) @equiv{} x
@end example

These functions effectively do the same thing as @code{fold} or
@code{fold-right}, respectively, but omit the first 
application of @var{f} to @var{ridentity}, using the above nature.
So @var{ridentity} is used only when @var{list} is empty.
@end defun

@defun unfold p f g seed &optional tail-gen
[SRFI-1]
Fundamental recursive list constructor.
Defined by the following recursion.

@example
(unfold p f g seed tail-gen) @equiv{}
   (if (p seed)
       (tail-gen seed)
       (cons (f seed)
             (unfold p f g (g seed))))
@end example
That is, @var{p} determines where to stop, @var{g} is used to generate
successive seed value from the current seed value, and @var{f} is used
to map each seed value to a list element.
@end defun

@defun unfold-right p f g seed &optional tail
[SRFI-1]
Fundamental iterative list constructor.
Defined by the following recursion.

@example
(unfold-right p f g seed tail) @equiv{}
  (let lp ((seed seed) (lis tail))
    (if (p seed)
        lis
        (lp (g seed) (cons (f seed) lis))))
@end example
@end defun

@defun append-map f clist1 clist2 @dots{}
@defunx append-map! f clist1 clist2 @dots{}
[SRFI-1]
Equivalent to

@example
  (apply append (map @var{f} @var{clist1} @var{clist2} @dots{}))
  (apply append! (map @var{f} @var{clist1} @var{clist2} @dots{}))
@end example
At least one of the list arguments must be finite. 
@end defun

@defun map! f clist1 clist2 @dots{}
[SRFI-1]
The procedure @var{f} is applied to each element of @var{clist1} and
corresponding elements of @var{clist2}s, and the result is collected
to a list.  Cells in @var{clist1} is reused to construct the result list.
@end defun

@defun map-in-order f clist1 clist2 @dots{}
[SRFI-1] A variant of @code{map}, but it guarantees to apply @var{f}
on each elements of arguments in a left-to-right order.
Since Gauche's @code{map} implementation follows the same order,
this function is just a synonym of @code{map}.
@end defun

@defun pair-for-each f clist1 clist2 @dots{}
[SRFI-1]
Like @code{for-each}, but the procedure @var{f} is applied on each @code{cdr}
of @var{clist}s.
@end defun

@defun filter-map  f clist1 clist2 @dots{}
[SRFI-1]
Like @code{map}, but only true values are saved.
At least one of the list arguments must be finite. 
@example
(filter-map (lambda (x) (and (number? x) (* x x)))
            '(a 1 b 3 c 7))
  @result{} (1 9 49)
@end example
@end defun

@node SRFI-1 Filtering & Partitioning, SRFI-1 Searching, SRFI-1 Fold, List library
@subsection List filtering & partitioning
@c NODE リストのフィルタおよび分割

@defun filter pred list
@defunx filter! pred list
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned true on it is returned.
@example
(filter odd? '(3 1 4 5 9 2 6)) @result{} (3 1 5 9)
@end example
@code{filter!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun remove pred list
@defunx remove! pred list
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned false on it is returned.
@example
(remove odd? '(3 1 4 5 9 2 6)) @result{} (4 2 6)
@end example
@code{remove!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun partition pred list
@defunx partition! pred list
[SRFI-1] @code{filter} and @code{remove} simultaneously, i.e. 
returns two lists, the first is the result of filtering elements of
@var{list} by @var{pred}, and the second is the result of
removing elements of @var{list} by @var{pred}.
@example
(partition odd? '(3 1 4 5 9 2 6))
  @result{} (3 1 5 9) (4 2 6)
@end example
@code{partition!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@node SRFI-1 Searching, SRFI-1 Deletion, SRFI-1 Filtering & Partitioning, List library
@subsection List searching
@c NODE リストの探索

@defun find pred clist
[SRFI-1] Applies @var{pred} for each element of @var{clist}, from 
left to right, and returns the first element that @var{pred} returns
true on.  If no element satisfies @var{pred}, @code{#f} is returned.
@end defun

@defun find-tail pred clist
[SRFI-1]
Applies @var{pred} for each element of @var{clist}, from left to right,
and when @var{pred} returns a true value, returns the pair whose car
is the element.  If no element satisfies @var{pred}, @code{#f} is returned.
@end defun

@defun take-while pred clist
@defunx take-while! pred list
[SRFI-1]
Returns the longest initial prefix of @var{clist} whose elements all
satisfy @var{pred}.
@end defun

@defun drop-while pred clist
[SRFI-1]
Drops the longest initial prefix of @var{clist} whose elements all
satisfy @var{pred}, and returns the rest.
@end defun

@defun span pred clist
@defunx span! pred list
@defunx break pred clist
@defunx break! pred list
[SRFI-1]
@code{span} is equivalent to
@code{(values (take-while pred clist) (drop-while pred clist))}.
@code{break} inverts the sense of @var{pred}.
@end defun

@defun any pred clist1 clist2 @dots{}
[SRFI-1]
Applies @var{pred} across each element of @var{clist}s, and
returns as soon as @var{pred} returns a non-false value.
The return value of @code{any} is the non-false value @var{pred} returned.
If @var{clist}s are exhausted before @var{pred} returns a non-false
value, @code{#f} is returned.
@end defun

@defun every pred clist1 clist2 @dots{}
[SRFI-1]
Applies @var{pred} across each element of @var{clist}s, and
returns @code{#f} as soon as @var{pred} returns @code{#f}.
If all application of @var{pred} return a non-false value, 
@code{every} returns the last result of the applications.
@end defun

@defun list-index pred clist1 clist2 @dots{}
[SRFI-1]
Returns the index of the leftmost element that satisfies @var{pred}.
If no element satisfies @var{pred}, @code{#f} is returned.
@end defun

@node SRFI-1 Deletion, SRFI-1 Association lists, SRFI-1 Searching, List library
@subsection List deletion
@c NODE リストの削除

@defun delete x list &optional elt=
@defunx delete! x list &optional elt=
[SRFI-1]
Equivalent to
@example
  (remove (lambda (y) (elt= x y)) list)
  (remove! (lambda (y) (elt= x y)) list)
@end example
The comparison procedure, @var{elt=}, defaults to @code{equal?}.
@end defun

@defun delete-duplicates list &optional elt=
@defunx delete-duplicates! list &optional elt=
[SRFI-1]
Removes duplicate elements from @var{list}.
If there are multiple equal elements in @var{list},
the result list only contains the first or leftmost of these
elements in the result. The order of these surviving elements
is the same as in the original list.
The comparison procedure, @var{elt=}, defaults to @code{equal?}.
@end defun

@node SRFI-1 Association lists, SRFI-1 Set operations, SRFI-1 Deletion, List library
@subsection Association lists
@c NODE 連想リスト

@defun alist-cons key datum alist
[SRFI-1] Returns @code{(cons (cons @var{key} @var{datum}) @var{alist})}.
This is an alias of the Gauche builtin procedure @code{acons}.
@end defun

@defun alist-copy alist
[SRFI-1] Returns a fresh copy of @var{alist}.
The spine of @var{alist} and each cell that points a key and a value
is copied.
@example
(define a (list (cons 'a 'b) (cons 'c 'd)))
a @result{} ((a . b) (c . d))

(define b (alist-copy a))
b @result{} ((a . b) (c . d))

(set-cdr! (car a) 'z)
a @result{} ((a . z) (c . d))
b @result{} ((a . b) (c . d))
@end example
@end defun

@defun alist-delete key alist &optional =
@defunx alist-delete! key alist &optional =
[SRFI-1]
Deletes all cells in @var{alist} whose key is the same as @var{key}.
Comparison is done by a procedure @var{=}.  The default is @code{eqv?}.

The linear-update version @code{alist-delete!} may or may not modify
@var{alist}.
@end defun

@node SRFI-1 Set operations,  , SRFI-1 Association lists, List library
@subsection Lists as sets
@c NODE 集合としてのリスト

These procedures use a list as a set, that is,
the elements in a list matter, but their order doesn't.

All procedures in this category takes a comparison procedure
@var{elt=}, as the first argument, which is used to determine
two elements in the given sets are the same.

See also @ref{Combination library}, which
concerns combinations of elements in the set.

@defun lset<= elt= list1 @dots{}
[SRFI-1]
Returns @code{#t} iff all elements in @var{list1} are also included
in @var{list2}, and so on.
If no lists are given, or a single list is given,
@code{#t} is returned.
@end defun

@defun lset= elt= list1 list2 @dots{}
[SRFI-1]
Returns @code{#t} if all elements in @var{list1} are in @var{list2},
and all elements in @var{list2} are in @var{list1}, and so on.

@example
(lset= eq? '(b e a) '(a e b) '(e e b a)) @result{} #t
@end example
@end defun

@defun lset-adjoin elt= list elt @dots{}
[SRFI-1]
Adds @var{elt} @dots{} to the set @var{list}, if each one is not
already a member of @var{list}.  (The order doesn't matter).

@example
(lset-adjoin eq? '(a b c) 'a 'e) @result{} '(e a b c)
@end example
@end defun

@defun lset-union elt= list1 @dots{}
[SRFI-1]
Returns the union of the sets @var{list1} @dots{}.
@end defun

@defun lset-intersection elt= list1 list2 @dots{}
[SRFI-1]
Returns a set of elements that are in every @var{list}s.
@end defun

@defun lset-difference elt= list1 list2 @dots{}
[SRFI-1]
Returns a set of elements that are in @var{list1} but not
in @var{list2}.  In n-ary case, binary differece operation is
simply folded.
@end defun

@defun lset-xor elt= list1 @dots{}
[SRFI-1]
Returns the exclusive-or of given sets; that is, the returned
set consists of the elements that are in either @var{list1} or @var{list2},
but not in both.   In n-ary case, binary xor operation is simply folded.
@end defun

@defun lset-diff+intersection elt= list1 list2 @dots{}
[SRFI-1]
Returns two sets, a difference and an intersection of given sets.
@end defun

@defun lset-union! elt= list @dots{}
@defunx lset-intersection! elt= list1 list2 @dots{}
@defunx lset-difference! elt= list1 list2 @dots{}
@defunx lset-xor! elt= list1 @dots{}
@defunx lset-diff+intersection! elt= list1 list2 @dots{}
[SRFI-1]
Linear update variant of the corresponding procedures.
The cells in the first list argument may be reused to construct the result.
@end defun

@c ----------------------------------------------------------------------
@node Homogeneous vectors, A compatible let form with signatures and rest arguments, List library, Library modules - SRFIs
@section @code{srfi-4} - Homogeneous vectors
@c NODE 単一型のベクタ, @code{srfi-4} - 単一型のベクタ

@deftp {Module} srfi-4
@mdindex srfi-4
SRFI-4 is now implemented in @code{gauche.uvector} module
@xref{Uniform vectors}.
This module simply inherits @code{gauche.uvector} for backward-compatibility.
@end deftp

@c ----------------------------------------------------------------------
@node A compatible let form with signatures and rest arguments, Feature-based program configuration language, Homogeneous vectors, Library modules - SRFIs
@section @code{srfi-5} - A compatible let form with signatures and rest arguments
@c NODE シグネチャとrest引数に互換性のあるlet形式, @code{srfi-5} - シグネチャとrest引数に互換性のあるlet形式

@deftp {Module} srfi-5
@mdindex srfi-5
This module provides srfi-5's extended @code{let} syntax.
@end deftp

@defmac let ((var val) @dots{} [. (rest val @dots{})]) body @dots{}
@defmacx let name ((var val) @dots{} [. (rest val @dots{})]) body @dots{}
@defmacx let (name (var val) @dots{} [. (rest val @dots{})]) body @dots{}
[SRFI-5]
The @code{let} syntax is extended in two ways.

@itemize @bullet
@item 
The extended @code{let} syntax accepts the @var{name} identifier (for
named let syntax) within the list of bindings (as in the third
syntax above).
@item
The extended @code{let} syntax accepts the rest parameter binding
which works like the rest paremter in the @code{lambda} syntax.
@end itemize

See SRFI-5 document for rationale of this extension.
@end defmac

@c ----------------------------------------------------------------------
@node Feature-based program configuration language, Record types, A compatible let form with signatures and rest arguments, Library modules - SRFIs
@section @code{srfi-7} - Feature-based program configuration language
@c NODE 機能ベースプログラム設定言語, @code{srfi-7} - 機能ベースプログラム設定言語

@deftp {Module} srfi-7
@mdindex srfi-7
This module provides a program configuration metalanguage
(@code{program} form) defined in srfi-7.
Gauche autoloads srfi-7 module, so you don't need
to say @code{(use srfi-7)} explicitly.
Note that the @code{program} form isn't necessary to be a
Scheme expression.  Srfi-7 allows an implementation to preprocess
the @code{program} form to produce a Scheme program, then
executes it with different means.
Gauche implements @code{program} form as a macro, so it can
evaluates the form directly.  Nonetheless, it doesn't make sense
to mix @code{program} form and other forms in one file,
or expecting a return value of @code{program} form.
A typical usage of @code{program} form is to prepare a single
file which just contains @code{program} form.  (It can load
other files using @code{files} clause (see below) within the
@code{program} form.)   To execute such a program file in Gauche,
you can just load it.
@end deftp

@deffn {Configuration Language} program program-clause program-clause2 @dots{}
[SRFI-7] 
This is a configuration language to structure a Scheme program,
based on availability of the features.

A Scheme program is constructed from the @code{program} form.
Gauche evaluates the constructed Scheme program on-the-fly.

Each @var{program-clause} needs to be one of the "Program Clauses" below.
@end deffn

@deffn {Program Clause} requires feature-id feature-id2 @dots{}
[SRFI-7] 
The @var{feature-id}'s are the same as @code{srfi-0}'s
(@xref{Feature conditional}).
It tells that the following code requires these @var{feature-id}'s.

If a feature-id which is not supported in Gauche is given,
an error is signaled.
@end deffn

@deffn {Program Clause} files filename @dots{}
[SRFI-7] 
Inserts the content of the @var{filename}s into a program.
In Gauche, this clause just causes @var{filename}s to be loaded
into the current module.
@end deffn

@deffn {Program Clause} code scheme-expression @dots{}
[SRFI-7] 
The @var{scheme-expression}s are inserted into a program.
@end deffn

@deffn {Program Clause} feature-cond clause clause2 @dots{}
[SRFI-7] 
@var{Clause} is a following form:
@example
(@var{requirement} @var{program-clause} @var{program-clause2} @dots{})
@end example

Where @var{requirement} should be one of the following:
@itemize @bullet
@item
@var{feature-id}
@item
@code{(and @var{requirement} @dots{})}
@item
@code{(or @var{requirement} @dots{})}
@item
@code{(not @var{requirement})}
@end itemize

The @var{requirement} of the last @var{clause} may be @code{else}.

Gauche checks each @var{requirement} one by one, and if it finds
a fulfilled @var{requirement}, inserts the @var{program-clause}s
in that @var{clause} into the program.
@end deffn

@c ----------------------------------------------------------------------
@node Record types, Let-values, Feature-based program configuration language, Library modules - SRFIs
@section @code{srfi-9} - Record types
@c NODE レコード型, @code{srfi-9} - レコード型

@deftp {Module} srfi-9
@mdindex srfi-9
Contains a macro to use record types.  A record type is implemented on
top of Gauche's object system.

The SRFI-9 record type is not as powerful as the object system, but
it will be useful if you want your program to be portable.

See also @ref{SLIB-compatible record type},
which provides an SCM-compatible
procedural interface of record types.
@end deftp

@defmac define-record-type name (constructor init-tag @dots{}) predicate (field accessor [modifier]) @dots{}
Creates a record type and binds it to @var{name}.
In Gauche, a record type is just a subclass of @code{<record>}.

@var{constructor} is bound to a procedure that creates an instance
of the record type,
which takes as many arguments as @var{init-tag} @dots{}.  Each
@var{init-tag} corresponds to one of the field name, and the fields
of the created record instance is initialized accordingly.  Not all
of fields need to appear in @var{init-tag}; uninitialized fields remain
unbound.

@var{predicate} is bound to a procedure that takes one argument, and
returns #t if the argument is an instance of the defined record type,
#f otherwise.

Followings are field specifications.  The record has fields
@var{field} @dots{}, and each field can be accessed by a method
@var{accessor}.  If @var{modifier} is given to the field, it is bound
to a method that sets the value to the field.

Example:
@example
(define-record-type pare
  (kons x y) pare?
  (x kar set-kar!)
  (y kdr))
 @result{} #<class pare>

(pare? (kons 2 3)) @result{} #t
(pare? (cons 2 3)) @result{} #f

(kar (kons 2 3)) @result{} 2
(kdr (kons 2 3)) @result{} 3

(let ((x (kons 2 3)))
  (set-kar! x -1)
  (kar x)) @result{} -1
@end example

Conceptually, the above example is expanded into the following
sequence of forms.
@example
(define-class pare (<record>) (x y))
(define (kons x y)
  (let ((obj (make pare)))
    (slot-set! obj 'x x) 
    (slot-set! obj 'y y)
    obj))
(define (pare? obj) (is-a? obj pare))
(define-method kar ((obj pare))
  (slot-ref obj 'x))
(define-method set-kar! ((obj pare) value)
  (slot-set! obj 'x value))
(define-method kdr ((obj pare))
  (slot-ref obj 'y))
@end example

@end defmac

@c ----------------------------------------------------------------------
@node Let-values, String library, Record types, Library modules - SRFIs
@section @code{srfi-11} - Let-values

@deftp {Module} srfi-11
@mdindex srfi-11
Defines two macros, @code{let-values} and @code{let*-values}.
They are convenient to use with multiple values (@ref{srfi-11,,[SRFI-11]}).

@end deftp

@defmac let-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
@var{vars} are a list of variables. @var{expr} is evaluated, and
its first return value is bound to the first variable in @var{vars},
its second return value to the second variable, and so on, then
@var{body} is evaluated.
The scope of @var{expr}s are the outside of @code{let-values} form,
like @code{let}.

@example
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d)) @result{} (1 2 3 4)

(let ((a 1) (b 2) (c 3) (d 4))
  (let-values (((a b) (values c d))
               ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 1 2)
@end example

@var{vars} can be a dotted list or a single symbol, like the
lambda parameters.

@example
(let-values (((x . y) (values 1 2 3 4)))
  y) @result{} (2 3 4)

(let-values ((x (values 1 2 3 4)))
  x) @result{} (1 2 3 4)
@end example

If the number of values returned by @var{expr} doesn't match
what @var{vars} expects, an error is signalled.
@end defmac

@defmac let*-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
Same as @code{let-values}, but each @var{expr}'s scope includes
the preceding @var{vars}.

@example
(let ((a 1) (b 2) (c 3) (d 4))
  (let*-values (((a b) (values c d))
                ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 3 4)
@end example
@end defmac

@c ----------------------------------------------------------------------
@node String library, Character-set library, Let-values, Library modules - SRFIs
@section @code{srfi-13} - String library
@c NODE 文字列ライブラリ, @code{srfi-13} - 文字列ライブラリ

@deftp {Module} srfi-13
@mdindex srfi-13
Defines a large set of string-related functions.
In Gauche, those functions are splitted to number of files
and the form @code{(use srfi-13)} merely sets up autoloading of
those files.  So it is not likely to slow down the script startup.
See SRFI-13 (@ref{srfi-13, [SRFI-13], SRFI-13})
for the detailed specification and discussion of design issues.
This manual serves as a reference of function API.
Some SRFI-13 functions are Gauche built-in and not listed here.
Note: SRFI-13 documents suggests the name of the module that
implements these functions to be ``string-lib'' and ``string-lib-internals''.
Gauche uses the name ``srfi-13'' for consistency.
@end deftp

@menu
* SRFI-13 General conventions::  
* SRFI-13 String predicates::   
* SRFI-13 String Constructors::  
* SRFI-13 String Selection::    
* SRFI-13 String Comparison::   
* SRFI-13 String Prefixes & Suffixes::  
* SRFI-13 String searching::    
* SRFI-13 String case mapping::  
* SRFI-13 String reverse & append::  
* SRFI-13 String mapping::      
* SRFI-13 String rotation::     
* SRFI-13 other string operations::  
* SRFI-13 String filtering::    
* SRFI-13 Low-level string procedures::  
@end menu

@node SRFI-13 General conventions, SRFI-13 String predicates, String library, String library
@subsection General conventions
@c NODE 一般規約

There are a few common factors in string library API, which I don't
repeat in each function description

@table @emph
@item argument convention
The following argument names imply their types.
@table @var
@item s, s1, s2
Those arguments must be strings.
@item char/char-set/pred
This argument can be a character, a character-set object,
or a predicate that takes a single character and returns a boolean value.
``Applying @var{char/char-set/pred} to a character'' means,
if @var{char/char-set/pred} is a character, it is compared to the given
character; if @var{char/char-set/pred} is a character set, it is
checked if the character set contains the given character; if
@var{char/char-set/pred} is a procedure, it is applied
to the given character.  ``A character satisfies @var{char/char-set/pred}''
means such application to the character yields true value.

@item start, end
Lots of SRFI-13 functions takes these two optional arguments, which
limit the area of input string from @var{start}-th character
(inclusive) to @var{end}-th character (exclusive),
where the operation is performed.
When specified, the condition
0 <= @var{start} <= @var{end} <= @var{length of the string} must be
satisfied.  Default value of @var{start} and @var{end} is
0 and the length of the string, respectively.
@end table

@item `shared' variant
Some functions have variants with ``/shared'' attached to its name.
SRFI-13 defines those functions to allow to share the part of input
string, for better performance.  Gauche doesn't have a concept of
shared string, and these functions are mere synonyms of their
non-shared variants.  However, Gauche @emph{internally} shares
the storage of strings, so generally you don't need to worry
about the overhead of copying substrings.

@item `right' variant
Most functions works from left to right of the input string.
Some functions have variants with ``-right'' to its name, 
that works from right to left.

@end table

@node SRFI-13 String predicates, SRFI-13 String Constructors, SRFI-13 General conventions, String library
@subsection String predicates
@c NODE 文字列についての述語

@defun string-null? s
[SRFI-13] Returns @code{#t} if @var{s} is an empty string, @code{""}.
@end defun

@defun string-every char/char-set/pred s &optional start end
[SRFI-13] Sees if every character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-every} returns
the value that is returned at the last application of @var{char/char-set/pred}.
If any of the application returns @code{#f}, @code{string-every}
returns @code{#f} immediately.
@end defun

@defun string-any char/char-set/pred s &optional start end
[SRFI-13] Sees if any character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-any} returns
the value that is returned by the application.   If no character
satisfies @var{char/char-set/pred}, @code{#f} is returned.
@end defun

@node SRFI-13 String Constructors, SRFI-13 String Selection, SRFI-13 String predicates, String library
@subsection String Constructors
@c NODE 文字列の構築子

@defun string-tabulate proc len
[SRFI-13] @var{proc} must be a procedure that takes an integer
argument and returns a character.  @code{string-tabulate}
creates a string, whose @var{i}-th character is calculated by
@code{(proc i)}.
@example
(string-tabulate
  (lambda (i) (integer->char (+ i #x30))) 10)
 @result{} "0123456789"
@end example

@end defun

@defun reverse-list->string char-list
[SRFI-13] @equiv{} @code{(list->string (reverse char-list))}.
@end defun

@node SRFI-13 String Selection, SRFI-13 String Comparison, SRFI-13 String Constructors, String library
@subsection String selection
@c NODE 文字列の選択

@defun substring/shared s start &optional end
[SRFI-13] In Gauche, this is the same as @code{substring}, except
that the @var{end} argument is optional.
@example
(substring/shared "abcde" 2) @result{} "cde"
@end example
@end defun

@defun string-copy! target tstart s &optional start end
[SRFI-13] Copies a string @var{s} into a string
@var{target} from the position @var{tstart}.
Optional @var{start} and @var{end} arguments limits the range of @var{s}.
If the copied string run over the end of @var{target}, an error is
signalled.
@example
(define s (string-copy "abcde"))
(string-copy! s 2 "ZZ")
s @result{} "abZZe"
@end example
@end defun

@defun string-take s nchars
@defunx string-drop s nchars
@defunx string-take-right s nchars
@defunx string-drop-right s nchars
[SRFI-13] Returns the first @var{nchars}-character string of @var{s}
(@code{string-take}) or the string without first @var{nchars}
(@code{string-drop}).  The @code{*-right} variation counts from
the end of string.  It is guaranteed that the returned string is
always a copy of @var{s}, even no character is dropped.
@example
(string-take "abcde" 2) @result{} "ab"
(string-drop "abcde" 2) @result{} "cde"

(string-take-right "abcde" 2) @result{} "de"
(string-drop-right "abcde" 2) @result{} "abc"
@end example
@end defun

@defun string-pad s len &optional char start end
@defunx string-pad-right s len &optional char start end
[SRFI-13]
If a string @var{s} is shorter than @var{len}, 
returns a string of @var{len} where @var{char} is
padded to the left or right, respectively.
If @var{s} is longer than @var{len}, the rightmost
or leftmost @var{len} chars are taken.
@var{Char} defaults to @code{#\space}.
If @var{start} and @var{end} are provided, 
the substring of @var{s} is used as the source.

@example
(string-pad "abc" 10)    @result{} "       abc"
(string-pad "abcdefg" 3) @result{} "efg"

(string-pad-right "abc" 10) @result{} "abc       "

(string-pad "abcdefg" 10 #\+ 2 5)
  @result{} "+++++++cde"
@end example
@end defun

@defun string-trim s &optional char/char-set/pred start end
@defunx string-trim-right s &optional char/char-set/pred start end
@defunx string-trim-both s &optional char/char-set/pred start end
[SRFI-13]
Removes characters that match @var{char/char-set/pred}
from @var{s}.  @code{String-trim} removes the characters from
left of @var{s}, @code{string-trim-right} does from right,
and @code{string-trim-both} does from both sides.
@var{Char/char-set/pred} defaults to @code{#[\s]}, i.e. a char-set
of whitespaces.
If @var{start} and @var{end} are provided, 
the substring of @var{s} is used as the source.

@example
(string-trim "   abc  ")       @result{} "abc  "
(string-trim-right "   abc  ") @result{} "   abc"
(string-trim-both "   abc  ")  @result{} "abc"
@end example
@end defun

@node SRFI-13 String Comparison, SRFI-13 String Prefixes & Suffixes, SRFI-13 String Selection, String library
@subsection String comparison
@c NODE 文字列の色々な比較

@defun string-compare s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
@defunx string-compare-ci s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string= s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-ci@code{=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-hash s &optional bound start end 
@defunx string-hash-ci s &optional bound start end 
[SRFI-13]
@end defun

@node SRFI-13 String Prefixes & Suffixes, SRFI-13 String searching, SRFI-13 String Comparison, String library
@subsection String Prefixes & Suffixes
@c NODE 文字列のプリフィックスとサフィックス

@defun string-prefix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-length-ci s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-prefix? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix? s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-ci? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-ci? s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@node SRFI-13 String searching, SRFI-13 String case mapping, SRFI-13 String Prefixes & Suffixes, String library
@subsection String searching
@c NODE 文字列の探索

@defun string-index s char/char-set/pred &optional start end
@defunx string-index-right s char/char-set/pred &optional start end
[SRFI-13] Looks for the first element in a string @var{s}
that matches @var{char/char-set/pred}, and returns its index.
If @var{char/char-set/pred} is not found in @var{s}, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@example
(string-index "Aloha oe" #\a) @result{} 4
(string-index "Aloha oe" #[Aa]) @result{} 0
(string-index "Aloha oe" #[\s]) @result{} 5
(string-index "Aloha oe" char-lower-case?) @result{} 1
(string-index "Aloha oe" #\o 3) @result{} 6
@end example

See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@end defun

@defun string-skip s char/char-set/pred &optional start end
@defunx string-skip-right s char/char-set/pred &optional start end
[SRFI-13] Looks for the first element that does not match
@var{char/char-set/pred} and returns its index.
If such element is not found, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@end defun

@defun string-count s char/char-set/pred &optional start end
[SRFI-13] Counts the number of elements in @var{s}
that matches @var{char/char-set/pred}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@end defun

@defun string-contains s1 s2 &optional start1 end1 start2 end2
@defunx string-contains-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13] Looks for a string @var{s2} inside another string @var{s1}.
If found, returns an index in @var{s1} from where the matching string
begins.  Returns @code{#f} otherwise.
Optional @var{start1}, @var{end1}, @var{start2} and @var{end2}
limits the range of @var{s1} and @var{s2}.

See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@end defun

@node SRFI-13 String case mapping, SRFI-13 String reverse & append, SRFI-13 String searching, String library
@subsection String case mapping
@c NODE 文字列のケース(大文字小文字)マッピング

@defun string-titlecase s &optional start end
@defunx string-titlecase! s &optional start end
[SRFI-13]
@end defun

@defun string-upcase s &optional start end
@defunx string-upcase! s &optional start end
[SRFI-13]
@end defun

@defun string-downcase s &optional start end
@defunx string-downcase! s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String reverse & append, SRFI-13 String mapping, SRFI-13 String case mapping, String library
@subsection String reverse & append
@c NODE 文字列の反転と追加

@defun string-reverse s &optional start end
@defunx string-reverse! s &optional start end
[SRFI-13] Returns a string in which the character positions are reversed
from @var{s}.  @code{string-reverse!} modifies @var{s}.
@example
(string-reverse "mahalo") @result{} "olaham"
(string-reverse "mahalo" 3) @result{} "ola"
(string-reverse "mahalo" 1 4) @result{} "aha"

(let ((s (string-copy "mahalo")))
  (string-reverse! s 1 5)
  s)
  @result{} "mlahao"
@end example
@end defun

@defun string-concatenate string-list
[SRFI-13] Concatenates list of strings.
@example
(string-concatenate '("humuhumu" "nukunuku" "apua" "`a"))
  @result{} "humuhumunukunukuapua`a"
@end example
@end defun

@defun string-concatenate/shared string-list
@defunx string-append/shared s @dots{}
[SRFI-13] ``Shared'' version of @code{string-concatenate} and
@code{string-append}.  In Gauche, these are just synonyms of them.
@end defun

@defun string-concatenate-reverse string-list
@defunx string-concatenate-reverse/shared string-list
[SRFI-13] Reverses @var{string-list} before concatenation.
``Shared'' version works the same in Gauche.
@end defun

@node SRFI-13 String mapping, SRFI-13 String rotation, SRFI-13 String reverse & append, String library
@subsection String mapping
@c NODE 文字列のマッピング

@defun string-map proc s &optional start end
@defunx string-map! proc s &optional start end
[SRFI-13] @code{string-map} applies @var{proc} on every character of @var{s},
and collects the results into a string and returns it.
On the other hand, @code{string-map!} modifies @var{s}.
@example
(string-map char-upcase "wikiwiki") @result{} "WIKIWIKI"
(string-map char-upcase "wikiwiki" 4) @result{} "WIKI"

(let ((s (string-copy "wikiwiki")))
  (string-map! char-upcase s 4)
  s)
  @result{} "wikiWIKI"
@end example
@end defun

@defun string-fold kons knil s &optional start end
@defunx string-fold-right kons knil s &optional start end
[SRFI-13]
@end defun

@defun string-unfold p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-unfold-right p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-for-each proc s &optional start end
[SRFI-13]
@end defun

@defun string-for-each-index proc s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String rotation, SRFI-13 other string operations, SRFI-13 String mapping, String library
@subsection String rotation
@c NODE 文字列のローテーション

@defun xsubstring s from &optional to start end
[SRFI-13]
@end defun

@defun string-xcopy! target tstart s sfrom &optional sto start end
[SRFI-13]
@end defun

@node SRFI-13 other string operations, SRFI-13 String filtering, SRFI-13 String rotation, String library
@subsection Other string operations
@c NODE 他の文字列操作

@defun string-replace s1 s2 start1 end2 &optional start2 end2
[SRFI-13]
@end defun

@defun string-tokenize s &optional token-set start end
[SRFI-13]
Splits the string @var{s} into a list of substrings,
where each substring is a maximal non-empty contiguous
sequence of characters from the character set @var{token-set}.
The default of @var{token-set} is @code{char-set:graphic}
(@xref{SRFI-14 Predefined character-set}).

See also Gauche's built-in @code{string-split} (@xref{String utilities}),
which provides similar features but different criteria.
@end defun

@node SRFI-13 String filtering, SRFI-13 Low-level string procedures, SRFI-13 other string operations, String library
@subsection String filtering
@c NODE 文字列のフィルタリング

@defun string-filter s char/char-set/pred &optional start end
@defunx string-delete s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@node SRFI-13 Low-level string procedures,  , SRFI-13 String filtering, String library
@subsection Low-level string procedures
@c NODE 低レベルな文字列に関する手続き

@defun string-parse-start+end proc s args
@defunx string-parse-final-start+end proc s args
[SRFI-13]
@end defun

@defmac let-string-start+end (start end [rest]) proc-exp s-exp args-exp body @dots{}
[SRFI-13]
@end defmac

@defun check-substring-spec proc s start end
@defunx substring-spec-ok? s start end
[SRFI-13]
@end defun

@defun make-kmp-restart-vector s &optional c= start end
[SRFI-13]
@end defun

@defun kmp-step pat rv c i c= p-start
[SRFI-13]
@end defun

@defun string-kmp-partial-search pat rv s i &optional c= p-start s-start s-end
[SRFI-13]
@end defun

@c ----------------------------------------------------------------------
@node Character-set library, Time data types and procedures, String library, Library modules - SRFIs
@section @code{srfi-14} - Character-set library
@c NODE 文字集合ライブラリ, @code{srfi-14} - 文字集合ライブラリ

@deftp {Module} srfi-14
@mdindex srfi-14
Implements the character set library defined in SRFI-14
(@ref{srfi-14,,SRFI-14}).  Note that several basic character-set
operations are Gauche's build-in functions.  @xref{Character set}.
@end deftp

@menu
* SRFI-14 Character-set constructors::  
* SRFI-14 Character-set Comparison::  
* SRFI-14 Character-set iteration::  
* SRFI-14 Character-set query::  
* SRFI-14 Character-set algebra::  
* SRFI-14 Predefined character-set::  
@end menu

@node SRFI-14 Character-set constructors, SRFI-14 Character-set Comparison, Character-set library, Character-set library
@subsection Character-set constructors
@c NODE 文字セットの構築子

@defun list->char-set char-list &optional base-cs
@defunx list->char-set! char-list base-cs
[SRFI-14]
Constructs a character set from a list of characters @var{char-list}.
If @var{base-cs} is given, it must be a character set, and the characters
in it are added to the result character set.
@code{List->char-set!} is allowed, but not required, to reuse @var{base-cs}
to store the result.
@end defun

@defun string->char-set s &optional base-cs
@defunx string->char-set! s base-cs
[SRFI-14]
Like @code{list->char-set} and @code{list->char-set!}, 
but take a list of characters from a string @var{s}.
@end defun

@defun char-set-filter pred char-set &optional base-cs
@defunx char-set-filter! pred char-set base-cs
[SRFI-14]
Returns a character set containing every character @var{c} in
@var{char-set} such that @code{(@var{pred} @var{c})} returns true.
If a character set @var{base-cs} is given, its content is added to 
the result.  The linear update version @code{char-set-filter!}
is allowed, but not required, to modify @var{base-cs} to store the result.
@end defun

@defun ucs-range->char-set lower upper &optional error? base-cs
@defunx ucs-range->char-set! lower upper error? base-cs
[SRFI-14]

@end defun

@defun integer-range->char-set lower upper &optional error? base-cs
@defunx integer-range->char-set! lower upper error? base-cs
@end defun

@defun ->char-set x
[SRFI-14]
@end defun

@node SRFI-14 Character-set Comparison, SRFI-14 Character-set iteration, SRFI-14 Character-set constructors, Character-set library
@subsection Character-set comparison
@c NODE 文字セットの比較

@defun char-set= char-set1 @dots{}
[SRFI-14]
@end defun

@defun char-set@code{<=} char-set1 @dots{}
[SRFI-14]
@end defun

@defun char-set-hash char-set &optional bound
[SRFI-14]
@end defun

@node SRFI-14 Character-set iteration, SRFI-14 Character-set query, SRFI-14 Character-set Comparison, Character-set library
@subsection Character-set iteration
@c NODE 文字セットのイテレーション

@defun char-set-cursor char-set
[SRFI-14]
@end defun

@defun char-set-ref char-set cursor
[SRFI-14]
@end defun

@defun char-set-cursor-next char-set cursor
[SRFI-14]
@end defun

@defun end-of-char-set? ccursor
[SRFI-14]
@end defun

@defun char-set-fold kons knil char-set
[SRFI-14]
@end defun

@defun char-set-unfold pred fun gen seed &optional base-char-set
@defunx char-set-unfold! pred fun gen seed base-char-set
[SRFI-14]
@end defun

@defun char-set-for-each proc char-set
[SRFI-14]
@end defun

@defun char-set-map proc char-set
[SRFI-14]
@end defun

@node SRFI-14 Character-set query, SRFI-14 Character-set algebra, SRFI-14 Character-set iteration, Character-set library
@subsection Character-set query
@c NODE 文字セットへの問い合わせ

@defun char-set-size char-set
[SRFI-14]
@end defun

@defun char-set-count pred char-set
[SRFI-14]
@end defun

@defun char-set->list char-set
[SRFI-14]
@end defun

@defun char-set->string char-set
[SRFI-14]
@end defun

@defun char-set-every pred char-set
[SRFI-14]
@end defun

@defun char-set-any pred char-set
[SRFI-14]
@end defun

@node SRFI-14 Character-set algebra, SRFI-14 Predefined character-set, SRFI-14 Character-set query, Character-set library
@subsection Character-set algebra
@c NODE 文字セットに適用できる代数的関数

@defun char-set-adjoin char-set char1 @dots{}
@defunx char-set-adjoin! char-set char1 @dots{}
[SRFI-14]
Returns a character set that adds @var{char1} @dots{} to
@var{char-set}.
@end defun

@defun char-set-delete char-set char1 @dots{}
@defunx char-set-delete! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-complement char-set
@defunx char-set-complement! char-set
[SRFI-14]
@end defun

@defun char-set-union char-set @dots{}
@defunx char-set-union! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-intersection char-set @dots{}
@defunx char-set-intersection! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-difference char-set1 char-set2 @dots{}
@defunx char-set-difference! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-xor char-set @dots{}
@defunx char-set-xor! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-diff+intersection char-set1 char-set2 @dots{}
@defunx char-set-diff+intersection! char-set1 char-set2 char-set3 @dots{}
[SRFI-14]
@end defun



@node SRFI-14 Predefined character-set,  , SRFI-14 Character-set algebra, Character-set library
@subsection Predefined character-set
@c NODE 定義済みの文字セット

@defvar char-set:letter
[SRFI-14]
@end defvar

@defvar char-set:blank
[SRFI-14]
@end defvar

@defvar char-set:iso-control
[SRFI-14]
@end defvar

@defvar char-set:digit
@defvarx char-set:hex-digit
[SRFI-14]
@end defvar

@defvar char-set:graphic
[SRFI-14]
@end defvar

@defvar char-set:lower-case
@defvarx char-set:upper-case
@defvarx char-set:title-case
[SRFI-14]
@end defvar

@defvar char-set:printing
[SRFI-14]
@end defvar

@defvar char-set:punctuation
[SRFI-14]
@end defvar

@defvar char-set:whitespace
[SRFI-14]
@end defvar

@defvar char-set:symbol
[SRFI-14]
@end defvar

@defvar char-set:ascii
[SRFI-14]
@end defvar

@defvar char-set:empty
[SRFI-14]
@end defvar

@defvar char-set:full
[SRFI-14]
@end defvar

@c ----------------------------------------------------------------------
@node Time data types and procedures, Sources of random bits, Character-set library, Library modules - SRFIs
@section @code{srfi-19} - Time data types and procedures
@c NODE 時間のデータ型と手続き, @code{srfi-19} - 時間のデータ型と手続き

@deftp {Module} srfi-19
@mdindex srfi-19
This SRFI defines various representations of time and date, and
conversion methods among them.

On Gauche, time object is supported natively by @code{<time>} class
(@xref{Time}).  Date object is supported by @code{<date>} class
described below.
@end deftp

@menu
* SRFI-19 Time types::          
* SRFI-19 Time queries::        
* SRFI-19 Time procedures::     
* SRFI-19 Date::                
* SRFI-19 Date reader and writer::  
@end menu

@node SRFI-19 Time types, SRFI-19 Time queries, Time data types and procedures, Time data types and procedures
@subsection Time types
@c NODE 時間のタイプ

Time type is represented by a symbol.  This module defines
the following constant variables that is bound to its name, for
convenience.

@defvr {Constant} time-utc
[SRFI-19]
UTC time.  Gauche's built-in @code{current-time} always returns
this type (@xref{Time}).
@end defvr

@defvr {Constant} time-tai
[SRFI-19]
International Atomic Time.  This time is a bit larger than UTC, due to
the leap seconds.
@end defvr

@defvr {Constant} time-monotonic
[SRFI-19]
Implementation-dependent monotonically increasing time.
In Gauche, this is the same as @code{time-tai}.
@end defvr

@defvr {Constant} time-duration
[SRFI-19]
Duration between two absolute time points.
@end defvr

@defvr {Constant} time-process
[SRFI-19]
CPU time in current process.
Gauche calculates this from user time and system time returned by 
POSIX times(3).
@end defvr

@defvr {Constant} time-thread
[SRFI-19]
CPU time in current thread.
In the current implementation, this is the same as @code{time-process}.
@end defvr

@node SRFI-19 Time queries, SRFI-19 Time procedures, SRFI-19 Time types, Time data types and procedures
@subsection Time queries
@c NODE 時間に関する問い合わせ

@defun current-time &optional time-type
[SRFI-19]
Extends Gauche built-in @code{current-time} (@xref{Time}) to take
optional @var{time-type} argument to specify the desired time type.
@var{time-type} must be one of the types described in @ref{SRFI-19 Time types}.
@end defun

@defun current-date &optional tz-offset
[SRFI-19]
Returns the current date as an instance of @code{<date>} class
(@xref{SRFI-19 Date}).  If @var{tz-offset} is given, it must be
an offset from UTC in number of seconds.  If @var{tz-offset} is
not given, returns the date in local time zone.
@end defun

@defun current-julian-day 
[SRFI-19]
Returns the current julian day, a point in time as a real number of
days since -4714-11-24T12:00:00Z (November 24, -4714 at noon, UTC). 
@end defun

@defun current-modified-julian-day
[SRFI-19]
Returns the current modified julian day, a point in time as a real
number of days since 1858-11-17T00:00:00Z
(November 17, 1858 at midnight, UTC). 
@end defun

@defun time-resolution
[SRFI-19]
@end defun


@node SRFI-19 Time procedures, SRFI-19 Date, SRFI-19 Time queries, Time data types and procedures
@subsection Time procedures
@c NODE 時間に関する手続き

@defun make-time type nanoseconds seconds
[SRFI-19]
Returns an instance of @code{<time>} class with specified initial values.
Equivalent to @code{(make <time> :type type :second seconds :nanosecond nanoseconds)}.

(This function had been defined incorrectly before release 0.6.8; 
the arguments @var{seconds} and @var{nanoseconds} were switched.
Please check your code if it uses @code{make-time}).
@end defun

@defun time-type time
@defunx time-second time
@defunx time-nanosecond time
@defunx set-time-type! time type
@defunx set-time-second! time second
@defunx set-time-nanosecond! time nanosecond
[SRFI-19]
Getter and setter of @code{<time>} object slots.
@end defun

@defun copy-time time
[SRFI-19]
Returns a new instance of @code{<time>} whose content is the same as
given @var{time}
@end defun

@defun time=? time0 time1
@defunx time<? time0 time1
@defunx time<=? time0 time1
@defunx time>? time0 time1
@defunx time>=? time0 time1
[SRFI-19]
Compares two times.  Types of both times must match.
@end defun

@defun time-difference time0 time1
@defunx time-difference! time0 time1
[SRFI-19]
Returns the difference of two times, in @code{time-duration} time.
Types of both times must match.  
@code{Time-difference!} modifies @var{time0} to store the result.
@end defun

@defun add-duration time0 time-duration
@defunx add-duration! time0 time-duration
@defunx subtract-duration time0 time-duration
@defunx subtract-duration! time0 time-duration
[SRFI-19]
Adds or subtracts @var{time-duration} to or from @var{time0}.
Type of returned time is the same as @var{time0}.  Type of
@var{time-duration} must be @code{time-duration}.
@code{add-duration!} and @code{subtract-duration!} reuse
@var{time0} to store the result.
@end defun

@node SRFI-19 Date, SRFI-19 Date reader and writer, SRFI-19 Time procedures, Time data types and procedures
@subsection Date
@c NODE 日付

@deftp {Class} <date>
@clindex date
Represents a date.

@defivar <date> nanosecond
Nanosecond portion of the date by an integer between 0 and 999,999,999,
inclusive.
@end defivar

@defivar <date> second
Second portion of the date by an integer between 0 and 60, inclusive.
(60 for leap second).
@end defivar

@defivar <date> minute
Minute portion of the date by an integer between 0 and 59, inclusive.
@end defivar

@defivar <date> hour
Hour portion of the date by an integer between 0 and 23, inclusive.
@end defivar

@defivar <date> day
Day portion of the date by an integer between 0 and 31, inclusive.
The actual upper bound of the day is determined by the year and the month.
(Note: 1 is for the first day; 0 is allowed by the specification,
but I don't see why).
@end defivar

@defivar <date> month
Month portion of the date by an integer between 1 and 12, inclusive.
1 for January, 2 for February, and so on.
(Note: this is different from POSIX's @code{<sys-tm>} convention).
@end defivar

@defivar <date> year
Year portion of the date.
@end defivar

@defivar <date> zone-offset
The number of seconds east of GMT for this timezone, by an integer.
@end defivar
@end deftp

@defun make-date nanosecond second minute hour day month year zone-offset
[SRFI-19]
Makes a @code{<date>} object from the given values.
Note: this procedure does not check if the values are in the valid range.
@end defun

@defun date? obj
[SRFI-19]
Returns true iff @var{obj} is a @code{<date>} object.
@end defun

@defun date-nanosecond date
@defunx date-second date
@defunx date-minute date
@defunx date-hour date
@defunx date-day date
@defunx date-month date
@defunx date-year date
@defunx date-zone-offset date
[SRFI-19]
Accessors.
@end defun

@defun date-year-day date
@defunx date-week-day date
@defunx date-week-number date day-of-week-starting-week
[SRFI-19]
Calculates the day number in the year (1 for January 1st),
the day number in the week (0 for Sunday, 1 for Monday, ...),
and the ordinal week of the year which holds this date,
ignoring a first partial week, respectively.

@var{Day-of-week-starting-week} is the integer corresponding to
the day of the week which is to be considered the first day of
the week (Sunday=0, Monday=1, etc.).
@end defun

@defun date->julian-day date
@defunx date->modified-julian-day date
@defunx date->time-monotonic date
@defunx date->time-tai date
@defunx date->time-utc date
[SRFI-19]
Conversions from date to various date/time types.
@end defun

@defun julian-day->date jd &optional tz-offset
@defunx julian-day->time-monotonic jd
@defunx julian-day->time-tai jd
@defunx julian-day->time-utc jd
[SRFI-19]
Conversions from julian-day to various date/time types.
@end defun

@defun modified-julian-day->date jd &optional tz-offset
@defunx modified-julian-day->time-monotonic jd
@defunx modified-julian-day->time-tai jd
@defunx modified-julian-day->time-utc jd
[SRFI-19]
Conversions from modified julian-day to various date/time types.
@end defun

@defun time-monotonic->date time &optional tz-offset
@defunx time-monotonic->julian-day time
@defunx time-monotonic->modified-julian-day time
@defunx time-monotonic->time-tai time
@defunx time-monotonic->time-tai! time
@defunx time-monotonic->time-utc time
@defunx time-monotonic->time-utc! time
[SRFI-19]
Conversions from time-monotonic to various date/time types.
@end defun

@defun time-tai->date time &optional tz-offset
@defunx time-tai->julian-day time
@defunx time-tai->modified-julian-day time
@defunx time-tai->time-monotonic time
@defunx time-tai->time-monotonic! time
@defunx time-tai->time-utc time
@defunx time-tai->time-utc! time
[SRFI-19]
Conversions from time-tai to various date/time types.
@end defun

@defun time-utc->date time &optional tz-offset
@defunx time-utc->julian-day time
@defunx time-utc->modified-julian-day time
@defunx time-utc->time-monotonic time
@defunx time-utc->time-monotonic! time
@defunx time-utc->time-tai time
@defunx time-utc->time-tai! time
[SRFI-19]
Conversions from time-utc to various date/time types.
@end defun

@node SRFI-19 Date reader and writer,  , SRFI-19 Date, Time data types and procedures
@subsection Date reader and writer
@c NODE 日付の読み書き

@defun date->string date &optional format-string
[SRFI-19+]
Converts a @code{<date>} object to a string, according
to the format specified by @var{format-string}.
If @var{format-string} is omitted, @code{"~c"} is assumed.

A format string is copied to output, except a sequence begins with
@code{~} which is replaced with the following rules:

@table @code
@item ~~
A literal @code{~}.
@item ~a
Locale's abbreviated weekday name (Sun...Sat).
@item ~A
Locale's full weekday name (Sunday...Saturday).
@item ~b
Locale's abbreviate month name (Jan...Dec).
@item ~B
Locale's full month name (January...December).
@item ~c
Locale's date and time (e.g., "Fri Jul 14 20:28:42-0400 2000").
@item ~d
Day of month, zero padded (01...31).
@item ~D
Date (mm/dd/yy).
@item ~e
Day of month, blank padded ( 1...31).
@item ~f
Seconds+fractional seconds, using locale's decimal separator (e.g. 5.2).
@item ~h
Same as ~b.
@item ~H
Hour, zero padded, 24-hour clock (00...23).
@item ~I
Hour, zero padded, 12-hour clock (01...12).
@item ~j
Day of year, zero padded.
@item ~k
Hour, blank padded, 24-hour clock ( 0...23).
@item ~l
Hour, blank padded, 12-hour clock ( 1...12).
@item ~m
Month, zero padded (01...12).
@item ~M
Minute, zero padded (00...59).
@item ~n
New line.
@item ~N
Nanosecond, zero padded.
@item ~p
Locale's AM or PM.
@item ~r
Time, 12 hour clock, same as "~I:~M:~S ~p".
@item ~s
Number of full seconds since "the epoch" (in UTC).
@item ~S
Second, zero padded (00...60).
@item ~t
Horizontal tab.
@item ~T
Time, 24 hour clock, same as "~H:~M:~S".
@item ~U
Week number of year with Sunday as first day of week (01...53).
@item ~V
Week number of year with Monday as first day of week (00...52).
@item ~w
Day of week (0...6).
@item ~W
Week number of year with Monday as first day of week (00...52).
@item ~x
Locale's date representation, for example: "07/31/00".
@item ~X
Locale's time representation, for example: "06:51:44".
@item ~y
Last two digits of year (00...99).
@item ~Y
Year.
@item ~z
Time zone in RFC-822 style.
@c @item ~Z
@c Symbol time zone (not-implemented).
@item ~1
ISO-8601 year-month-day format.
@item ~2
ISO-8601 hour-minute-second-timezone format.
@item ~3
ISO-8601 hour-minute-second format.
@item ~4
ISO-8601 year-month-day-hour-minute-second-timezone format.
@item ~5
ISO-8601 year-month-day-hour-minute-second format.
@end table

Note: currently Gauche doesn't honor process's locale setting,
and it always formats the date as if the locale is "C".  It may
be changed in future, so you shouldn't rely on, for example,
@code{~a} always formatted as "Sun".."Sat".

There's no portable way to ensure you'll get "C" locale formats
since there's no standard way to set process's locale yet.
However, Gauche provides a way to ensure the locale to be "C",
as an extension to srfi-19.
Insert @code{@@} between @code{~} and the directive
character, such as @code{~@@a}.
@end defun

@defun string->date string template-string
[SRFI-19]
@c   [NB] srfi-19's string->date is broken, in both spec and reference
@c   implementation.  I'm wondering whether I should change string->date
@c   to make usable, or introduce another procedure, like string->date*,
@c   which fixes the problem.
@
@c Both procedures parse a string representation of date in @var{string},
@c according to the format given in @var{template-string}.

@c The input string must match the @var{template-string},
@c except tilde-directives described below, which matches
@c one or more component(s) of the date.  If the input string
@c is parsed successfully, a @code{<date>} object is returned
@c with the matched components are filled.

@c If the input string does not match @var{template-string},
@c an error is signalled.  (The SRFI-19 spec doesn't explicitly
@c state what happens if @code{string->date} doesn't accept the
@c input, which actually reduces usability of @code{string->date}

@c but the reference implentation signals an error, and
@c it would be safe to assume


@c @table @code
@c @item ~~
@c Matches literal @code{~}.
@c @item ~a
@c Skip to an alphanumeric character, then matches abbreviated
@c weekday in locale.  Match result is ignored.
@c @item ~A
@c Skip to an alphanumeric character, then matches full
@c weekday in locale.  Match result is ignored.
@c @item ~b
@c Skip to an alphanumeric character, then matches abbreviated
@c month name in locale.  Sets the month component of the date.
@c @item ~B
@c Skip to an alphanumeric character, then matches full
@c month name in locale.  Sets the month component of the date.
@c @item ~d
@c Skip to a numeric character, then maches the day of month.
@c Sets the month component of the date.
@c @item ~e

@c ~e	any	day of month, blank padded	date-day
@c ~h	char-alphabetic?	same as ~b	nothing
@c ~H	char-numeric?	hour	date-hour
@c ~k	any	hour, blank padded	date-hour
@c ~m	char-numeric?	month	date-month
@c ~M	char-numeric?	minute	date-minute
@c ~S	char-numeric?	second	date-second
@c ~y	any	2-digit year	date-year within 50 years
@c ~Y	char-numeric?	year	date-year
@c ~z	any	time zone	date-zone-offset@end table

@end defun

@c ----------------------------------------------------------------------
@node Sources of random bits, Localization, Time data types and procedures, Library modules - SRFIs
@section @code{srfi-27} - Sources of Random Bits
@c NODE ランダムビットのソース, @code{srfi-27} - ランダムビットのソース

@deftp {Module} srfi-27
@mdindex srfi-27
This module provides SRFI-27 pseudo random generator interface,
using Mersenne Twister algorithm 
(@xref{Mersenne-Twister random number generator}) as the backbone.
@end deftp

@defun random-integer n
[SRFI-27]
Returns a random exact integer between [0, @var{n}-1], inclusive,
using the default random source.
To set a random seed for this procedure, use @code{random-source-randomize!}
or @code{random-source-pseudo-randomize!} on @code{default-random-source}.
@end defun

@defun random-real
[SRFI-27]
Returns a random real number between (0, 1), exclusive,
using the default random source.
To set a random seed for this procedure, use @code{random-source-randomize!}
or @code{random-source-pseudo-randomize!} on @code{default-random-source}.
@end defun

@defvar default-random-source
[SRFI-27]
Keeps the default random source that is used by @code{random-integer}
and @code{random-real}.
@end defvar

@defun make-random-source
[SRFI-27]
Creates and returns a new random source.
In the current Gauche implementation, it is just a @code{<mersenne-twister>}
object.  It may be changed in the future implementation.
@end defun

@defun random-source? obj
[SRFI-27]
Returns @code{#t} if @var{obj} is a random source object.
@end defun

@defun random-source-state-ref s
@defunx random-source-state-set! s state
[SRFI-27]
Gets and sets the "snapshot" of the state of the random source @var{s}.
@var{State} is an opaque object whose content depends on the backbone
generator.
@end defun

@defun random-source-randomize! s
[SRFI-27]
Makes an effort to set the state of the random source @var{s} to 
a truly random state.  The current implementation uses the current
time and the process ID to set the random seed.
@end defun

@defun random-source-pseudo-randomize! s i j
[SRFI-27]
Changes the state of the random source @var{s} into the initial state 
of the (@var{i}, @var{j})-th independent random source, 
where @var{i} and @var{j} are non-negative integers. 
This procedure can be used to reuse a random source @var{s} as large 
number of independent random source, indexed by two non-negative integers.
Note that this procedure is entirely deterministic. 
@end defun

@defun random-source-make-integers s
[SRFI-27]
Returns a procedure, that takes one integer argument @var{n} and
returns a random integer between 0 and @var{n}-1 inclusive for every
invocation, from the random source @var{s}.
@end defun

@defun random-source-make-reals s &optional unit
[SRFI-27]
Returns a procedure, that takes no argument and
returns a random real between 0 and 1 exclusive for
every invocation, from the random source @var{s}.
If @var{unit} is given, the random real the returned procedure
generates will be quantized by the given @var{unit}, where 
0 < @var{unit} < 1.
@end defun

@c ----------------------------------------------------------------------
@node Localization, A program argument processor, Sources of random bits, Library modules - SRFIs
@section @code{srfi-29} - Localization
@c NODE 地域化, @code{srfi-29} - 地域化

@deftp {Module} srfi-29
@mdindex srfi-29
@mdindex srfi-29.bundle
@mdindex srfi-29.format
This module implements the message localization mechanism
defined in SRFI-29.

In fact, this module consists of two submodules, 
@code{srfi-29.bundle} and @code{srfi-29.format}.
The module @code{srfi-29} extends both submodules.
It is because srfi-29's definition of the @code{format}
procedure is incompatible to Gauche's native @code{format}
(thus Common Lisp's @code{format}) in the handling of 
@code{~@@*} directive.

So I splitted the module into two, @code{srfi-29.format}
which contains srfi-29's @code{format}, and @code{srfi-29.bundle}
which contains the rest ("bundle" API).
If a program wishes a complete compatibility of
srfi-29, use @code{srfi-29} module, which overrides
Gauche's native @code{format}.   If a program just wants
srfi-29's "bundle" API, but wants to keep Gauche's @code{format},
use @code{srfi-29.bundle}.

A localization feature is also provided by @code{text.gettext} module
(@xref{Localized messages}),
which is a preferable way of message localization in Gauche.
This module is provided mainly for porting code that uses
srfi-29 features.
@end deftp

@subheading Bundle specifier

A @emph{bundle specifier} is an arbitrary list of symbols,
but typically it takes the form like:
@example
@code{(@var{package} @var{language} @var{country} @var{details} @dots{})}
@end example
Where @var{package} specifies the software package,
@var{language} and @var{country} specifies language and country code,
and @var{details} gives other informations like encoding.

The values for the default bundle specifier can be obtained
by the following parameters.

@deffn {Parameter} current-language
@deffnx {Parameter} current-country
@deffnx {Parameter} current-locale-details
[SRFI-29]
The @code{current-language} and @code{current-country} parameters
keep the ISO 639-1 language code and ISO 3166-1 country code
respectively, both as symbols.
The @code{current-locale-details} keeps a list of auxiliary
local informations, such as encodings.

These parameters are initialized if @code{LANG} environment
variable is set in the form of @code{lang_country.encoding} format.
For example, if the @code{LANG} setting is @code{ja_JP.eucJP},
those parameters are @code{ja}, @code{jp}, and @code{(eucjp)}, 
respectively.   If @code{LANG} is @code{C} or undefined,
the default values are @code{en}, @code{us}, and @code{()}, respectively.
@end deffn

@subheading Bundle preparation

@defun declare-bundle! bundle-specifier association-list
[SRFI-29]
Put the association list of template key (symbol) and the locale-specific
message (string) into the bundle database, with @var{bundle-specifier}
as the key.
@end defun

Gauche currently supports only in-memory bundle database.
That is, you have to call @code{declare-bundle!} within the application
in order to lookup the localized messages.

@defun save-bundle! bundle-specifier
@defunx load-bundle! bundle-specifier
[SRFI-29]
Since Gauche doesn't support persistent bundle database yet,
these procedures does nothing and returns @code{#f}.
(It is still conforming behavior of srfi-29).
@end defun

@subheading Retrieving localized message

@defun localized-template package-name message-template-name
[SRFI-29]
Retrieves localized message, associated with a symbol
@var{message-template-name} in the package @var{package-name}.
@end defun

@subheading Extended format procedure

@defun format format-string args
[SRFI-29]
SRFI-29 extends SRFI-28's @code{format} procedure spec
(which supports @code{~a}, @code{~s}, @code{~%} and @code{~~} directives),
in order to support argument repositioning.  

A directive @code{~N@@*}, where N is an integer or can be omitted,
causes the next directive to retrieve a value from @var{N}-th
optional argument.  The referenced value isn't consumed,
and won't affect the processing of subsequent directives.

Although SRFI-28 spec is compatible to 
Gauche's native @code{format} (@xref{Output}),
this SRFI-29 extention isn't.
Specifically, the @code{~N@@*} directive of Gauche's @code{format}
changes the argument pointer to points @var{N}-th optional argument,
thus it affects all the subsequent arguments.

Because of this incompatibility, this function is defined in
a separate module, @code{srfi-29.format}.  If you use @code{srfi-29},
which extends @code{srfi-29.bundle} and @code{srfi-29.format},
the @code{format} procedure will be overridden by srfi-29's @code{format}
in your module.  If you want to keep Gauche's native @code{format},
use @code{srfi-29.bundle} only.
@end defun

@c ----------------------------------------------------------------------
@node A program argument processor, Eager comprehensions, Localization, Library modules - SRFIs
@section @code{srfi-37} - args-fold: a program argument processor
@c NODE args-fold プログラム引数処理, @code{srfi-37} - args-fold プログラム引数処理

@deftp {Module} srfi-37
@mdindex srfi-37
This module implements @code{args-fold},
yet another procedure to process command-line
arguments, defined in SRFI-37 (@ref{srfi-37,[SRFI-37],SRFI-37}).

Unlike @code{gauche.parseopt}
(@xref{Parsing command-line options}),
@code{args-fold} provides functional interface, i.e. 
the user's states are explicitly passed via parser's argument and
return values, and also follows POSIX and GNU getopt guidelines,
including long options.
@end deftp

@defun args-fold args options unrecognized-proc operand-proc &rest seeds
Processes program options @var{args} from left to right,
according to given option specification @var{options},
and two procedures @var{unrecognized-proc} and @var{operand-proc}.

@var{Options} is a list of option objects, explained below.
Each option object keeps the name(s) of the option, 
a flag to specify whether the option takes
an argument or not, and a procedure to process that option
(we'll call it @emph{option procedure}).  

@code{Args-fold} recognizes both single-character options (short options)
and long options.  A short option must begin with single hyphen
(e.g. @code{-a}), while long option must begin with double hyphens
(e.g. @code{--help}).   Short options can be
concatenated, e.g. @code{-abc} or @code{-a -b -c}.
Both a short option and a long option can take
required or optional arguments.   Required short-option argument
can appear with or without space after the option, e.g.
@code{-afoo} or @code{-a foo}.
Long-option argument can appear after character '@code{=}' or
space, e.g. @code{--long=foo} or @code{--long foo}.

When @code{args-fold} encounters a command-line argument that cannot
be an option argument, and doesn't begin with hyphen, the argument is
treated as an @emph{operand}.   @code{Args-fold} allows operands and
options to be interleaved.  However, if @code{args-fold} encounters
'@code{--}', the rest of arguments are treated as operands,
regardless of beginning with hyphen or not.

When the given option matches one of option object in @var{options},
the option procedure is called as follows:

@example
(@var{option-proc} @var{option} @var{name} @var{arg} @var{seed} @dots{})
@end example

where @var{option} is the matched option object, @var{name} is
the string actually used to specify the option, @var{arg} is
the option argument (or @code{#f} if there's none), and
@var{seed} @dots{} is the user's state information.
@var{Option-proc} must return as many arguments as @var{seed}s.

When @code{args-fold} encounters an option that doesn't match
any of the option objects, it creates a new option object
for the option and calls @var{unrecognized-proc}
with the same arguments as @var{option-proc}.  

When @code{args-fold} finds an operand, @var{operand-proc}
is called as follows:

@example
(@var{operand-proc} @var{operand} @var{seed} @dots{})
@end example

@var{Operand-proc} must return as many arguments as @var{seed}s.

The caller's state should be explicitly passed around seed arguments
and return values.  The initial seed values are @var{seed}s given
to @code{args-fold}.  The values returned from option procedure,
@var{unrecognized-proc} and @var{operand-proc} are used as the seed
arguments of next invocation of those procedures.  The values
returned from the last call to the procedures are returned
from @code{args-fold}.
@end defun

@defun option names require-arg? optional-arg? processor
Creates an option object with the passed properties.

@var{Names} is a list of characters and/or strings.
A character is used for a short option, and a string is used
for a long option.

Two flags, @var{require-arg?} and @var{optional-arg?}
indicates whether the option should take an option argument,
or may take an option argument.  

@var{Processor} is the option processor procedure.

Note that, if an option argument is passed using '@code{=}'
character, it is passed to the option procedure even if 
the option has @code{#f} in both @var{require-arg?}
and @var{optional-arg?}.  It is up to the option procedure
to deal with the argument.

It should also be noted that the optional option argument
for a short option is only recognized if it is given
without whitespace after the short option.  That is, if
a short option '@code{d}' is marked to take optional option argument,
then '@code{-dfoo}' is interpreted as '@code{-d}' with argument '@code{foo}',
but '@code{-d foo}' is interpreted as '@code{-d}' without argument
and an operand @code{foo}.  If '@code{d}' is marked to
take required option argument, however, both are interpreted
as '@code{-d}' with argument '@code{foo}'.
@end defun

@defun option? obj
Returns @code{#t} if @var{obj} is an option object,
@code{#f} otherwise.
@end defun

@defun option-names option
@defunx option-required-arg? option
@defunx option-optional-arg? option
@defunx option-processor
Returns the properties of an option object @var{option}.
@end defun

A simple example:

@example
(use srfi-37)

(define options
 (list (option '(#\d "debug") #f #t
               (lambda (option name arg debug batch paths files)
                 (values (or arg "2") batch paths files)))
       (option '(#\b "batch") #f #f
               (lambda (option name arg debug batch paths files)
                 (values debug #t paths files)))
       (option '(#\I "include") #t #f
               (lambda (option name arg debug batch paths files)
                 (values debug batch (cons arg paths) files)))))

(define (main args)
  (receive (debug-level batch-mode include-paths files)
    (args-fold (cdr args)
               options
               (lambda (option name arg . seeds)         ; unrecognized
                 (error "Unrecognized option:" name))
               (lambda (operand debug batch paths files) ; operand
                 (values debug batch paths (cons operand files)))
               0      ; default value of debug level
               #f     ; default value of batch mode
               '()    ; initial value of include paths
               '()    ; initial value of files
               )
     (print "debug level = " debug-level)
     (print "batch mode = " batch-mode)
     (print "include paths = " (reverse include-paths))
     (print "files = " (reverse files))
     0))
@end example

@c ----------------------------------------------------------------------
@node Eager comprehensions, Vector library, A program argument processor, Library modules - SRFIs
@section @code{srfi-42} - Eager comprehensions
@c NODE Eager comprehensions, @code{srfi-42} - 先行評価的内包表記

@deftp {Module} srfi-42
@mdindex srfi-42
This module provides a generic comprehension mechanism, which some other
languages (e.g. Haskell and Python) provides as a built-in mechanism.
It provides rich set of operators so it can be used as not only a list
generator but a generic loop construct (actually, some may say
it is as powerful/evil as Common Lisp's @emph{loop} macro).

It is also runs eagerly, that is, if it generates a list, it
creates the entire list when evaluated, instead of generate the
elements @emph{on demand}.  Thus it can't represent an infinite
sequence, which Haskell's comprehension naturally can.  In Scheme,
you can use streams built on top of delayed evaluation for
such purpose.
@end deftp

@subheading Eager comprehension examples

Let's begin with some examples.

Generate a list of squares for the first five integers:
@example
(list-ec (: i 5) (* i i)) @result{} (0 1 4 9 16)
@end example

Generate set of pair of numbers @code{(x y)}, where @code{x}
is between 2 (inclusive) and 5 (exclusive),
and @code{y} is between 1 (inclusive) and x (exclusive).
@example
(list-ec (: x 2 5) (: y 1 x) (list x y))
  @result{} ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3))
@end example

The above two examples can be written in Haskell as the followings:
@example
[ i*i   | i <- [0..4] ]
[ (x,y) | x <- [2..4], y <- [1..x-1] ]
@end example
Note the differences: (1) In Haskell, the body expression to yield the
elements comes first, followed by qualifiers (selectors).  In srfi-42, the body
expression comes last.  (2) In srfi-42, range operator's lower bound
is inclusive but its upper bound is exclusive.

List a set of numbers @code{(a b c d)}, where @code{a^3+b^3 = c^3+d^3}:
@example
(define (taxi-number n)
  (list-ec (: a 1 n)
           (: b (+ a 1) n)
           (: c (+ a 1) b)
           (: d (+ c 1) b)
           (if (= (+ (expt a 3) (expt b 3))
                  (+ (expt c 3) (expt d 3))))
           (list a b c d)))
@end example

You can generate not only a list, but other sequences:
@example
(vector-ec (: i 5) i) @result{} #(0 1 2 3 4)
(string-ec (: i 5) (integer->char (+ i 65))) @result{} "ABCDE"
@end example

Or apply folding operations:
@example
(sum-ec (: i 1 100) i)
  @result{} 4950    ;; sum of integers from 1 below 100.
(product-ec (: i 1 10) i)
  @result{} 362880 ;; ... and product of them.
@end example

@subheading Comprehension macros

Each comprehension takes the following form.
@example
(@var{comprehension-macro} @var{qualifier} @dots{} @var{body})
@end example

Evaluates @var{body} repeatedly as specified by @var{qualifier}s.
Depending on the type of comprehension,
the results of @var{body} may be either collected to create an 
aggregate (list, vector, string, ...), folded by some operator
(sum, product, min, max, ...), or simply discarded.

A few comprehensions takes extra values before @var{qualifiers} or
after @var{bodies}.

@defmac do-ec qualifier @dots{} body
[SRFI-42]
@end defmac

@defmac list-ec qualifier @dots{} body
[SRFI-42]
@end defmac

@defmac append-ec qualifier @dots{} body
[SRFI-42]
@end defmac

@defmac string-ec qualifier @dots{} body
@defmacx string-append-ec qualifier @dots{} body
[SRFI-42]
@end defmac

@defmac vector-ec qualifier @dots{} body
[SRFI-42]
@end defmac

@defmac vector-of-length-ec qualifier @dots{} body
[SRFI-42]
@end defmac

@defmac sum-ec qualifier @dots{} body
@defmacx product-ec qualifier @dots{} body
@defmacx min-ec qualifier @dots{} body
@defmacx max-ec qualifier @dots{} body
[SRFI-42]
@end defmac

@defmac any?-ec qualifier @dots{} test
@defmacx every?-ec qualifier @dots{} test
[SRFI-42]
@end defmac

@defmac first-ec default qualifier @dots{} body
@defmacx last-ec default qualifier @dots{} body
[SRFI-42]
@end defmac

@defmac fold-ec x0 qualifier @dots{} expr f2
@defmacx fold3-ec x0 qualifier @dots{} expr f1 f2
[SRFI-42]
@end defmac

@subheading Qualifiers

@subsubheading Control qualifiers

@deffn {EC Qualifier} if test
@end deffn

@deffn {EC Qualifier} not test
@deffnx {EC Qualifier} and test
@deffnx {EC Qualifier} or test
@end deffn

@deffn {EC Qualifier} begin test
@end deffn

@deffn {EC Qualifier} nested test
@end deffn

@subsubheading Generational qualifiers

@deffn {EC Qualifier} : vars arg1 args @dots{}
@end deffn

@deffn {EC Qualifier} :list vars arg1 args @dots{}
@deffnx {EC Qualifier} :vector vars arg1 args @dots{}
@deffnx {EC Qualifier} :string vars arg1 args @dots{}
@end deffn

@deffn {EC Qualifier} :integers vars
@end deffn

@deffn {EC Qualifier} :range vars stop
@deffnx {EC Qualifier} :range vars start stop
@deffnx {EC Qualifier} :range vars start stop step
@end deffn

@deffn {EC Qualifier} :real-range vars stop
@deffnx {EC Qualifier} :real-range vars start stop
@deffnx {EC Qualifier} :real-range vars start stop step
@end deffn

@deffn {EC Qualifier} :char-range vars min max
@end deffn

@deffn {EC Qualifier} :port vars port
@deffnx {EC Qualifier} :port vars port read-proc
@end deffn

@deffn {EC Qualifier} :dispatched vars dispatch arg1 args @dots{}
@end deffn

@deffn {EC Qualifier} :do (lb @dots{}) ne1? (ls @dots{})
@deffnx {EC Qualifier} :do (let (ob @dots{}) oc @dots{}) (lb @dots{}) ne1? (let (ib @dots{}) ic @dots{}) ne2? (ls @dots{})
@end deffn

@deffn {EC Qualifier} :let vars expr
@end deffn

@deffn {EC Qualifier} :parallel generator @dots{}
@end deffn

@deffn {EC Qualifier} :while generator expr
@end deffn

@deffn {EC Qualifier} :until generator expr
@end deffn

@c ----------------------------------------------------------------------
@node Vector library, Requiring extensions, Eager comprehensions, Library modules - SRFIs
@section @code{srfi-43} - Vector library
@c NODE Vector library, @code{srfi-43} - ベクタライブラリ

@deftp {Module} srfi-43
@mdindex srfi-43
This module provides library functions for vectors.
Some of srfi-43 procedures are built-in; see @ref{Vectors}.
@end deftp

@subheading Vector constructors

@defun vector-unfold f length seed @dots{}
[SRFI-43]
@end defun

@defun vector-unfold-right f length seed @dots{}
[SRFI-43]
@end defun

@defun vector-reverse-copy vec &optional start end
[SRFI-43]
@end defun

@defun vector-append vec @dots{}
[SRFI-43]
Returns a newly allocated vector whose contents are concatenation
of elements of @var{vec} in order.
@end defun

@defun vector-concatenate list-of-vectors
[SRFI-43]
Acts like @code{(apply vector-append list-of-vectors)}, though
this may be more efficient.
@end defun

@subheading Vector predicates

@defun vector-empty? vec
[SRFI-43]
Returns @code{#t} if @var{vec}'s length is zero, and
@code{#f} if @var{vec}'s length is more than zero.
Signals an error if @var{vec} is not a vector.
@end defun

@defun vector= elt= vec @dots{}
[SRFI-43]
Compares @var{vec}s element-wise, using given predicate @var{elt=}.
Returns @code{#t} iff lengths of all the vectors are the same,
and every corresponding elements are equal by @var{elt=}.
@var{Elt=} is always called with two arguments and must
return @code{#t} iff two are the same. 
@end defun

@subheading Iteration over vectors

@defun vector-fold kons knil vec1 vec2 @dots{}
[SRFI-43]
@var{Kons} is iterated over each corresponding elements of
the given vectors, with passing around the seed value, whose
default is proided by @var{knil}.
@end defun

@defun vector-fold-right kons knil vec1 vec2 @dots{}
[SRFI-43]
@end defun

@defun vector-map f vec1 vec2 @dots{}
[SRFI-43]
@end defun

@defun vector-map! f vec1 vec2 @dots{}
[SRFI-43]
@end defun

@defun vector-for-each f vec1 vec2 @dots{}
[SRFI-43]
@end defun

@defun vector-count pred vec1 vec2 @dots{}
[SRFI-43]
@end defun

@subheading Vector searching

@defun vector-index pred vec1 vec2 @dots{}
@defunx vector-index-right pred vec1 vec2 @dots{}
[SRFI-43]
Returns the index of the first or the last elements in @var{vec1}
@var{vec2} @dots{} that satisfy @var{pred}, respectively.
Returns @code{#f} if no elements satisfy @var{pred}.
In @code{vector-index}, comparison ends at the end of the shortest vector.
For @code{vector-index-right}, all the vectors must have the same length.
@end defun

@defun vector-skip pred vec1 vec2 @dots{}
@defunx vector-skip-right pred vec1 vec2 @dots{}
[SRFI-43]
Like @code{vector-index} and @code{vector-index-right}, except that
the result of @var{pred} is negated.  That is, returns the index
of the first or the last elements that don't sastisfy @var{pred}.
@end defun

@defun vector-binary-search vec value cmp &optional start end
[SRFI-43+]
Look for @var{value} in a vector @var{vec}, and returns its
index if it is found, or @code{#f} if it is not found.
Comparison of @var{value} and an element in @var{vec} is
done by a procedure @var{cmp}, which takes two arguments,
and should return a negative integer if the first argument is less than the
second, 0 if they are the same, and a positive integer if the first
is greater than tne second.

Elements in @var{vec} must be ordered from smaller to greater
w.r.t. @var{cmp}.  Using that fact, this procedure performs
binary search instead of linear search.

The optional arguments @var{start} and @var{end} are an
extention to SRFI-43, and can be used to limit the range of the
search in @var{start}-th element (inclusive) to
@var{end}-th element (exclusive).
@end defun

@defun vector-any pred vec1 vec2 @dots{}
[SRFI-43]
Applies @var{pred} on each corresponding elements 
of @var{vec1} @var{vec2} @dots{} left to right, and
as soon as @var{pred} returns non-@code{#f} value, 
the procedure stops iteration and returns the value.

If no elements that satisfy @var{pred} are found, it returns @code{#f}.

Vectors can have different lengths.  Iteration stops at the end
of the shortest.
@end defun

@defun vector-every pred vec1 vec2 @dots{}
[SRFI-43]
Applies @var{pred} on each corresponding elements 
of @var{vec1} @var{vec2} @dots{} left to right.
If all the elements (when the lengths of vectors differ, the
first N elements where N is the length of the shortest) satisfy
@var{pred}, returns the last result of @var{pred}.   Otherwise
returns @code{#t}.
@end defun

@subheading Vector mutators

@defun vector-swap! vec i j
[SRFI-43]
Swaps vector @var{vec}'s @code{i}-th and @code{j}-th elements.
@end defun

@defun vector-reverse! vec &optional start end
[SRFI-43]
@end defun

@defun vector-copy! target tstart source &optional sstart send
[SRFI-43]
@end defun

@defun vector-reverse-copy! target tstart source &optional sstart send
[SRFI-43]
@end defun

@subheading Vector conversion

@defun reverse-vector->list vec &optional start end
[SRFI-43]
@end defun

@defun reverse-list->vector list &optional start end
[SRFI-43]
@end defun

@c ----------------------------------------------------------------------
@node Requiring extensions,  , Vector library, Library modules - SRFIs
@section @code{srfi-55} - Requiring extensions
@c NODE Requiring extensions, @code{srfi-55} - require の拡張

@deftp {Module} srfi-55
@mdindex srfi-55
This module defines @code{require-extension} macro, a yet another way
to write portable scripts.  See @ref{Feature conditional} and
@ref{Feature-based program configuration language} for other means of
ensuring specific features.

This module is autoloaded when you use @code{require-extension}, so
you don't need explicitly say @code{(use srfi-55)}; for portable scripts,
you shouldn't.
@end deftp

@defmac require-extension clause @dots{}
Make extension(s) specified by @var{clause}s available in the rest
of the program.

A @var{clause} takes the following form:
@example
(@var{extension-id} @var{extension-arg} @dots{})
@end example

Currently, only @code{srfi} is supported as @var{extension-id}, and
its arguments are SRFI numbers.

For example, the following form:
@example
(require-extension (srfi 1 13 14))
@end example

Roughly correspons to Gauche's @code{use} forms:
@example
(use srfi-1)
(use srfi-13)
(use srfi-14)
@end example
@end defmac

@node Library modules - Utilities, References, Library modules - SRFIs, Top
@chapter Library modules - Utilities
@c NODE ライブラリモジュール - ユーティリティ


@c ----------------------------------------------------------------------
@menu
* Binary I/O::                  binary.io
* Packing Binary Data::         binary.pack
* Rational-less arithmetic::    compat.norational
* Database independent access layer::  dbi
* Generic DBM interface::       dbm
* File-system dbm::             dbm.fsdbm
* GDBM interface::              dbm.gdbm
* NDBM interface::              dbm.ndbm
* Original DBM interface::      dbm.odbm
* Filtering file content::      file.filter
* Filesystem utilities::        file.util
* Mathematic constants::        math.const
* Mersenne-Twister random number generator::  math.mt-random
* RFC822 message parsing::      rfc.822
* Base64 encoding/decoding::    rfc.base64
* HTTP cookie handling::        rfc.cookie
* FTP::                         rfc.ftp
* HMAC keyed-hashing::          rfc.hmac
* HTTP::                        rfc.http
* IP packets::                  rfc.ip
* ICMP packets::                rfc.icmp
* MD5 message digest::          rfc.md5
* MIME message handling::       rfc.mime
* Quoted-printable encoding/decoding::  rfc.quoted-printable
* SHA1 message digest::         rfc.sha1
* URI parsing and construction::  rfc.uri
* SLIB::                        slib
* Functional XML parser::       sxml.ssax
* SXML Query Language::         sxml.sxpath
* Manipulating SXML structure::  sxml.tools
* Serializing XML and HTML from SXML::  sxml.serializer
* CSV tables::                  text.csv
* Calculate difference of text streams::  text.diff
* Localized messages::          text.gettext
* Simple HTML document construction::  text.html-lite
* Parsing input stream::        text.parse
* Showing progress on text terminals::  text.progress
* SQL parsing and construction::  text.sql
* Transliterate characters::    text.tr
* Lazy text construction::      text.tree
* Combination library::         util.combinations
* Message digester framework::  util.digest
* Determine isomorphism::       util.isomorph
* The longest common subsequence::  util.lcs
* Additional list library::     util.list
* Pattern matching::            util.match
* Queue::                       util.queue
* Red black tree::              util.rbtree
* SLIB-compatible record type::  util.record
* Relation framework::          util.relation
* Stream library::              util.stream
* Trie::                        util.trie
* Topological sort::            util.toposort
* CGI Utility::                 www.cgi
* CGI testing::                 www.cgi.test
@end menu

@c ----------------------------------------------------------------------
@node Binary I/O, Packing Binary Data, Library modules - Utilities, Library modules - Utilities
@section @code{binary.io} - Binary I/O
@c NODE バイナリI/O, @code{binary.io} - バイナリI/O

@deftp {Module} binary.io
@mdindex binary.io
This module provides basic procedures to perform binary I/O
of numeric data.  Each datum can be read from or written to a port,
and got from or put to a uniform vector (see @ref{Uniform vectors}).
For structured binary data I/O,
more convenient @code{pack} utility is implemented
on top of this module (see @ref{Packing Binary Data}).
You might want to use this module directly if you need
speed or want a flexible control of endianness.

See also @ref{Uniform vectors}, which provides binary block I/O.
@end deftp

@subheading Endianness
Most procedures of this module take an optional @var{endian} argument,
specifying the byte order of the binary input.
It must be either one of symbols @code{big-endian}, @code{little-endian},
or @code{arm-little-endian}.
If the endian argument is omitted, the current value of the builtin
parameter @code{default-endian} is used.  The default value of
the @code{default-endian} parameter is the machine's native endian.
(For 8-bit I/O procedures like @code{read-u8} the endian
argument has no effect, but is accepted for consistency).

@deffn {Builtin Parameter} default-endian &optional value
When called without @var{value}, returns the current default
endian.  When called with @var{value}, sets the current endian
to the @var{value}, which must be one of the following symbols:
@table @code
@item big-endian
Big endian.  An integer @code{#x12345678} is written out as an octet
sequence @code{#x12 #x34 #x56 #x78}.
@item little-endian
Little endian.  An integer @code{#x12345678} is written out as an octet
sequence @code{#x78 #x56 #x34 #x12}.
@item arm-little-endian
This is a variation of @code{little-endian}, and used in ARM
processors in some specific modes.  It works just like @code{little-endian},
except reading/writing double-precision floating point number (@code{f64}),
which is written as two little-endian 32bit words ordered by big-endian
(e.g. If machine register's representation is @code{#x0102030405060708},
it is written as @code{#x04 #x03 #x02 #x01 #x08 #x07 #x06 #x05}.
@end table

The default endian value is thread-local.  You can use @code{parameterize}
(@xref{Parameters}) to switch default endianness within certain dynamic scope.
@end deffn

@subheading I/O using port

@defun read-u8 &optional port endian
@defunx read-u16 &optional port endian
@defunx read-u32 &optional port endian
@defunx read-u64 &optional port endian
Reads 8, 16, 32 or 64 bit unsigned integer from @var{port}
with specified endian, respectively.  If @var{port} is omitted, 
current input port is used.  If @var{port} reaches EOF before
a complete integer is read, EOF is returned.
@end defun

@defun read-s8 &optional port endian
@defunx read-s16 &optional port endian
@defunx read-s32 &optional port endian
@defunx read-s64 &optional port endian
Reads 8, 16, 32 or 64 bit 2's complement signed integer from @var{port}
with specified endian, respectively.  If @var{port} is omitted, 
current input port is used.  If @var{port} reaches EOF before
a complete integer is read, EOF is returned.
@end defun

@defun read-uint size &optional port endian
@defunx read-sint size &optional port endian
More flexible version.  Reads @var{size}-octet unsigned
or signed integer from @var{port} with specified endian.
If @var{port} reaches EOF before a complete integer is read,
EOF is returned.
@end defun

@defun read-ber-integer &optional port
Reads BER compressed integer a la X.209.
A BER compressed integer is an unsigned integer in base 128,
most  significant digit first, where the high bit is set on all but the
final (least significant) byte.
@end defun

@defun write-u8 val &optional port endian
@defunx write-u16 val &optional port endian
@defunx write-u32 val &optional port endian
@defunx write-u64 val &optional port endian
Writes a nonnegative integer @var{val} as 8, 16, 32 or 64 bit
unsigned integer
to @var{port} with specified endian, respectively.  @var{Val} must be within
the range of integers representable by the specified bits.
When @var{port} is omitted, current output port is used.
@end defun

@defun write-s8 val &optional port endian
@defunx write-s16 val &optional port endian
@defunx write-s32 val &optional port endian
@defunx write-s64 val &optional port endian
Writes an integer @var{val} as 8, 16, 32 or 64 bit
as 2's complement signed integer to @var{port} with specified endian,
respectively.  @var{Val} must be within
the range of integers representable by the specified bits.
When @var{port} is omitted, current output port is used.
@end defun

@defun write-uint size val &optional port endian
@defunx write-sint size val &optional port endian
More flexible version.  Writes an integer @var{val} as unsigned
or signed integer of @var{size} bytes to @var{port} with
specified endian.
When @var{port} is omitted, current output port is used.
@end defun

@defun write-ber-integer val &optional port
Writes a nonnegative integer @var{val} in BER compressed integer
to @var{port}.  See @code{read-ber-integer} above for BER format.
@end defun

@defun read-f16 &optional port endian
@defunx read-f32 &optional port endian
@defunx read-f64 &optional port endian
Reads 16, 32, or 64-bit floating point numbers, respectively.
32bit is IEEE754 single-precision, and 64bit is
IEEE754 double-precision numbers.  16-bit floating
point number consists of 1-bit sign, 5-bit exponent and
10-bit mantissa, as used in some HDR image format.

If @var{port} is omitted, 
current input port is used.  If @var{port} reaches EOF before
a complete number is read, EOF is returned.
@end defun

@defun write-f16 val &optional port endian
@defunx write-f32 val &optional port endian
@defunx write-f64 val &optional port endian
Writes a real number @var{val} to @var{port} in 16, 
32, or 64-bit floating point number, respectively.
If @var{port} is omitted, current output port is used. 
@end defun


@subheading I/O using uniform vectors

In the following routines, the argument @var{uv} can be any
type of uniform vector; if it is not a @code{u8vector}, it is
treated as if @code{(uvector-alias <u8vector> @var{uv})} is
called---that is, it reads directly from the memory image
that holds the uvector's content.  The @var{pos} argument
specifies the byte position from the beginning of the memory
area (it is always byte position, regardless of the uniform
vector's element size).

@defun get-u8 uv pos &optional endian
@defunx get-u16 uv pos &optional endian
@defunx get-u32 uv pos &optional endian
@defunx get-u64 uv pos &optional endian
@defunx get-s8 uv pos &optional endian
@defunx get-s16 uv pos &optional endian
@defunx get-s32 uv pos &optional endian
@defunx get-s64 uv pos &optional endian
@defunx get-f16 uv pos &optional endian
@defunx get-f32 uv pos &optional endian
@defunx get-f64 uv pos &optional endian
Reads a number of a specific format from a uniform vector @var{uv},
starting at a byte position @var{pos}.  An error is signalled
if the specified position makes reference outside of the uniform
vector's content.  Returns the read number.
@end defun

@defun get-u16be uv pos
@defunx get-u16le uv pos
@defunx get-u32be uv pos
@defunx get-u32le uv pos
@defunx get-u64be uv pos
@defunx get-u64le uv pos
@defunx get-s16be uv pos
@defunx get-s16le uv pos
@defunx get-s32be uv pos
@defunx get-s32le uv pos
@defunx get-s64be uv pos
@defunx get-s64le uv pos
@defunx get-f16be uv pos
@defunx get-f16le uv pos
@defunx get-f32be uv pos
@defunx get-f32le uv pos
@defunx get-f64be uv pos
@defunx get-f64le uv pos
These are big-endian (@code{be}) or little-endian (@code{le}) specific
versions of @code{get-*} procedures.  In speed-sensitive code,
you might want to use these to avoid the overhead of optional-argument
handling.
@end defun

@defun put-u8! uv pos val &optional endian
@defunx put-u16! uv pos val &optional endian
@defunx put-u32! uv pos val &optional endian
@defunx put-u64! uv pos val &optional endian
@defunx put-s8! uv pos val &optional endian
@defunx put-s16! uv pos val &optional endian
@defunx put-s32! uv pos val &optional endian
@defunx put-s64! uv pos val &optional endian
@defunx put-f16! uv pos val &optional endian
@defunx put-f32! uv pos val &optional endian
@defunx put-f64! uv pos val &optional endian
Writes a number @var{val} into a uniform vector @var{uv} in
a specific format, starting at a byte position @var{pos}.
An error is signalled
if the specified position makes reference outside of the uniform
vector's content.
@end defun

@defun put-u16be! uv pos val
@defunx put-u16le! uv pos val
@defunx put-u32be! uv pos val
@defunx put-u32le! uv pos val
@defunx put-u64be! uv pos val
@defunx put-u64le! uv pos val
@defunx put-s16be! uv pos val
@defunx put-s16le! uv pos val
@defunx put-s32be! uv pos val
@defunx put-s32le! uv pos val
@defunx put-s64be! uv pos val
@defunx put-s64le! uv pos val
@defunx put-f16be! uv pos val
@defunx put-f16le! uv pos val
@defunx put-f32be! uv pos val
@defunx put-f32le! uv pos val
@defunx put-f64be! uv pos val
@defunx put-f64le! uv pos val
These are big-endian (@code{be}) or little-endian (@code{le}) specific
versions of @code{put-*} procedures.  In speed-sensitive code,
you might want to use these to avoid the overhead of optional-argument
handling.
@end defun

@subheading Compatibility notes

@code{read-u8} etc. were called @code{read-binary-uint8} etc., and 
@code{read-f32} and @code{read-f64} were called @code{read-binary-float}
and @code{read-binary-double}, respectively.
These old names are still supported for the backward compatibility
but their use is deprecated.  The reason of the changes is
for brevity and for consistency with the uniform vectors.

@c ----------------------------------------------------------------------
@node Packing Binary Data, Rational-less arithmetic, Binary I/O, Library modules - Utilities
@section @code{binary.pack} - Packing Binary Data
@c NODE バイナリデータのパック, @code{binary.pack} - バイナリデータのパック

@deftp {Module} binary.pack
@mdindex binary.pack
This module provides an interface for packing and unpacking (writing
and reading) binary data with templates.  The functionality was
inspired largely by the Perl pack/unpack functions, with comparison of
similar features from other languages, however an effort was made to
make it more general and more efficient, to be usable for
database-like processing.  To that end, the most notable differences
are that any packable value is unpackable (and vice versa), and the
default behavior is to pack and unpack using port I/O, so you can seek
in a large file and unpack from it.  Also, templates may be stored as
dispatch closures to pack, unpack or even skip over values without
re-parsing the template.

@c See also binary.io - Binary I/O for utilities to read and write
@c individual binary values.
@end deftp

@defun pack template list &keyword :output :to-string?
Writes the values in @var{list} to the current output port, according
to the format specified by the string @var{template}.  The template
string is a series of single character codes, optionally followed by a
numeric count (which defaults to 1).
The format characters can generally be divided into string types,
which interpret the count as a string byte size, and object types,
which treat the count as a repetition indicator.  The count may be
specified as the character @code{*}, which means to use the full
size of the string for string types, and use all remaining values for
object types.
Counts may also be specified as a template enclosed in brackets, which
means the count is the byte size of the enclosed template.  For
example, @code{x[L]} skips a long.
The special format character @code{/} may be used to indicate a
structure where the packed data contains a dynamic count followed by
the value itself.  The template is written as
@code{<count-item>/<value-item>}, where @code{<count-item>} is any
template character to be interpreted as a numeric count, and
@code{<value-item>} is any other template character to use this count.
If a normal count is given after @code{<value-item>} it is ignored.
The format character @code{@@} may be used with a count to pad to an
absolute position since the start of the template.
Sub-templates may be grouped inside parentheses.  If angle-brackets
are used, then they also behave as group operators but recursively
operate on nested lists.
The string types:
@table @code
@item a
An arbitrary incomplete string, null padded.

@item A
A text string, space padded.

@item Z
A null terminated (ASCIZ) string, null padded.

@item b
A bit string (ascending bit order inside each byte).

@item B
A bit string (descending bit order inside each byte).

@item h
A hex string (low nybble first).

@item H
A hex string (high nybble first).
@end table

The object types:

@table @code
@item c
A signed 8bit integer.

@item C
An unsigned 8bit integer.

@item s
A signed short (16 bit) value.

@item S
An unsigned short (16 bit) value.

@item i
A signed integer (>= 32 bit) value.

@item I
An unsigned integer (>= 32 bit) value.

@item l
A signed long (32 bit) value.

@item L
An unsigned long (32 bit) value.

@item n, n!
An unsigned and signed short (16 bit) in "network" (big-endian) order.

@item N, N!
An unsigned and signed long (32 bit) in "network" (big-endian) order.

@item v, v!
An unsigned and signed short (16 bit) in "VAX" (little-endian) order.

@item V, V!
An unsigned and signed long (32 bit) in "VAX" (little-endian) order.

@item q
A signed quad (64 bit) value.

@item Q
An unsigned quad (64 bit) value.

@item f
A single-precision float in the native format.

@item d
A double-precision float in the native format.

@item w
A BER compressed integer.  An unsigned integer in base 128, most
significant digit first, where the high bit is set on all but the
final (least significant) byte.  Thus any size integer can be encoded,
but the encoding is efficient and small integers don't take up any
more space than they would in normal char/short/int encodings.

@item x
A null byte.

@item o
An sexp, handled with @code{read} and @code{write}.

@end table

If the optional keyword @var{:output} is given that port is used
instead of the current output port.  If @var{:to-string?} is given and
true, then pack accumulates and returns the output as a string.

Note that the returned string may be an incomplete string
if the packed string contains a byte sequence invalid as
a character sequence.

@example
(pack "CCCC" '(65 66 67 68) :to-string? #t)
 @result{} "ABCD"

(pack "C/a*" '("hello") :to-string? #t)
 @result{} "\x05hello"
@end example
@end defun

@defun unpack template &keyword :input :from-string
The complement of pack, unpack reads values from the current input
port assuming they've been packed according to the string template and
returns the values as a list.  unpack accepts the same format strings
as pack.  Further, the following tautology holds:

@example
(equal? x (unpack fmt :from-string (pack fmt x :to-string? #t)))
@end example

for any list @var{x} and format string @var{fmt}.  The only exceptions
to this are when the template includes a @code{*} and when the
@code{o} template is used, since Scheme numeric literals cannot be
reliably delimited (though future versions of @code{pack} may
circumvent this by registering a new read syntax).

If the optional keyword @var{:input} is given that port is used
instead of the current input port.  If @var{:from-string} is given,
then pack reads input from that string.

@example
(unpack "CCCC" :from-string "ABCD")
 @result{} '(65 66 67 68)

(unpack "C/a*" :from-string "\x05hello")
 @result{} '("hello")
@end example

@emph{Note:} in the current version, @code{@@} in @code{unpack}
template has a bug and does not work as supposed.  It will
be fixed in the future version.
@end defun

@defun unpack-skip template &keyword :input
unpack-skip is the same as unpack except it does not return the
values.  In some cases, particularly with fixed-size templates, this
can be much more efficient when you just want to skip over a value.
@end defun

@defun make-packer template
The low-level interface.  This function returns a dispatch closure
that can be used to pack, unpack and skip over the same cached
template.  The dispatch closure accepts symbol methods as follows:

@table @code
@item 'pack list
pack the items in list to the current output port.

@item 'unpack
unpack items from the current input port.

@item 'skip
skip items from the current input port.

@item 'packer
return the cached 'pack closure

@item 'unpacker
return the cached 'unpack closure.

@item 'skipper
return the cached 'skip closure.

@item 'length
return the known fixed length of the template.

@item 'variable-length?
return #t if the template has variable length elements.
@end table
@end defun

@c ----------------------------------------------------------------------

@node Rational-less arithmetic, Database independent access layer, Packing Binary Data, Library modules - Utilities
@section @code{compat.norational} - Rational-less arithmetic
@c NODE @code{compat.norational} - 有理数のない算術演算

@deftp {Module} compat.norational
@mdindex compat.norational

Until release 0.8.7, Gauche didn't have exact rational numbers.
It was able to read the rational number literals such as
@code{2/3}, but they are immediately coerced to inexact real
numbers (except when it represents a whole integer).
And if you divided an exact integer by another exact integer,
the result could be coerced to an inexact real if the result
wasn't a whole integer.

As of 0.8.8, this is not the case anymore.  Exact division
always yields exact result, except when the divisor is zero.
@example
(/ 2 3)  @result{} 2/3
(/ 5)    @result{} 1/5
(/ 4 2)  @result{} 2
@end example

This is more precise, but has one drawback: exact rational
arithmetic is much slower than the integer and inexact real
arithmetic.  If you inadvertently produce
a rational number in the early stage of calculation, and
continue to apply exact arithmetic, performance would be
degraded miserably.

The proper way to solve this is to insert @code{exact->inexact}
to appropriate places.  However, to ease the transition, you can
just import this module and the division @code{/} behaves
in the way it used to.

@example
(use compat.norational)

(/ 2 3)  @result{} 0.6666666666666666
(/ 5)    @result{} 0.2
(/ 4 2)  @result{} 2
@end example

The effect is not global, but only to the modules you explicitly
import @code{compat.norational}.

This module only redefines @code{/}.  So if your code has
exact rational literals, they are treated as exact rationals
rather than coerced to inexact reals.  You should prefix
rational literals with @code{#i} to force Gauche to coerce
them to inexact reals:
@example
gosh> 1/3
1/3
gosh> #i1/3
0.3333333333333333
@end example
@end deftp

@c ----------------------------------------------------------------------

@node Database independent access layer, Generic DBM interface, Rational-less arithmetic, Library modules - Utilities
@section @code{dbi} - Database independent access layer
@c NODE @code{dbi} - データベース非依存アクセス層

@deftp {Module} dbi
@mdindex dbi
This module provides the unified interface to access various 
relational database systems (RDBMS).  The operations specific
to individual database systems are packaged
in database driver (DBD) modules, which is usually loaded
implicitly by DBI layer.

The module is strongly influenced by Perl's DBI/DBD architecture.
If you have used Perl DBI, it would be easy to use this module.
@end deftp

It's better to look at the example.  This is a simple outline
of accessing a database by @code{dbi} module:

@example
(guard (e ((<dbi-error> e)
           ;; handle error
           ))
  (let* ((conn   (dbi-connect "dbi:mysql:test;host=dbhost"))
         (query  (dbi-prepare conn
                   "SELECT id, name FROM users WHERE department = ?"))
         (result (dbi-execute query "R&D"))
         (getter (relation-accessor result)))
    (map (lambda (row)
           (list (getter row "id")
                 (getter row "name")))
         result)))
@end example

There's nothing specific to the underlying database system
except the argument @code{"dbi:mysql:test;host=dbhost"}
passed to @code{dbi-connect}, from which @code{dbi} module
figures out that it is an access to @code{mysql} database,
loads @code{dbd.mysql} module, and let it handle the mysql-specific
stuff.  If you want to use whatever database system, you can just
pass @code{"dbi:@var{whatever}:@var{parameter}"} to @code{dbi-connect}
instead, and everything stays the same as far as you have
@code{dbd.whatever} installed in your system.

A query to the database can be created by @code{dbi-prepare}.
You can issue the query by @code{dbi-execute}.  This two-phase
approach allows you to create a prepared query, which is a kind of
parameterized SQL statement.  In the above example the query
takes one parameter, denoted as @code{'?'} in the SQL.
The actual value is given in @code{dbi-execute}.  When you
issue similar queries a lot, creating a prepared query and
execute it with different parameters may give you performance gain.
Also the parameter is automatically quoted.

When the query is a @code{SELECT} statement,
its result is returned as a collection that implements 
the relation protocol.  See @ref{Collection framework}
and @ref{Relation framework} for the details.

The outermost @code{guard} is to catch errors.  The @code{dbi} related
errors are supposed to inherit @code{<dbi-error>} condition.
There are a few specific errors defined in @code{dbi} module.
A specific @code{dbd} layer may define more specific errors.

In the next section we describe user-level API, that is,
the procedures you need to concern when you're using @code{dbi}.
The following section is for the driver API, which you need to use
to write a specific @code{dbd} driver to make it work with @code{dbi}
framework.

@menu
* DBI user API::                
* Writing drivers for DBI::     
@end menu

@node DBI user API, Writing drivers for DBI, Database independent access layer, Database independent access layer
@subsection DBI user API
@c NODE DBIのユーザAPI

@subsubheading DBI Conditions

There are several predefined conditions @code{dbi} API may throw.
See @ref{Exceptions} for the details of conditions.

@deftp {Condition} <dbi-error>
The base class of @code{dbi}-related conditions.  Inherits @code{<error>}.
@end deftp

@deftp {Condition} <dbi-nonexistent-driver-error>
This condition is thrown by @code{dbi-connect} when it cannot
find the specified driver.  Inherits @code{<dbi-error>}.

@defivar <dbi-nonexistent-driver-error> driver-name
Holds the requested driver name as a string.
@end defivar
@end deftp

@deftp {Condition} <dbi-unsupported-error>
This condition is thrown when the called method isn't supported 
by the underlying driver.  Inherits @code{<dbi-error>}.
@end deftp

@deftp {Condition} <dbi-parameter-error>
This condition is thrown when the number of parameters given to
the prepared query doesn't match the ones in the prepared statement.
@end deftp

Besides these errors, if a driver relies on @code{dbi} to
parse the prepared SQL statement, @code{<sql-parse-error>} may 
be thrown if an invalid SQL statement is passed to @code{dbi-prepare}.
(@xref{SQL parsing and construction}).

@subsubheading Connecting to the database

@defun dbi-connect dsn &keyword username password
Connect to a database using a data source specified by @var{dsn}
(data source name).  @var{Dsn} is a string with the following syntax:
@example
dbi:@var{driver}:@var{options}
@end example

@var{Driver} part names a specific driver.  You need to have the
corresponding driver module, @code{dbd.@var{driver}}, installed in
your system.  For example, if @var{dsn} begins with @code{"dbi:mysql:"},
@code{dbi-connect} tries to load @code{dbd.mysql}.

Interpretation of the @var{options} part is up to the driver.
Usually it is in the form of @code{key1=value1;key2=value2;...},
but some driver may interpret it differently.  For example,
@code{mysql} driver allows you to specify a database name
at the beginning of @var{options}.   You have to check out
the document of each driver for the exact specification of
@var{options}.

The keyword arguments gives extra information required for
connection.  The @var{username} and @var{password} are commonly
supported arguments.  The driver may recognize more keyword arguments.

If a connection to the database is successfully established,
a connection object (an instance of a subclass of @code{<dbi-connection>})
is returned.  Otherwise, an error is signalled.
@end defun

@deftp {Class} <dbi-connection>
The base class of a connection to a database system.
Each driver defines a subclass of this to keep information about
database-specific connections.
@end deftp

@deffn {Method} dbi-open? (c <dbi-connection>)
Queries whether a connection to the database is still open (active).
@end deffn

@deffn {Method} dbi-close (c <dbi-connection>)
Closes a connection to the database.  This causes releasing resources
related to this connection.   Once closed, @var{c} cannot
be used for any dbi operations (except passing to @code{dbi-open?}).
Calling @code{dbi-close} on an already closed connection has no effect.

Although a driver usually closes a connection when @code{<dbi-connection>}
object is garbage-collected, it is not a good idea to rely on that,
since the timing of GC is unpredictable.  The user program must make
sure that it calls @code{dbi-close} at a proper moment.
@end deffn

@defun dbi-list-drivers
Returns a list of module names of known drivers.
@end defun

@deftp {Class} <dbi-driver>
The base class of a driver.  You usually don't need to see this
as far as you're using the high-level @code{dbi} API.
@end deftp

@defun dbi-make-driver driver-name
This is a low-level function called from @code{dbi-connect} method,
and usually a user doesn't need to call it.

Loads a driver module specified by @var{driver-name}, and
instantiate the driver class and returns it.
@end defun

@subsubheading Preparing and issuing queries

@deffn {Method} dbi-prepare conn sql &keyword pass-through @dots{}
From a string representation of SQL statement @var{sql},
creates and returns a query object (an instance of @code{<dbi-query>}
or its subclass) for the database connection @code{conn}

@var{Sql} may contain parameter slots, denoted by @code{?}.
@example
(dbi-prepare conn "insert into tab (col1, col2) values (?, ?)")

(dbi-prepare conn "select * from tab where col1 = ?")
@end example

They will be filled when you actually issue the query by
@code{dbi-execute}.
There are some advantages of using parameter
slots: (1) The necessary quoting is done automatically.
You don't need to concern about security holes caused by
improper quoting, for example.
(2) Some drivers support a feature to send the template SQL
statement to the server at the preparation stage, and send
only the parameter values at the execution stage.  It would be
more efficient if you issue similar queries lots of time.

If the backend does't support prepared statements (SQL templates
having @code{?} parameters), the driver may use @code{text.sql}
module to parse @var{sql}.  It may raise @code{<sql-parse-error>}
condition if the given SQL is not well formed.

You may pass a true value to the keyword argument @var{pass-through}
to suppress interpretation of SQL and pass @var{sql} as-is to the
back end database system.  It is useful if the back-end supports
extension of SQL which @code{text.sql} doesn't understand.

If the driver lets prepared statement handled in back-end,
without using @code{text.sql}, the @code{pass-through} argument
may be ignored.
The driver may also take other keyword arguments.  Check out
the documentation of individual drivers.

@emph{Note:} Case folding of SQL statement
is implementation dependent.  Some DBMS may treat table
names and column names in case insensitive way, while
others do in case sensitive way.  To write a portable
SQL statement, make them quoted identifiers, that is,
always surround names by double quotes.
@end deffn

@deftp {Class} <dbi-query>
Holds information about prepared query, created by @code{dbi-prepare}.
The following slots are defined.

@defivar <dbi-query> connection
Contains the @code{<dbi-connection>} object.
@end defivar

@defivar <dbi-query> prepared
If the driver prepares query by itself, this slot may contain
a prepared statement.  It is up to each driver how to use
this slot, so the client shouldn't rely on its value.
@end defivar

@end deftp

@deffn {Method} dbi-open? (q <dbi-query>)
Returns @code{#t} iff the query can still be passed to
@code{dbi-execute}.
@end deffn

@deffn {Method} dbi-close (q <dbi-query>)
Destroy the query and free resources associated to the query.
After this operation, @code{dbi-open?} returns @code{#f} for @var{q},
and the query can't be used in any other way.  Although the resource
may be freed when @var{q} is garbage-collected, it is strongly recommended
that the application closes queries explicitly.
@end deffn

@deffn {Method} dbi-execute (q <dbi-query>) parameter @dots{}
Executes a query created by @code{dbi-prepare}.  You should pass
the same number of @var{parameter}s as the query expects.

If the issued query is @code{select} statement, @code{dbi-execute}
returns an object represents a @emph{relation}.
A relation encapsulates the values in
rows and columns, as well as meta information like column names.
See "Retrieving query results" below for how to access the result.

If the query is other types, such as @code{create}, @code{insert} 
or @code{delete}, the return value of the query closure is unspecified.
@end deffn

@deffn {Method} dbi-do conn sql &optional options parameter-value @dots{}
This is a convenience procedure when you create a query
and immediately execute it.   It is equivalent to the following
expression, although the driver may overload this method to avoid
creating intermediate query object to avoid the overhead.
@example
(dbi-execute (apply dbi-prepare conn sql options)
             parameter-value @dots{})
@end example
@end deffn

@deffn {Method}  dbi-escape-sql conn str
Returns a string where special characters in @var{str} are escaped.

The official SQL standard only specify a single quote (@code{'}) as
such character.  However, it doesn't specify non-printable characters,
and the database system may use other escaping characters.  So 
it is necessary to use this method rather than doing escaping
by your own.

@example
;; assumes c is a valid DBI connection
(dbi-escape-sql c "don't know")
  @result{} "don''t know"
@end example
@end deffn

@subsubheading Retrieving query results

If the query is a @code{select} statement, it returns an object
of both @code{<collection>} and @code{<relation>}.   
It is a collection of rows (that is, it implements @code{<collection>} API),
so you can use @code{map}, @code{for-each} or other generic functions
to access rows.  You can also use the relation API to retrieve column
names and accessors from it.  See @ref{Relation framework}, for the relation
API, and @ref{Collection framework}, for the collection API.

The actual class of the object returned from a query depends on
the driver, but you may use the following method on it.

@deffn {Method} dbi-open? result
Check whether the result of a query is still active.
The result may become inactive when it is explicitly closed
by @code{dbi-close} and/or the connection to the database is
closed.
@end deffn

@deffn {Method} dbi-close result
Close the result of the query.  This may cause releasing resources
related to the result.   You can no longer use @var{result} once it is
closed, except passing it to @code{dbi-open?}.

Although a driver usually releases resources when the result is
garbage-collected, the application shouldn't rely on that and
is recommended call @code{dbi-close} explicitly when it is done
with the result.
@end deffn

@node Writing drivers for DBI,  , DBI user API, Database independent access layer
@subsection Writing drivers for DBI
@c NODE DBI用のドライバを書く

Writing a driver for a specific database system means implementing
a module @code{dbd.@var{foo}}, where @var{foo} is the name of the driver.

The module have to implement several classes and methods, as explained below.

@subsubheading DBI classes to implement

You have to define the following classes.

@itemize @bullet
@item
Subclass @code{<dbi-driver>}.  
The class name @emph{must} be @code{<@var{foo}-driver>}, where
@var{foo} is the name of the driver.  
Usually this class produces a singleton instance, 
and is only used to dispatch @code{dbi-make-connection}
method below.
@item
Subclass @code{<dbi-connection>}.  An instance of this class is created
by @code{dbi-make-connection}.  It needs to keep the information about
the actual connections.
@item
Subclass @code{<relation>} and @code{<collection>} to represent
query results suitable for the driver.  (In most cases, the order of
the result of SELECT statement is significant, since it may be 
sorted by ORDER BY clause.  Thus it is more appropriate to
inherit @code{<sequence>}, rather than @code{<collection>}).
@item
Optionally, subclass @code{<dbi-query>} to keep driver-specific
information of prepared queries.
@end itemize

@subsubheading DBI methods to implement

The driver need to implement the following methods.

@deffn {Method} dbi-make-connection (d <foo-driver>) (options <string>) (option-alist <list>) &keyword username password @dots{} 
This method is called from @code{dbi-connect}, and responsible to
connect to the database and to create a connection object.
It must return a connection object, or raise an @code{<dbi-error>} if
it cannot establish a connection.

@var{Options} is the option part of the data source name (DSN) given to
@code{dbi-connect}.  @var{Option-alist} is an assoc list of
the result of parsing @var{options}.  Both are provided so that
the driver may interpret @var{options} string in nontrivial way.

For example, given @code{"dbi:foo:myaddressbook;host=dbhost;port=8998"}
as DSN, foo's @code{dbi-make-connection} will receive
@code{"myaddressbook;host=dbhost;port=8998"} as @var{options},
and @code{(("myaddressbook" . #t) ("host" . "dbhost") ("port" . "8998"))}
as @var{optons-alist}.

After @var{options-alist}, whatever keyword arguments given to
@code{dbi-connect} are passed.  DBI protocol currently 
specifies only @var{username} and @var{password}.
The driver may define other keyword arguments.
It is recommended to name the driver-specific keyword arguments
prefixed by the driver name, e.g. for @code{dbd.foo}, it may take
a @code{:foo-whatever} keyword argument.

It is up to the driver writer to define what options are available and
the syntax of the options.  The basic idea is that the DSN
identifies the source of the data; it's role is like URL in WWW.
So, it may include the hostname and port number of the database,
and/or the name of the database, etc.  However, it shouldn't include
information related to authentication, such as username and password.
That's why those are passed via keyword arguments.
@end deffn

@deffn {Method} dbi-prepare (c <foo-connection>) (sql <string>) &keyword pass-through @dots{}
This method should create and return a prepared query object,
which is an instance of @code{<dbi-query>} or its subclass.
The query specified by @var{sql} is issued to the database system
when the prepared query object is passed to @code{dbi-execute}.

The method must set @var{c} to the @code{connection} slot of 
the returned query object.

@var{Sql} is an SQL statement.  It may contain placeholders represented
by @code{'?'}.  The query closure should take the same number of arguments
as of the placeholders.   It is up to the driver whether it parses
@var{sql} internally and construct a complete SQL statement when
the query closure is called, or it passes @var{sql} to the back-end
server to prepare the statement and let the query closure just send
parameters.

If the driver parses SQL statement internally, it should recognize
a keyword argument @code{pass-through}.  If a true value is given,
the driver must treat @code{sql} opaque and pass it as is when
the query closure is called.

The driver may define other keyword arguments.
It is recommended to name the driver-specific keyword arguments
prefixed by the driver name, e.g. for @code{dbd.foo}, it may take
a @code{:foo-whatever} keyword argument.
@end deffn

@deffn {Method} dbi-execute-using-connection (c <foo-connection>) (q <dbi-query>) (params <list>)
This method is called from @code{dbi-execute}.
It must issue the query kept in @var{q}.  If the query is parameterized,
the actual parameters given to @var{dbi-execute} are passed to
@var{params} argument.

If @var{q} is a @code{select}-type query, this method must return
an appropriate relation object.
@end deffn

@deffn {Method} dbi-escape-sql (c <foo-connection>) str
If the default escape method isn't enough, the driver may
overload this method to implement a specific escaping.
For example, MySQL treats backslash characters specially
as well as single quotes, so it has its @code{dbi-escape-sql} 
method.
@end deffn

@deffn {Method} dbi-open? (c <foo-connection>)
@deffnx {Method} dbi-open? (q <foo-query>)
@deffnx {Method} dbi-open? (r <foo-result>)
@deffnx {Method} dbi-close (c <foo-connection>)
@deffnx {Method} dbi-close (q <foo-query>)
@deffnx {Method} dbi-close (r <foo-result>)
Queries open/close status of a connection and a result, and
closes a connection and a result.  The close methods should cause
releasing resources used by connection/result.  The driver
has to allow @code{dbi-close} to be called on a connection or a
result which has already been closed.
@end deffn

@deffn {Method} dbi-do (c <foo-connection>) (sql <string>) &optional options parameter-value @dots{}
The default method uses @code{dbi-prepare} and @code{dbi-execute}
to implement the function.  It just works,
but the driver may overload this method in order to skip
creating intermediate query object for efficiency.
@end deffn

@subsubheading DBI utility functions

The following functions are low-level utilities which you may
use to implement the above methods.

@defun dbi-parse-dsn data-source-name
Parse the data source name (DSN) string given to @code{dbi-connect},
and returns tree values: (1) The driver name in a string. (2)
'options' part of DSN as a string.  (3) parsed options in an assoc
list.  This may raise @code{<dbi-error>} if the given string doesn't
conform DSN syntax.

You don't need to use this to write a typical driver, for the
parsing is done before @code{dbi-make-connection} is called.
This method may be useful if you're writing a kind of meta-driver,
such as a proxy.
@end defun

@defun dbi-prepare-sql connection sql
Parses an SQL statement @var{sql} which may contain placeholders,
and returns a closure, which generates a complete SQL statement when
called with actual values for the parameters.  If the back-end
doesn't support prepared statements, you may use this function
to prepare queries in the driver.

@var{Connection} is a DBI connection to the database.  It is required
to escape values within SQL properly (see @code{dbi-escape-sql} above).

@example
;; assume c contains a valid dbi connection
((dbi-prepare-sql c "select * from table where id=?") "foo'bar")
 => "select * from table where id='foo''bar'"
@end example
@end defun

@c ----------------------------------------------------------------------

@node Generic DBM interface, File-system dbm, Database independent access layer, Library modules - Utilities
@section @code{dbm} - Generic DBM interface
@c NODE 汎用DBMインタフェース, @code{dbm} - 汎用DBMインタフェース

@deftp {Module} dbm
@mdindex dbm
DBM-like libraries provides an easy way to store values to a file,
indexed by keys.  You can think it as a persistent associative memory.

This modules defines @code{<dbm>} abstract class, which has
a common interface to use various DBM-type database packages.
As far as you operate on the already opened database,
importing @code{dbm} module is enough.

To create or open a database, you need a concrete implementation
of the database.  Gauche currently has the following implementations.
Each module defines its own low-level accessing functions
as well as the common interface.
Note that your system may not have one or more of those DBM libraries;
Gauche defines only what the system provides.

@table @code
@item dbm.fsdbm
file-system dbm (@xref{File-system dbm}).

@item dbm.gdbm
GDBM library (@xref{GDBM interface}).

@item dbm.ndbm
NDBM library (@xref{NDBM interface}).

@item dbm.odbm
DBM library  (@xref{Original DBM interface}).
@end table
@end deftp

The following code shows a typical usage of the database.

@example
(use dbm)         ; @r{dbm abstract interface}
(use dbm.gdbm)    ; @r{dbm concrete interface}

; @r{open the database}
(define *db* (dbm-open <gdbm> :path "mydb" :rw-mode :write))

; @r{put the value to the database}
(dbm-put! *db* "key1" "value1")

; @r{get the value from the database}
(define val (dbm-get *db* "key1"))

; @r{iterate over the database}
(dbm-for-each *db* (lambda (key val) (foo key val)))

; @r{close the database}
(dbm-close *db*)
@end example

@menu
* Opening and closing a dbm database::  
* Accessing a dbm database::    
* Iterating on a database::     
* Managing dbm database instance::  
* Writing a dbm implementation::  
@end menu

@node Opening and closing a dbm database, Accessing a dbm database, Generic DBM interface, Generic DBM interface
@subsection Opening and closing a dbm database
@c NODE DBMデータベースのオープンとクローズ

@deftp {Class} <dbm>
@clindex dbm
An abstract class for dbm-style database.  Defindes the common
database operations.   This class has the following instance slots.
They must be set before the database is actually opened by
@code{dbm-open}.

The concrete class may add more slots for finer control on the database,
such as locking.

@defivar <dbm> path
Pathname of the dbm database.  Some dbm implementation may append
suffixes to this.
@end defivar

@defivar <dbm> rw-mode
Specifies read/write mode.  Can be either one of the following keywords:
@table @code
@item :read
The database will be opened in read-only mode.  The database file must
exist when @code{dbm-open} is called.  This is the default value.
@item :write
The database will be opened in Read-write mode.
If the database file does not exist, @code{dbm-open} creates one.
@item :create
The database will be created and opened in Read-write mode.
If the database file exists, @code{dbm-open} truncates it.
@end table
@end defivar

@defivar <dbm> file-mode
Specifies the file permissions (as @code{sys-chmod}) to create the
database.  The default value is @code{#o664}.
@end defivar

@defivar <dbm> key-convert
@defivarx <dbm> value-convert
By default, you can use only strings for both key and values.  With this
option, however, you can specify how to convert other Scheme values to/from
string to be stored in the database.   The possible values are the
followings:
@table @asis
@item @code{#f}
The default value.  Keys (values) are not converted.  They must be
a string.
@item @code{#t}
Keys (values) are converted to its string representation, using 
@code{write}, to store in the database, and converted
back to Scheme values, using @code{read}, to retrieve from the database.
The data must have an external representation that can be read back.
(But it is not checked when the data is written; you'll get an error
when you read the data).  The key comparison is done in the string
level, so the external representation of the same key must match.
@item a list of two procedures
Both procedure must take a single argument.  The first procedure must
receive a Scheme object and returns a string.  It is used to convert
the keys (values) to store in the database.  The second procedure
must receive a string and returns a Scheme object.  It is used to
convert the stored data in the database to a Scheme object.
The key comparison is done in the string
level, so the external representation of the same key must match.
@end table
@end defivar
@end deftp

@deftp {Metaclass} <dbm-meta>
@clindex dbm-meta
A metaclass of @code{<dbm>} and its subclasses.
@end deftp

@deffn {Method} dbm-open (dbm <dbm>)
Opens a dbm database.  @var{dbm} must be an instance of
one of the concrete classes that derived from the @code{<dbm>} class,
and its slots must be set appropriately.   On success, it returns
the @var{dbm} itself.  On failure, it signals an error.
@end deffn

@deffn {Method} dbm-open (dbm-class <dbm-meta>) options @dots{}
A convenient method that creates dbm instance and opens it.
It is defined as follows.
@example
(define-method dbm-open ((class <class>) . initargs)
  (dbm-open (apply make class initargs)))
@end example
@end deffn

Database file is closed when it is garbage collected.
However, to ensure the modification is properly synchronized,
you should close the database explicitly.

@deffn {Method} dbm-close (dbm @code{<dbm>})
Closes a database @var{dbm}.  Once the database is closed, any
operation to access the database content raises an error.
@end deffn

@deffn {Method} dbm-closed? (dbm @code{<dbm>})
Returns true if a database @var{dbm} is already closed, false otherwise.
@end deffn

@node Accessing a dbm database, Iterating on a database, Opening and closing a dbm database, Generic DBM interface
@subsection Accessing a dbm database
@c NODE DBMデータベースのアクセス

Once a database is opened, you can use the following methods
to access individual key/value pairs.

@deffn {Method} dbm-put! (dbm @code{<dbm>}) key value
Put a @var{value} with @var{key}.
@end deffn

@deffn {Method} dbm-get (dbm @code{<dbm>}) key &optional default
Get a value associated with @var{key}.  If no value exists for @var{key}
and @var{default} is specified, it is returned.  If no value exists for
@var{key} and @var{default} is not specified, an error is signalled.
@end deffn

@deffn {Method} dbm-exists? (dbm @code{<dbm>}) key
Return true if a value exists for @var{key}, false otherwise.
@end deffn

@deffn {Method} dbm-delete! (dbm @code{<dbm>}) key
Delete a value associated with @var{key}.  
@end deffn


@node Iterating on a database, Managing dbm database instance, Accessing a dbm database, Generic DBM interface
@subsection Iterating on a dbm database
@c NODE DBMデータベース上の繰り返し処理

To walk over the entire database, following methods are provided.

@deffn {Method} dbm-fold (dbm @code{<dbm>}) procedure knil
The basic iterator.
For each key/value pair, @var{procedure} is called as
@code{(@var{procedure} @var{key} @var{value} @var{r})},
where @var{r} is @var{knil} for the fist call of @var{procedure},
and the return value of the previous call for subsequent calls.
Returns the result of the last call of @var{procedure}.
If no data is in the database, @var{knil} is returned.

The following method returns the sum of all the integer values.
@example
(dbm-fold dbm (lambda (k v r) (if (integer? v) (+ v r) r)) 0)
@end example
@end deffn

@deffn {Method} dbm-for-each (dbm @code{<dbm>}) procedure
For each key/value pair in the database @var{dbm}, @var{procedure}
is called.  Two arguments are passed to @var{procedure}---a key and
a value.   The result of @var{procedure} is discarded.
@end deffn

@deffn {Method} dbm-map (dbm @code{<dbm>}) procedure
For each key/value pair in the database @var{dbm}, @var{procedure}
is called.  Two arguments are passed to @var{procedure}---a key and
a value.   The result of @var{procedure} is accumulated to a list
which is returned as a result of @code{dbm-map}.
@end deffn

@node Managing dbm database instance, Writing a dbm implementation, Iterating on a database, Generic DBM interface
@subsection Managing dbm database instance
@c NODE DBMデータベースインスタンスの管理

Each dbm implementation has its own way to store the
database.  Legacy dbm uses two files, whose names are
generated by adding @file{.dir} and @file{.pag} to the
value of @var{path} slot.  @code{Fsdbm} creates a directory
under @var{path}.  If dbm database is backed up by
some database server, @var{path} may be used only as
a key to the database in the server.
The following methods hide such variations and provides
a convenient way to manage a database itself.   You have to
pass a class that implements a concrete dbm database to their
first argument.

@deffn {Generic Function} dbm-db-exists? class name
Returns @code{#t} if a database of class @var{class}
specified by @var{name} exists.

@example
;; Returns #t if testdb.dir and testdb.pag exist
(dbm-db-exists? <odbm> "testdb")
@end example
@end deffn

@deffn {Generic Function} dbm-db-remove class name
Removes an entire database of class @var{class} specified by
@var{name}.
@end deffn

@deffn {Generic Function} dbm-db-copy class from to
Copy a database of class @var{class} specified by
@var{from} to @var{to}.  The integrity of @var{from}
is guaranteed if the @var{class}'s dbm implementation supports
locking (i.e. you won't get a corrupted database even if
some other process is trying to write to @var{from}
during copy).   If the destination database @var{to} exists,
its content is destroyed.  If this function is interrupted,
whether @var{to} is left in incomplete state or not depends
on the dbm implementation.   The implementation usually tries
its best to provide transactional behavior, that is,
to recover original @var{to} when the copy fails.  However,
for the robust operations the caller have to check the state 
of @var{to} if @code{dbm-db-copy} fails.

@example
(dbm-db-copy <gdbm> "testdb.dbm" "backup.dbm")
@end example
@end deffn

@deffn {Generic Function} dbm-db-move class from to
Moves or renames a database of class @var{class} specified by
@var{from} to @var{to}.  Like @code{dbm-db-copy}, the database
integrity is guaranteed as far as @var{class}'s dbm implementation
supports locking.  If the destination database @var{to} exists,
its content is destroyed.
@end deffn

@node Writing a dbm implementation,  , Managing dbm database instance, Generic DBM interface
@subsection Writing a dbm implementation
@c NODE DBM実装を書く

When you write an extension module that behaves like
a persistent hashtable, it is a good idea to adapt it
to the dbm interface, so that the application can use
the module in a generic way.

The minimum procedures to conform the dbm interface
are as follow:

@itemize @bullet
@item
Define a metaclass @code{<@var{foo}-meta>}.   It doesn't
need to inherit anything except @code{<class>}.
@item
Define a dbm class @code{<@var{foo}>} that inherits @code{<dbm>}
and whose metaclass is @code{<@var{foo}-meta>}.
@item
Define methods for @code{dbm-open}, @code{dbm-close},
@code{dbm-put!}, @code{dbm-get}, @code{dbm-exists},
@code{dbm-delete!}, @code{dbm-fold}, @code{dbm-closed?},
specialized for @code{<@var{foo}>}.
(The case of @code{dbm-open} for @code{<@var{foo}-meta>} is
handled automatically, so you don't need to define it unless
you want something special).
Also note that the specialized @code{dbm-open} must call
@code{next-method} in it to set up dbm base class internals.
@item
Define methods for @code{dbm-db-exists?} and
@code{dbm-db-remove} on @code{<@var{foo}-meta>}.
@end itemize

Besides above, you may define the following methods.

@itemize @bullet
@item
Methods for @code{dbm-for-each} and @code{dbm-map}.
If you don't define them, a generic implementation
by @code{dbm-fold} is used.  There may be an implementation
specific way which is more efficient.
@item
Methods for @code{dbm-db-copy} and @code{dbm-db-move}.
If you don't define them, a fallback method
opens the specified databases and copies elements one by
one, and removes the original if the method is  @code{dbm-db-move}.
Note that the fallback method is not only inefficient,
but also it may not copy any implementation-specific 
meta information.  It is highly recommended for the
dbm implementation to provide these methods as well.
@end itemize

It is generally recommended to name the implementation module 
as @code{dbm.@var{foo}}, and the class of the implementation
as @code{<@var{foo}>}.  With this convention it is easier to
write an application that dynamically loads and uses
dbm implementation specified at runtime.

@c ----------------------------------------------------------------------
@node File-system dbm, GDBM interface, Generic DBM interface, Library modules - Utilities
@section @code{dbm.fsdbm} - File-system dbm
@c NODE ファイルシステムdbm, @code{dbm.fsdbm} - ファイルシステムdbm

@deftp {Module} dbm.fsdbm
@mdindex dbm.fsdbm
Implements fsdbm.  Extends @code{dbm}.
@end deftp

@deftp {Class} <fsdbm>
@clindex fsdbm
@code{Fsdbm} is a dbm implementation that directly uses
the filesystem.  Basically, it uses file names for keys,
and file content for values.   Unlike other dbm implementations,
this doesn't depend on external libraries---it is pure Scheme 
implementation---so it is always available, while other dbm
implementations may not.
Obviously, it is not suitable for the database that has
lots of entries, or has entries deleted and added very frequently.
The advantage is when the number of entries
are relatively small, and the values are relatively large while
keys are small.
The database name given to @code{<fsdbm>} instance
is used as a directory name that stores the data.
The data files are stored in subdirectories under @var{path} of
@code{fsdbm} instance, hashed by the key.  Non-alphanumeric characters
in the key is encoded like @code{_3a} for '@code{:}', for example.
If a key is too long to be a file name, it is chopped to chunks,
and each chunk but the last one is used as a directory name.
Note that a long key name may still cause a problem, for example,
some of old 'tar' command can't deal with pathnames (not each
pathname components, but the entire pathname) longer than 256
characters.
@end deftp

Fsdbm implements all of the dbm protocol 
(see @ref{Generic DBM interface}).
It doesn't have any fsdbm-specific procedures.

@c ----------------------------------------------------------------------
@node GDBM interface, NDBM interface, File-system dbm, Library modules - Utilities
@section @code{dbm.gdbm} - GDBM interface
@c NODE GDBMインタフェース, @code{dbm.gdbm} - GDBMインタフェース

@deftp {Module} dbm.gdbm
@mdindex dbm.gdbm
Provides interface to the gdbm library.  Extends @code{dbm}.
@end deftp

@deftp {Class} <gdbm>
@clindex gdbm
Inherits @code{<dbm>}.  Provides an implementation for GDBM library.
This module is only installed when your system already has GDBM
(1.8.0 is preferred, but works with older 1.7.x with some limitations).

@defivar <gdbm> sync
@end defivar
@defivar <gdbm> nolock
@end defivar
@defivar <gdbm> bsize
@end defivar
@end deftp

Besides the unified DBM interface (@xref{Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the gdbm API.  See gdbm manual for details of these
APIs.

@defun gdbm-open path &optional size rwmode fmode error-callback

@defvar GDBM_READER
@end defvar

@defvar GDBM_WRITER
@end defvar

@defvar GDBM_WRCREAT
@end defvar

@defvar GDBM_NEWDB
@end defvar

@defvar GDBM_FAST
@end defvar

@defvar GDBM_SYNC
@end defvar

@defvar GDBM_NOLOCK
@end defvar
@end defun

@defun gdbm-close gdbm-object
@end defun

@defun gdbm-closed? gdbm-object
@end defun

@defun gdbm-store key value &optional flag


@defvar GDBM_INSERT
@end defvar

@defvar GDBM_REPLACE
@end defvar

@end defun


@defun gdbm-fetch gdbm-object key
@end defun


@defun gdbm-delete gdbm-object key
@end defun


@defun gdbm-firstkey gdbm-object
@end defun


@defun gdbm-nextkey gdbm-object key
@end defun


@defun gdbm-reorganize gdbm-object
@end defun


@defun gdbm-sync gdbm-object
@end defun


@defun gdbm-exists? gdbm-object key
@end defun


@defun gdbm-strerror errno
@end defun


@defun gdbm-setopt gdbm-object option value

@defvar GDBM_CACHESIZE
@end defvar

@defvar GDBM_FASTMODE
@end defvar

@defvar GDBM_SYNCMODE
@end defvar

@defvar GDBM_CENTFREE
@end defvar

@defvar GDBM_COALESCEBLKS
@end defvar
@end defun

@defun gdbm-version
@end defun

@defun gdbm-errno
@end defun

@c ----------------------------------------------------------------------
@node NDBM interface, Original DBM interface, GDBM interface, Library modules - Utilities
@section @code{dbm.ndbm} - NDBM interface
@c NODE NDBMインタフェース, @code{dbm.ndbm} - NDBMインタフェース

@deftp {Module} dbm.ndbm
@mdindex dbm.ndbm
Provides interface to the 'new' dbm library, a.k.a. ndbm.
Extends @code{dbm}.
@end deftp

@deftp {Class} <ndbm>
@clindex ndbm
Inherits @code{<dbm>}.  Provides an implementation for NDBM library.
This module is only installed when your system already has NDBM.
@end deftp

Besides the unified DBM interface (@xref{Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the ndbm API.  See ndbm manual for details of these
APIs.

@defun ndbm-open path flags mode
@end defun

@defun ndbm-close ndbm-object
@end defun

@defun ndbm-closed? ndbm-object
@end defun

@defun ndbm-store ndbm-object key content &optional flag
@end defun

@defun ndbm-fetch ndbm-object key
@end defun

@defun ndbm-delete ndbm-object key
@end defun

@defun ndbm-firstkey ndbm-object
@end defun

@defun ndbm-nextkey ndbm-object
@end defun

@defun ndbm-error ndbm-object
@end defun

@defun ndbm-clear-error ndbm-object
@end defun

@c ----------------------------------------------------------------------
@node Original DBM interface, Filtering file content, NDBM interface, Library modules - Utilities
@section @code{dbm.odbm} - Original DBM interface
@c NODE オリジナルのDBMインタフェース, @code{dbm.odbm} - オリジナルのDBMインタフェース

@deftp {Module} dbm.odbm
@mdindex dbm.odbm
Provides interface to the legacy dbm library.
Extends @code{dbm}.
@end deftp

@deftp {Class} <odbm>
@clindex odbm
Inherits @code{<dbm>}.  Provides an implementation for legacy DBM
library.
This module is only installed when your system already has DBM.

The biggest limitation of the legacy DBM is that you can only open
one database at a time.  You can create a multiple @code{<odbm>}
instances, but you can open at most one of it at a time, or
you'll get an error.
@end deftp

Besides the unified DBM interface (@xref{Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the dbm API.  See dbm manual for details of these
APIs.

@defun odbm-init path
@end defun

@defun odbm-close
@end defun

@defun odbm-store key value
@end defun

@defun odbm-fetch key
@end defun

@defun odbm-delete key
@end defun

@defun odbm-firstkey
@end defun

@defun odbm-nextkey key
@end defun


@c ----------------------------------------------------------------------
@c @node Pseudo DBM interface, gauche.charconv - Character code conversion, Original DBM interface, Library modules
@c @section @code{dbm.pdbm} - Pseudo DBM interface

@c ----------------------------------------------------------------------
@node Filtering file content, Filesystem utilities, Original DBM interface, Library modules - Utilities
@section @code{file.filter} - Filtering file content
@c NODE ファイルのフィルタ, @code{file.filter} - ファイルのフィルタ

@deftp {Module} file.filter
@mdindex file.filter
This module provides utilities for a common pattern in
filter-type commands, that is, to take an input, to process
the content, and to write the result.   The common occurring
pattern is:

@itemize @bullet
@item
Input may be a specified file, or an input port
(the current input port by default).
@item
Output may be a specified file, or an output port
(the current output port by default).
@item
Output may be a temporary file, which will be renamed
upon completion of the processing.
@item
Output file may be removed when an error occurs
in the processing.
@end itemize
@end deftp

@defun file-filter proc &keyword input output temporary-file keep-output?
Calls @var{proc} with two arguments, an input port and 
an output port.   Returns the result(s) of @var{proc}.
The input port and output port are chosen depending on the keyword arguments.

@table @code
@item input
The argument must be either an input port or a string
that specifies a file name.
If it's an input port, it is passed to @var{proc} as is.
If it's a string, the named file is opened for input and the resulting
port is passed to @var{proc}, and the port is closed when @var{proc}
returns.
If this argument is omitted, the current input port is passed.
@item output
The argument must be either an output port or a string
that specifies a file name.
If it's an output port, it is passed to @var{proc} as is.
If it's a string, the named file is opened for output
(unless @var{temporary-file} is given, in that case
a temporary file is opened instead), and the resulting port
is passed to @var{proc}.  This port is closed when @var{proc} returns.
If this argument is omitted, the current output port is passed.
@item temporary-file
If a string file name is given to this argument, the named file
is opened for output during the processing, instead of the file
name as @var{output}.   The output port @var{proc} receives
is connected to this file.  When @var{proc}
returns normally, the file is renamed to the name given to @var{output}
keyword argument.

If the given file name begins with characters except @code{"/"}, @code{"./"}
or @code{"../"}, the directory of the file name given to @var{output} argument
is attached before it.
Furthermore, a unique name is attached to the temporary file name
(the temporary file is opened by @code{sys-mkstemp}.)

This argument is ignored when @var{output} argument is not a string
file name.
@item keep-output?
If a true value is given, the output is not deleted even
when @var{proc} signals an error.
By default, the output (or the temporary file when
@var{temporary-file} is given) will be deleted on error.
@end table
@end defun

@c ----------------------------------------------------------------------
@node Filesystem utilities, Mathematic constants, Filtering file content, Library modules - Utilities
@section @code{file.util} - Filesystem utilities
@c NODE ファイルシステムユーティリティ, @code{file.util} - ファイルシステムユーティリティ

@deftp {Module} file.util
@mdindex file.util
Provides convenient utility functions handling files and directories.
Those functions are built on top of the primitive system
procedures described in @ref{Filesystems}.

Many procedures in this module takes a keyword argument @var{follow-link?},
which specifies the behavior when the procedure sees a symbolic link.
If true value is given to @var{follow-link?} (which is the default),
the procedure operates on the file referenced by the link; if false is 
given, it operates on the link itself.
@end deftp

Note on the naming convention: Some Scheme implementations "create"
new directories and files, while the others "make" them.
Some implementations "delete" them, while the others "remove" them.
It seems that both conventions are equally popular.
So Gauche provides @emph{both}.

@menu
* Directory utilities::         
* Pathname utilities::          
* File attribute utilities::    
* File operations::             
@end menu

@node Directory utilities, Pathname utilities, Filesystem utilities, Filesystem utilities
@subsection Directory utilities
@c NODE ディレクトリユーティリティ

@defun current-directory &optional new-directory
When called with no argument, this returns the pathname of the current
working directory.  When called with a string argument @var{new-directory},
this sets the current working directory of the process to it.
If the process can't change directory to @var{new-directory}, an error is
signalled.

This function is in ChezScheme, MzScheme and some other Scheme
implementations.
@end defun

@defun home-directory &optional user
Returns the home directory of the given @var{user},
which may be a string user name or an integer user id.
If @var{user} is omitted, the current user is assumed.
If the given user cannot be found, or the home directory
of the user cannot be determined, @code{#f} is returned.
@end defun

@defun temporary-directory
Returns the name of the directory that can be used
to create a temporary files.   It returns the value of 
the environment variable @code{TMPDIR} if it is defined,
or @file{/tmp} otherwise.
@end defun

@defun directory-list path &keyword children? add-path? filter filter-add-path?
Returns a list of entries in the directory @var{path}.
The result is sorted by dictionary order.

By default, only the basename (the last component) of the entries
returned.   If @var{add-path?} is given and true, @var{path} is appended
to each entry.  If @var{children?} is given and true, @code{"."} and 
@code{".."} are excluded from the result.  

If @var{filter} is given, it must be a predicate that takes one argument.  
It is called on every element of the directory entry,
and only the entries on which
@var{filter} returns true are included in the result.
The argument passed to @var{filter} is a basename of the directory entry
by default, but when @var{filter-add-path?} is true, @var{path} is 
appended to the entry.

If @var{path} is not a directory, an error is signalled.

@example
(directory-list "test")
 @result{} ("." ".." "test.scm" "test.scm~")

(directory-list "test" :add-path? #t)
 @result{} ("test/." "test/.." "test/test.scm" "test/test.scm~")

(directory-list "test" :children? #t)
 @result{} ("test.scm" "test.scm~")

(directory-list "test" :children? #t :add-path? #t
   :filter (lambda (e) (not (string-suffix? "~" e))))
 @result{} ("test/test.scm")
@end example
@end defun

@defun directory-list2 path &keyword children? add-path? filter follow-link?
Like @code{directory-list}, but returns two values; the first one is a list
of subdirectories, and the second one is a list of the rest.
The keyword arguments @var{children?}, @code{add-path?} and @var{filter}
are the same as @code{directory-list}.

Giving false value to @var{follow-link?} makes @code{directory-list2}
not follow the symbolic links; if the @var{path} contains a
symlink to a directory,
it will be included in the first list if @var{follow-link?}
is omitted or true,
while it will be in the second list if @var{follow-link?} is false.
@end defun

@defun directory-fold path proc seed &keyword lister follow-link?
A fundamental directory traverser.
Conceptually it works as follows, in recursive way.

@itemize @bullet
@item
If @var{path} is not a directory, calls 
@code{(@var{proc} @var{path} @var{seed})} and returns the result.
@item
If @var{path} is a directory, calls
@code{(@var{lister} @var{path} @var{seed})}.  The procedure @var{lister}
is expected to return two values: a list of pathnames, and the 
next seed value.   Then
@code{directory-fold} is called on each returned pathname,
passing the returned seed value to the @var{seed} argument of the
next call of @code{directory-fold}.
Returns the result of the last seed value.
@end itemize

The default procedure of @var{lister} is just a call to @code{directory-list},
as follows.
@example
(lambda (path seed)
  (values (directory-list path :add-path? #t :children? #t)
          seed))
@end example

Note that @var{lister} shouldn't return the given path itself (@code{"."})
nor the parent directory (@code{".."}), or the recursion wouldn't
terminate.  Also note @var{lister} is expected to return a path accessible
from the current directory, i.e. if @var{path} is @code{"/usr/lib/foo"} and
it contains @code{"libfoo.a"} and @code{"libfoo.so"}, @var{lister} should
return @code{'("/usr/lib/foo/libfoo.a" "/usr/lib/foo/libfoo.so")}.

The keyword argument @var{follow-link?} is used to determine whether
@var{lister} should be called on a symbolic link pointing to a directory.
When @var{follow-link?} is true (default), @var{lister} is called
with the symbolic link if it points to a directory.
When @var{follow-link?} is false, @var{proc} is not called.

The following example returns a list of pathnames of the emacs backup files
(whose name ends with "~") under the given path.
@example
(use srfi-13) ;; for string-suffix?
(directory-fold path
                (lambda (entry result) 
                  (if (string-suffix? "~" entry)
                      (cons entry result)
                      result))
                '())
@end example

The following example lists all the files and directories under the
given pathname.   Note the use of @var{lister} argument to include
the directory path itself in the result.
@example
(directory-fold path cons '()
  :lister (lambda (path seed)
            (values (directory-list path :add-path? #t :children? #t)
                    (cons path seed))))
@end example

@end defun

@defun make-directory* name &optional perm
@defunx create-directory* name &optional perm
Creates a directory @var{name}.  If the intermediate path to the
directory doesn't exist, they are also created
(like @code{mkdir -p} command on Unix).   If the directory
@var{name} already exist, these procedure does nothing.
@var{Perm} specifies the integer flag for permission bits of the
directory.
@end defun


@defun remove-directory* name
@defunx delete-directory* name 
Deletes directory @var{name} and its content recursively 
(like @code{rm -r} command on Unix).   Symbolic links are not
followed.
@end defun

@defun copy-directory* src dst &keyword if-exists backup-suffix safe keep-timestamp keep-mode follow-link?
If @var{src} is a regular file, copies its content to @var{dst}, just like
@code{copy-file} does.  If @var{src} is a directory, recursively
desends it and copy the file tree to @var{dst}.  Basically
it mimics the behavior of @code{cp -r} command.

If there's any symbolic links under @var{src}, the link itself
is copied instead of the file pointed to by it, unless a true value
is given to the @var{follow-link?} keyword argument,
i.e. the default value of @var{follow-link?} is @code{#f}.
(Note that this is opposite to the @code{copy-file}, in which
@var{follow-link?} is true by default.)

The meanings of the other keyword arguments are the same as
@code{copy-file}.  See the entry of @code{copy-file} for the details.
@end defun


@node Pathname utilities, File attribute utilities, Directory utilities, Filesystem utilities
@subsection Pathname utilities
@c NODE パスネームユーティリティ

@defun build-path base-path component @dots{}
Appends pathname components @var{component} to the @var{base-path}.
@var{Component} can be a symbol @code{up} or @code{same};
in Unix, they are synonym to @code{".."} and @code{"."}.
This API is taken from MzScheme.
@end defun

@defun absolute-path? path
@defunx relative-path? path
Returns @code{#t} if @var{path} is absolute or relative, respectively.
@end defun

@defun expand-path path
Expands tilda-notation of @var{path} if it contains one.
Otherwise, @var{path} is returned.  This function does not
check if @var{path} exists and/or readable.
@end defun

@defun resolve-path path
Expands @var{path} like @code{expand-path},
then resolve symbolic links for every components
of the path.  If @var{path} does not exist, or contains dangling link,
or contains unreadable directory, an error is signalled.
@end defun

@defun simplify-path path
Remove 'up' (@code{".."}) components and 'same' (@code{"."}) components
from @var{path} as much as possible.
This function does not access the filesystem.
@end defun

@defun decompose-path path
Returns three values; the directory part of @var{path},
the basename without extension of @var{path}, and
the extension of @var{path}.    If the pathname doesn't have an extension,
the third value is @code{#f}.  If the pathname ends with a directory
separator, the second and third values are @code{#f}. (Note: This treatment
of the trailing directory separator differs from 
@code{sys-dirname}/@code{sys-basename}; those follow popular shell's
convention, which ignores trailing slashes.)
@example
(decompose-path "/foo/bar/baz.scm")
  @result{} "/foo/bar", "baz", "scm"
(decompose-path "/foo/bar/baz")
  @result{} "/foo/bar", "baz", #f

(decompose-path "baz.scm")
  @result{} ".", "baz", "scm"
(decompose-path "/baz.scm")
  @result{} "/", "baz", "scm"

;; Boundary cases
(decompose-path "/foo/bar/baz.")
  @result{} "/foo/bar", "baz", ""
(decompose-path "/foo/bar/.baz")
  @result{} "/foo/bar", ".baz", #f
(decompose-path "/foo/bar.baz/")
  @result{} "/foo/bar.baz", #f, #f
@end example
@end defun

@defun path-extension path
@defunx path-sans-extension path
Returns an extension of @var{path},
and  a pathname of @var{path} without extension, respectively.
If @var{path} doesn't have an extension, @code{#f} and @var{path}
is returned respectively.

@example
(path-extension "/foo/bar.c")       @result{} "c"
(path-sans-extension "/foo/bar.c")  @result{} "/foo/bar"

(path-extension "/foo/bar")         @result{} #f
(path-sans-extension "/foo/bar")    @result{} "/foo/bar"
@end example
@end defun

@defun path-swap-extension path newext
Returns a pathname in which the extension of @var{path} is replaced
by @var{newext}.  If @var{path} doesn't have an extension,
"." and @var{newext} is appended to @var{path}.  

If @var{newext} is @code{#f}, it returns @var{path} without extension.

@example
(path-swap-extension "/foo/bar.c" "o")  @result{} "/foo/bar.o"
(path-swap-extension "/foo/bar.c" #f)   @result{} "/foo/bar"
@end example
@end defun

@defun find-file-in-paths name &keyword paths pred
Looks for a file that has name @var{name} in the given list of pathnames
@var{paths} and that satisfies a predicate @var{pred}.  If found,
the absolute pathname of the file is returned.  Otherwise, @code{#f}
is returned.

If @var{name} is an absolute path, only the existence of @var{name}
and whether it satisfies @var{pred} are checked.

The default value of @var{paths} is taken from the environment variable
@code{PATH}, and the default value of @var{pred} is @code{file-is-executable?}
(@xref{File attribute utilities}).  That is, @code{find-file-in-paths}
searches the named executable file in the command search paths
by default.

@example
(find-file-in-paths "ls")
  @result{} "/bin/ls"

;; @r{example of searchin user preference file of my application}
(find-file-in-paths "userpref"
  :paths `(,(expand-path "~/.myapp")
           "/usr/local/share/myapp"
           "/usr/share/myapp")
  :pred  file-is-readable?)
@end example
@end defun

@node File attribute utilities, File operations, Pathname utilities, Filesystem utilities
@subsection File attribute utilities
@c NODE ファイル属性ユーティリティ

@defun file-type path &keyword follow-link?
@defunx file-perm path &keyword follow-link?
@defunx file-mode path &keyword follow-link?
@defunx file-ino path &keyword follow-link?
@defunx file-dev path &keyword follow-link?
@defunx file-rdev path &keyword follow-link?
@defunx file-nlink path &keyword follow-link?
@defunx file-uid path &keyword follow-link?
@defunx file-gid path &keyword follow-link?
@defunx file-size path &keyword follow-link?
@defunx file-atime path &keyword follow-link?
@defunx file-mtime path &keyword follow-link?
@defunx file-ctime path &keyword follow-link?
These functions return the attribute of file/directory specified by
@var{path}.  The attribute name corresponds to the slot name of
@code{<sys-stat>} class (@xref{File stats}).
If the named path doesn't exist, @code{#f} is returned.

If @var{path} is a symbolic link, these functions queries the
attributes of the file pointed by the link, unless
an optional argument @var{follow-link?} is given and false.

MzScheme and Chicken have @code{file-size}.  Chicken also has
@code{file-modification-time}, which is @code{file-mtime}.
@end defun

@defun file-is-readable? path
@defunx file-is-writable? path
@defunx file-is-executable? path
Returns @code{#t} if @var{path} exists and readable/writable/executable
by the current effective user, respectively.
This API is taken from STk.
@end defun

@defun file-is-symlink? path
Returns @code{#t} if @var{path} exists and a symbolic link.
See also @code{file-is-regular?} and @code{file-is-directory?} in
@ref{File stats}.
@end defun

@defun file-eq? path1 path2
@defunx file-eqv? path1 path2
@defunx file-equal? path1 path2
Compares two files specified by @var{path1} and @var{path2}.
@code{file-eq?} and @code{file-eqv?} checks if @var{path1} and @var{path2}
refers to the identical file, that is, whether they are on the same
device and have the identical inode number.  The only difference is
when the last component of @var{path1} and/or @var{path2} is a symbolic
link, @code{file-eq?} doesn't resolve the link (so compares the links
themselves) while @var{file-eqv?} resolves the link and compares the
files referred by the link(s).

@code{file-equal?} compares @var{path1} and @var{path2} considering their
content, that is, when two are not the identical file in the sense of
@code{file-eqv?}, @code{file-equal?} compares their content and returns
@code{#t} if all the bytes match.

The behavior of @code{file-equal?} is undefined
when @var{path1} and @var{path2} are both directories.
Later, it may be extended to scan the directory contents.
@end defun

@deffn {Generic Function} file-mtime=? f1 f2
@deffnx {Generic Function} file-mtime<? f1 f2
@deffnx {Generic Function} file-mtime<=? f1 f2
@deffnx {Generic Function} file-mtime>? f1 f2
@deffnx {Generic Function} file-mtime>=? f1 f2
Compares file modification time stamps.  There are a bunch of methods defined,
so each argument can be either one of the followings.

@itemize @bullet
@item
String pathname.   The mtime of the specified path is used.
@item
@code{<sys-stat>} object (@xref{File stats}).
The mtime is taken from the stat structure.
@item
@code{<time>} object.  The time is used as the mtime.
@item
Number.  It is considered as the number of seconds since Unix Epoch, and
used as mtime.
@end itemize

@example
;; @r{compare "foo.c" is newer than "foo.o"}
(file-mtime>? "foo.c" "foo.o")

;; @r{see if "foo.log" is updated within last 24 hours}
(file-mtime>? "foo.c" (- (sys-time) 86400))
@end example
@end deffn

@deffn {Generic Function} file-ctime=? f1 f2
@deffnx {Generic Function} file-atime=? f1 f2
@findex file-ctime<?
@findex file-ctime<=?
@findex file-ctime>?
@findex file-ctime>=?
@findex file-atime<?
@findex file-atime<=?
@findex file-atime>?
@findex file-atime>=?
Same as @code{file-mtime=?}, except these checks file's change time
and access time, respectively.
All the variants of @code{<}, @code{<=}, @code{>}, @code{>=} are also
defined.
@end deffn

@node File operations,  , File attribute utilities, Filesystem utilities
@subsection File operations
@c NODE ファイル操作

@defun touch-file path
@defunx touch-files paths
Updates timestamp of @var{path}, or each path in the list @var{paths},
to the current time.  If the specified path
doesn't exist, a new file with size zero is created.
See also @code{sys-utime} (@xref{File stats}).
@end defun

@defun copy-file src dst &keyword if-exists backup-suffix safe keep-timestamp keep-mode follow-link?
Copies file from @var{src} to @var{dst}.  The source file @var{src} must exist.
The behavior when the destination @var{dst} exists varies by the keyword
argument @var{if-exists};

@table @code
@item :error
(Default) Signals an error when @var{dst} exists.
@item :supersede
Replaces @var{dst} to the copy of @code{src}. 
@item :backup
Keeps @var{dst} by renaming it.
@item #f
Doesn't copy and returns @code{#f} when @var{dst} exists.
@end table

@code{Copy-file} returns @code{#t} after completion.

If @var{src} is a symbolic link, @code{copy-file} follows the
symlink and copies the actual content by default.  An error
is raised if @var{src} is a dangling symlink.

Giving @code{#f} to the keyword argument @var{follow-link?} 
makes @code{copy-file} to copy the link itself.
It is possible that @var{src} is a dangling 
symlink in this case.

If @var{if-exists} is @code{:backup}, the keyword argument @var{backup-suffix}
specifies the suffix attached to the @var{dst} to be renamed.
The default value is @code{".orig"}.

By default, @code{copy-file} starts copying to @var{dst} directly.
However, if the keyword argument @var{safe} is a true value,
it copies the file to a temporary file in the same directory of @var{dst},
then renames it to @var{dst} when copy is completed.
If copy is interrupted for some reason, the filesystem is "rolled back"
properly.

If the keyword argument @var{keep-timestamp} is true, @code{copy-file}
sets the destination's timestamp to the same as the source's timestamp
after copying.

If the keyword argument @var{keep-mode} is true, the destination file's 
permission bits are set to the same as the source file's.  If it is false
(default), the destination file's permission remains the same if
the destination already exists and the @var{safe} argument is false,
otherwise it becomes @code{#o666} masked by umask settings.
@end defun

@c @defun copy-files files dstdir &keyword if-exists backup-suffix safe keep-timestamp keep-mode follow-link?
@c @c EN
@c Copies each file in a list @var{files} to the destination @var{dstdir}, which
@c must be an existing directory.  The keyword arguments are passed
@c to @code{copy-file}.
@c @c JP
@c リスト@var{files}中の各ファイルをディレクトリに@var{dstdir}にコピーします。
@c @var{dstdir}は既に存在しなければなりません。
@c キーワード引数はそのまま@code{copy-file}に渡されます。
@c @c COMMON
@c @end defun

@defun move-file src dst &keyword if-exists backup-suffix
Moves file @var{src} to @var{dst}.   The source @var{src} must exist.
The behavior when @var{dst} exists varies by the keyword argument
@var{if-exists}, as follows.
@table @code
@item :error
(Default) Signals an error when @var{dst} exists.
@item :supersede
Replaces @var{dst} by @code{src}. 
@item :backup
Keeps @var{dst} by renaming it.
@item #f
Doesn't move and returns @code{#f} when @var{dst} exists.
@end table

@code{Move-file} returns @code{#t} after completion.

If @var{if-exists} is @code{:backup}, the keyword argument @var{backup-suffix}
specifies the suffix attached to the @var{dst} to be renamed.
The default value is @code{".orig"}.

The file @var{src} and @var{dst} can be on the different filesystem.
In such a case, @code{move-file} first copies @var{src} to the
temporary file on the same directory as @var{dst}, then renames
it to @var{dst}, then removes @var{src}.
@end defun

@c @defun move-files files dstdir &keyword if-exists backup-suffix
@c @c EN
@c Moves each file in a list @var{files} to @var{dstdir},
@c which must be an existing directory.  Keyword arguments
@c are passed to @code{move-file}.
@c @c JP
@c リスト@var{files}中の各ファイルをディレクトリ@var{dstdir}に移動します。
@c @var{dstdir}は既に存在しなければなりません。
@c キーワード引数はそのまま@code{move-file}に渡されます。
@c @c COMMON
@c @end defun

@defun remove-files paths
@defunx delete-files paths
Removes each path in a list @var{paths}.  If the path is 
a file, it is @code{unlink}ed.  If it is a directory,
its contents are recursively removed by @code{remove-directory*}.
If the path doesn't exist, it is simply ignored.

@code{delete-files} is just an alias of @code{remove-files}.
@end defun


@defun file->string filename options @dots{}
@defunx file->list reader filename options @dots{}
@defunx file->string-list filename options @dots{}
@defunx file->sexp-list filename options @dots{}
Convenience procedures to read from a file @var{filename}.
They first open the named file, then call @code{port->string},
@code{port->list}, @code{port->string-list} and @code{port->sexp-list}
on the opened file, respectively.  (@xref{Input utility functions}).
The file is closed if all the content is read or an error is
signalled during reading.

Those procedures take the same keyword arguments as
@code{call-with-input-file}.
When the named file doesn't exist, the behavior depends on 
@var{:if-does-not-exist} keyword argument---an error is signalled
if it is @code{:error}, and @code{#f} is returned if the argument is
@code{#f}.
@end defun


@c ----------------------------------------------------------------------
@node Mathematic constants, Mersenne-Twister random number generator, Filesystem utilities, Library modules - Utilities
@section @code{math.const} - Mathematic constants
@c NODE 定数, @code{math.const} - 定数

@deftp {Module} math.const
@mdindex math.const
This module defines several commonly-used mathematic constants.
@end deftp

@defvr {Constant} pi
@defvrx {Constant} pi/2
@defvrx {Constant} pi/4
@defvrx {Constant} pi/180
@defvrx {Constant} 1/pi
@defvrx {Constant} 180/pi
Bound to pi, pi/2, pi/4, pi/180, 1/pi and 180/pi, respectively.
@end defvr

@defvr {Constant} e
e.
@end defvr

@c ----------------------------------------------------------------------
@node Mersenne-Twister random number generator, RFC822 message parsing, Mathematic constants, Library modules - Utilities
@section @code{math.mt-random} - Mersenne Twister Random number generator
@c NODE Mersenne Twister乱数発生器, @code{math.mt-random} - Mersenne Twister乱数発生器

@deftp {Module} math.mt-random
@mdindex math.mt-random
Provides a pseudo random number generator (RNG) based on 
"Mersenne Twister" algorithm developed by Makoto Matsumoto and
Takuji Nishimura.   It is fast, and has huge period of 2^19937-1.
See @ref{MT,,MT}, for details about the algorithm.
@end deftp

@deftp {Class} <mersenne-twister>
@clindex mersenne-twister
A class to encapsulate the state of Mersenne Twister RNG.
Each instance of this class has its own state, and can be used
as an independent source of random bits if initialized
by individual seed.

The random seed value can be given at the instantiation time
by @code{:seed} initialization argument, or by using
@code{mt-random-set-seed!} described below.

@example
(define m (make <mersenne-twister> :seed (sys-time)))

(mt-random-real m) @result{} 0.10284287848537865
(mt-random-real m) @result{} 0.463227748348805
(mt-random-real m) @result{} 0.8628500643709712
@dots{}
@end example
@end deftp

@defun mt-random-set-seed! mt seed
Sets random seed value @var{seed} to the Mersenne Twister RNG @var{mt}.
@var{Seed} can be an arbitrary positive exact integer,
or arbitrary length of u32vector (@xref{Homogeneous vectors}).
If it is an integer, the lower 32bits are used for initialization.
If it is a u32vector, up to 624 elements are used for initialization.
@end defun

@defun mt-random-get-state mt
@defunx mt-random-set-state! mt state
Retrieves and reinstalls the state of Mersenne Twister RNG @var{mt}.
The state is represented by a u32vector of 625 elements.  The state
can be stored elsewhere, and then restored to an instance of
@code{<mersenne-twister>} to continue to generate the pseudo random
sequence.
@end defun

@defun mt-random-real mt
@defunx mt-random-real0 mt
Returns a random real number between 0.0 and 1.0.
1.0 is not included in the range.  @code{Mt-random-real} doesn't
include 0.0 either, while @code{mt-random-real0} does.
Excluding 0.0 is from the draft SRFI-27.
@end defun

@defun mt-random-integer mt range
Returns a random exact positive integer between 0 and @var{range}-1.
@var{Range} can be any positive exact integer.
@end defun

@defun mt-random-fill-u32vector! mt u32vector
@defunx mt-random-fill-f32vector! mt f32vector
@defunx mt-random-fill-f64vector! mt f64vector
Fills the given uniform vector by the random numbers.
For @code{mt-random-fill-u32vector!}, the elements are filled
by exact positive integers between 0 and 2^32-1.
For @code{mt-random-fill-f32vector!} and
@code{mt-random-fill-f64vector!}, it is filled by an inexact
real number between 0.0 and 1.0, exclusive.

If you need a bunch of random numbers at once, these are much
faster than getting one by one.
@end defun

@c ----------------------------------------------------------------------
@c @node Parser combinators for PEG, RFC822 message parsing, Mersenne-Twister random number generator, Library modules - Utilities
@c @section @code{parser.peg} - Parser combinators for PEG
@c @c NODE PEGパーザコンビネータ, @code{parser.peg} - PEGパーザコンビネータ

@c @deftp {Module} parser.peg
@c @mdindex parser.peg
@c This module implements a parser combinator library
@c to build parsers based on Parsing Expression Grammer, or PEG.

@c PEG is a @emph{formal grammer} to define a language, like regular 
@c expressions or context-free grammers, although PEG is more powerful
@c than those.  An interesting characteristic of PEG is that it can
@c be directly mapped to a recursive decent parser, which is exactly
@c what this library does---each production rule is a Scheme expression
@c that takes parsers and returns a combined parser.  One advantage of
@c this approach is that you can freely mix ordinary Scheme code
@c within the parser, that is, there's no special ``parser description
@c language'' distinct from the base Scheme langauge, nor you need to
@c run separate tools like parser generators to obtain a runnable parser code.

@c Although PEG can directly parse the character string, the parser
@c combinators are not tied to it.  In fact, it can take any
@c stream of tokens, where the exact meaning of token depends on
@c the application; you can have separate lexer that generates
@c token stream that PEG parser can parse.  See @ref{PEG stream}
@c for the details of the stream abstraction layer

@c This library is specifically written to get a good performance
@c on Gauche.  The parser created by @code{parser.peg} is
@c no slower than the parser written manually from scratch, or
@c even faster.  However, you have to watch out some traps; see
@c @ref{PEG performance tips}, for the details.
@c @end deftp

@c @menu
@c * PEG Walkthrough::             
@c * PEG high-level API::          
@c * PEG combinators::             
@c * PEG stream::                  
@c * PEG performance tips::        
@c @end menu

@c @node PEG Walkthrough, PEG high-level API, Parser combinators for PEG, Parser combinators for PEG
@c @subsection Walkthrough

@c In @code{parser.peg}, a parser is merely a Scheme procedure
@c that takes an input (peg stream) as an argument and returns
@c a result (well, in fact, it returns three values, but we'll go
@c into the details later.)

@c Typically you don't need to write parsers directly in
@c procedural style.  Instead, you can use procedures that
@c generates parsers.   A parser can be as simple as the 
@c following, which accepts a character @code{#\a}.

@c @example
@c ($char #\a)   ; => a parser
@c @end example

@c A parser can be invoked by a @emph{parser driver}.  For example,
@c you can use @code{peg-parse-string} to invoke the above parser
@c on a string:

@c @example
@c gosh> (peg-parse-string ($char #\a) "abc")
@c #\a
@c @end example

@c The parsing succeeds, and returns the matched value---@code{#\a} in this case.
@c If the parser can't accept the input, the driver throws an error
@c @code{<parse-error>}.

@c @example
@c gosh> (peg-parse-string ($char #\a) "xyz")
@c *** PARSE-ERROR: expecting #\a at 0
@c @end example

@c A parser can also be constructed by combining simpler parsers,
@c using @emph{parser combinators}.   For example, @code{$seq} takes
@c zero or more parsers and apply them sequentially, returning
@c the last result.

@c @example
@c gosh> (peg-parse-string ($seq ($char #\a) ($char #\b) ($char #\c)) "abc")
@c #\c
@c @end example

@c The combinator @code{$many} takes a parser and returns a new parser
@c that accepts zero or more occurrence of the string the original parser
@c accepts.

@c @example
@c gosh> (peg-parse-string ($many ($char #\a)) "aaaaabc")
@c (#\a #\a #\a #\a #\a)
@c gosh> (peg-parse-string ($many ($char #\a)) "xxxxxyz")
@c ()
@c @end example

@c A parser is just an ordinary Scheme procedure, so it can be bound
@c to a variable, then can be used to construct more complex parsers.

@c @example
@c (define digits    ($many1 ($one-of #[\d])))
@c (define ws        ($skip-many ($one-of #[\s])))
@c (define separator ($seq ws ($char #\,) ws))
@c @end example

@c I leave explanation of @code{$many1}, @code{$one-of}, and
@c @code{$skip-many} for the later section, 
@c but I guess you can imagine what those parsers do; 
@c @code{digits} accepts a sequence of digits, and
@c @code{ws} accepts whitespaces.   The @code{separator}
@c parser accepts a comma, optionally surrounded by whitespaces.

@c The @code{digits} parser returns a list of accepted
@c characters:

@c @example
@c gosh> (peg-parse-string digits "12345")
@c (#\1 #\2 #\3 #\4 #\5)
@c @end example

@c Can we create a parser that returns an integer as
@c a parsed result?    Yes, we can use the @code{$do} form
@c and the @code{$return} combinator.

@c @example
@c (define integer
@c   ($do [ds digits]
@c        ($return (x->integer (list->string ds)))))
@c @end example

@c The @code{$do} form works somewhat like @code{ant-let*}; it takes
@c a form of @code{($do [@var{var} @var{parser}] @dots{} @var{expr})},
@c applying the @var{parser}s in order, binding the result of each
@c parser to @var{var}.  The @code{$return} combinator is create a
@c parser that doesn't consume input and returns the given value; 
@c you can think that @code{$do} is to pull out a value from,
@c and @code{$return} to put back a value to, the chain of parsers.
@c (Note: If you know Monads, you can recognize the pattern.
@c It is also no coincidence that @code{$do} is similar to @code{and-let*},
@c since @code{and-let*} is just a Maybe monad in disguise.)

@c @example
@c gosh> (peg-parse-string integer "12345")
@c 12345
@c @end example

@c Now you can combine those parsers to build more complex one, such
@c as a list of integers:

@c @example
@c (define integers1 ($seq integer
@c                         ($many ($seq separator integer))))

@c gosh> (peg-parse-string integers1 "123, 456, 789")
@c (456 789)
@c @end example

@c Oops, where's 123?  Well, remember that 
@c @code{$seq} discards the results but the last one.
@c We can use @code{$do} again to keep all the results.

@c @example
@c (define integers2 ($do [n  integer]
@c                        [ns ($many ($seq separator integer))]
@c                        ($return (cons n ns))))

@c gosh> (peg-parse-string integers2 "123, 456, 789")
@c (123 456 789)
@c @end example

@c This parser doesn't handle the case when the list contains no
@c integers.   Using the @code{$or} form, which represents a choice,
@c we can modify it to handle zero-element case.

@c @example
@c (define integers3 ($or ($do [n  integer]
@c                             [ns ($many ($seq separator integer))]
@c                             ($return (cons n ns)))
@c                        ($return '())))
@c @end example

@c By the way, ``list of stuff separated by something'' is a very common
@c pattern, so we can extract the pattern to name it:

@c @example
@c (define (sep-by stuff separator)
@c   ($or ($do [n  stuff]
@c             [ns ($many ($seq separator stuff))]
@c             ($return (cons n ns)))
@c        ($return '()))
@c @end example

@c Then the list of integers can be written this simple:

@c @example
@c (define integers4 (sep-by integer separator))
@c @end example

@c In fact, @code{parser.peg} provides @code{$sep-by} to do the above,
@c but we've just shown the definition to demonstrate
@c the power of the combinatorial approach; 
@c you can use ordinary procedural abstraction to factor out common patterns.

@c There's one catch in the @code{$or} form.
@c It tries the next alternative only when the
@c parser fails without consuming the input.  Once the input is
@c consumed, @code{$or} commits to that choice.   For example,
@c the following fails even if the input seems to match the
@c second alternative:

@c @example
@c gosh> (peg-parse-string ($or ($string "(a)") ($string "(b)")) "(b)")
@c *** PARSE-ERROR: expecting (a) at 1
@c @end example

@c It's because when @code{$or} tries the first branch, it reads the initial
@c open paren from the input, so @code{$or} commits to the first branch.
@c When the branch fails, @code{$or} doesn't bother to try the second branch.
@c (In other words, @code{$or} does not backtrack.)

@c You may factor out the common prefix:

@c @example
@c ($seq ($char #\()
@c       ($or ($string "a") ($string "b"))
@c       ($char #\)))
@c @end example

@c But it complicates the syntax, and it is not always trivial to
@c factor out like above.  The better way is to use the @code{$try}
@c combinator: @code{($try @var{p})} runs a parser @var{p}, and if
@c it fails, @code{$try} rolls back the input as if it didn't
@c consume input at all.  Using with @code{$or}, you can do arbitrary
@c lookahead.

@c @example
@c ($or ($try ($string "(a)"))
@c      ($string "(b)"))
@c @end example

@c Now, let's get back to the integer list example and make
@c it more intersting.
@c Suppose the list of integers are surrounded by brackets.  
@c We can just put open and close bracket around the
@c comma-separated integers (you can omit the parentheses around
@c the clauses in @code{$do} form, if the parser expression consists
@c of single symbol and you don't need the result):

@c @example
@c (define begin-list  ($seq ($char #\[ ) ws))
@c (define end-list    ($seq ws ($char #\] )))

@c (define int-list1 ($do begin-list
@c                        [ns ($sep-by integer separator)]
@c                        end-list
@c                        ($return ns)))

@c gosh> (peg-parse-string int-list1 "[123, 456, 789]")
@c (123 456 789)
@c @end example

@c The above pattern is also common, so there's a pre-defined combinator:
@c @code{$between}:

@c @example
@c (define int-list2 ($between begin-list
@c                             ($sep-by integer separator)
@c                             end-list))
@c @end example

@c What if we want a nested list?  In BNF, we could write
@c something like this:

@c @example
@c list : '[' (elem (separator elem)* )? ']'
@c elem : integer | list
@c @end example

@c Unfortunately, the straightforward translation won't work:

@c @example
@c ;; Does not work
@c (define list1 ($between begin-list
@c                         ($sep-by elem separator)
@c                         end-list))
@c (define elem  ($or integer list1))
@c @end example

@c We need the parser @code{elem} to construct @code{list1}, but
@c we need the parser @code{list1} to construct @code{elem}.
@c In lazy languages like Haskell this doesn't matter, but we Schemers
@c are @emph{eager}!

@c The solution is to delay the parser construciton until it is
@c actually used.  The @code{$lazy} combinator does the job:

@c @example
@c (define list2 ($lazy
@c                ($between begin-list
@c                          ($sep-by elem separator)
@c                          end-list)))
@c (define elem  ($or integer list2))

@c gosh> (peg-parse-string list2 "[123, [456, [], 789], 987]")
@c (123 (456 () 789) 987)
@c @end example


@c @node PEG high-level API, PEG combinators, PEG Walkthrough, Parser combinators for PEG
@c @subsection High-level API

@c @defun peg-parse-string parser input-string
@c @end defun

@c @defun peg-parse-port parser input-string
@c @end defun

@c @defun peg-run-parser parser peg-stream
@c @end defun

@c @deftp {Condition type} <parse-error>
@c @end deftp

@c @defun make-peg-parse-error type objs stream
@c @end defun


@c @node PEG combinators, PEG stream, PEG high-level API, Parser combinators for PEG
@c @subsection Combinators

@c In the following entries, @var{p}, @var{p1}, @var{p2}, @dots{} in
@c the arguments must be parsers, and @var{ps} must be a list of parsers.

@c @subsubheading Generic combinators

@c @defmac $do clause @dots{} expr
@c @end defmac

@c @defmac $do* clause @dots{} expr
@c @end defmac

@c @defun $fold proc seed ps
@c @end defun

@c @defun $fold-right proc seed ps
@c @end defun

@c @defun $seq p1 p2 @dots{}
@c @end defun

@c @defmac $or p1 p2 @dots{}
@c @end defmac

@c @defun $try p
@c Returns a parser that accepts the same input
@c the parser @var{p} accepts, but when @var{p} fails
@c the returned parser doesn't consume input.  Used with @code{$or},
@c you can explicitly implement a backtrack behavior.
@c @end defun

@c @defun $many p &optional min max
@c @end defun

@c @defun $skip-many p &optional min max
@c @end defun

@c @defun $optional p
@c @end defun

@c @defun $repeat p count
@c @end defun

@c @defun $count p count
@c @end defun

@c @defun $sep-by p psep &optional min max
@c @end defun

@c @defun $alternate p psep
@c @end defun

@c @defun $end-by p psep &rest p2 @dots{}
@c @end defun

@c @defun $sep-end-by p psep &rest p2 @dots{}
@c @end defun

@c @defun $not p
@c @end defun

@c @defun $many-till p pend &rest p2 @dots{}
@c @end defun

@c @defun $chain-left p p-op
@c @end defun

@c @defun $chain-right p p-op
@c @end defun

@c @defmac $lazy p
@c @end defmac

@c @defun $->rope p
@c @end defun

@c @subsubheading Semantic predicate

@c @defmac $satisfy p expect
@c @end defmac

@c @subsubheading String parsers

@c @defun $char c
@c @defunx $char-ci c
@c Returns a parser that accepts a single character, @var{c}.
@c @code{$char-ci} ignores case.
@c On success, the semantic value is the input character.
@c @end defun

@c @defun $string str
@c @defunx $string-ci str
@c Returns a parser that accepts an input that matches 
@c a string @var{str}.  @code{$string-ci} ignores case.
@c On success, the semantic value is the input string.

@c The parsing of string is atomic: When the parser fails,
@c it doesn't consume the input.  That is,
@c @code{($string "ab")} is not the same as
@c @code{($do [a ($char #\a)] [b ($char #\b)] ($return (string a b)))};
@c you may think it is surrouned by implicit @code{$try}.
@c (If you've used Parsec, 
@c @end defun

@c @defun $one-of cset
@c Returns a parser that accepts any character in the character set @var{cset}.
@c @end defun

@c @defun $none-of cset
@c @end defun

@c @defmac $many-chars cset
@c @end defmac

@c @defvar anychar
@c @defvarx upper
@c @defvarx lower
@c @defvarx letter
@c @defvarx alphanum
@c @defvarx digit
@c @defvarx hexdigit
@c @defvarx newline
@c @defvarx tab
@c @defvarx space
@c @defvarx spaces
@c @defvarx eof
@c @end defvar


@c @node PEG stream, PEG performance tips, PEG combinators, Parser combinators for PEG
@c @subsection PEG stream

@c @defun make-peg-steram generator &optional fini
@c @end defun

@c @defun string->peg-stream string
@c @end defun

@c @defun port->peg-stream port &key (reader read-char)
@c @end defun

@c @defun list->peg-stream lis
@c @end defun

@c @defun peg-stream-position s
@c @end defun

@c @defun peg-stream-peek! s
@c @end defun

@c @node PEG performance tips,  , PEG stream, Parser combinators for PEG
@c @subsection Performance



@c ----------------------------------------------------------------------
@node RFC822 message parsing, Base64 encoding/decoding, Mersenne-Twister random number generator, Library modules - Utilities
@section @code{rfc.822} - RFC822 message parsing
@c NODE RFC822メッセージ形式, @code{rfc.822} - RFC822メッセージ形式

@deftp {Module} rfc.822
@mdindex rfc.822
Defines a set of functions that parses and constructs the ``Internet
Message Format'', a text format used to exchange e-mails.
The most recent specification can be found in
RFC2822 (@ref{rfc2822,[RFC2822],RFC2822}).
The format was originally defined in RFC 822, and people still 
call it ``RFC822 format'', hence I named this module.
In the following document, I also refer to the format as ``RFC822 format''.
@end deftp

@subheading Parsing message headers

@defun rfc822-read-headers iport &keyword strict? reader
Reads RFC822 format message from an input port @var{iport},
until it reaches the end of the message header.
The header fields are broken into a list of the following
format:
@example
((name body) @dots{})
@end example
@var{Name} @dots{} are the field names, and @var{body} @dots{} are
the corresponding field body, both as strings.
Field names are converted to lower-case characters.
Field bodies are not modified, except the folded line is unfolded.
The order of fields are preserved.

By default, the parser works permissively.  If EOF is encountered
during parsing header, it is taken as the end of the message.
And if a line that doesn't consist neither continuing (folded) line
nor start a new header field, it is simply ignored.
You can change this behavior by giving true value to
the keyword argument @var{strict?}; then the parser raises an error
for such a malformed header.

The keyword argument @var{reader} takes a procedure that reads
a line from @var{iport}.  Its default is @code{read-line}, which
should be enough for most cases.
@end defun

@defun rfc822-header->list iport &keyword strict? reader
This is an old name of @code{rfc822-read-headers}.  This is kept
for the backward compatibility.  The new code should use
@code{rfc822-read-headers} instead.
@end defun


@defun rfc822-header-ref header-list field-name &optional default
An utility procedure to get a specific field from the parsed
header list, which is returned by @code{rfc822-read-headers}.

@var{Field-name} specifies the field name in a lowercase string.
If the field with given name is in @var{header-list}, the procedure
returns its value in a string.  Otherwise, if @var{default} is given,
it is returned, and if not, @code{#f} is returned.
@end defun

@subheading Basic field parsers

Several procedures are provided to parse "structured" header fields
of RFC2822 messages.  These procedures deal with the body of
a header field, i.e. if the header field is 
"@code{To: Wandering Schemer <schemer@@example.com>}",
they parse "@code{Wandering Schemer <schemer@@example.com>}".

Most of procedures take an input port.  Usually you first parse
the entire header fields by @code{rfc822-read-headers},
obtain the body of the header by @code{rfc822-header-ref},
then open an input string port for the body and use those
procedures to parse them.

The reason for this complexity is because you need
different tokenization schemes depending on the type of the field.
Rfc2822 also allows comments to appear between tokens for most cases,
so a simple-minded regexp won't do the job,
since rfc2822 comment can be nested 
and can't be represented by regular grammar.
So, this layer of procedures are designed flexible enough
to handle various syntaxes.  For the standard header types,
high-level parsers are also provided; see "specific field parsers" below.

@defun rfc822-next-token iport &optional tokenizer-specs
A basic tokenizer.  First it skips whitespaces and/or
comments (@code{CFWS}) from @var{iport}, if any.  Then
reads one token according to @var{tokenizer-specs}.  If @var{iport}
reaches EOF before any token is read, EOF is returned.

@var{Tokenizer-specs} is a list of tokenizer spec, which is
either a char-set or a cons of a char-set and a procedure.

After skipping @code{CFWS}, the procedure peeks a character
at the head of @var{iport}, and checks it
against the char-sets in @var{tokenizer-specs} one by one.
If a char-set that contains the character belongs to is found,
then a token is retrieved as follows: 
If the tokenizer spec is just a char-set, a sequence of characters
that belong to the char-set consists a token.
If it is a cons, the procedure is called with @var{iport} to
read a token.

If the head character doesn't match any char-sets,
the character is taken from @var{iport} and returned.

The default @var{tokenizer-specs} is as follows:
@example
(list (cons #["] rfc822-quoted-string)
      (cons *rfc822-atext-chars* rfc822-dot-atom))
@end example
Where @code{rfc822-quoted-string} and @code{rfc822-dot-atom}
are tokenizer procedures described below, and @code{*rfc822-atext-chars*}
is bound to a char-set of @code{atext} specified in rfc2822.
This means @code{rfc822-next-token} retrieves a token
either @code{quoted-string} or @code{dot-atom} specified in rfc2822
by default.

Using @var{tokenizer-specs}, you can customize how the header
field is parsed.  For example, if you want to retrieve a token
that is either (1) a word constructed by alphabetic characters, or
(2) a quoted string, then you can call @code{rfc822-next-token}
by this:

@example
(rfc822-next-token iport
   `(#[[:alpha:]] (#["] . ,rfc822-quoted-string)))
@end example
@end defun

@defun rfc822-field->tokens field &optional tokenizer-specs
A convenience procedure.  Creates an input string port for
a field body @var{field}, and calls @code{rfc822-next-token}
repeatedly on it until it consumes all input, then returns
a list of tokens.   @var{Tokenizer-specs} is passed to
@code{rfc822-next-token}.
@end defun

@defun rfc822-skip-cfws iport
A utility procedure that consumes any comments and/or whitespace
characters from @var{iport}, and returns the head character
that is neither a whitespece nor a comment.  The returned character
remains in @var{iport}.
@end defun

@defvr {Constant} *rfc822-atext-chars*
Bound to a char-set that is a valid constituent of @code{atom}.
@end defvr

@defvr {Constant} *rfc822-standard-tokenizers*
Bound to the default @var{tokenizer-specs}.
@end defvr

@defun rfc822-atom iport
@defunx rfc822-dot-atom iport
@defunx rfc822-quoted-string iport
Tokenizers for @code{atom}, @code{dot-atom} and @code{quoted-string},
respectively.  The double-quotes and escaping backslashes within
@code{quoted-string} are removed by @code{rfc822-quoted-string}.
@end defun

@subheading Specific field parsers

@defun rfc822-parse-date string
Takes RFC-822 type date string, and returns eight values:
@example
year, month, day-of-month, hour, minutes, seconds, timezone, day-of-week.
@end example

@emph{Timezone} is an offset from UT in minutes.
@emph{Day-of-week} is a day from sunday,
and may be #f if that information is not available.
@emph{Month} is an integer between 1 and 12, inclusive.
If the string is not parsable, all the elements are #f.
@end defun

@defun rfc822-date->date string
Parses RFC822 type date format and returns SRFI-19 @code{<date>} object
(see @ref{SRFI-19 Date}).  If @var{string} can't be parsed, 
returns @code{#f} instead.
@end defun

@subheading Message constructors

@defun rfc822-write-headers headers &keyword output continue check
This is a sort of inverse function of @code{rfc822-read-headers}.
It receives a list of header data, in which each header data
consists of @code{(<name> <body>)}, and writes them out in RFC822 header
field format to the output port specified by the @var{output} keyword
argument.  The default output is the current output port.

By default, the procedure assumes @var{headers} contains all the
header fields, and adds an empty line in the end of output
to indicate the end of the header.  You can pass a true value to
the @var{continue} keyword argument to prevent this, enabling
more headers can be added later.

I said ``a sort of'' above.  That's because this function doesn't
(and can't) do the exact inverse.
Specifically, the caller is responsible for line folding and
make sure each header line doesn't exceed the ``hard limit'' defined
by RFC2822 (998 octets).  This procedure cannot do the line 
folding on behalf of the caller, because the places where 
line folding is possible depend on the semantics of each
header field.

It is also the caller's responsibility to make sure header
field bodies don't have any characters except non-NUL US-ASCII
characters.  If you want to include characters outside of that
range, you should convert them in the way allowed by the
protocol, e.g. MIME.  The @code{rfc.mime} module 
(@xref{MIME message handling}) provides a convenience procedure
@code{mime-encode-text} for such purpose.
Again, this procedure cannot do the encoding automatically,
since the way the field
should be encoded depends on header fields.

What this procedure can do is to check and report such violations.
By default, it runs several checks and signals an error if it finds any
violations of RFC2822.  You can control this checking behavior
by the @var{check} keyword argument.  It can take one of the
following values:

@table @code
@item :error
Default.  Signals an error if a violation is found.
@item #f, :ignore
Doesn't perform any check.  Trust the caller.
@item @var{procedure}
When @code{rfc822-write-headers} finds a violation, the procedure
is called with three arguments; the header field name,
the header field body, and the type of violation explained below.
The procedure may correct the problem and return two values,
the corrected header field name and body.  The returned values
are checked again.  If the procedure returns the
header field name and body unchanged, an error is signalled
in the same way as @code{:error} is specified.
@end table

The third argument passed to the procedure given to the @var{check}
argument is one of the following symbols.  New symbols may be
added in future versions for more checks.

@table @code
@item incomplete-string
Incomplete string is passed.
@item bad-character
Header field contains characters outside of US-ASCII or NUL.
@item line-too-long
Line length exceeds 998 octet limit.
@item stray-crlf
The string contains CR and/or LF character that doesn't consist of 
proper line folding.
@end table

@end defun



@c ----------------------------------------------------------------------
@node Base64 encoding/decoding, HTTP cookie handling, RFC822 message parsing, Library modules - Utilities
@section @code{rfc.base64} - Base64 encoding/decoding
@c NODE Base64エンコーディング, @code{rfc.base64} - Base64エンコーディング

@deftp {Module} rfc.base64
@mdindex rfc.base64
This module defines a few functions to encode/decode Base64 format,
defined in RFC 2045 (@ref{rfc2045, [RFC2045], RFC2045}), section 6.3
and RFC3548 (@ref{rfc3548, [RFC3548], RFC3548})
@end deftp

@defun base64-encode &keyword line-width
Reads byte stream from the current input port, encodes it in Base64
format and writes the result character stream to the current output port.
The conversion ends when it reads EOF from the current input port.

Newline characters can be inserted to keep the maximum line width to
the value given to the @var{line-width} keyword argument.  The default
value of @var{line-width} is 76, as specified in RFC2045.  You can give
@code{#f} or zero to @var{line-width} to suppress line splitting.
@end defun

@defun base64-encode-string string &keyword line-width
Converts contents of @var{string} to Base64 encoded format.
Input string can be either complete or incomplete string;
it is always interpreted as a byte sequence.
@end defun

@defun base64-decode
Reads character stream from the current input port, decodes it from Base64
format and writes the result byte stream to the current output port.
The conversion ends when it reads EOF or the termination character
(@code{=}).  The characters which does not in legal Base64 encoded character
set are silently ignored.
@end defun

@defun base64-decode-string string
Decodes a Base64 encoded string @var{string} and returns
the result as a string.
The conversion terminates at the end of @var{string} or
the termination character (@code{=}).
The characters which does not in legal Base64 encoded character
set are silently ignored.
@end defun

@c ----------------------------------------------------------------------
@node HTTP cookie handling, FTP, Base64 encoding/decoding, Library modules - Utilities
@section @code{rfc.cookie} - HTTP cookie handling
@c NODE HTTPクッキー, @code{rfc.cookie} - HTTPクッキー

@deftp {Module} rfc.cookie
@mdindex rfc.cookie
Defines a set of functions to parse and construct a ``cookie'' information
defined in RFC 2965 (@ref{rfc2965,,RFC2965}).
@end deftp

@defun parse-cookie-string string &optional version
Parse a cookie string @var{string}, which is the value of ``Cookie''
request header.  Usually, the same information is available to CGI
program via the environemnt variable @code{HTTP_COOKIE}.

If the cookie version is known, via ``Cookie2'' request header,
the integer version must be passed to @var{version}.  Otherwise,
@code{parse-cookie} figures out the version from @var{string}.

The result has the following format.
@example
((<name> <value> [:path <path>] [:domain <domain>] [:port <port>])
 @dots{})
@end example
where @var{<name>} is the attribute name, and @var{<value>} is
the corresponding value.  If the attribute doesn't have value,
@var{<value>} is @code{#f}.  (Note that it differs from the attribute
having null value, @code{""}.)
If the attribute has path, domain or port options, it is given
as a form of keyword-value pair.
@end defun

@defun construct-cookie-string specs &optional version
Given list of cookie specs, creates a cookie string suitable for
@code{Set-cookie2} or @code{Set-cookie} header.

Optional @var{version} argument specifies cookie protocol version.
0 for the old Netscape style format, and 1 for RFC2965 style format.
When omitted, version 1 is assumed.

Each cookie spec has the following format.
@example
(<name> <value> [:comment <comment>] [:comment-url <url>]
                [:discard <bool>] [:domain <domain>]
                [:max-age <age>] [:path <path>]
                [:port <port-list>] [:secure <bool>]
                [:version <version>] [:expires <date>])
@end example
Where,
@table @code
@item <name>
A string.  Name of the cookie.
@item <value>
Value of the cookie.  May be a string, or @code{#f} if no value is needed.
@item <comment> <url> <domain> <path> <port-list>
Strings.
@item <bool>
Boolean value
@item <age> <version>
Integers
@item <date>
Either an integer (seconds since Epoch) or a formatted date string
following the netscape cookie specification.
@end table

The attribute values are quoted appropriately.  If the specified attribute
is irrelevant for the @var{version}, it is ignored.  So you can pass
the same specs to generate both old-style and new-style cookie strings.

Return value is a list of cookie strings, each of which stands for
each cookie.  For old-style protocol (using @code{Set-cookie} header)
you must send each of them by individual header.  For new-style
protocol (using @code{Set-cookie2} header), you can join them
with comma and send it at once.  See RFC2965 for further details.

Some examples:
@example
(construct-cookie-string
   `(("name" "foo" :domain "foo.com" :path "/"
                   :expires ,(+ (sys-time) 86400) :max-age 86400)))
 @result{} ("name=foo;Domain=foo.com;Path=/;Max-age=86400")

(construct-cookie-string
   `(("name" "foo" :domain "foo.com" :path "/"
                   :expires ,(+ (sys-time) 86400) :max-age 86400))
   0)
 @result{}
 ("name=foo;Domain=foo.com;Path=/;Expires=Sun, 09-Sep-2001 01:46:40 GMT")
@end example
@end defun

@c ----------------------------------------------------------------------
@node FTP, HMAC keyed-hashing, HTTP cookie handling, Library modules - Utilities
@section @code{rfc.ftp} - FTP client
@c NODE FTPクライアント, @code{rfc.ftp} - FTPクライアント

@deftp {Module} rfc.ftp
@mdindex rfc.ftp
This module provides a set of convenient functions to access ftp
servers.
@end deftp

@deftp {Class} <ftp-connection>
@clindex ftp-connection
An object to keep FTP connection to a server.  It has the following
public slots.

@defivar {<ftp-connection>} transfer-type
FTP transfer type.  Must be one of the following symbols:
@code{ascii}, @code{binary} (default), and @code{image}.
FTPの転送タイプ。以下のシンボルのどれかひとつでなければなりません。
@code{ascii}、@code{binary} (デフォルト)、および@code{image}。
@end defivar

@defivar {<ftp-connection>} passive
True if the client uses passive connection.c
@end defivar

@defivar {<ftp-connection>} log-drain
This slot must hold a @code{<log-drain>} instance (@xref{User-level logging})
or @code{#f}.  If it has a @code{<log-drain>} instance, ftp communication
logs are put to it.

@end defivar
@end deftp

@deftp {Condition} <ftp-error>
@clindex ftp-error
This type of exception is thrown when the ftp server returns an error code.
Inherits @code{<error>}.  The message field contains the server reply,
including the status code.
@end deftp

@defun call-with-ftp-connection host proc &keyword passive port username password account log-drain
A high-level convenience routine to open an ftp connection to
an ftp server and calls the given procedure.

The server is specified by @var{host}.  Optionally, you can add user
name and/or port number by the form 
@code{@var{user}@@@var{servername}:@var{port}}.
If present, user and port portion in @var{host} supersedes the
keyword arguments.

If ftp connection to @var{host} is established successfully, 
@var{proc} is called with one argument, which is an instance
of @code{<ftp-connection>}.  When @var{proc} returns, 
the connection is closed and the return value(s) of @var{proc}
is/are returned from @code{call-with-ftp-connection}.
When an exception is thrown, the ftp connection is closed
before the exception escapes from @code{call-with-ftp-connection}.

When a true value is given to the keyword argument @var{passive},
created ftp connection will use passive mode to send/receive
data.  The default is the active mode.

The keyword argument @var{port}, @var{username}, and @var{password}
specify the port number, username, and password, respectively.
When omitted, the port number defaults to 21, @var{username} to
@code{"anonymous"}, and @var{password} to @code{"anonymous@@"}.
Note that the port number and/or username are ignored when
those information is given in the @var{host} argument.

If the keyword arugment @var{account} is given, its value
is passed to ftp @code{ACCT} command when requested by
the server at login time.  The defalut value is a null string @code{""}.

The keyword argument @var{log-draion} is set to the created
ftp connection's @code{log-drain} slot.
@end defun

@defun ftp-transfer-type conn
Returns the transfer type of the ftp connection @code{conn}.
Can be used with setter, e.g. @code{(set! (ftp-transfer-type conn) 'ascii)}.
@end defun

@defun ftp-passive? conn
Returns true iff ftp connection uses passive data retrieval.
@end defun

@defun ftp-login host &keyword passive port username password account log-drain
Connects to the ftp server specified by @var{host}, authenticate the user,
and returns a newly created @code{<ftp-connection>} instance.
This procedure is called implicitly when you use
@code{call-with-ftp-connection}.  The semantics of
the @var{host} argument and the keyword arguments are
the same as @code{call-with-ftp-connection}.
@end defun

@defun ftp-quit conn
Sends ftp @code{QUIT} command to the connection @var{conn} and
shutdown the connection.
This procedure is called implicitly when you use
@code{call-with-ftp-connection}.

Once a connection is shut down, you cannot communicate through
this connection.
@end defun

@defun ftp-chdir conn dirname
Changes the remote directory to @var{dirname}.
@end defun

@defun ftp-remove conn path
Removes the remote file named by @var{path}.
@end defun

@defun ftp-help conn &optional option @dots{}
Sends ftp @code{HELP} commands.  @var{Option}s must be strings,
and will be passed to the @code{HELP} command arguments.
@end defun

@defun ftp-mkdir conn dirname
Creates a directory @var{dirname}.  Returns the created directory
name.
@end defun

@defun ftp-current-directory conn
Returns the current remote directory.
@end defun

@defun ftp-site conn arg
Sends ftp @code{SITE} command with the argument @var{arg}.
The @code{SITE} command's semantics depends on the server.
Returns the server reply.
@end defun

@defun ftp-rmdir conn dirname
Removes remote directory specified by @var{dirname}.
Returns the server reply.
@end defun

@defun ftp-stat conn &optional pathname
Sends ftp @code{STAT} command to the server.
RFC959 defines several different semantics of this command.
See RFC959 for the details.
Returns the server reply.
@end defun

@defun ftp-system conn
Queries the server's operating system by ftp @code{SYST} command.
Returns the server reply without status code.

@example
(call-with-ftp-connection "localhost" ftp-system)
  @result{} "UNIX Type: L8"
@end example
@end defun

@defun ftp-size conn path
Queries the size of the remote file specified by @var{path}.
Returns the integer value.
@end defun

@defun ftp-mdtm conn path
Queries the modification time of the remote file specified by @var{path}.
This function returns the server's reply as is, including the status
code.  Use @code{ftp-mtime} below to obtain a parsed result.
@end defun

@defun ftp-mtime conn path &optional local-time?
Queries the modification time of the remote file specified by @var{path},
and returns the result in a @code{<date>} object 
(@xref{Time data types and procedures}).
If a true value is given to @code{local-time?}, the returned date is
in local time.  Otherwise, the returned date is in UTC.
@end defun

@defun ftp-noop conn
Sends ftp @code{NOOP} command and returns the server's reply.
@end defun

@defun ftp-list conn &optional path
Returns the information about the files within the remote file 
or directory specified by @var{path}, or the current remote directory,
much like @code{ls(1)} format.  Returns a list of strings, where
each string is for each line of the server's reply.  The exact
format depends on the server.
Return the list of names in the specfied @var{path}, or the current
remote directory, without any other information.  @code{ftp-ls}
is just an alias of @code{ftp-name-list} for the convenience.

Note that the server may return an error if there's no files
in the remote directory.
@end defun

@defun ftp-get conn path &keyword sink flusher
Retrieves a remote file @var{path}.  The retrieved data is
sent to an output port given to @var{sink}.  Once all the data
is retrieved, a procedure given to @var{flusher} is called
with the port @var{sink} as an argument, and its return value(s)
is/are returned from @code{ftp-get}.  

The default values of @var{sink} and @var{flusher} are
a newly created string port and @code{get-output-string}, respectively.
That is, @code{ftp-get} returns the retrieved data as a string
by default.
You don't want this behavior if the retrieved file is huge.
@end defun

@defun ftp-put conn from-file &optional to-file
Sends the local file specified by @var{from-file} to the remote
server as the name specified by @var{to-file}.  If @var{to-file}
is omitted, the basename of @var{from-file} is used.
Returns the server response.
@end defun

@defun ftp-put-unique conn from-file
Sends the local file specified by @var{from-file} to the 
remote server.  The remote side filename is guaranteed to 
be unique.  Returns two values---the final server response,
and the remote file name.  The second value can be @code{#f}
if the remote host doesn't support RFC1123 (which must be rare).
@end defun

@defun ftp-rename conn from-name to-name
Renames the remote file specified by @var{from-name} to the
name @var{to-name}.  Returns the final response of the server.
@end defun

@c ----------------------------------------------------------------------
@node HMAC keyed-hashing, HTTP, FTP, Library modules - Utilities
@section @code{rfc.hmac} - HMAC keyed-hashing
@c NODE HMAC鍵付きハッシング, @code{rfc.hmac} - HMAC鍵付きハッシング

@deftp {Module} rfc.hmac
@mdindex rfc.hmac
This module implements HMAC algorithm,
Keyed-hashing for message authentication, defined in RFC 2104.

For simple batched keyed hashing, you can use high-level API 
@code{hmac-digest} and @code{hmac-digest-string}.
Or you can create @code{<hmac>} object and update its state
as the data coming in.
@end deftp

@deftp {Class} <hmac>
@clindex hmac
Keeps state information of HMAC algorithm.
Key and the hashing algorithm should be given at the construction
time, using @code{:key} and @code{:hasher} keyword-arguments respectively.
You can pass any class object that implements message digest 
interface (@xref{Message digester framework}),
such as @code{<md5>} (@xref{MD5 message digest})
or @code{<sha1>} (@xref{SHA1 message digest}).

Example:
@example
(make <hmac> :key (make-byte-string 16 #x0b) :hasher <md5>)
@end example
@end deftp

@deffn {Method} hmac-update! (hmac <hmac>) data
Updates the internal state of @var{hmac} by @var{data},
which must be represented by a (possibly incomplete) string.
@end deffn

@deffn {Method} hmac-final! (hmac <hmac>)
Finalizes the internal state of @var{hmac} and returns the
hashed string in incomplete string.
You can use @code{digest-hexify}
(@xref{Message digester framework}) to obtain "hexified"
result.
Once finalized, you can't call @code{hmac-update!} or @code{hmac-final!}
on @var{hmac}.
@end deffn

@deffn {Method} hmac-digest &keyword key hasher
Creates an @code{<hmac>} object and hash the data stream
from the current input port, then returns the hashed result
in an incomplete string.
@end deffn

@deffn {Method} hmac-digest-string string &keyword key hasher
Creates an @code{<hmac>} object and hash the data in @var{string},
then returns the hashed result in an incomplete string.
@end deffn

@c ----------------------------------------------------------------------
@node HTTP, IP packets, HMAC keyed-hashing, Library modules - Utilities
@section @code{rfc.http} - HTTP

@deftp {Module} rfc.http
@mdindex rfc.http
This module provides a simple client API for
HTTP/1.1, defined in RFC2616, "Hypertext Transfer Protocol -- HTTP/1.1"
(@ref{rfc2616, [RFC2616], RFC2616}).

Current API implements only a part of the protocol.
Only GET, HEAD, and POST requests are supported,
it doesn't talk with HTTP/1.0 server yet,
and it doesn't support HTTP/1.1 advanced features
such as persistent connection.
Support for those features may be added in the future versions.
@end deftp

@deftp {Condition} <http-error>
@clindex http-error
This type of condition is raised when the server terminates
connection prematurely or server's response has invalid
header fields.  Inherits @code{<error>}.
@end deftp

@defun http-get server request-uri &keyword sink flusher no-redirect @dots{}
@defunx http-head server request-uri &keyword no-redirect @dots{}
@defunx http-post server request-uri body &keyword sink flusher no-redirect @dots{}

Send http GET, HEAD and POST requests to the http @var{server},
respectively, and returns the server's reply.

If the server returns "3xx" redirection reply, these procedures
try to follow the URI returned in the "location" reply message header
by default.  See the "keyword arguments" heading below to suppress
redirection following.

@strong{Required arguments:}
The @var{server} argument specifies http server name in a string.
A server name can be optionally followed by colon and a port number.
Examples: @code{"w3c.org"}, @code{"mycompany.com:8080"}.

The @var{request-uri} argument is the request-uri specified in
RFC2616; usually, this is the path part of http url.

@code{Http-post} takes the third argument, @var{body}, which is
a string to be posted to the server.   The body is sent "as is";
the caller has to take care of necessary escaping or encoding.

So, the most simple form of retrieving the content will be
something like this:
@example
(http-get "practical-scheme.net" "/gauche/index.html")
@end example

Access via proxy can be done by specifying proxy server to @var{server}
and passing the entire URI to @var{request-uri}, but the author
haven't tested yet.

@strong{Return values:}
All procedures return three values.

The first value is the status code defined in RFC2616
in a string (such as "200" for success, "404" for "not found").

The second value is a list of parsed headers---each element of list
is a list of @code{(@var{header-name} @var{value} @dots{})}, 
where @var{header-name} is a string name of the header
(such as "content-type" or "location"), and @var{value} is
the corresponding value in a string.  The header name is converted
to lowercase letters.  The value is untouched except that "soft line breaks"
are removed, as defined in RFC2822.   If the server returns
more than one headers with the same name, their values are
consolidated to one list.  Except that, the order of the header list
in the second return value is the same as the order in the server's reply.

The third value is for the message body of the server's reply.
By default, it is a message body itself in a string.   If the server's
reply doesn't have a body, the third value is @code{#f}.  You can
change how the message body is handled by keyword arguments; for example,
you can directly store the returned message body to a file without
creating intermediate string.  The details are explained below.

@strong{Keyword arguments:}
By default, these procedures only attaches @code{"Host"} header
field to the request message.  You can give keyword arguments
to add more header fields.
@example
(http-get "foo.bar.com" "/index.html"
  :accept-language "ja"
  :user-agent "My Scheme Program/1.0")
@end example

The following keyword arguments are recognized by the procedure
and do not appear in the request headers.

@table @var
@item no-redirect
If a true value is given, suppress the redirection tracking;
i.e. the procedures return "3xx" message as is.
@item sink, flusher
You can customize how the message body is handled by these
keyword arguments.  You have to pass an output port to @var{sink},
and a procedure that takes two arguments to @var{flusher}.

When the procedure starts receiving the message body, it
feeds the received chunk to @var{sink}.  When the procedure
receives entire message body, @var{flusher} method is called
with @var{sink} and a list of message header fields (in the
same format to be returned in the second value from the procedure).
The return value of @var{flusher} becomes the third return value
from the procedure.

So, the default value of @var{sink} is a newly opened string
port and the default value of @var{flusher} is
@code{(lambda (sink headers) (get-output-string sink))}.

The following example saves the message body directly to a file,
without allocating (potentially very big) string buffer.
@example
(call-with-output-file "page.html"
  (lambda (out)
    (http-get "www.schemers.org" "/"
       :sink out :flusher (lambda _ #t))))
@end example

@end table

@end defun

@c ----------------------------------------------------------------------
@node IP packets, ICMP packets, HTTP, Library modules - Utilities
@section @code{rfc.ip} - IP packets
@c NODE IPパケット, @code{rfc.ip} - IPパケット

@deftp {Module} rfc.ip
@mdindex rfc.ip
This module provides some basic utilities to parse raw IP packets.
@end deftp

The @var{packet} argument in the following functions must be
any type of uniform vector (@xref{Uniform vectors}), containing
a raw IP packet including its IP header.
Those functions work for both IPv4 and IPv6 packets; however,
reading from a raw IPv6 socket returns a packet without IPv6 header,
so you usually don't need to use these functions.

@defun ip-version packet
Returns the IP version number (either 4 or 6) of the given IP packet.
@end defun

@defun ip-header-length packet
Returns the size of IP header of the given packet in octets,
including any IP header options.
@end defun

@defun ip-protocol packet
Returns the IP protocol number of the given packet.
@end defun

@defun ip-source-address packet
@defunx ip-destination-address packet
Returns the source and destination address in the given packet
in an integer, respectively.
@end defun


@c ----------------------------------------------------------------------
@node ICMP packets, MD5 message digest, IP packets, Library modules - Utilities
@section @code{rfc.icmp} - ICMP packets
@c NODE ICMPパケット, @code{rfc.icmp} - ICMPパケット

@deftp {Module} rfc.icmp
@mdindex rfc.icmp
This module provides some basic utilities to construct and parse ICMP
packets.
@end deftp

For the functions below, @var{buffer} should be a writable 
u8vector of the enough size.

Parsing functions takes @var{offset} as well as @var{buffer},
which specifies the beginning of the ICMP packet.  Using the offset
you can carry the whole IP packet in @var{buffer}, without
creating a new buffer to extract ICMP portion.

@defun icmp4-fill-echo! buffer ident sequence data
Fills @var{buffer} with the ICMPv4 Echo Request packet.
@var{Data} must be a u8vector.  The checksum field is
left to be zero, which can be filled by @code{icmp4-fill-checksum!}.
@end defun

@defun icmp4-fill-checksum! buffer size
Calculates the ICMPv4 checksum of the packet in the @var{buffer},
of @var{size} length (the size of the packet, not the buffer),
and fills the checksum field of the packet.
@end defun

@defun icmp6-fill-echo! buffer ident sequence data
Fills @var{buffer} with the ICMPv6 Echo Request packet.
@var{Data} must be a u8vector.  The checksum field is
left to be zero, which is to be filled by the kernel
(so you don't need to fill by yourself).
@end defun

@defun icmp-packet-type buffer offset
@defunx icmp-packet-code buffer offset
@defunx icmp-packet-ident buffer offset
@defunx icmp-packet-sequence buffer offsetj
Extracts type, code, ident and sequence fields of ICMP packet.
These functions are common to both ICMPv4/v6.
@end defun

@defun icmp4-describe-packet buffer offset
@defunx icmp6-describe-packet buffer offset
Prints out a simple text description of the given ICMPv4 and v6 packet,
respectively.
@end defun

@defun icmp4-message-type->string type
@defunx icmp4-unreach-code->string code
@defunx icmp4-redirect-code->string code
@defunx icmp4-router-code->string code
@defunx icmp4-exceeded-code->string code
@defunx icmp4-parameter-code->string code
@defunx icmp4-security-code->string code
@defunx icmp6-message-type->string type
@defunx icmp6-unreach-code->string code
@defunx icmp6-exceeded-code->string code
@defunx icmp6-parameter-code->string code
Returns a text description of ICMPv4 and ICMPv6 types and codes.
@end defun

@c ----------------------------------------------------------------------
@node MD5 message digest, MIME message handling, ICMP packets, Library modules - Utilities
@section @code{rfc.md5} - MD5 message digest
@c NODE MD5メッセージダイジェスト, @code{rfc.md5} - MD5メッセージダイジェスト

@deftp {Module} rfc.md5
@mdindex rfc.md5
This module implements MD5 message digest algorithm, defined in
RFC 1321 (@ref{rfc1321, [RFC1321], RFC1321}).
The module extends util.digest 
(@xref{Message digester framework}).
@end deftp

@deftp {Class} <md5>
@clindex md5
The instance of this class keeps internal state of MD5 digest algorithm.

This class implements @code{util.digest} framework interface,
@code{digest-update!}, @code{digest-final!}, 
@code{digest}, and @code{digest-string}.
@xref{Message digester framework}, for detailed explanation
of these methods.
@end deftp

Besides the digester framework, this module provides to 
short-cut procedures.

@defun md5-digest
Reads data from the current input port until EOF, and returns
its digest in an incomplete string.
@end defun

@defun md5-digest-string string
Digest the data in @var{string}, and returns the result 
in an incomplete string.
@end defun

@c ----------------------------------------------------------------------
@node MIME message handling, Quoted-printable encoding/decoding, MD5 message digest, Library modules - Utilities
@section @code{rfc.mime} - MIME message handling
@c NODE MIMEメッセージ処理, @code{rfc.mime} - MIMEメッセージ処理

@deftp {Module} rfc.mime
@mdindex rfc.mime
This module provides utility procedures to handle
Multipurpose Internet Mail Extensions (MIME) messages,
defined in RFC2045 thorough RFC2049.
This module is supposed to be used with @code{rfc.822} module
(@xref{RFC822 message parsing}).
@end deftp

@subheading Utilities for header fields

A few utility procedures to parse and generate MIME-specific header fields.

@defun mime-parse-version field
If @var{field} is a valid header field for MIME-Version, returns
its major and minor versions in a list.  Otherwise, returns @code{#f}.
It is allowed to pass @code{#f} to @var{field}, so that 
you can directly pass the result of @code{rfc822-header-ref} to it.
Given parsed header list by @code{rfc822-read-headers}, you can
get mime version (currently, it should be @code{(1 0)}) by the
following code.
@example
(mime-parse-version (rfc822-header-ref headers "mime-version"))
@end example

Note: simple regexp such as @code{#/\d+\.\d+/} doesn't do this job,
for @var{field} may contain comments between tokens.
@end defun

@defun mime-parse-content-type field
Parses the "content-type" header field, and returns a list such as:
@example
(@i{type} @i{subtype} (@i{attribute} . @i{value}) @dots{})
@end example
where @i{type} and @i{subtype} are MIME media type and
subtype in a string, respectively

@example
(mime-parse-content-type "text/html; charset=iso-2022-jp")
 @result{} ("text" "html" ("charset" . "iso-2022-jp"))
@end example

If @var{field} is not a valid content-type field, @code{#f} is
returned.
@end defun

@defun mime-decode-word word
Decodes RFC2047-encoded word.  If @var{word} isn't an encoded word,
it is returned as is.

Note that this procedure decodes only if the entire @var{word} is
an ``encoded word'' defined in RFC2047.  If you are dealing with
a field that may contain multiple encoded word and/or unencoded parts,
use @code{mime-decode-text} below.

@example
(mime-decode-word "=?iso-8859-1?q?this=20is=20some=20text?=")
 @result{} "this is some text"
@end example

@end defun
@defun mime-decode-text text
Returns a string in which 
all encoded words contained within @var{text} are decoded.
This procedure can deal with a header field body that may contain
mixture of non-encoded and encoded parts, and/or multiple encoded
parts.  One of such header field is the Subject field of email.

@example
(mime-decode-text "This is =?US-ASCII?q?some=20text?=")
 @result{} "This is some text"
@end example

Care should be taken if you apply this procedure to a ``structured''
header field body (see RFC2822 section 2.2.2).  
The proper way of parsing a structured header field body is
to tokenize it first, then to decode each word using @code{mime-decode-word}.
since the decoded text may contain characters that affects the tokenization.
(However, if you can just show the header field in human readable way
for informational purposes, you may just use @code{mime-decode-text}
on entire header field for the convenience).
@end defun

@defun mime-encode-word word &keyword charset transfer-encoding
Encodes @var{word} in the RFC2047 format.  The keyword
argument @var{charset} specifies the character encoding scheme
in string or symbol.
whose default is @code{utf-8}.  If @var{charset} differs from
Gauche's internal encoding and @var{word} is a complete string,
the procedure convers the character encoding to @var{charset},
then performs transfer encoding.

@example
(mime-encode-word "this is some text")
 @result{} "=?utf-8?B?dGhpcyBpcyBzb21lIHRleHQ=?="
@end example

The keyword argument @var{transfer-encoding} specifies how
the octets are encoded to transfer-safe characters.  You can
give a symbol @code{b}, @code{B} or @code{base64} for Base64,
and @code{Q}, @code{q}, @code{quoted-printable} for Quoted-printable
transfer encodings.  An error is raised if you pass values other
than those.  The default is Base64 encoding.

This procedure does not consider the length of the resulting
encoded word, which RFC2047 recommends to be less than 75 octets.
Use @code{mime-encode-text} below to conform the line length limit.

(Note: In most Gauche procedures, a keyword argument @code{encoding}
is used to specify character encodings.  In this context we have
two encodings, however, and to avoid the confusion we chose to use
the terms ``charset'' and ``transfer-encoding'' that appear in
RFC documents.)
@end defun

@defun mime-encode-text text &keyword charset transfer-encoding line-width start-column force
Encode @var{text} in RFC2047 format if necessary, and considering
line foling if the result gets too long.

The keyword arguments @var{charset} and @var{transfer-encoding} are the same
as @code{mime-encode-word}.

If the @var{text} only consists of printable ASCII characters,
no encoding is done, and only line folding is considered.
However, if a true value is given to the @var{force} argument,
even ASCII-only @var{text} is encoded.

The @var{line-width} specifies the maximum line width of the result.
Its default is 76.
If the encoded word gets too long, it is splitted to multiple encoded
words and CR LF SPC sequence (``folding white space'' defined in RFC2822)
are inserted inbetween.
You can suppress this behavior by passing @code{#f} or @code{0} to
@var{line-width}.
Since encoded word needs some overhead characters, it doesn't make much sense
to specify small value to @code{line-width}.  Current implementation
rejects @code{line-width} smaller than 30.

The @var{start-column} keyword argument can be used to 
shorten the first of folded
lines to make room for header field name.  For example, if
you want to encode the body of a Subject header field,
you can pass the value of @code{(string-length "Subject: ")} so that
the encoded result can directly concatenated after the header
field name.  The default value is 0.

This procedure is not designed to encode parts of structured
header fields, which have further restrictions such as which parts
can be encoded and where the folding white spaces can be inserted.
The robust way is to encode some parts first, then construct
a structured header fields, considering line folding.
@end defun

@subheading Streaming parser

The streaming parser is designed so that you can decide how
to do with the message body before the entire message is read.

@defun mime-parse-message port headers handler
The fundamental streaming parser.  @var{Port} is an input port
from where the message is read.  @var{Headers} is a list of headers
parsed by @code{rfc822-read-headers}; that is, this procedure
is supposed to be called after the header part of the message
is parsed from @var{port}:
@example
(let* ((headers (rfc822-read-headers port)))
  (if (mime-parse-version (rfc822-header-ref headers "mime-version"))
     ;; parse MIME message
     (mime-parse-message port headers handler)
     ;; retrieve a non-MIME body
     ...))
@end example

@code{Mime-parse-message} analyzes @var{headers}, and calls
@var{handler} on each message body with two arguments:

@example
(handler @var{part-info} @var{xport})
@end example

@var{Part-Info} is a @code{<mime-part>} structure described below
that encapsulates the information of this part of the message.
@var{Xport} is an input port, initially points to the beginning
of the body of message.  The handler can read from the port
as if it is reading from the original @var{port}.  However,
@var{xport} recognizes MIME boundary internally, and returns EOF
when it reaches the end of the part.
(Do not read from the original @var{port} directly, or it will mess up
the internal state of @var{vport}).

@var{Handler} can read the part into the memory, or
save it to the disk, or even discard the part.
Whatever it does, it has to read from @var{vport} until it
returns EOF.

The return value of @var{handler} will be set in
the @code{content} slot of @var{part-info}.
If the message has nested multipart messages, @var{handler} is
called for each "leaf" part, in depth-first order.  @var{Handler}
can know its nesting level by examining @var{part-info} structure.
The message doesn't need to be a multipart type; if it is a
MIME @code{message} type, @var{handler} is called on the body
of enclosed message.  If it is other media types such as @code{text}
or @code{application}, @var{handler} is called on the (only) message body.
@end defun

@deftp {Class} <mime-part>
@clindex mime-message
A structure that encloses metainformation about a MIME part.
It is constructed when the header of the part is read, and
passed to the handler that reads the body of the part.

It has the following slots:

@defivar {<mime-part>} type
MIME media type string.  If @code{content-type} header is omitted
to the part, an appropriate default value is set.
@end defivar

@defivar {<mime-part>} subtype
MIME media subtype string.  If @code{content-type} header is omitted
to the part, an appropriate default value is set.
@end defivar

@defivar {<mime-part>} parameters
Associative list of parameters given to @code{content-type} header field.
@end defivar

@defivar {<mime-part>} transfer-encoding
The value of @code{content-transfer-encoding} header field.
If the header field is omitted, an appropriate default value is set.
@end defivar

@defivar {<mime-part>} headers
The list of header fields, as parsed by @code{rfc822-read-headers}.
@end defivar

@defivar {<mime-part>} parent
If this is a part of multipart message or encapsulated message,
points to the enclosing part's @code{<mime-part>} structure.
Otherwise @code{#f}.
@end defivar

@defivar {<mime-part>} index
Sequence number of this part within the same parent.
@end defivar

@defivar {<mime-part>} content
If this part is multipart/* or message/* media type,
this slot contains a list of parts within it.
Otherwise, the return value of @var{handler} is stored.
@end defivar
@end deftp

@defun mime-retrieve-body part-info xport outp
A procedure to retrieve message body.  It is intended to
to be a building block of @var{handler} to be passed to
@code{mime-parse-message}.

@var{Part-info} is a @code{<mime-part>} object.
@var{Xport} is an input port passed to the handler,
from which the MIME part can be read.
This procedure read from @var{xport}
until it returns EOF.  It also looks at the
@code{transfer-encoding} of @var{part-info}, and decodes
the body accordingly; that is, base64 encoding and
quoted-printable encoding is handled.  The result is
written out to an output port @var{outp}.

This procedure does not handle charset conversion.
The caller must use CES conversion port as @var{outp}
(@xref{Character code conversion}) if desired.
@end defun

A couple of convenience procedures are defined for typical
cases on top of @code{mime-retrieve-body}.

@defun mime-body->string part-info xport
@defunx mime-body->file part-info xport filename
Reads in the body of mime message, decoding transfer encoding,
and returns it as a string or writes it to a file, respectively.
@end defun

The simplest form of MIME message parser would be like this:

@example
(let ((headers (rfc822-read-headers port)))
  (mime-parse-message port headers
                      (cut mime-body->string <> <>)))
@end example

This reads all the message on memory (i.e. the "leaf" @code{<mime-part>}
objects' @code{content} field would hold the part's body as a string),
and returns the top @code{<mime-part>} object.  Content transfer encoding
is recognized and handled, but character set conversion isn't done.

You may want to feed the message body to a file directly,
or even want to skip some body according to mime media types and/or
other header information.  Then you can put the logic in the handler
closure.  That's the reason that this module provides building
blocks, instead of all-in-one procedure.


@c ----------------------------------------------------------------------
@node Quoted-printable encoding/decoding, SHA1 message digest, MIME message handling, Library modules - Utilities
@section @code{rfc.quoted-printable} - Quoted-printable encoding/decoding
@c NODE Quoted-printableエンコーディング, @code{rfc.quoted-printable} - Quoted-printableエンコーディング

@deftp {Module} rfc.quoted-printable
@mdindex rfc.quoted-printable
This module defines a few functions to encode/decode Quoted-printable format,
defined in RFC 2045 (@ref{rfc2045, [RFC2045], RFC2045}), section 6.7.
@end deftp

@defun quoted-printable-encode &keyword line-width binary
Reads byte stream from the current input port, encodes it in Quoted-printable
format and writes the result character stream to the current output port.
The conversion ends when it reads EOF from the current input port.
The keyword argument @var{line-width} specifies the maximum 
line width of the generated output in characters.  If the encoded
output creates a long line, the procedure inserts a ``soft line break''
so that the each line is equal to or shorter than this number.
Soft line breaks are removed when quoted-printable text is
decoded.
The default line width is 76.  (The minimum meaningful number of
line-width is 4).  You can suppress soft line breaks by
giving @code{#f} or @code{0} to @var{line-width}.
By default, @code{quoted-printable-encode} generates @code{CR-LF} sequence
for each line break in the input (``hard line break'').
When a true value is given to the keyword argument @var{binary},
however, octets @code{#x0a} and @code{#x0d} in the input are encoded
as @code{=0A} and @code{=0D}, respectively.  See RFC2045 section 6.7
for the details.
@end defun

@defun quoted-printable-encode-string string &keyword line-width binary
Converts contents of @var{string} to Quoted-printable encoded format.
Input string can be either complete or incomplete string;
it is always interpreted as a byte sequence.

The keyword arguments are the same as @code{quoted-printable-encode}.
@end defun

@defun quoted-printable-decode
Reads character stream from the current input port,
decodes it from Quoted-printable
format and writes the result byte stream to the current output port.
The conversion ends when it reads EOF.
If it encounters illegal character sequence (such as '=' followed 
by non-hexadecimal characters), it copies them literally to the output.
@end defun

@defun quoted-printable-decode-string string
Decodes a Quoted-printable encoded string @var{string} and returns
the result as a string.
@end defun

@c ----------------------------------------------------------------------
@node SHA1 message digest, URI parsing and construction, Quoted-printable encoding/decoding, Library modules - Utilities
@section @code{rfc.sha1} - SHA1 message digest
@c NODE SHA1メッセージダイジェスト, @code{rfc.sha1} - SHA1メッセージダイジェスト

@deftp {Module} rfc.sha1
@mdindex rfc.sha1
This module implements US Secure Hash Algorithm 1 (SHA1), 
defined in RFC 3174 (@ref{rfc3174, [RFC3174], RFC3174}).
The module extends util.digest 
(@xref{Message digester framework}).
@end deftp

@deftp {Class} <sha1>
@clindex sha1
The instance of this class keeps internal state of SHA1 digest algorithm.

This class implements @code{util.digest} framework interface,
@code{digest-update!}, @code{digest-final!}, 
@code{digest}, and @code{digest-string}.
@xref{Message digester framework}, for detailed explanation
of these methods.
@end deftp

Besides the digester framework, this module provides to 
short-cut procedures.

@defun sha1-digest
Reads data from the current input port until EOF, and returns
its digest in an incomplete string.
@end defun

@defun sha1-digest-string string
Digest the data in @var{string}, and returns the result 
in an incomplete string.
@end defun

@c ----------------------------------------------------------------------
@node URI parsing and construction, SLIB, SHA1 message digest, Library modules - Utilities
@section @code{rfc.uri} - URI parsing and construction
@c NODE URIの解析と作成, @code{rfc.uri} - URIの解析と作成

@deftp {Module} rfc.uri
@mdindex rfc.uri
Provides a set of functions to parse Uniform Resource Identifiers
defined in RFC 2396 (@ref{rfc2396, [RFC2396], RFC2396}).
@end deftp

@defun uri-parse uri
@defunx uri-scheme&specific uri
@defunx uri-decompose-hierarchical specific
@defunx uri-decompose-authority authority
General parser of URI.  These functions does not decode
URI encoding, since the parts to be decoded differ among
the uri schemes.   After parsing uri, use @code{uri-decode} below
to decode them.

@code{uri-parse} is the most handy procedure.  It breaks the uri
into the following parts and returns them as multiple values.
If the uri doesn't have the corresponding
parts, @code{#f} are returned for the parts.

@itemize @bullet
@item
URI scheme as a string
(e.g. @code{"mailto"} in @code{"mailto:foo@@example.com"}).
@item
User-info in the authority part (e.g. @code{"anonymous"}
in @code{ftp://anonymous@@ftp.example.com/pub/foo}).
@item
Hostname in the authority part (e.g. @code{"ftp.example.com"}
in @code{ftp://anonymous@@ftp.example.com/pub/foo}).
@item
Port number in the authority part, as an integer (e.g. @code{8080}
in @code{http://www.example.com:8080/}).
@item
Path part (e.g. @code{"/index.html"} in
@code{http://www.example.com/index.html}).
@item
Query part (e.g. @code{"key=xyz&lang=en"} in
@code{http://www.example.com/search?key=xyz&lang=en}).
@item
Fragment part (e.g. @code{"section4"} in
@code{http://www.example.com/document.html#section4}).
@end itemize

The following procedures are finer grained and break up
uris with different stages.

@code{uri-scheme&specific} takes a URI @var{uri}, and
returns two values, its scheme part and its scheme-specific part.
If @var{uri} doesn't have a scheme part, @var{#f} is returned for it.
@example
(uri-scheme&specific "mailto:sclaus@@north.pole")
  @result{} "mailto" @r{and} "sclaus@@north.pole"
(uri-scheme&specific "/icons/new.gif")
  @result{} #f @r{and} "/icons/new.gif"
@end example

If the URI scheme uses hierarchical notation, i.e.
``@code{//@var{authority}/@var{path}?@var{query}#@var{fragment}}'',
you can pass
the scheme-specific part to @code{uri-decompose-hierarchical}
and it returns four values, @var{authority}, @var{path}, @var{query}
and @var{fragment}.
@example
(uri-decompose-hierarchical "//www.foo.com/about/company.html")
  @result{} "www.foo.com"@r{,} "/about/company.html"@r{,} #f @r{and} #f
(uri-decompose-hierarchical "//zzz.org/search?key=%3fhelp")
  @result{} "zzz.org"@r{,} "/search"@r{,} "key=%3fhelp" @r{and} #f
(uri-decompose-hierarchical "//jjj.jp/index.html#whatsnew")
  @result{} "jjj.jp"@r{,} "/index.html"@r{,} #f @r{and} "whatsnew"
(uri-decompose-hierarchical "my@@address")
  @result{} #f@r{,} #f@r{,} #f @r{and} #f
@end example

Furthermore, you can parse @var{authority} part of the
hierarchical URI by @code{uri-decompose-authority}.
It returns @var{userinfo}, @var{host} and @var{port}.
@example
(uri-decompose-authority "yyy.jp:8080")
  @result{} #f@r{,} "yyy.jp" @r{and} "8080"
(uri-decompose-authority "mylogin@@yyy.jp")
  @result{} "mylogin"@r{,} "yyy.jp" @r{and} #f
@end example
@end defun

@defun uri-compose &keyword scheme userinfo host port authority path path* query fragment specific
Compose a URI from given components.
There can be various combinations of components to create a valid
URI---the following diagram shows the possible 'paths' of
combinations:

@example
        /-----------------specific-------------------\
        |                                            |
 scheme-+------authority-----+-+-------path*---------+-
        |                    | |                     |
        \-userinfo-host-port-/ \-path-query-fragment-/
@end example

If @code{#f} is given to a keyword argument, it is
equivalent to the absence of that keyword argument.
It is particularly useful to pass the results of
parsed uri.

If a component contains a character that is not appropriate
for that component, it must be properly escaped before
being passed to @code{url-compose}.

Some examples:
@example
(uri-compose :scheme "http" :host "foo.com" :port 80
             :path "/index.html" :fragment "top")
  @result{} "http://foo.com:80/index.html#top"

(uri-compose :scheme "http" :host "foo.net"
             :path* "/cgi-bin/query.cgi?keyword=foo")
  @result{} "http://foo.net/cgi-bin/query.cgi?keyword=foo"

(uri-compose :scheme "mailto" :specific "a@@foo.org")
  @result{} "mailto:a@@foo.org"

(receive (authority path query fragment)
   (uri-decompose-hierarchical "//foo.jp/index.html#whatsnew")
 (uri-compose :authority authority :path path
              :query query :fragment fragment))
  @result{} "//foo.jp/index.html#whatsnew"
@end example
@end defun

@defun uri-decode &keyword :cgi-decode
@defunx uri-decode-string string &keyword :cgi-decode :encoding
Decodes ``URI encoding'', i.e. @code{%}-escapes.
@code{uri-decode} takes input from the current input port,
and writes decoded result to the current output port.
@code{uri-decode-string} takes input from @var{string} and
returns decoded string.

If @var{cgi-decode} is true, also replaces @code{+} to a space character.

To @code{uri-decode-string} you can provide the external character
encoding by the @var{encoding} keyword argument.  When it is given,
the decoded octet sequence is assumed to be in the specified encoding
and converted to the Gauche's internal character encoding.
@end defun

@defun uri-encode &keyword :noescape
@defunx uri-encode-string string &keyword :noescape :encoding
Encodes unsafe characters by @code{%}-escape.  @code{uri-encode}
takes input from the current input port and writes the result to
the current output port.  @code{uri-encode-string} takes input
from @var{string} and returns the encoded string.

By default, characters that are not specified ``unreserved'' in
RFC3986 are escaped.  You can pass different character
set to @var{noescape} argument to keep from being encoded.
For example, the older RFC2396 has several more ``unreserved''
characters, and passing @code{*rfc2396-unreserved-char-set*} (see below)
prevents those characters from being escaped.

The multibyte characters are encoded as the octet stream of Gauche's
native multibyte representation by default.  However, you can pass
the @code{encoding} keyword argument to @code{uri-encode-string},
to convert @var{string} to the specified character encoding.
@end defun

@defvr {Constant} *rfc2396-unreserved-char-set*
@defvrx {Constant} *rfc3986-unreserved-char-set*
These constants are bound to character sets that represents
``unreserved'' characters defined in RFC2396 and RFC3986, respectively.
(See @ref{Character set}, and @ref{Character-set library}, for
operations on character sets).
@end defvr


@c ----------------------------------------------------------------------
@node SLIB, Functional XML parser, URI parsing and construction, Library modules - Utilities
@section @code{slib} - SLIB interface
@c NODE SLIBインタフェース, @code{slib} - SLIBインタフェース

@deftp {Module} slib
@mdindex slib
This module is the interface to the Aubrey Jaffer's SLIB.
To use SLIB, say @code{(use slib)}.   SLIB itself is not included
in Gauche distribution.   If you don't have it on your system,
get it from @uref{http://www-swiss.ai.mit.edu/~jaffer/SLIB.html}.

This module redefines @code{require}, shadowing the Gauche's original
@code{require}.  If it gets a symbol as an argument, it works as
SLIB's @code{require}, while if it gets a string, it works as
Gauche's @code{require}.   The same applies to @code{provide} and
@code{provided?}.

All SLIB symbol bindings, loaded by @code{require}, stay in the
module @code{slib}.
@end deftp

@example
(use slib)         ; @r{load and set up slib}
(require 'getopt)  ; @r{load SLIB's getopt module}
(require "foo")    ; @r{load Gauche's foo module}
@end example

@c ----------------------------------------------------------------------
@node Functional XML parser, SXML Query Language, SLIB, Library modules - Utilities
@section @code{sxml.ssax} - Functional XML parser
@c NODE 関数的なXMLパーザ, @code{sxml.ssax} - 関数的なXMLパーザ

@deftp {Module} sxml.ssax
@mdindex sxml.ssax
@code{sxml.*} modules are the adaptation of
Oleg Kiselyov's SXML framework (@ref{ssax,,SSAX}),
which is based on S-expression representation of XML structure.

SSAX is a parser part of SXML framework.
This is a quote from SSAX webpage:

@quotation
A SSAX functional XML parsing framework consists of a DOM/SXML parser,
a SAX parser, and a supporting library of lexing and parsing procedures.
The procedures in the package can be used separately to tokenize or parse
various pieces of XML documents.
The framework supports XML Namespaces, character, internal
and external parsed entities, attribute value normalization,
processing instructions and CDATA sections. The package includes
a semi-validating SXML parser : a DOM-mode parser that is an
instantiation of a SAX parser (called SSAX).
@end quotation

The current version is based on the SSAX CVS version newer than
the last 'official' release of SXML toolset (4.9), and
SXML-gauche-0.9 package which was based on SXML-4.9.
There is an important change from that release.
Now the API uses lowercase letter suffix @code{ssax:}
instead of uppercase @code{SSAX:}---the difference matters since
Gauche is case sensitive by default.
Alias names are defined for backward compatibility,
but the use of uppercase suffixed names are deprecated.
@end deftp

I derived the content of this part of the manual from SSAX
source code, just by converting its comments into texinfo format.
The original text is by Oleg Kiselyov.  Shiro Kawai
should be responsible for any typographical error or formatting error
introduced by conversion.

The manual entries are ordered in "bottom-up" way, beginning from
the lower-level constructs towards the high-level utilities.
If you just want to parse XML document and obtain SXML,
check out @code{ssax:xml->sxml} in @ref{SSAX Highest-level parsers - XML to SXML}.

@c ----------------------------------------------------------------------
@menu
* SSAX data types::             
* SSAX low-level parsing code::  
* SSAX higher-level parsers and scanners::  
* SSAX Highest-level parsers - XML to SXML::  
@end menu

@node SSAX data types, SSAX low-level parsing code, Functional XML parser, Functional XML parser
@subsection SSAX data types
@c NODE SSAXデータタイプ

@table @emph
@item TAG-KIND
a symbol '@code{START}, '@code{END}, '@code{PI}, '@code{DECL}, '@code{COMMENT}, '@code{CDSECT}
or '@code{ENTITY-REF} that identifies a markup token.
@item UNRES-NAME
a name (called @code{GI} in the XML Recommendation) as given in an xml
document for a markup token: start-tag, @code{PI} target, attribute name.
If a @code{GI} is an @code{NCName}, @var{UNRES-NAME} is this @code{NCName} converted into
a Scheme symbol. If a @code{GI} is a @code{QName}, @var{UNRES-NAME} is a pair of
symbols: (@var{PREFIX} . @var{LOCALPART})
@item RES-NAME
An expanded name, a resolved version of an @var{UNRES-NAME}.
For an element or an attribute name with a non-empty namespace URI,
@var{RES-NAME} is a pair of symbols, (@var{URI-SYMB} . @var{LOCALPART}).
Otherwise, it's a single symbol.
@item ELEM-CONTENT-MODEL
A symbol:
@multitable @columnfractions .3 .7
@item @code{ANY}
@tab anything goes, expect an END tag.
@item @code{EMPTY-TAG} 
@tab no content, and no END-tag is coming.
@item @code{EMPTY} 
@tab no content, expect the END-tag as the next token.
@item @code{PCDATA}
@tab expect character data only, and no children elements.
@item @code{MIXED}
@tab
@item @code{ELEM-CONTENT}
@tab
@end multitable
@item URI-SYMB
A symbol representing a namespace URI -- or other symbol chosen
by the user to represent URI. In the former case,
@var{URI-SYMB} is created by @code{%}-quoting of bad URI characters and
converting the resulting string into a symbol.
@item NAMESPACES
A list representing namespaces in effect. An element of the list
has one of the following forms:

@table @code
@item (@var{prefix} @var{uri-symb} . @var{uri-symb})
or,
@item (@var{prefix} @var{user-prefix} . @var{uri-symb})
@var{user-prefix} is a symbol chosen by the user
to represent the URI.
@item (#f @var{user-prefix} . @var{uri-symb})
Specification of the user-chosen prefix and a @var{uri-symbol}.
@item (*DEFAULT* @var{user-prefix} . @var{uri-symb})
Declaration of the default namespace
@item (*DEFAULT* #f . #f)
Un-declaration of the default namespace. This notation
represents overriding of the previous declaration
@end table

A @var{NAMESPACES} list may contain several elements for the same @var{PREFIX}.
The one closest to the beginning of the list takes effect.

@item ATTLIST
An ordered collection of (@var{NAME} . @var{VALUE}) pairs, where @var{NAME} is
a @var{RES-NAME} or an @var{UNRES-NAME}. The collection is an ADT.
@item STR-HANDLER
A procedure of three arguments:
@code{(@var{string1} @var{string2} @var{seed})}
returning a new @var{seed}.
The procedure is supposed to handle a chunk of character data
@var{string1} followed by a chunk of character data @var{string2}.
@var{string2} is a short string, often "\n" and even ""
@item ENTITIES
An assoc list of pairs:
@example
  (@var{named-entity-name} . @var{named-entity-body})
@end example
where @var{named-entity-name} is a symbol under which the entity was
declared, @var{named-entity-body} is either a string, or
(for an external entity) a thunk that will return an
input port (from which the entity can be read).
@var{named-entity-body} may also be @code{#f}. This is an indication that a
@var{named-entity-name} is currently being expanded. A reference to
this @var{named-entity-name} will be an error: violation of the
WFC nonrecursion.
@item XML-TOKEN
A record with two slots, @var{kind} and @var{token}.
This record represents a markup, which is, according to the XML
Recommendation, "takes the form of start-tags, end-tags, empty-element tags,
entity references, character references, comments, CDATA section delimiters,
document type declarations, and processing instructions."
@table @var
@item kind
a @var{TAG-KIND}
@item head
an @var{UNRES-NAME}. For xml-tokens of kinds '@code{COMMENT} and
'@code{CDSECT}, the head is @code{#f}
@end table

For example,
@example
<P>  => kind='START, head='P
</P> => kind='END, head='P
<BR/> => kind='EMPTY-EL, head='BR
<!DOCTYPE OMF ...> => kind='DECL, head='DOCTYPE
<?xml version="1.0"?> => kind='PI, head='xml
&my-ent; => kind = 'ENTITY-REF, head='my-ent
@end example
Character references are not represented by xml-tokens as these references
are transparently resolved into the corresponding characters.
@item XML-DECL
A record with three slots, @var{elems}, @var{entities}, and @var{notations}.

The record represents a datatype of an XML document: the list of
declared elements and their attributes, declared notations, list of
replacement strings or loading procedures for parsed general
entities, etc. Normally an xml-decl record is created from a DTD or
an XML Schema, although it can be created and filled in in many other
ways (e.g., loaded from a file).

@var{elems}: an (assoc) list of decl-elem or @code{#f}. The latter instructs
the parser to do no validation of elements and attributes.

@var{decl-elem}: declaration of one element:
@code{(@var{elem-name} @var{elem-content} @var{decl-attrs})};
@var{elem-name} is an @var{UNRES-NAME} for the element.
@var{elem-content} is an @var{ELEM-CONTENT-MODEL}.
@var{decl-attrs} is an @var{ATTLIST},
of @code{(@var{attr-name} . @var{value})} associations.
This element can declare a user procedure to handle parsing of an
element (e.g., to do a custom validation, or to build a hash of
IDs as they're encountered).

@var{decl-attr}: an element of an @var{ATTLIST}, declaration of one attribute
@code{(@var{attr-name} @var{content-type} @var{use-type} @var{default-value})}:
@var{attr-name} is an @var{UNRES-NAME} for the declared attribute;
@var{content-type} is a symbol: @code{CDATA}, @var{NMTOKEN}, @var{NMTOKENS}, ...;
or a list of strings for the enumerated type.
@var{use-type} is a symbol: @code{REQUIRED}, @code{IMPLIED}, @code{FIXED}
default-value is a string for the default value, or @code{#f} if not given.
@end table

@defun make-empty-attlist
@defunx attlist-add attlist name-value
@defunx attlist-null?
@defunx attlist-remove-top attlist
@defunx attlist->alist attlist
@defunx attlist-fold
Utility procedures to deal with attribute list, which
keeps name-value association.
@end defun

@defun make-xml-token kind head
@defunx xml-token? token
A constructor and a predicate for a @var{XML-TOKEN} record.
@end defun

@defmac xml-token-kind token
@defmacx xml-token-head token
Accessor macros of a @var{XML-TOKEN} record.
@end defmac

@c ----------------------------------------------------------------------
@node SSAX low-level parsing code, SSAX higher-level parsers and scanners, SSAX data types, Functional XML parser
@subsection SSAX low-level parsing code
@c NODE SSAXの低レベルパージングコード

They deal with primitive lexical units (Names, whitespaces, tags)
and with pieces of more generic productions. Most of these parsers
must be called in appropriate context. For example, @code{ssax:complete-start-tag}
must be called only when the start-tag has been detected and its @code{GI}
has been read.

@defun ssax:skip-S port
Skip the S (whitespace) production as defined by
@example
 [3] S ::= (#x20 | #x9 | #xD | #xA)
@end example
The procedure returns the first not-whitespace character it
encounters while scanning the @var{port}. This character is left
on the input stream.
@end defun

@defun ssax:ncname-starting-char? a-char
Check to see if a-char may start a @code{NCName}.
@end defun

@defun ssax:read-NCName port
Read a @code{NCName} starting from the current position in the @var{port} and
return it as a symbol.
@end defun

@defun ssax:read-QName port
Read a (namespace-) Qualified Name, @code{QName}, from the current
position in the @var{port}.

From REC-xml-names:
@example
 [6] QName ::= (Prefix ':')? LocalPart
 [7] Prefix ::= NCName
 [8] LocalPart ::= NCName
@end example

Return: an @var{UNRES-NAME}.
@end defun

@defvar ssax:Prefix-XML
The prefix of the pre-defined XML namespace, i.e. '@code{xml}.
@end defvar

@defun ssax:read-markup-token port
This procedure starts parsing of a markup token. The current position
in the stream must be @code{#\<}. This procedure scans enough of the input stream
to figure out what kind of a markup token it is seeing. The procedure returns
an xml-token structure describing the token. Note, generally reading
of the current markup is not finished! In particular, no attributes of
the start-tag token are scanned.

Here's a detailed break out of the return values and the position in the @var{port}
when that particular value is returned:
@table @code
@item PI-token
only @code{PI}-target is read.
To finish the Processing Instruction and disregard it,
call @code{ssax:skip-pi}. @code{ssax:read-attributes} may be useful
as well (for @code{PI}s whose content is attribute-value
pairs)
@item END-token
The end tag is read completely; the current position
is right after the terminating @code{#\>} character.
@item COMMENT
is read and skipped completely. The current position
is right after "@code{-->}" that terminates the comment.
@item CDSECT
The current position is right after "@code{<!CDATA[}".
Use @code{ssax:read-cdata-body} to read the rest.
@item DECL
We have read the keyword (the one that follows "@code{<!}")
identifying this declaration markup. The current
position is after the keyword (usually a
whitespace character)
@item START-token
We have read the keyword (@code{GI}) of this start tag.
No attributes are scanned yet. We don't know if this
tag has an empty content either.
Use @code{ssax:complete-start-tag} to finish parsing of
the token.
@end table
@end defun

@defun ssax:skip-pi port
The current position is inside a @code{PI}. Skip till the rest of the @code{PI}.
@end defun

@defun ssax:read-pi-body-as-string port
The current position is right after reading the @code{PITarget}. We read the
body of @code{PI} and return it as a string. The port will point to the
character right after '@code{?>}' combination that terminates @code{PI}.
@example
 [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
@end example
@end defun

@defun ssax:skip-internal-dtd port
The current pos in the port is inside an internal DTD subset
(e.g., after reading @code{#\[ }that begins an internal DTD subset)
Skip until the "@code{]>}" combination that terminates this DTD
@end defun

@defun ssax:read-cdata-body port str-handler seed
This procedure must be called after we have read a string "@code{<![CDATA[}"
that begins a @code{CDATA} section. The current position must be the first
position of the @code{CDATA} body. This function reads @emph{lines} of the @code{CDATA}
body and passes them to a @var{STR-HANDLER}, a character data consumer.

The str-handler is a @var{STR-HANDLER}, a procedure @code{string1} @var{string2} @var{seed}.
The first @var{string1} argument to @var{STR-HANDLER} never contains a newline.
The second @var{string2} argument often will. On the first invocation of
the @var{STR-HANDLER}, the seed is the one passed to @code{ssax:read-cdata-body}
as the third argument. The result of this first invocation will be
passed as the seed argument to the second invocation of the line
consumer, and so on. The result of the last invocation of the
@var{STR-HANDLER} is returned by the @code{ssax:read-cdata-body}.  Note a
similarity to the fundamental '@code{fold}' iterator.

Within a @code{CDATA} section all characters are taken at their face value,
with only three exceptions:
@itemize @bullet
@item
@code{CR}, @code{LF}, and @code{CRLF} are treated as line delimiters, and passed
as a single @code{#\newline} to the @var{STR-HANDLER}.
@item
"@code{]]>}" combination is the end of the @code{CDATA} section.
@item
@code{&gt;} is treated as an embedded @code{#\>} character.
Note, @code{&lt;} and @code{&amp;} are not specially recognized (and are not expanded)!
@end itemize
@end defun

@defun ssax:read-char-ref port
@example
 [66]  CharRef ::=  '&#' [0-9]+ ';' 
                  | '&#x' [0-9a-fA-F]+ ';'
@end example
This procedure must be called after we we have read "@code{&#}" 
that introduces a char reference.
The procedure reads this reference and returns the corresponding char.
The current position in @var{port} will be after "@code{;}" that terminates
the char reference.
Faults detected: @code{WFC: XML-Spec.html#wf-Legalchar}.

According to Section "4.1 Character and Entity References"
of the XML Recommendation:
@quotation
"[Definition: A character reference refers to a specific character
 in the ISO/IEC 10646 character set, for example one not directly
 accessible from available input devices.]"
@end quotation
Therefore, we use a @code{ucscode->char} function to convert a character
code into the character -- @emph{regardless} of the current character
encoding of the input stream.
@end defun

@defun ssax:handle-parsed-entity port name entities content-handler str-handler seed
Expand and handle a parsed-entity reference
@itemize @bullet
@item
@var{port} - a PORT
@item
@var{name} - the name of the parsed entity to expand, a symbol.
@item
@var{entities} - see @var{ENTITIES}
@item
@var{content-handler} - procedure @var{port} @var{entities} @var{seed}
that is supposed to return a @var{seed}.
@item
@var{str-handler} - a @var{STR-HANDLER}. It is called if the entity in question
turns out to be a pre-declared entity
@end itemize
The result is the one returned by @var{content-handler} or @var{str-handler}.

Faults detected:
@example
  WFC: XML-Spec.html#wf-entdeclared
  WFC: XML-Spec.html#norecursion
@end example
@end defun

@defun ssax:read-attributes port entities
This procedure reads and parses a production @code{Attribute*}
@example
 [41] Attribute ::= Name Eq AttValue
 [10] AttValue ::=  '"' ([^<&"] | Reference)* '"' 
                 | "'" ([^<&'] | Reference)* "'"
 [25] Eq ::= S? '=' S?
@end example
The procedure returns an @var{ATTLIST}, of @var{Name} (as @var{UNRES-NAME}),
@var{Value} (as string) pairs.
The current character on the @var{port} is a non-whitespace character
that is not an ncname-starting character.

Note the following rules to keep in mind when reading an 'AttValue'
"Before the value of an attribute is passed to the application
or checked for validity, the XML processor must normalize it as follows:
@itemize @bullet
@item
a character reference is processed by appending the referenced
character to the attribute value
@item
an entity reference is processed by recursively processing the
replacement text of the entity [see @var{ENTITIES}]
[named entities amp lt gt quot apos are assumed pre-declared]
@item
a whitespace character (@code{#x20}, @code{#xD}, @code{#xA}, @code{#x9}) is processed by appending @code{#x20}
to the normalized value, except that only a single @code{#x20} is appended for a
"@code{#xD#xA}" sequence that is part of an external parsed entity or the
literal entity value of an internal parsed entity
@item
other characters are processed by appending them to the normalized value "
@end itemize

Faults detected:
@example
 WFC: XML-Spec.html#CleanAttrVals
 WFC: XML-Spec.html#uniqattspec
@end example
@end defun

@defun ssax:resolve-name port unres-name namespaces apply-default-ns?
Convert an @var{unres-name} to a @var{res-name} given the appropriate @var{namespaces}
declarations.
The last parameter @var{apply-default-ns?} determines if the default
namespace applies (for instance, it does not for attribute names)

Per @code{REC-xml-names/#nsc-NSDeclared}, "xml" prefix is considered pre-declared
and bound to the namespace name "@url{http://www.w3.org/XML/1998/namespace}".

This procedure tests for the namespace constraints:
@url{http://www.w3.org/TR/REC-xml-names/#nsc-NSDeclared}.
@end defun

@defun ssax:uri-string->symbol uri-str
Convert a @var{uri-str} to an appropriate symbol.
@end defun

@defun ssax:complete-start-tag tag port elems entities namespaces
This procedure is to complete parsing of a start-tag markup. The
procedure must be called after the start tag token has been
read. @var{Tag} is an @var{UNRES-NAME}.
@var{Elem
s} is an instance of @code{xml-decl::elems};
it can be @code{#f} to tell the function to do @emph{no} validation of elements
and their attributes.

This procedure returns several values:
@table @var
@item elem-gi
a @var{RES-NAME}.
@item attributes
element's attributes, an @var{ATTLIST} of @code{(@var{res-name} . @var{string})}
pairs. The list does @emph{not} include @code{xmlns} attributes.
@item namespaces
the input list of namespaces amended with namespace
(re-)declarations contained within the start-tag under parsing
@var{ELEM-CONTENT-MODEL}.
@end table

On exit, the current position in @var{port} will be the first character after
@code{#\>} that terminates the start-tag markup.

Faults detected:
@example
 VC: XML-Spec.html#enum 
 VC: XML-Spec.html#RequiredAttr
 VC: XML-Spec.html#FixedAttr
 VC: XML-Spec.html#ValueType
 WFC: XML-Spec.html#uniqattspec (after namespaces prefixes are resolved)
 VC: XML-Spec.html#elementvalid 
 WFC: REC-xml-names/#dt-NSName
@end example

Note, although XML Recommendation does not explicitly say it,
@var{xmlns} and @var{xmlns:} attributes don't have to be declared (although they
can be declared, to specify their default value).
@end defun

@defun ssax:read-external-id port
This procedure parses an @code{ExternalID} production.
@example
 [75] ExternalID ::= 'SYSTEM' S SystemLiteral
                 | 'PUBLIC' S PubidLiteral S SystemLiteral
 [11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'") 
 [12] PubidLiteral ::=  '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
 [13] PubidChar ::=  #x20 | #xD | #xA | [a-zA-Z0-9]
                | [-'()+,./:=?;!*#@@$_%]
@end example
This procedure is supposed to be called when an @code{ExternalID} is expected;
that is, the current character must be either @code{#\S} or @code{#\P} that start
correspondingly a @code{SYSTEM} or @code{PUBLIC} token. This procedure returns the
@code{SystemLiteral} as a string. A @code{PubidLiteral} is disregarded if present.
@end defun

@c ----------------------------------------------------------------------
@node SSAX higher-level parsers and scanners, SSAX Highest-level parsers - XML to SXML, SSAX low-level parsing code, Functional XML parser
@subsection SSAX higher-level parsers and scanners
@c NODE SSAXの高レベルのパーザとスキャナ

They parse productions corresponding to the whole (document) entity
or its higher-level pieces (prolog, root element, etc).

@defun ssax:scan-Misc port
Scan the @code{Misc} production in the context:
@example
[1]  document ::=  prolog element Misc*
[22] prolog ::= XMLDecl? Misc* (doctypedec l Misc*)?
[27] Misc ::= Comment | PI |  S
@end example
The following function should be called in the prolog or epilog contexts.
In these contexts, whitespaces are completely ignored.
The return value from @code{ssax:scan-Misc} is either a @code{PI}-token,
a @code{DECL}-token, a @code{START} token, or EOF.
Comments are ignored and not reported.
@end defun

@defun ssax:read-char-data port expect-eof? str-handler seed
This procedure is to read the character content of an XML document
or an XML element.
@example
 [43] content ::= 
        (element | CharData | Reference | CDSect | PI
         | Comment)*
@end example
To be more precise, the procedure reads @code{CharData}, expands @code{CDSect}
and character entities, and skips comments. The procedure stops
at a named reference, EOF, at the beginning of a @code{PI} or a start/end tag.

@table @var
@item port
a port to read
@item expect-eof?
a boolean indicating if EOF is normal, i.e., the character
data may be terminated by the EOF. EOF is normal
while processing a parsed entity.
@item str-handler
a @var{STR-HANDLER}.
@item seed
an argument passed to the first invocation of @var{STR-HANDLER}.
@end table

The procedure returns two results: @var{seed} and @var{token}.

The @var{seed} is the result of the last invocation of @var{str-handler}, or the
original seed if @var{str-handler} was never called.

@var{Token} can be either an eof-object (this can happen only if
@var{expect-eof?} was @code{#t}), or:
@itemize @bullet
@item
an xml-token describing a @var{START} tag or an @var{END}-tag;
For a start token, the caller has to finish reading it.
@item
an xml-token describing the beginning of a @code{PI}. It's up to an
application to read or skip through the rest of this @code{PI};
@item
an xml-token describing a named entity reference.
@end itemize

@code{CDATA} sections and character references are expanded inline and
never returned. Comments are silently disregarded.

As the XML Recommendation requires, all whitespace in character data
must be preserved. However, a @code{CR} character (@code{#xD}) must be disregarded
if it appears before a @code{LF} character (@code{#xA}), or replaced by a @code{#xA} character
otherwise. See Secs. 2.10 and 2.11 of the XML Recommendation. See also
the canonical XML Recommendation.
@end defun

@defun ssax:assert-token token kind gi error-cont
Make sure that @var{token} is of anticipated @var{kind} and has anticipated @var{gi}.
Note @var{gi} argument may actually be a pair of two symbols, Namespace
URI or the prefix, and of the localname.
If the assertion fails, @var{error-cont} is evaluated by passing it
three arguments: @var{token} @var{kind} @var{gi}.
The result of @var{error-cont} is returned.
@end defun

@c ----------------------------------------------------------------------
@node SSAX Highest-level parsers - XML to SXML,  , SSAX higher-level parsers and scanners, Functional XML parser
@subsection SSAX Highest-level parsers - XML to SXML
@c NODE SSAXの高レベルのパーザ - XMLからSXMLへ

These parsers are a set of syntactic forms to instantiate a SSAX parser.
A user can instantiate the parser to do the full validation, or
no validation, or any particular validation. The user specifies
which @code{PI} he wants to be notified about. The user tells what to do
with the parsed character and element data. The latter handlers
determine if the parsing follows a SAX or a DOM model.

@defmac ssax:make-pi-parser my-pi-handlers
Create a parser to parse and process one Processing Element (@code{PI}).

@var{My-pi-handlers}:
An assoc list of pairs (@var{PI-TAG} . @var{PI-HANDLER})
where @var{PI-TAG} is an @var{NCName} symbol, the @code{PI} target, and
@var{PI-HANDLER} is a procedure @var{port} @var{pi-tag} @var{seed}
where @var{port} points to the first symbol after the @code{PI} target.
The handler should read the rest of the @code{PI} up to and including
the combination '@code{?>}' that terminates the @code{PI}. The handler should
return a new seed.
One of the @var{PI-TAG}s may be a symbol @code{*DEFAULT*}. The corresponding
handler will handle @code{PI}s that no other handler will. If the
@code{*DEFAULT*} @var{PI-TAG} is not specified,
@code{ssax:make-pi-parser} will make
one, which skips the body of the @code{PI}.

The output of the @code{ssax:make-pi-parser} is a procedure
@var{port} @var{pi-tag} @var{seed},
that will parse the current @code{PI} accoding to user-specified handlers.
@end defmac

@defmac ssax:make-elem-parser my-new-level-seed my-finish-element my-char-data-handler my-pi-handlers
Create a parser to parse and process one element, including its
character content or children elements. The parser is typically
applied to the root element of a document.

@table @var
@item my-new-level-seed
procedure @var{elem-gi} @var{attributes} @var{namespaces} @var{expected-content} @var{seed} @*
where @var{elem-gi} is a @var{RES-NAME} of the element
about to be processed.
This procedure is to generate the seed to be passed
to handlers that process the content of the element.
@c This is the function identified as 'fdown' in the denotational
@c semantics of the XML parser given in the title comments to this
@c file.

@item my-finish-element
procedure @var{elem-gi} @var{attributes} @var{namespaces} @var{parent-seed} @var{seed} @*
This procedure is called when parsing of @var{elem-gi} is finished.
The @var{seed} is the result from the last content parser (or
from @var{my-new-level-seed} if the element has the empty content).
@var{Parent-seed} is the same seed as was passed to @var{my-new-level-seed}.
The procedure is to generate a seed that will be the result
of the element parser.
@c This is the function identified as 'fup' in the denotational
@c semantics of the XML parser given in the title comments to this
@c file.

@item my-char-data-handler
A @var{STR-HANDLER}.

@item my-pi-handlers
See @code{ssax:make-pi-handler} above.
@end table

The generated parser is a:
procedure @var{start-tag-head} @var{port} @var{elems} @var{entities}
@var{namespaces} @var{preserve-ws?} @var{seed}. @*
The procedure must be called after the start tag token has been
read. @var{Start-tag-head} is an @var{UNRES-NAME} from the start-element tag.
@var{Elems} is an instance of @code{xml-decl::elems}.
See @code{ssax:complete-start-tag::preserve-ws?}

Faults detected:
@example
 VC: XML-Spec.html#elementvalid 
 WFC: XML-Spec.html#GIMatch
@end example
@end defmac

@defmac ssax:make-parser user-handler-tag user-handler-proc ...
Create an XML parser, an instance of the XML parsing framework.
This will be a SAX, a DOM, or a specialized parser depending
on the supplied user-handlers.

@var{user-handler-tag} is a symbol that identifies a procedural expression
that follows the tag. Given below are tags and signatures of the
corresponding procedures. Not all tags have to be specified. If some
are omitted, reasonable defaults will apply.

@table @code
@item tag: @var{DOCTYPE}
handler-procedure: @var{port} @var{docname} @var{systemid} @var{internal-subset?} @var{seed}

If @var{internal-subset?} is @code{#t}, the current position in the port
is right after we have read @code{#\[} that begins the internal DTD subset.
We must finish reading of this subset before we return
(or must call skip-internal-subset if we aren't interested in reading it).
The port at exit must be at the first symbol after the whole
DOCTYPE declaration.

The handler-procedure must generate four values: @*
@var{elems} @var{entities} @var{namespaces} @var{seed}@*
See @code{xml-decl::elems} for @var{elems}.
It may be @code{#f} to switch off the validation.
@var{namespaces} will typically contain @var{USER-PREFIX}es for selected @var{URI-SYMB}s.
The default handler-procedure skips the internal subset,
if any, and returns @code{(values #f '() '() seed)}.

@item tag: @var{UNDECL-ROOT}
handler-procedure: @var{elem-gi} @var{seed} @*
where @var{elem-gi} is an @var{UNRES-NAME} of the root element. This procedure
is called when an XML document under parsing contains @emph{no} @code{DOCTYPE}
declaration.
The handler-procedure, as a DOCTYPE handler procedure above,
must generate four values: @*
@var{elems} @var{entities} @var{namespaces} @var{seed}@*
The default handler-procedure returns @code{(values #f '() '() seed)}.

@item tag: @var{DECL-ROOT}
handler-procedure: @var{elem-gi} @var{seed} @*
where @var{elem-gi} is an @var{UNRES-NAME} of the root element. This procedure
is called when an XML document under parsing does contains the @code{DOCTYPE}
declaration.
The handler-procedure must generate a new @code{seed} (and verify
that the name of the root element matches the doctype, if the handler
so wishes). 
The default handler-procedure is the identity function.

@item tag: @var{NEW-LEVEL-SEED}
handler-procedure: see @code{ssax:make-elem-parser}, @var{my-new-level-seed}

@item tag: @var{FINISH-ELEMENT}
handler-procedure: see @code{ssax:make-elem-parser}, @var{my-finish-element}

@item tag: @var{CHAR-DATA-HANDLER}
handler-procedure: see @code{ssax:make-elem-parser}, @var{my-char-data-handler}

@item tag: @var{PI}
handler-procedure: see @code{ssax:make-pi-parser}. @*
The default value is @code{'()}.
@end table

The generated parser is a @*
procedure @var{PORT} @var{SEED}

This procedure parses the document prolog and then exits to
an element parser (created by ssax:make-elem-parser) to handle
the rest.

@example
 [1]  document ::=  prolog element Misc*
 [22] prolog ::= XMLDecl? Misc* (doctypedec | Misc*)?
 [27] Misc ::= Comment | PI |  S

 [28] doctypedecl ::=  '<!DOCTYPE' S Name (S ExternalID)? S? 
                        ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
 [29] markupdecl ::= elementdecl | AttlistDecl
                      | EntityDecl
                      | NotationDecl | PI
                      | Comment 
@end example
@end defmac

A few utility procedures that turned out useful.

@defun ssax:reverse-collect-str fragments
given the list of @var{fragments} (some of which are text strings)
reverse the list and concatenate adjacent text strings.
@end defun

@defun ssax:reverse-collect-str-drop-ws fragments
given the list of fragments (some of which are text strings)
reverse the list and concatenate adjacent text strings.
We also drop "unsignificant" whitespace, that is, whitespace
in front, behind and between elements. The whitespace that
is included in character data is not affected.
We use this procedure to "intelligently" drop "insignificant"
whitespace in the parsed SXML. If the strict compliance with
the XML Recommendation regarding the whitespace is desired, please
use the @code{ssax:reverse-collect-str} procedure instead.
@end defun

@defun ssax:xml->sxml port namespace-prefix-assig
This is an instance of a SSAX parser above that returns an SXML
representation of the XML document to be read from @var{port}.
@var{Namespace-prefix-assig} is a list of
@code{(@var{USER-PREFIX} . @var{URI-STRING})}
that assigns @var{USER-PREFIX}es to certain namespaces identified by
particular @var{URI-STRING}s. It may be an empty list.
The procedure returns an SXML tree. The port points out to the
first character after the root element.
@end defun

@c ----------------------------------------------------------------------
@node SXML Query Language, Manipulating SXML structure, Functional XML parser, Library modules - Utilities
@section @code{sxml.sxpath} - SXML Query Language
@c NODE SXMLクエリ言語, @code{sxml.sxpath} - SXMLクエリ言語

@deftp {Module} sxml.sxpath
@mdindex sxml.sxpath
SXPath is a query language for SXML, an instance of XML Information
set (Infoset) in the form of s-expressions. 

It is originally written by Oleg Kiselyov, and
improved by Dmitry Lizorkin and Kirill Lisovsky.
This module also incorporates
various procedures written for SXPath by Dmitry Lizorkin and Kirill Lisovsky.

Current version is based on sxpathlib.scm,v 3.915,
sxpath.scm,v 1.1, and sxpath-ext.scm,v 1.911.
@end deftp

This manual is mostly derived from the comments in the
original source files.

The module consists of three layers.
@enumerate
@item
Basic converters and applicators, which provides the means to
access and translate SXML tree.
@item
High-level query language compiler,
which takes abbreviated SXPath and
returns a Scheme function that selects a nodeset
that satisfies the specified path from the given nodeset.
@item
Extension libraries, which implements
SXML counterparts to W3C XPath Core Functions Library.
@end enumerate

@c ----------------------------------------------------------------------
@menu
* SXPath basic converters and applicators::  
* SXPath query language::       
* SXPath extension::            
@end menu

@node SXPath basic converters and applicators, SXPath query language, SXML Query Language, SXML Query Language
@subsection SXPath basic converters and applicators
@c NODE SXPathの基本的なコンバータとアプリケータ

A converter is a function
@example
  type Converter = Node|Nodeset -> Nodeset
@end example
A converter can also play a role of a predicate: in that case, if a
converter, applied to a node or a nodeset, yields a non-empty
nodeset, the converter-predicate is deemed satisfied. Throughout
this file a nil nodeset is equivalent to @code{#f} in denoting a failure.

@defun nodeset? x
Returns @code{#t} if given object is a nodeset.
@end defun

@defun as-nodeset x
If @var{x} is a nodeset - returns it as is, otherwise wrap it in a list.
@end defun

@defun sxml:element? obj
Predicate which returns @var{#t}
if @var{obj} is SXML element, otherwise returns @var{#f}.
@end defun

@defun ntype-names?? crit
The function @code{ntype-names??} takes a list of acceptable node names as a
criterion and returns a function, which, when applied to a node, 
will return @code{#t} if the node name is present in criterion list
and @code{#f} othervise.
@example
 ntype-names?? :: ListOfNames -> Node -> Boolean
@end example
@end defun

@defun ntype?? crit
The function @code{ntype??} takes a type criterion and returns
a function, which, when applied to a node, will tell if the node satisfies
the test.
@example
  ntype?? :: Crit -> Node -> Boolean
@end example

The criterion @var{crit} is 
one of the following symbols:
@table @code
@item id
tests if the Node has the right name (id)
@item @@
tests if the Node is an @var{attributes-list}.
@item *
tests if the Node is an @var{Element}.
@item *text*
tests if the Node is a text node.
@item *data*
tests if the Node is a data node 
(text, number, boolean, etc., but not pair).
@item *PI*
tests if the Node is a @code{PI} node.
@item *COMMENT*
tests if the Node is a @code{COMMENT} node.
@item *ENTITY*
tests if the Node is a @code{ENTITY} node.
@item *any*
@code{#t} for any type of Node.
@end table
@end defun

@defun ntype-namespace-id?? ns-id
This function takes a namespace-id, and returns a predicate
@code{Node -> Boolean}, which is @code{#t}
for nodes with this very namespace-id.
@var{ns-id} is a string.
@code{(ntype-namespace-id?? #f)} will be @code{#t}
for nodes with non-qualified names.
@end defun

@defun sxml:invert pred
This function takes a predicate and returns it inverted .
That is if the given predicate yields @code{#f} or '@code{()} the inverted one  
yields the given node (@code{#t}) and vice versa.
@end defun

@defun node-eq? other
@defunx node-equal? other
Curried equivalence converter-predicates, i.e.
@example
  ((node-eq? a) b)    @equiv{} (eq? a b)
  ((node-equal? a) b) @equiv{} (equal? a b)
@end example
@end defun

@defun node-pos n

@example
 node-pos:: N -> Nodeset -> Nodeset, or
 node-pos:: N -> Converter
@end example

Select the @var{N}'th element of a Nodeset and return as a singular Nodeset;
Return an empty nodeset if the Nth element does not exist.
@code{((node-pos 1) Nodeset)} selects the node at the head of the Nodeset,
if exists;
@code{((node-pos 2) Nodeset)} selects the Node after that, if
exists.
@var{N} can also be a negative number: in that case the node is picked from
the tail of the list.
@code{((node-pos -1) Nodeset)} selects the last node of a non-empty nodeset;
@code{((node-pos -2) Nodeset)} selects the last but one node, if exists.
@end defun

@defun sxml:filter pred?

@example
 filter:: Converter -> Converter
@end example

A filter applicator, which introduces a filtering context. The argument
converter is considered a predicate, with either @code{#f}
or nil result meaning failure.
@end defun

@defun take-until pred?

@example
 take-until:: Converter -> Converter, or
 take-until:: Pred -> Node|Nodeset -> Nodeset
@end example

Given a converter-predicate and a nodeset, apply the predicate to
each element of the nodeset, until the predicate yields anything but
@var{#f} or nil. Return the elements of the input nodeset that have
been processed
till that moment (that is, which fail the predicate).
@code{take-until} is a variation of the filter above:
@code{take-until} passes
elements of an ordered input set till (but not including) the first
element that satisfies the predicate.
The nodeset returned by @code{((take-until (not pred)) nset)} is a subset -- 
to be more precise, a prefix -- of the nodeset returned by
@code{((filter pred) nset)}.
@end defun

@defun take-after pred?

@example
take-after:: Converter -> Converter, or
take-after:: Pred -> Node|Nodeset -> Nodeset
@end example

Given a converter-predicate and a nodeset, apply the predicate to
each element of the nodeset, until the predicate yields anything but
@code{#f} or
nil. Return the elements of the input nodeset that have not been processed:
that is, return the elements of the input nodeset that follow the first
element that satisfied the predicate.
@code{take-after} along with @code{take-until}
partition an input nodeset into three
parts: the first element that satisfies a predicate, all preceding
elements and all following elements.
@end defun

@defun map-union proc lst
Apply proc to each element of lst and return the list of results.
If proc returns a nodeset, splice it into the result.

From another point of view,
@code{map-union} is a function Converter->Converter,
which places an argument-converter in a joining context.
@end defun

@defun node-reverse node-or-nodeset

@example
node-reverse :: Converter, or
node-reverse:: Node|Nodeset -> Nodeset
@end example

Reverses the order of nodes in the nodeset.
This basic converter is needed to implement a reverse document order
(see the XPath Recommendation).
@end defun

@defun node-trace title

@example
 node-trace:: String -> Converter
@end example

@code{(node-trace title)} is an identity converter. In addition it prints out
a node or nodeset it is applied to, prefixed with the 'title'.
This converter is very useful for debugging.
@end defun

What follow are Converter combinators,
higher-order functions that transmogrify a converter
or glue a sequence of converters into a single, non-trivial
converter. The goal is to arrive at converters that correspond to
XPath location paths.

From a different point of view, a combinator is a fixed, named
@emph{pattern} of applying converters. Given below is a complete set of
such patterns that together implement XPath location path
specification. As it turns out, all these combinators can be built
from a small number of basic blocks: regular functional composition,
map-union and filter applicators, and the nodeset union.

@defun select-kids test-pred?

@example
select-kids:: Pred -> Node -> Nodeset
@end example
Given a Node, return an (ordered) subset its children that satisfy
the Pred (a converter, actually).

@example
select-kids:: Pred -> Nodeset -> Nodeset
@end example
The same as above, but select among children of all the nodes in
the Nodeset.
@end defun

@defun node-self pred

@example
 node-self:: Pred -> Node -> Nodeset, or
 node-self:: Converter -> Converter
@end example

Similar to select-kids but apply to the Node itself rather
than to its children. The resulting Nodeset will contain either one
component, or will be empty (if the Node failed the Pred).
@end defun

@defun node-join . selectors

@example
 node-join:: [LocPath] -> Node|Nodeset -> Nodeset, or
 node-join:: [Converter] -> Converter
@end example

join the sequence of location steps or paths as described
in the title comments above.
@end defun

@defun node-reduce . converters

@example
 node-reduce:: [LocPath] -> Node|Nodeset -> Nodeset, or
 node-reduce:: [Converter] -> Converter
@end example

A regular functional composition of converters.
From a different point of view,
@code{((apply node-reduce converters) nodeset)}
is equivalent to
@code{(foldl apply nodeset converters)}
i.e., folding, or reducing, a list of converters with the nodeset
as a seed.
@end defun

@defun node-or . converters

@example
 node-or:: [Converter] -> Converter
@end example

This combinator applies all converters to a given node and
produces the union of their results.
This combinator corresponds to a union, '@code{|}' operation for XPath
location paths.
@end defun

@defun node-closure test-pred?

@example
 node-closure:: Converter -> Converter
@end example

Select all @emph{descendants} of a node that satisfy a converter-predicate.
This combinator is similar to @code{select-kids} but applies to
grand... children as well.
This combinator implements the "@code{descendant::}" XPath axis.
Conceptually, this combinator can be expressed as
@example
 (define (node-closure f)
      (node-or
        (select-kids f)
	 (node-reduce (select-kids (ntype?? '*)) (node-closure f))))
@end example

This definition, as written, looks somewhat like a fixpoint, and it
will run forever.  It is obvious however that sooner or later
@code{(select-kids (ntype?? '*))} will return an empty nodeset. At
this point further iterations will no longer affect the result and
can be stopped.
@end defun

@c ----------------------------------------------------------------------
@node SXPath query language, SXPath extension, SXPath basic converters and applicators, SXML Query Language
@subsection SXPath query language
@c NODE SXPathクエリ言語

@defun sxpath abbrpath . ns-binding
Evaluates an abbreviated SXPath

@example
 sxpath:: AbbrPath -> Converter, or
 sxpath:: AbbrPath -> Node|Nodeset -> Nodeset
@end example

@var{AbbrPath} is a list. It is translated to the full SXPath according
to the following rewriting rules:
@example
 (sxpath '()) -> (node-join)
 (sxpath '(path-component ...)) ->
                (node-join (sxpath1 path-component) (sxpath '(...)))
 (sxpath1 '//) -> (node-or 
                     (node-self (ntype?? '*any*))
                     (node-closure (ntype?? '*any*)))
 (sxpath1 '(equal? x)) -> (select-kids (node-equal? x))
 (sxpath1 '(eq? x))    -> (select-kids (node-eq? x))
 (sxpath1 '(or@@ ...))  -> (select-kids (ntype-names??
                                          (cdr '(or@@ ...))))
 (sxpath1 '(not@@ ...)) -> (select-kids (sxml:invert 
                                         (ntype-names??
                                          (cdr '(not@@ ...)))))
 (sxpath1 '(ns-id:* x)) -> (select-kids 
                                      (ntype-namespace-id?? x))
 (sxpath1 ?symbol)     -> (select-kids (ntype?? ?symbol))
 (sxpath1 ?string)     -> (txpath ?string)
 (sxpath1 procedure)   -> procedure
 (sxpath1 '(?symbol ...)) -> (sxpath1 '((?symbol) ...))
 (sxpath1 '(path reducer ...)) ->
                (node-reduce (sxpath path) (sxpathr reducer) ...)
 (sxpathr number)      -> (node-pos number)
 (sxpathr path-filter) -> (filter (sxpath path-filter))
@end example
@end defun

Some wrapper functions around @code{sxpath}:

@defun if-sxpath path
@code{sxpath} always returns a list, which is @code{#t} in Scheme.
@code{if-sxpath} returns @code{#f} instead of empty list.
@end defun

@defun if-car-sxpath path
Returns first node found, if any.
Otherwise returns @code{#f}.
@end defun

@defun car-sxpath path
Returns first node found, if any.
Otherwise returns empty list.
@end defun

@defun sxml:id-alist node . lpaths
Built an index as a list of
@code{(@var{ID_value} . @var{element})} pairs for given
node.  @var{lpaths} are location paths for attributes of type ID.
@end defun

@c ----------------------------------------------------------------------
@node SXPath extension,  , SXPath query language, SXML Query Language
@subsection SXPath extension
@c NODE SXPathの拡張

SXML counterparts to W3C XPath Core Functions Library.

@defun sxml:string object
The counterpart to XPath @code{string} function (section 4.2 XPath Rec.)
Converts a given object to a string.
NOTE:
@enumerate
@item
When converting a nodeset - a document order is not preserved
@item
@var{number->string} function returns the result in a form which is slightly
different from XPath Rec. specification
@end enumerate
@end defun

@defun sxml:boolean object
The counterpart to XPath @code{boolean} function (section 4.3 XPath Rec.)
Converts its argument to a boolean.
@end defun

@defun sxml:number obj
The counterpart to XPath @code{number} function (section 4.4 XPath Rec.)
Converts its argument to a number
NOTE:
@enumerate
@item
The argument is not optional (yet?).
@item
@code{string->number} conversion is not IEEE 754 round-to-nearest.
@item
NaN is represented as 0.
@end enumerate
@end defun

@defun sxml:string-value node
Returns a string value for a given node in accordance to
XPath Rec. 5.1 - 5.7
@end defun


@defun sxml:node? node
According to XPath specification 2.3, this test is true for any
XPath node.
For SXML auxiliary lists and lists of attributes has to be excluded.
@end defun

@defun sxml:attr-list obj
Returns the list of attributes for a given SXML node.
Empty list is returned if the given node is not an element,
or if it has no list of attributes
@end defun

@defun sxml:id id-index
Select SXML element by its unique IDs.  (XPath Rec. 4.1)
Returns a converter that takes @var{object},
which is a nodeset or a datatype which can be converted to a string by means
of a '@code{string}' function.

@var{id-index} is @code{( (id-value . element) (id-value . element) ... )}.

This index is used for selection of an element by its unique ID.
@end defun

Comparators for XPath objects:

@defun sxml:equality-cmp bool-op number-op string-op
A helper for XPath equality operations: @code{=} , @code{!=}
@var{bool-op}, @var{number-op} and
@var{'string-op} are comparison operations for 
a pair of booleans,  numbers and strings respectively.
@end defun

@defun sxml:equal? a b
@defunx sxml:not-equal? a b
Counterparts of XPath equality operations: @code{=} , @code{!=},
using default equality tests.
@end defun

@defun sxml:relational-cmp op
Creates a relational operation ( @code{<} , @code{>} , @code{<=} , @code{>=} )
for two XPath objects.
@code{op} is comparison procedure: @code{<} , @code{>} , @code{<=} or @code{>=}.
@end defun

XPath axises.
An order in resulting nodeset is preserved.

@defun sxml:attribute test-pred?
Attribute axis.
@end defun

@defun sxml:child test-pred?
Child axis.
This function is similar to '@code{select-kids}', but it returns an empty
child-list for PI, Comment and Entity nodes.
@end defun

@defun sxml:parent test-pred?
Parent axis.

Given a predicate, it returns a function 
@code{RootNode -> Converter}
which yields a 
@code{ node -> parent }
converter then applied to a rootnode.

Thus, such a converter may be constructed using
@code{ ((sxml:parent test-pred) rootnode) }
and returns a parent of a node it is applied to.
If applied to a nodeset, it returns the 
list of parents of nodes in the nodeset. The rootnode does not have
to be the root node of the whole SXML tree -- it may be a root node
of a branch of interest.
The @code{parent::} axis can be used with any SXML node.
@end defun

@defun sxml:ancestor test-pred?
Ancestor axis
@end defun

@defun sxml:ancestor-or-self test-pred?
Ancestor-or-self axis
@end defun

@defun sxml:descendant test-pred?
Descendant axis
@end defun

@defun sxml:descendant-or-self test-pred?
Descendant-or-self axis
@end defun

@defun sxml:following test-pred?
Following axis
@end defun

@defun sxml:following-sibling test-pred?
Following-sibling axis
@end defun

@defun sxml:namespace test-pred?
Namespace axis
@end defun

@defun sxml:preceding test-pred?
Preceding axis
@end defun

@defun sxml:preceding-sibling test-pred?
Preceding-sibling axis
@end defun

Popular shortcuts:

@defun sxml:child-nodes nodeset
@example
((sxml:child sxml:node?) nodeset)
@end example
@end defun

@defun sxml:child-elements nodeset
@example
((select-kids sxml:element?) nodeset)
@end example
@end defun


@c ----------------------------------------------------------------------
@node Manipulating SXML structure, Serializing XML and HTML from SXML, SXML Query Language, Library modules - Utilities
@section @code{sxml.tools} - Manipulating SXML structure
@c NODE SXML構造を操作する, @code{sxml.tools} - SXML構造を操作する

@deftp {Module} sxml.tools
@mdindex sxml.tools

This module is a port of Kirill Lisofsky's sxml-tools,
a collection of convenient procedures that work on
SXML structure.
The current version is derived from sxml-tools CVS revision 3.13.

The manual entry is mainly derived from the comments in the original
source code.
@end deftp

@c ----------------------------------------------------------------------
@menu
* SXML predicates::             
* SXML accessors::              
* SXML modifiers::              
* SXPath auxiliary utilities::  
* SXML to markup conversion::   
@end menu

@c ----------------------------------------------------------------------
@node SXML predicates, SXML accessors, Manipulating SXML structure, Manipulating SXML structure
@subsection SXML predicates
@c NODE SXMLの述語

@defun sxml:empty-element? obj
A predicate which returns @var{#t} if given element @var{obj} is empty. 
Empty element has no nested elements, text nodes, @code{PI}s,
Comments or entities
but it may contain attributes or namespace-id.
It is a SXML counterpart of XML @code{empty-element}.
@end defun

@defun sxml:shallow-normalized? obj
Returns @code{#t} if the given @var{obj} is shallow-normalized SXML element.
The element itself has to be normalized but its nested elements are not tested.
@end defun

@defun sxml:normalized? obj
Returns @code{#t} if the given @var{obj} is normalized SXML element.
The element itself and all its nested elements have to be normalised.
@end defun

@defun sxml:shallow-minimized? obj
Returns @code{#t} if the given @var{obj} is shallow-minimized SXML element.
The element itself has to be minimised but its nested elements are not tested.
@end defun

@defun sxml:minimized? obj
Returns @code{#t} if the given @var{obj} is minimized SXML element.
The element itself and all its nested elements have to be minimised.
@end defun

@c ----------------------------------------------------------------------
@node SXML accessors, SXML modifiers, SXML predicates, Manipulating SXML structure
@subsection SXML accessors
@c NODE SXMLへのアクセッサ

@defun sxml:name obj
Returns a name of a given SXML node.
It's just an alias of @code{car}, but introduced for the sake of encapsulation.
@end defun

@defun sxml:element-name obj
A version of @code{sxml:name}, which returns @code{#f}
if the given @var{obj} is not a SXML element.
Otherwise returns its name.
@end defun

@defun sxml:node-name obj
Safe version of @code{sxml:name}, which returns @code{#f}
if the given @var{obj} is not a SXML node.
Otherwise returns its name.
@end defun

@defun sxml:ncname obj
Returns Local Part of Qualified Name (Namespaces in XML production [6])
for given obj, which is "@code{:}"-separated suffix of its Qualified Name.
If a name of a node given is @code{NCName} (Namespaces in XML production [4]),
then it is returned as is.
Please note that while SXML name is a symbol this function returns a string.
@end defun

@defun sxml:name->ns-id sxml-name
Returns namespace-id part of given name, or @var{#f} if it's LocalName
@end defun

@defun sxml:content obj
Returns the content of given SXML element or nodeset (just text and element
nodes) representing it as a list of strings and nested elements in document 
order.  This list is empty if @var{obj} is empty element or empty list.
@end defun

@defun sxml:content-raw obj
Returns all the content of normalized SXML element except
@var{attr-list} and @var{aux-list}.
Thus it includes @code{PI}, @code{COMMENT} and @code{ENTITY}
nodes as well as @code{TEXT} and @code{ELEMENT} nodes
returned by @code{sxml:content}.
Returns  a list of nodes in document order or empty list if @var{obj} is empty 
element or empty list.
This function is faster than @code{sxml:content}.
@end defun

In SXML normal form, an element is represented by a list as this:
@example
  (@var{name} @var{attr-list} @var{aux-list} @var{content} @dots{})
@end example
where @var{attr-list} is a list beginning with @code{@@},
and @var{aux-list} is a list beginning with @code{@@@@}.

In the minimized form,
@var{Aux-list} can be omitted when it is empty.
@var{Attr-list} can be omitted when it is empty @emph{and}
@var{aux-list} is absent.

The following procedures extract @var{attr-list} and @var{aux-list}.

@defun sxml:attr-list-node obj
Returns @var{attr-list} for a given @var{obj},
or @code{#f} if it is absent
@end defun

@defun sxml:attr-as-list obj
Returns @var{attr-list} wrapped in list,
or '@code{((@@))} if it is absent and @var{aux-list} is present,
or '@code{()} if both lists are absent.
@end defun

@defun sxml:aux-list-node obj
Returns @var{aux-list} for a given @var{obj},
or @code{#f} if it is absent.
@end defun

@defun sxml:aux-as-list obj
Returns @var{aux-list} wrapped in list,
or '@code{()} if it is absent.
@end defun

@defun sxml:attr-list-u obj
Returns the list of attributes for given element or nodeset.
Analog of @code{((sxpath '(@@ *)) @var{obj})}.
Empty list is returned if there is no list of attributes.

The @code{-u} suffix indicates it can be used for non-normalized
SXML node.  ('u' stands for 'universal').
@end defun

@defun sxml:aux-list obj
Returns the list of auxiliary nodes for given element or nodeset.
Analog of @code{((sxpath '(@@@@ *)) @var{obj})}.
Empty list is returned if a list of auxiliary nodes is absent.
@end defun

@defun sxml:aux-list-u obj
Returns the list of auxiliary nodes for given element or nodeset.
Analog of @code{((sxpath '(@@@@ *)) @var{obj})}.
Empty list is returned if a list of auxiliary nodes is absent.

The @code{-u} suffix indicates it can be used for non-normalized
SXML node.  ('u' stands for 'universal').
@end defun

@defun sxml:aux-node obj aux-name
Return the first aux-node with @var{aux-name}
given in SXML element @var{obj}
or @code{#f} is such a node is absent.
Note: it returns just the @emph{first} node found even if multiple nodes are
present, so it's mostly intended for nodes with unique names .
@end defun

@defun sxml:aux-nodes obj aux-name
Return a list of aux-node with @var{aux-name}
given in SXML element @var{obj} 
or '@code{()} if such a node is absent.
@end defun

@defun sxml:attr obj attr-name
Accessor for an attribute @var{attr-name} of
given SXML element @var{obj}.
It returns: 
the value of the attribute if the attribute is present, or
@var{#f} if there is no such an attribute in the given element.
@end defun

@defun sxml:num-attr obj attr-name
Accessor for a numerical attribute @var{attr-name}
of given SXML element @var{obj}.
It returns: 
a value of the attribute as the attribute as a number if the attribute 
is present and its value may be converted to number using @code{string->number},
or @code{#f} if there is no such an attribute in the given element or
its value can't be converted to a number.
@end defun

@defun sxml:attr-u obj attr-name
Accessor for an attribute @var{attr-name}
of given SXML element @var{obj} which 
may also be an attributes-list or nodeset (usually content of SXML element).

It returns: 
the value of the attribute if the attribute is present,
or @code{#f} if there is no such an attribute in the given element.

The @code{-u} suffix indicates it can be used for non-normalized
SXML node.  ('u' stands for 'universal').
@end defun

@defun sxml:ns-list obj
Returns the list of namespaces for given element.
Analog of @code{((sxpath '(@@@@ *NAMESPACES* *)) @var{obj})}
Empty list is returned if there is no list of namespaces.
@end defun

@defun sxml:ns-id->nodes obj namespace-id
Returns the list of namespace-assoc's for given @var{namespace-id} in 
SXML element @var{obj}.
Analog of @code{((sxpath '(@@@@ *NAMESPACES* namespace-id)) @var{obj})}.
Empty list is returned if there is no namespace-assoc with
@var{namespace-id} given.
@end defun

@defun sxml:ns-id->uri obj namespace-id
Returns a URI for @var{namespace-id} given, or
@code{#f} if there is no namespace-assoc with @var{namespace-id} given.
@end defun

@defun sxml:ns-uri->id obj uri
Returns a namespace-id for namespace URI given.
@end defun

@defun sxml:ns-id ns-assoc
Returns namespace-id for given namespace-assoc list.
@end defun

@defun sxml:ns-uri ns-assoc
Returns URI for given namespace-assoc list.
@end defun

@defun sxml:ns-prefix ns-assoc
It returns namespace prefix for given namespace-assoc list.
Original (as in XML document) prefix for namespace-id given 
has to be strored as the third element in namespace-assoc list 
if it is different from namespace-id.
If original prefix is omitted in namespace-assoc then
namespace-id is used instead.
@end defun

@c ----------------------------------------------------------------------
@node SXML modifiers, SXPath auxiliary utilities, SXML accessors, Manipulating SXML structure
@subsection SXML modifiers
@c NODE SXMLのモディファイヤ

Constructors and mutators for normalized SXML data.
These functions are optimized for normalized SXML data.
They are not applicable to arbitrary non-normalized SXML data.

Most of the functions are provided in two variants:
@enumerate
@item
side-effect intended functions for linear update of given elements.
Their names are ended with exclamation mark.
Note that the returned value of this variant is unspecified,
unless explicitly noted.
An example: @code{sxml:change-content!}.
@item
pure functions without side-effects which return modified elements.
An example: @code{sxml:change-content}.
@end enumerate

@defun sxml:change-content obj new-content
@defunx sxml:change-content! obj new-content
Change the content of given SXML element to @var{new-content}.
If @var{new-content} is an empty list then the @var{obj} is transformed
to an empty element.
The resulting SXML element is normalized.
@end defun

@defun sxml:change-attrlist obj new-attrlist
@defunx sxml:change-attrlist! obj new-attrlist
The resulting SXML element is normalized.
If @var{new-attrlist} is empty,
the cadr of @var{obj} is @code{(@@)}.
@end defun

@defun sxml:change-name obj new-name
@defunx sxml:change-name! obj new-name
Change a name of SXML element destructively.
@end defun

@defun sxml:add-attr obj attr
Returns SXML element @var{obj} with attribute @var{attr} added,
or @code{#f} if the attribute with given name already exists.
@var{attr} is @code{(@var{attr-name} @var{attr-value})}.
Pure functional counterpart to @code{sxml:add-attr!}.
@end defun

@defun sxml:add-attr! obj attr
Add an attribute @var{attr} for an element @var{obj}.
Returns @code{#f} if the attribute with given name already exists. 
The resulting SXML node is normalized.
Linear update counterpart to @code{sxml:add-attr}.
@end defun

@defun sxml:change-attr obj attr
Returns SXML element @var{obj} with changed value of
attribute @var{attr}, or @code{#f}
if where is no attribute with given name. 
@var{attr} is @code{(@var{attr-name} @var{attr-value})}.
@end defun

@defun sxml:change-attr! obj attr
Change value of the attribute for element @var{obj}.
@var{attr} is @code{(@var{attr-name} @var{attr-value})}.
Returns @code{#f} if where is no such attribute.
@end defun

@defun sxml:set-attr obj attr
@defunx sxml:set-attr! obj attr
Set attribute @var{attr} of element @var{obj}.
If there is no such attribute the new one is added.
@end defun

@defun sxml:add-aux obj aux-node
Returns SXML element @var{obj}
with an auxiliary node @var{aux-node} added.
@end defun

@defun sxml:add-aux! obj aux-node
Add an auxiliary node @var{aux-node} for an element @var{obj}.
@end defun

@defun sxml:squeeze obj
@defunx sxml:squeeze! obj
Eliminates empty lists of attributes and aux-lists for given SXML element 
@var{obj} and its descendants ("minimize" it).
Returns a minimized and normalized SXML element.
@end defun

@defun sxml:clean obj
Eliminates empty lists of attributes and all aux-lists for given SXML element 
@var{obj} and its descendants.
Returns a minimized and normalized SXML element.
@end defun

@c ----------------------------------------------------------------------
@node SXPath auxiliary utilities, SXML to markup conversion, SXML modifiers, Manipulating SXML structure
@subsection SXPath auxiliary utilities
@c NODE SXPathの補助的ユーティリティ

These are convenience utilities to extend SXPath functionalities.

@defun sxml:add-parents obj . top-ptr
Returns an SXML nodeset with a 'parent pointer' added.
A parent pointer is an aux node of the form @code{(*PARENT* @var{thunk})},
where @var{thunk} returns the parent element.
@end defun

@defun sxml:node-parent rootnode
Returns a fast 'node-parent' function, i.e.
a function of one argument - SXML element - which returns its parent
node using @code{*PARENT*} pointer in aux-list.
'@code{*TOP-PTR*} may be used as a pointer to root node.
It return an empty list when applyed to root node.
@end defun

@defun sxml:lookup id index
Lookup an element using its ID.
@end defun

@c ----------------------------------------------------------------------
@node SXML to markup conversion,  , SXPath auxiliary utilities, Manipulating SXML structure
@subsection SXML to markup conversion
@c NODE SXMLからマークアップへの変換

Procedures to generate XML or HTML marked up text from SXML.
For more advanced conversion, see the SXML serializer
(@ref{Serializing XML and HTML from SXML}).


@defun sxml:clean-feed . fragments
Filter the 'fragments'.
The fragments are a list of strings, characters,
numbers, thunks, @code{#f} -- and other fragments.
The function traverses the tree depth-first, and returns a list
of strings, characters and executed thunks,
and ignores @code{#f} and '@code{()}.

If all the meaningful fragments are strings, then
@var{(apply string-append ... )}
to a result of this function will return its string-value.

It may be considered as a variant of Oleg Kiselyov's
@code{SRV:send-reply}:
While @code{SRV:send-reply} displays fragments, this function returns the list 
of meaningful fragments and filter out the garbage.
@end defun

@defun sxml:attr->xml attr
Creates the XML markup for attributes.
@end defun

@defun sxml:string->xml string
Return a string or a list of strings where all the occurences of 
characters @code{<}, @code{>},
@code{&}, @code{"}, or @code{'} in a given string are
replaced by corresponding 
character entity references. See also @code{sxml:string->html}.
@end defun

@defun sxml:sxml->xml tree
A version of dispatch-node specialized and optimized for SXML->XML
transformation.
@end defun

@defun sxml:attr->html attr
Creates the HTML markup for attributes.
@end defun

@defun sxml:string->html string
Given a string, check to make sure it does not contain characters
@var{<}, @var{>}, @var{&},
@var{"} that require encoding.
See also @code{html-escape-string}
in @ref{Simple HTML document construction}.
@end defun

@defun sxml:non-terminated-html-tag? tag
This predicate yields @code{#t} for "non-terminated" HTML 4.0 tags.
@end defun

@defun sxml:sxml->html tree
A version of dispatch-node specialized and optimized for SXML->HTML
transformation.
@end defun

@c ----------------------------------------------------------------------
@node Serializing XML and HTML from SXML, CSV tables, Manipulating SXML structure, Library modules - Utilities
@section @code{sxml.serializer} -  Serializing XML and HTML from SXML
@c NODE SXMLからXMLとXHTMLのシリアライゼーション, @code{sxml.serializer} - SXMLからXMLとXHTMLのシリアライゼーション

@deftp {Module} sxml.serializer
@mdindex sxml.serializer
This module contains a full-featured serializer from SXML into XML and
HTML, partially conforming to XSLT 2.0 and XQuery 1.0 Serialization
(@uref{http://www.w3.org/TR/2005/CR-xslt-xquery-serialization-20051103/}).
It's more powerful than sxml:sxml->xml and sxml:sxml->html from
sxml.tools.

The manual entry is mainly derived from the comments in the original
source code.
@end deftp

@c ----------------------------------------------------------------------
@menu
* Simple SXML serializing::     
* Custom SXML serializing::     
@end menu

@c ----------------------------------------------------------------------
@node Simple SXML serializing, Custom SXML serializing, Serializing XML and HTML from SXML, Serializing XML and HTML from SXML
@subsection Simple SXML serializing
@c NODE 簡単なSXML変換

The SXML serializer provides some convenient high-level converters which
should be enough for most tasks.

@defun srl:sxml->xml sxml-obj &optional port-or-filename
Serializes the @var{sxml-obj} into XML, with indentation to facilitate
readability by a human.

If @var{port-or-filename} is not supplied, the functions return a
string that contains the serialized representation of the
@var{sxml-obj}.

If @var{port-or-filename} is supplied and is a port, the functions
write the serialized representation of @var{sxml-obj} to this port and
return an unspecified result.

If @var{port-or-filename} is supplied and is a string, this string is
treated as an output filename, the serialized representation of
@var{sxml-obj} is written to that filename and an unspecified result
is returned. If a file with the given name already exists, the effect
is unspecified.
@end defun

@defun srl:sxml->xml-noindent sxml-obj &optional port-or-filename
Serializes the @var{sxml-obj} into XML, without indentation.

Argument @var{port-or-filename} works like described in
@code{srl:sxml->xml}.
@end defun

@defun srl:sxml->html sxml-obj &optional port-or-filename
Serializes the @var{sxml-obj} into HTML, with indentation to
facilitate readability by a human.

Argument @var{port-or-filename} works like described in @code{srl:sxml->xml}.
@end defun

@defun srl:sxml->html-noindent sxml-obj &optional port-or-filename
Serializes the @var{sxml-obj} into HTML, without indentation.

Argument @var{port-or-filename} works like described in @code{srl:sxml->xml}.
@end defun

@c ----------------------------------------------------------------------
@node Custom SXML serializing,  , Simple SXML serializing, Serializing XML and HTML from SXML
@subsection Custom SXML serializing
@c NODE カスタムSXML変換

These functions provide full access to all configuration parameters of
the XML serializer.

@defun srl:parameterizable sxml-obj &optional port-or-filename params*
Generalized serialization procedure, parameterizable with all the
serialization parameters supported by this implementation.

@var{sxml-obj} - an SXML object to serialize

@var{port-or-filename} - either @code{#f}, a port or a string; works
like in srl:sxml->xml (@ref{Simple SXML serializing}).

@var{params} - each parameter is a cons of param-name (a symbol) and
param-value.  The available parameter names and their values are
described below:

@code{method} - Either the symbol @code{xml} or @code{html}.  For a
detailed explanation of the difference between XML and HTML methods,
see XSLT 2.0 and XQuery 1.0 Serialization (@uref{http://www.w3.org/TR/2005/CR-xslt-xquery-serialization-20051103/}).

@code{indent} - Whether the output XML should include whitespace for
human readability (@code{#t} or @code{#f}).  You can also supply a
string, which will be used as the indentation unit.

@code{omit-xml-declaration?} - Whether the XML declaration should be
omitted.  Default: @code{#t}.

@code{standalone} - Whether to define the XML document as standalone in
the XML declaration.  Should be one of the symbols @code{yes},
@code{no} or @code{omit}, the later causing standalone declaration to
be supressed.  Default: @code{omit}.

@code{version} - The XML version used in the declaration.  A string or
a number.  Default: @code{"1.0"}.

@code{cdata-section-elements} - A list of SXML element names (as
symbols).  The contents of those elements will be escaped as CDATA
sections.

@code{ns-prefix-assig} - A list of @code{(cons prefix namespace-uri)},
where each @code{prefix} is a symbol and each @code{namespace-uri} a
string.  Will serialize the given namespaces with the corresponding
prefixes.
ATTENTION: If a parameter name is unexpected or a parameter value is
ill-formed, the parameter is silently ignored!

Example usage:

@lisp
(srl:parameterizable
  '(tag (@@ (attr "value")) (nested "text node") (empty))
  (current-output-port)
  '(method . xml)  ; XML output method is used by default
  '(indent . "\t")  ; use a single tabulation to indent
  '(omit-xml-declaration . #f)  ; add XML declaration
  '(standalone . yes)  ; denote a standalone XML document
  '(version . "1.0"))  ; XML version
@end lisp

@lisp
param ::= (cons param-name param-value)
param-name ::= symbol

cdata-section-elements
value ::= (listof sxml-elem-name)
sxml-elem-name ::= symbol

indent
value ::= 'yes | #t | 'no | #f | whitespace-string

method
value ::= 'xml | 'html

ns-prefix-assig
value ::= (listof (cons prefix namespace-uri))
prefix ::= symbol
namespace-uri ::= string

omit-xml-declaration?
value ::= 'yes | #t | 'no | #f

standalone
value ::= 'yes | #t | 'no | #f | 'omit

version
value ::= string | number
@end lisp
@end defun

@defun srl:sxml->string sxml-obj cdata-section-elements indent method ns-prefix-assig omit-xml-declaration? standalone version
Same as @code{srl:parameterizable} returning a string and without the
overhead of parsing parameters.  This function interface may change in
future versions of the library.
@end defun

@defun srl:display-sxml sxml->obj port-or-filename cdata-section-elements indent method ns-prefix-assig omit-xml-declaration? standalone version

Same as @code{srl:parameterizable} writing output to
@var{port-or-filename} and without the overhead of parsing parameters. 
This function interface may change in
future versions of the library.
@end defun

@c ----------------------------------------------------------------------
@node CSV tables, Calculate difference of text streams, Serializing XML and HTML from SXML, Library modules - Utilities
@section @code{text.csv} - CSV tables
@c NODE CSVテーブル, @code{text.csv} - CSVテーブル

@deftp {Module} text.csv
@mdindex text.csv
Provides a function to parse/generate CSV (comma separated value) tables,
including the format defined in RFC4180.  You can customize the
separator and quoter character to deal with variations of CSV formats.

CSV table is consisted by a series of @var{records}, separated by
a newline.  Each record contains number of @var{fields}, separated
by a separator character (by default, a comma).  A field can contain
comma or newline if quoted, i.e. surrounded by double-quote characters.
To include double-quote character in a quoted field, use two
consecutive double-quote character.   Usually, the whitespaces around
the field are ignored.
@c example here

@end deftp

Right now, the following two low-level procedures are exported.
A plan is to provide higher features, such as labelling fields
and automatic conversions.

@defun make-csv-reader separator &optional (quote-char #\")
Returns a procedure with one argument, input port.
When the procedure is called, it reads one record from the port,
and returns a list of fields.
If input reaches EOF, it returns EOF.
@end defun

@defun make-csv-writer separator &optional newline (quote-char #\")
Returns a procedure with two arguments, output port and
a list of fields.  When the procedure is called, it
outputs a @var{separator}-separated fields with proper escapes,
to the output port.   You can also specify the record delimiter
string by @var{newline}; for example, you can pass @code{"\r\n"}
to prepare a file to be read by Windows programs.
@end defun

@c ----------------------------------------------------------------------
@node Calculate difference of text streams, Localized messages, CSV tables, Library modules - Utilities
@section @code{text.diff} - Calculate difference of text streams
@c NODE テキストストリームの相違点を計算する, @code{text.diff} - テキストストリームの相違点を計算する

@deftp {Module} text.diff
@mdindex text.diff
This module calculates the difference of two text streams or strings,
using @code{util.lcs} (@xref{The longest common subsequence}).
@end deftp

@defun diff src-a src-b &keyword reader eq-fn
Generates an "edit list" from text sources @var{src-a} and @var{src-b}.

Each of text sources, @var{src-a} and @var{src-b}, can be either an input
port or a string.  If it is a string, it is converted to a string input
port internally.  Then, the text streams from both sources are converted
to sequences by calling @var{reader} repeatedly on them; the default
of @var{reader} is @code{read-line}, and those sequences are
passed to @code{lcs-edit-list} to calculate the edit list.
The equality function @var{eq-fn} is also passed to @code{lcs-edit-list}.

An edit list is a set of commands that turn the text sequence
from @code{src-a} to the one from @code{src-b}.
See the description of @code{lcs-edit-list} for
the detailed explanation of the edit list.

@example
(diff "a\nb\nc\nd\n" "b\ne\nd\nf\n")
@result{}
  (((- 0 "a"))
   ((- 2 "c") (+ 1 "e"))
   ((+ 3 "f")))
@end example
@end defun

@defun diff-report src-a src-b &keyword reader eq-fn writer
A convenience procedure to take the diff of two text sources
and display the result nicely.  This procedure calls @code{lcs-fold}
to calculate the difference of two text sources.  The meanings of
@var{src-a}, @var{src-b}, @var{reader} and @var{eq-fn} are the
same as @code{diff}'s.

@var{Writer} is a procedure that takes two arguments, the text element
and a type, which is either a symbol @code{+}, 
a symbol @code{-}, or @code{#f}.   If the text element is only
in @var{src-a}, @var{writer} is called with the element and
@code{-}.  If the text element is only in @var{src-b}, 
it is called with the element and @code{+}.  If the text element
is in both sources, it is called with the element and
@code{#f}.   The default procedure of @var{writer} prints
the passed text element to the current output port
in unified-diff-like format:
@example
(diff-report "a\nb\nc\nd\n" "b\ne\nd\nf\n")
@end example
displays: 
@example
- a
  b
- c
+ e
  d
+ f
@end example
@end defun


@c ----------------------------------------------------------------------
@node Localized messages, Simple HTML document construction, Calculate difference of text streams, Library modules - Utilities
@section @code{text.gettext} - Localized messages
@c NODE 地域化メッセージ, @code{text.gettext} - 地域化メッセージ

@deftp {Module} text.gettext
@mdindex text.gettext
This module provides utilities to deal with localized messages.
The API is compatible to GNU's gettext, and the messages
are read from @file{*.po} and @file{*.mo} files,
so that you can use the GNU gettext
toolchain to prepare localized messages.
However, the code is written from scratch by Alex Shinn and
doesn't depend on GNU's gettext library.

This implementation extends GNU's gettext API in the following ways:
@itemize @bullet
@item
It can read from multiple message files in cascaded way,
allowing applications to share a part of message files.
@item
It supports multiple locale/domain simultaneously.
@end itemize

SRFI-29 (@xref{Localization}) provides another means of message
localization.  A portable program may wish to use srfi-29, but
generally @code{text.gettext} is recommended in Gauche scripts
because of its flexibility and compatibility to existing message files.
@end deftp

@subheading Gettext-compatible API

@defun textdomain domain-name &optional locale dirs cdir cached? lookup-cached?
Sets up the default domain and other parameters for
the application.  The setting affects to the following @code{gettext}
call.

@var{Domain} is a string or list of strings specifying the domain
(name of @file{.mo} or @file{.po} files) as in C gettext.
You can pass @code{#f} as @var{domain-name} just to get the default
domain accessor procedure.
You can alo pass multiple domains to @var{domain-name}.
@example
(textdomain '("myapp" "gimp"))  ; search 1st myapp, then gimp
(gettext "/File/Close")         ; "Close" from gimp unless overridden
@end example

@var{Locale} is a string or list of strings in the standard Unix format of
@code{LANG[_REGION][.ENCODING]}.  You can also pass a list of locales
to specify fallbacks.

@example
(textdomain "myapp" '("ru" "uk"))  ; search 1st Russian then Ukranian,
(gettext "Hello, World!")          ; which are somewhat similar
@end example

@var{Dirs} is the search path of directories which should hold the
@file{LOCALE/CDIR/} directories which contain the actual message catalogs.
This is always appended with the system default, e.g.
@file{"/usr/share/locale"}, and may also inherit from the 
@code{GETTEXT_PATH} colon-delimited environment variable.

@var{Cdir} is the category directory, defaulting to either the 
@code{LC_CATEGORY}
environment variable or the appropriate system default
(e.g. @code{LC_MESSAGES}).  You generally won't need this.

@var{Cached?}
means to cache individual messages, and defaults to @code{#t}.

@var{Lookup-cached?}
means to cache the lookup dispatch generated by these
parameters, and defaults to @code{#t}.

@code{Textdomain} just passes these parameters to the internal
@code{make-gettext},
and binds the result to the global dispatch used by @code{gettext}.  
You may build these closures manually for convenience in using multiple
separate domains or locales at once (useful for server environments).
See the description of @code{make-gettext} below.

@code{Textdomain} returns an @emph{accessor procedure} which
packages information of the domain.  See @code{make-gettext} below
for the details.
@end defun

@defun gettext msg-id
Returns a translated message of @var{msg-id}.  If there's no
translated message, @var{msg-id} itself is returned.
@end defun

@defun ngettext msg-id &optional msg-id2 num
Similar to @var{gettext}, but it can be used to handle
plural forms.
Pass a singular form to @var{msg-id}, and plural form to
@code{msg-id2}.  The @var{num} argument is used to determine
the plural form.  If no message catalog is found, @var{msg-id}
is returned when @var{num} is 1, and @var{msg-id2} otherwise.
@end defun

@defun bindtextdomain domain dirs
Sets the search path of domain @var{domain} to @var{dirs}, which 
may be just a single directory name or a list of directory names.
@end defun

@defun dgettext domain msg-id
@defunx dcgettext domain msg-id locale
Returns a translated message of @var{msg-id} in @var{domain}.
@code{Dcgettext} takes @var{locale} as well.
@end defun

@subheading Low-level flexible API

The following procedure is more flexible interface, on top of which
the gettext-compatible APIs are written.

@defun make-gettext &optional domain locale dirs gettext-cached? lookup-cached?
Creates and returns an @emph{accessor procedure}, which encapsulates
methods to retrieve localized messages.

The meaning of arguments are the same as @code{textdomain} above.
Indeed, @code{textdomain} just calls @code{make-gettext}, and later
it binds the result to the global parameter.   If you wish to have
multiple independent domains within a single program, you can
call @code{make-gettext} directly and manage the created
accessor procedure by yourself.

@example
(define my-gettext (make-gettex "myapp"))
(define (_ (my-gettext 'getter)))
(_ "Hello, World!")
@end example
@end defun

@c ----------------------------------------------------------------------
@node Simple HTML document construction, Parsing input stream, Localized messages, Library modules - Utilities
@section @code{text.html-lite} - Simple HTML document construction
@c NODE シンプルなHTMLドキュメントの構築, @code{text.html-lite} - シンプルなHTMLドキュメントの構築

@deftp {Module} text.html-lite
@mdindex text.html-lite
Provides procedures to construct an HTML document easily.
For example, you can construct an HTML table by the following code:
@example
(html:table
  (html:tr (html:th "Item No") (html:th "Quantity"))
  (html:tr (html:td 1) (html:td 120))
  (html:tr (html:td 2) (html:td 30))
  (html:tr (html:td 3) (html:td 215)))
@end example
See the description of @code{html:@var{element}} below for details.

This module does little check for the constructed html documents,
such as whether the attributes are valid, and whether the content
of the element matches DTD.  It does not provide a feature to parse
the html document neither.  Hence the name `lite'.
@end deftp

@defun html-escape
@defunx html-escape-string string
Escapes the ``unsafe'' characters in HTML.  @code{html-escape}
reads input string from the current input port and writes the result
to the current output port.   @code{html-escape-string} takes the
input from @var{string} and returns the result in a string.
@end defun

@defun html-doctype &keyword type
Returns a doctype declaration for an HTML document.
@var{type} can be either one of the followings (default is 
@code{:html-4.01-strict}).
@table @code
@item :html-4.01-strict, :html-4.01, :strict
HTML 4.01 Strict DTD
@item :html-4.01-transitional, :transitional
HTML 4.01 Transitional DTD
@item :html-4.01-frameset, :frameset
HTML 4.01 Frameset DTD
@item :xhtml-1.0-strict, :xhtml-1.0
XHTML 1.0 Strict DTD
@item :xhtml-1.0-transitional
XHTML 1.0 Transitional DTD
@item :xhtml-1.0-frameset
XHTML 1.0 Frameset DTD
@item :xhtml-1.1
XHTML 1.1 DTD
@end table
@end defun

@deftp {Function} html:@var{element} @var{args} @dots{}
@findex html:a
@findex html:abbr
@findex html:acronym
@findex html:address
@findex html:area
@findex html:b
@findex html:base
@findex html:bdo
@findex html:big
@findex html:blockquote
@findex html:body
@findex html:br
@findex html:button
@findex html:caption
@findex html:cite
@findex html:code
@findex html:col
@findex html:colgroup
@findex html:dd
@findex html:del
@findex html:dfn
@findex html:div
@findex html:dl
@findex html:dt
@findex html:em
@findex html:fieldset
@findex html:form
@findex html:frame
@findex html:frameset
@findex html:h1
@findex html:h2
@findex html:h3
@findex html:h4
@findex html:h5
@findex html:h6
@findex html:head
@findex html:hr
@findex html:html
@findex html:i
@findex html:iframe
@findex html:img
@findex html:input
@findex html:ins
@findex html:kbd
@findex html:label
@findex html:legend
@findex html:li
@findex html:link
@findex html:map
@findex html:meta
@findex html:noframes
@findex html:noscript
@findex html:object
@findex html:ol
@findex html:optgroup
@findex html:option
@findex html:p
@findex html:param
@findex html:pre
@findex html:q
@findex html:samp
@findex html:script
@findex html:select
@findex html:small
@findex html:span
@findex html:strong
@findex html:style
@findex html:sub
@findex html:sup
@findex html:table
@findex html:tbody
@findex html:td
@findex html:textarea
@findex html:tfoot
@findex html:th
@findex html:thead
@findex html:title
@findex html:tr
@findex html:tt
@findex html:ul
@findex html:var
Construct an HTML element @var{element}.  Right now,
the following elements are provided.
(The elements defined in HTML 4.01 DTD,
@uref{http://www.w3.org/TR/html4/sgml/dtd.html}).
@example
a        abbr       acronym    address     area      b
base     bdo        big        blockquote  body      br
button   caption    cite       code        col       colgroup
dd       del        dfn        div         dl        dt
em       fieldset   form       frame       frameset  
h1       h2         h3         h4          h5        h6
head     hr         html       i           iframe    img
input    ins        kbd        label       legend    li
link     map        meta       nofrmaes    noscript  object
ol       optgroup   option     p           param     pre
q        samp       script     select      small     span
strong   style      sub        sup         table     tbody
td       textarea   tfoot      th          thead     title
tr       tt         ul         var
@end example

The result of these functions is a tree of text segments,
which can be written out to a port by @code{write-tree} or
can be converted to a string by @code{tree->string}
(@xref{Lazy text construction}).

You can specify attributes of the element by using a keyword-value
notation before the actual content.
@example
(tree->string (html:a :href "http://foo/bar" "foobar"))
  @result{}
  "<a href=\"http://foo/bar\">foobar</a\n>"

(tree->string
  (html:table :width "100%" :cellpading 0 "content here"))
  @result{}
  "<table width=\"100%\" cellpadding=\"0\">content here</table\n>"
@end example

The boolean value given to the attribute has a special meaning.
If @code{#t} is given, the attribute is rendered without a value.
If @code{#f} is given, the attribute is not rendered.
@example
(tree->string (html:table :border #t))
  @result{} "<table border></table\n>"

(tree->string (html:table :border #f))
  @result{} "<table></table\n>"
@end example

Special characters in attribute values are escaped by the function,
but the ones in the content are not.  It is caller's responsibility
to escape them.

The functions signal an error if a content is given to the
HTML element that doesn't take a content.   They do not
check if the given attribute is valid, neither
if the given content is valid for the element.

@emph{Note:}
You might have noticed that these procedures insert a newline
before @code{>} of the closing tag.  That is, the rendered
HTML would look like this:

@example
<table><tr><td>foo</td
><td>bar</td
></tr
></table
>
@end example

We intentionally avoid inserting newlines after the closing
tag, since @emph{it depends on the surrounding context whether
the newline is significant or not}.  We may be able to insert newlines
after the elements directly below a @code{<head>} element,
for example, but we cannot in a @code{<p>} element.

There are three possible solutions: (1) not to insert newlines
at all, (2) to insert newlines within tags, and (3) to insert
newlines only at the safe position.  The first one creates one
long line of HTML, and although it is still valid HTML, it is
inconvenient to handle it with line-oriented tools.
The third one requires the
rendering routine to be aware of DTD.  So we took the second
approach.
@end deftp

@c ----------------------------------------------------------------------
@node Parsing input stream, Showing progress on text terminals, Simple HTML document construction, Library modules - Utilities
@section @code{text.parse} - Parsing input stream
@c NODE 入力ストリームのパージング, @code{text.parse} - 入力ストリームのパージング

@deftp {Module} text.parse
@mdindex text.parse
A collection of utilities that does simple parsing from
the input port.   The API is inspired, and compatible with
Oleg Kiselyov's input parsing library (@ref{oleg1,,OLEG1}).
His library is used in lots of other libraries, notably,
a full-Scheme XML parser/generator SSAX (@ref{ssax,,SSAX}).

You can use this module in place of his
@code{input-parse.scm} and @code{look-for-str.scm}.

I reimplemented the functions to be efficient on Gauche.
Especially, usage of @code{string-set!} is totally avoided.
I extended the interface a bit so that they can deal with character sets
and predicates, as well as a list of characters.

These functions work sequentially on the given input port,
that is, they read from the port as much as they need, without
buffering extra characters.
@end deftp

@defun find-string-from-port? str in-port &optional max-no-chars
Looks for a string @var{str} from the input port @var{in-port}.
The optional argument @var{max-no-chars} limits the maximum number of
characters to be read from the port; if omitted, the search span is
until EOF.

If @var{str} is found, this function returns the number of characters
it has read.   The next read from @var{in-port} returns the next char
of @var{str}.  If @var{str} is not found, it returns @code{#f}.

Note: Although this procedure has `@code{?}' in its name,
it may return non-boolean value, contrary to the Scheme convention.
@end defun

@defun peek-next-char &optional port
Discards the current character and peeks the next character from @var{port}.
Useful to look ahead one character.
If @var{port} is omitted, the current input port is used.
@end defun

In the following functions, @var{char-list} refers to one of the
followings:
@itemize @bullet
@item
A character set.
@item
A list of characters, character sets and/or symbol @code{*eof*}.
@end itemize
That denotes a set of characters.  If a symbol @code{*eof*} is
included, the EOF condition is also included.  Without @code{*eof*},
the EOF condition is regarded as an error.

@defun assert-curr-char char-list string &optional port
Reads a character from @var{port}.  If it is included in @var{char-list},
returns the character.  Otherwise, signals an error with a message
containing @var{string}.
If @var{port} is omitted, the current input port is used.
@end defun

@defun skip-until char-list/number &optional port
@var{char-list/number} is either a char-list or a number.
If it is a number; it reads that many characters and returns @code{#f}.
If the input is not long enough, an error is signalled.
If @var{char-list/number} is a char-list, it reads from @var{port}
until it sees a character that belongs to the char-list.
Then the character is returned.
If @var{port} is omitted, the current input port is used.
@end defun

@defun skip-while char-list &optional port
Reads from @var{port} until it sees a character that does not
belong to @var{char-list}.  The character remains in the stream.
If it reaches EOF, an EOF is returned.
If @var{port} is omitted, the current input port is used.

This example skips whitespaces from input.  Next read from
port returns the first non-whitespace character.
@example
(skip-while #[\s] port)
@end example
@end defun

@defun next-token prefix-char-list break-char-list &optional comment port
Skips any number of characters in @var{prefix-char-list},
then collects the characters until it sees @var{break-char-list}.
The collected characters are returned as a string.
The break character remains in the @var{port}.

If the function encounters EOF and @code{*eof*} is not included in
@var{break-char-list}, an error is signalled with @var{comment} is
included in the message.
@end defun

@defun next-token-of char-list/pred &optional port
Reads and collects the characters as far as
it belongs to @var{char-list/pred}, then returns them as a string.
The first character that doesn't belong to @var{char-list/pred} remains
on the port.

@var{char-list/pred} may be a char-list or a predicate that takes
a character.   If it is a predicate, each character is passed to it,
and the character is regarded to ``belong to'' @var{char-list/pred}
when it returns a true value.
@end defun

@defun read-string n &optional port
Reads up to @var{n} characters, collects them into a string, and returns it.
If the input stream contains less characters, the returns string contains
as many characters available.
@end defun

@c ----------------------------------------------------------------------
@node Showing progress on text terminals, SQL parsing and construction, Parsing input stream, Library modules - Utilities
@section @code{text.progress} - Showing progress on text terminals
@c NODE @code{text.progress} - テキスト端末上でプログレスを表示する

@deftp {Module} text.progress
@mdindex text.progress
This module provides a utility to report a progress of processing
on a text terminal, using characters to display bar chart.
The generic format of a progress bar consists of a single line
of text, which is splitted into several parts; a header, which
displays the title; followed by a bar, a numeric part, and a time part,
as shown in the followig example (only the line beginning with ``foo''
is actually displayed).
@example
<-header-> <-------bar---------> <-num-><-time->      <---info---->
foo       |#############        |123/211   01:21 ETA  compiling...
          ^
          separator
@end example

Various things like the character used in the bar chart or
the format of the numeric progress can be configured.

Internally a progress bar maintains two numbers, the maximum (goal)
value and the current value.  The bar shows the proportion of
the current value relative to the maximum value.  The numeric progress
shows the current value over the maximum value by default, but you
can configure it to show only the current value or percentage, for example.

A progress bar also has two states, ``in progress'' and ``finished''.
When it is in progress, every time the text is displayed it is
followed by @code{#\return}, so that the next display overwrites
the bar, and the time part shows ETA (estimated time of arrival).
Once it becomes finished, the last line of text is displayed
with @code{#\newline}, and the time part shows the actual time
it took to finish.
@end deftp

This module provides only one procedure, @code{make-text-progress-bar},
which packages the progress bar feature in a closure and returns it.

@defun make-text-progress-bar &keyword header header-width bar-char bar-width num-width num-format time-width info info-width separator-char max-value port

Returns a procedure that packages operations on the progress bar.
The procedure can be called with a symbol indicating an operation,
and an optional numeric argument.

@table @code
@item @var{proc} 'show
Redisplays the progress bar.  All other operations implies redisplay,
so you don't need to use this unless you have a specific reason to 
redisplay the current state.

@item @var{proc} 'set @var{value}
Sets the current value to @var{value}, then redisplays the progress bar.
If @var{value} exceeds the max value, it is clipped by the max value.

@item @var{proc} 'inc @var{value}
Increments the current value by @var{value}, then redisplays the progress bar.
If the current value exceeds the max value, it is clipped by the max value.

@item @var{proc} 'finish
Puts the progress bar to the ``finished'' state, then redisplays it.
The time part shows the total elapsed time, and the line is terminated
by @code{#\newline} so that it won't be clobbered.   Once a progress
bar becomes ``finished'', there's no way to put it back ``in progress''.

@item @var{proc} 'set-info @var{text}
Changes the text displayed in the ``info'' part.  To use the info part,
you have to give a positive value to @var{info-width} keyword argument
of @code{make-text-progress-bar}.


@item @var{proc} 'set-header @var{text}
Changes the text displayed in the ``header' area.
@end table

The keyword arguments are used to customize the display:
@table @var
@item header
The text to be displayed in the header part.
This can be changed later, by sending @code{set-header} message
to the created progress bar.

@item header-width
The width of the header part, in number of characters.
The header text is displayed left-aligned in the part.
If the header text is longer than the width, the excess characters
are omitted.  The default is 14.

@item bar-char
A character used to draw a bar chart.  The default is @code{#\#}.

@item bar-width
The width of the bar chart part, in number of characters.
The default is 40.

@item num-width
The width of the numeric part, in number of characters.
The default is 9.  Setting this to 0 hides the numeric part.

@item num-format
A procedure to format the numeric part.  Two arguments are
passed; the current value and the maximum value.  It must return
a string.  The default is the following procedure.
@example
(lambda (cur max)
  (format "~d/~d" cur max))
@end example

@item time-width
The width of the time part, in number of characters.
The default is 7.  Settings this to 0 hides the time part.

@item info
The text to be displayed in the info part.  This text can be
changed later by sending @code{set-info} message to the created
progress bar.  Note that you have to give a positive number
to @var{info-width} keyword argument to enable the info part.

@item info-width
The width of the info part.  The default value is zero,
which means the info part is not displayed.

@item separator-char
A character put around the bar part.  Default is @code{#\|}.
You can pass @code{#f} not to display the separators.

@item max-value
The maximum value of the progress bar.  Default is 100.

@item port
An output port to which the progress bar is displayed.  The default value
is the current output port when @code{make-text-progress-bar} is called.
@end table
@end defun

Here's a simple example, using customized numeric part:

@example
(use text.progress)

(define (main args)
  (define (num-format cur max)
    (format "~d/~d(~3d%)" cur max
            (round->exact (/. (* cur 100) max))))
  
  (let ((p (make-text-progress-bar :header "Example"
                                   :header-width 10
                                   :bar-char #\o
                                   :num-format num-format
                                   :num-width 13
                                   :max-value 256)))
    (do ((i 0 (+ i 1)))
        ((= i 256) (p 'finish))
      (p 'inc 1)
      (sys-select #f #f #f 50000))))
@end example

@c ----------------------------------------------------------------------
@node SQL parsing and construction, Transliterate characters, Showing progress on text terminals, Library modules - Utilities
@section @code{text.sql} - SQL parsing and construction
@c NODE @code{text.sql} - SQLのパーズと構築

@deftp {Module} text.sql
@mdindex text.sql
This module provides a utility to parse and construct SQL statement.

It is currently under development, and we only have a tokenization routine.
The plan is to define S-expression syntax of SQL and provides a routine
to translate one form to the other.

Note: If you're looking for a routine to escape strings to be
safe in SQL, see @code{dbi-escape-sql} in @ref{DBI user API}.
@end deftp

@defun sql-tokenize sql-string
Tokenize a SQL statement @var{sql-string}.  The return value is
a list of tokens, where each token is 
represented by one of the following forms.

@example
<symbol>              Special delimiter.  One of the followings:
                      + - * / < = > <> <= >= ||
<character>           Special delimiter.  One of the followings:
                      #\, #\. #\( #\) #\;
<string>              Regular identifier
(delimited <string>)  Delimited identifier
(parameter <num>)     Positional parameter (?)
(parameter <string>)  Named parameter (:foo)
(string    <string>)  Character string literal
(number    <string>)  Numeric literal
(bitstring <string>)  Binary string.  <string> is like "01101"
(hexstring <string>)  Binary string.  <string> is like "3AD20"
@end example

If it encounters an untokenizable string, it raises an
@code{<sql-parse-error>} condition.
@end defun

@deffn {Condition} <sql-parse-error>
A condition to indicate an SQL parse error.  Inherits @code{<error>}.
@defivar <sql-parse-error> sql-string
Holds the source SQL string.
@end defivar
@end deffn

@c ----------------------------------------------------------------------
@node Transliterate characters, Lazy text construction, SQL parsing and construction, Library modules - Utilities
@section @code{text.tr} - Transliterate characters
@c NODE 文字変換, @code{text.tr} - 文字変換

@deftp {Module} text.tr
@mdindex text.tr
This module implements a transliterate function,
that substitutes characters of the input string.
This functionality is realized in Unix @code{tr(1)} command,
and incorporated in various programs such as @code{sed(1)}
and @code{perl}.

Gauche's @code{tr} is aware of multibyte characters.
@end deftp

@defun tr from-list to-list &keyword :complement :delete :squeeze :table-size :input :output
Reads from @var{input} and writes to @var{output},
with transliterating characters in @var{from-list} to the
corresponding ones in @var{to-list}.  Characters that doesn't
appear in @var{from-list} are passed through.

The default values of @var{input} and @var{output} are
current input port and current output port, respectively.

Both @var{from-list} and @var{to-list} must be strings.
They may contain the following special syntax.
Other characters that doesn't fits in the syntax are taken as they are.

@table @code
@item @b{x-y}
Expanded to the increasing sequence of characters from @code{x} to @code{y},
inclusive.  The order is determined by the internal character
encoding system; generally it is safer to limit use of this within
the range of the same character class.   The character @code{x}
must be before @code{y}.

@item @b{x*n}
Repeat @code{x} for @code{n} times.  @code{n} is a decimal number notation.
Meaningful only in
@var{to-list}; it is an error to use this form in @var{from-list}.
If @code{n} is omitted or zero, @code{x} is repeated until @var{to-list}
matches the length of @var{from-list} (any character after it is ignored).

@item @b{@code{\}x}
Represents @code{x} itself.  Use this escape to avoid a special
character to be interpreted as itself.   Note that if you place
a backslash in a string, you must write @code{\\}, for the Scheme
reader also interprets backslash as a special character.

There's no special sequence to represent non-graphical characters,
for you can put such characters by the string syntax.
@end table

Here's some basic examples.
@example
;; @r{swaps case of input}
(tr "A-Za-z" "a-zA-Z")

;; @r{replaces 7-bit non-graphical characters to `?'}
(tr "\x00-\x19\x7f" "?*")
@end example

If @var{to-list} is shorter than @var{from-list}, the behavior
depends on the keyword argument @var{delete}.  If a true value is
given,  characters that appear in @var{from-list} but not
in @var{to-list} are deleted.   Otherwise, 
the extra characters in @var{from-list} are just passed through.

When a true value is specified to @var{complement},
the character set in @var{from-list} is complemented.
Note that it implies @emph{huge} set of characters,
so it is not very useful unless either output character
set is a single character (using `*') or used with
@code{delete} keyword.

When a true value is specified to @var{squeeze},
the sequence of the same replaced characters is squeezed to one.
If @var{to-list} is empty, the sequence of the same characters
in @var{from-list} is squeezed.

Internally, @code{tr} builds a table to map the characters for
efficiency.  Since Gauche can deal with potentially huge set
of characters, it limits the use of the table for only smaller
characters (<256 by default).  If you want to transliterate
multibyte characters on the large text, however, you might want 
to use larger table, trading off the memory usage.  You can specify
the internal table size by @var{table-size} keyword argument.
For example, if you transliterate lots of EUC-JP hiragana text
to katakana, you may want to set table size greater than 42483
(the character code of the last katakana).

Note that the pre-calculation to build the transliterate table
needs some overhead.  If you want to call @code{tr} many times
inside loop, consider to use @code{build-transliterator} described below.
@end defun

@defun string-tr string from-list to-list &keyword :complement :delete :squeeze :table-size
Works like @code{tr}, except that input is taken from a string @var{string}.
@end defun

@defun build-transliterator from-list to-list &keyword :complement :delete :squeeze :table-size :input :output
Returns a procedure that does the actual transliteration.  This effectively
``pre-compiles'' the internal data structure.   If you want to run
@code{tr} with the same sets repeatedly, you may build the procedure
once and apply it repeatedly, saving the overhead of initialization.

A note for an edge case:
When @var{input} and/or @var{output} keyword arguments are omitted,
the created transliterator is set up to use current-input-port and/or
current-output-port at the time transliterator is called.

@example
(with-input-from-file "huge-file.txt"
  (lambda ()
    (let loop ((line (read-line)))
      (unless (eof-object? line) (tr "A-Za-z" "a-zA-Z")))))

;; @r{runs more efficiently...}

(with-input-from-file "huge-file.txt"
  (lambda ()
    (let ((ptr (build-transliterator "A-Za-z" "a-zA-Z")))
      (let loop ((line (read-line)))
        (unless (eof-object? line) (ptr))))))
@end example

@end defun

@c ----------------------------------------------------------------------
@node Lazy text construction, Combination library, Transliterate characters, Library modules - Utilities
@section @code{text.tree} - Lazy text construction
@c NODE 怠惰なテキスト構築, @code{text.tree} - 怠惰なテキスト構築

@deftp {Module} text.tree
@mdindex text.tree
Defines simple but commonly used functions for a text construction.

When you generate a text by a program, 
It is a very common operation to concatenate text segments.
However, using string-append repeatedly causes unnecessary
copying of intermediate strings, and sometimes such intermediate
strings are discarded due to the error situation (for example,
think about constructing an HTML document in the CGI script).

The efficient technique is to delay concatenation of those
text segments until it is needed.  In Scheme it is done very
easily by just consing the text segments together, thus forming
a tree of text, and then traverse the tree to construct a text.
You can even directly writes out the text during traversal,
avoiding intermediate string buffer.
(Hans Boehm's ``cord'' library, which comes with his garbage
collector library, uses this technique and proves it is very
efficient for editor-type application).

Although the traversal of the tree can be written in a
few lines of Scheme, I provide this module in the spirits
of OnceAndOnlyOnce.   Also it's easier if we have a common interface.
@end deftp

@deffn {Generic Function} write-tree tree &optional out
Writes out an @var{tree} as a tree of text, to the output port @var{out}.
If @var{out} is omitted, the current output port is used.

Two methods are defined for this generic function, as shown below.
If you have more complex behavior, you can define more methods
to customize the behavior.
@end deffn

@deffn {Method} write-tree ((tree <list>) out)
@deffnx {Method} write-tree ((tree <top>) out)
Default methods.  For a list, @code{write-tree} is recursively
called for each element.  Any objects other than list is written out
using @code{display}.
@end deffn

@defun tree->string tree
Just calls the @code{write-tree} method for @var{tree} using
an output string port, and returns the result string.
@end defun

@c ----------------------------------------------------------------------
@node Combination library, Message digester framework, Lazy text construction, Library modules - Utilities
@section @code{util.combinations} - Combination library
@c NODE 組み合わせ, @code{util.combinations} - 組み合わせ

@deftp {Module} util.combinations
@mdindex util.combinations
This module implements several useful procedures of
combinations, permutations and related operations.

Most procedures in the module have two variants: a procedure without
star (e.g. @code{permutations}) treats all elements in the given
set distinct, while a procedure with star (e.g. @code{permutations*})
considers duplication.  The procedures with star take optional @var{eq}
argument that is used to test equality, which defaults to @code{eqv?}.
@end deftp

@defun permutations set
@defunx permutations* set &optional eq
Returns a list of all permutations of a list @var{set}.

@example
(permutations '(a b c))
  @result{} ((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))

(permutations '(a a b))
  @result{} ((a a b) (a b a) (a a b) (a b a) (b a a) (b a a))

(permutations* '(a a b))
  @result{} ((a a b) (a b a) (b a a))
@end example

The number of possible permutations explodes if @var{set} has
more than several elements.  Use with care.  If you want to process
each permutation at a time, consider @code{permutations-for-each} below.
@end defun

@defun permutations-for-each proc set
@defunx permutations*-for-each proc set &optional eq
For each permutation of a list @var{set}, calls @var{proc}.
Returns an undefined value.
@end defun

@defun combinations set n
@defunx combinations* set n &optional eq
Returns a list of all possible combinations of @var{n} elements out
of a list @var{set}.

@example
(combinations '(a b c) 2)
  @result{} ((a b) (a c) (b c))

(combinations '(a a b) 2)
  @result{} ((a a) (a b) (a b))

(combinations* '(a a b) 2)
  @result{} ((a a) (a b))
@end example

Watch out the explosion of combinations when @var{set} is large.
@end defun

@defun combinations-for-each proc set n
@defunx combinations*-for-each proc set n &optional eq
Calls @var{proc} for each combination of @var{n} elements out of @var{set}.
Returns an undefined value.
@end defun

@defun power-set set
@defunx power-set* set &optional eq
Returns power set (all subsets) of a list @var{set}.

@example
(power-set '(a b c))
  @result{} (() (a) (b) (c) (a b) (a c) (b c) (a b c))

(power-set* '(a a b)
  @result{} (() (a) (b) (a a) (a b) (a a b))
@end example
@end defun

@defun power-set-for-each proc set
@defunx power-set*-for-each proc set &optional eq
Calls @var{proc} for each subset of @var{set}.
@end defun

@defun power-set-binary set
Returns power set of @var{set}, like @code{power-set}, but in different order.
@code{Power-set-binary} traverses subset space in depth-first order,
while @code{power-set} in breadth-first order.

@example
(power-set-binary '(a b c))
  @result{} (() (c) (b) (b c) (a) (a c) (a b) (a b c))
@end example
@end defun

@defun cartesian-product list-of-sets
@defunx cartesian-product-right list-of-sets
Returns a cartesian product of sets in @var{list-of-sets}.
@code{Cartesian-product} construct the result in left fixed order
(the rightmost element varies first), while 
@code{cartesian-product-right} in right fixed order
(the leftmost element varies first).

@example
(cartesian-product '((a b c) (0 1)))
  @result{} ((a 0) (a 1) (b 0) (b 1) (c 0) (c 1))

(cartesian-product-right '((a b c) (0 1)))
  @result{} ((a 0) (b 0) (c 0) (a 1) (b 1) (c 1))
@end example
@end defun

@c ----------------------------------------------------------------------
@node Message digester framework, Determine isomorphism, Combination library, Library modules - Utilities
@section @code{util.digest} - Message digester framework
@c NODE メッセージダイジェストフレームワーク, @code{util.digest} - メッセージダイジェストフレームワーク

@deftp {Module} util.digest
@mdindex util.digest
This module provides a base class and common interface for 
message digest algorithms, such as MD5 (@xref{MD5 message digest})
and SHA1 (@xref{SHA1 message digest}).
@end deftp

@deftp {Class} <message-digest-algorithm-meta>
@clindex message-digest-algorithm-meta
A metaclass of message digest algorithm implementation.
@end deftp

@deftp {Class} <message-digest-algorithm>
@clindex message-digest-algorithm
A base class of message digest algorithm implementation.
@end deftp

The concrete subclass of message digest algorithm has to
implement the following methods.

@deffn {Generic function} digest-update! algorithm data
Takes the instance of massage-digest algorithm, and updates it
with the data @var{data}, represented in a (possibly incomplete) string.
@end deffn

@deffn {Generic function} digest-final! algorithm
Finalizes the instance of message-digest algorithm, and
returns the digest result in an incomplete string.
@end deffn

@deffn {Generic function} digest class
A wrapper of digest routines.  Given message-digest algorithm @var{class},
this function reads the input data from current input port until EOF,
and returns the digest result in an incomplete string.
@end deffn

@deffn {Generic function} digest-string class string
A wrapper of digest routines.  Given message-digest algorithm @var{class},
this function reads the input data from @var{string},
and returns the digest result in an incomplete string.
@end deffn

@defun digest-hexify digest-result
An utility procedure.  Given the result of digest, @var{digest-result},
converts it to a hexified string.
@end defun

@c ----------------------------------------------------------------------
@node Determine isomorphism, The longest common subsequence, Message digester framework, Library modules - Utilities
@section @code{util.isomorph} - Determine isomorphism
@c NODE 同型判定, @code{util.isomorph} - 同型判定

@deftp {Module} util.isomorph
@mdindex util.isomorph
Provides a procedure that determines whether two structures are
isomorphic.
@end deftp

@defun isomorphic? obj1 obj2 &optional context
Returns @code{#t} if @var{obj1} and @var{obj2} are isomorphic.

@var{context} is used if you want to call @code{isomorphic?}
recursively inside @code{object-isomorphic?} described below.

@example
(isomorphic? '(a b) '(a b)) @result{} #t

(define x (cons 0 0))
(define y (cons 0 0))
(isomorphic? (cons x x)
             (cons x y))
 @result{} #f
(isomorphic? (cons x x)
             (cons y y))
 @result{} #t
@end example
@end defun

@deffn {Generic Function} object-isomorphic? obj1 obj2 context
With this method, you can customize how to determine isomorphism of
two objects.  Basically, you will call @code{isomorphic?} recursively
for each slots of object you want to traverse; the method should return
@code{#t} if all of the test succeeds, or return @code{#f} otherwise.
@var{context} is an opaque structure
that keeps the traversal context, and you should pass it to
@code{isomorphic?} as is.

The default method returns @code{#t} if @var{obj1} and @var{obj2} are
equal (in the sense of @code{equal?}).
@end deffn

@c ----------------------------------------------------------------------
@node The longest common subsequence, Additional list library, Determine isomorphism, Library modules - Utilities
@section @code{util.lcs} - The longest common subsequence
@c NODE 最長共通サブシーケンス, @code{util.lcs} - 最長共通サブシーケンス

@deftp {Module} util.lcs
@mdindex util.lcs
This module implements the algorithm to find the longest common subsequence
of two given sequences.  The implemented algorithm is based on
Eugene Myers' O(ND) algorithm (@ref{myers86,[Myers86],Myers86}).

One of the applications of this algorithm is to calculate
the difference of two text streams;
see @ref{Calculate difference of text streams}.
@end deftp

@defun lcs seq-a seq-b &optional eq-fn
Calculates and returns the longest common sequence of
two lists, @var{seq-a} and @var{seq-b}.
Optional @var{eq-fn} specifies
the comparison predicate; if omitted, @code{equal?} is used.

@example
(lcs '(x a b y) '(p a q b))
 @result{} (a b)
@end example
@end defun

@defun lcs-with-positions seq-a seq-b &optional eq-fn
This is the detailed version of @code{lcs}.
The arguments are the same.

Returns a list of the following structure:

@example
(@var{length} ((@var{elt} @var{a-pos} @var{b-pos}) @dots{}))
@end example

@var{Length} is an integer showing the length of the found LCS.
What follows is a list of elements of LCS; each sublist
consists of the element, the integer position of the element
in @var{seq-a}, then the integer position of the element in @var{seq-b}.

@example
(lcs-with-positions '(a) '(a))
 @result{} (1 ((a 0 0)))

(lcs-with-positions '(x a b y) '(p q a b))
 @result{} (2 ((a 1 2) (b 2 3)))

(lcs-with-positions '(x a b y) '(p a q b))
 @result{} (2 ((a 1 1) (b 2 3)))

(lcs-with-positions '(x y) '(p q))
 @result{} (0 ())
@end example
@end defun

@defun lcs-fold a-proc b-proc both-proc seed a b &optional eq-fn
A fundamental iterator over the "edit list" derived from
two lists @var{a} and @var{b}.

@var{A-proc}, @var{b-proc}, @var{both-proc} are all procedures
that take two arguments.   The second argument is a intermediate
state value of the calculation.  The first value is an element
only in @var{a} for @var{a-proc}, or an element only in @var{b}
for @var{b-proc}, or an element in both @var{a} and @var{b}
for @var{both-proc}.  The return value of each procedure is used
as the state value of the next call of either one of the procedures.
@var{Seed} is used as the initial value of the state value.
The last state value is returned from @code{lcs-fold}.

The three procedures are called in the following order: Suppose the sequence
@var{a} consists of @var{a'}@var{c}@var{a''}, and @var{b} consists of 
@var{b'}@var{c}@var{b''}, where @var{a'}, @var{b'}, @var{a''}, and @var{b''}
are subsequences, and @var{c} is the head of the 
LCS of @var{a} and @var{b}.   Then @var{a-proc} is called first on
each element in @var{a'}, @var{b-proc} is called second on
each element in @var{b'}, then @var{both-proc} is called on @var{c}.
Afterwards, the process is repeated using @var{a''} and @var{b''}.
@end defun

@defun lcs-edit-list a b &optional eq-fn
Calculates 'edit-list' from two lists @var{a} and @var{b}, which is
the smallest set of commands (additions and deletions) that changes
@var{a} into @var{b}.
This procedure is built on top of @code{lcs-fold} above.

Returns a list of @emph{hunk}s, which is a contiguous section of
additions and deletions.  Each hunk consists of a list of
directives, which is a form of:
@example
(@var{+}|@var{-} @var{position} @var{element})
@end example

Here's an example.  Suppose @var{a} and @var{b} are the following
lists, respectively.

@example
@var{a} @equiv{} ("A" "B" "C" "E" "H" "J" "L" "M" "N" "P")
@var{b} @equiv{} ("B" "C" "D" "E" "F" "J" "K" "L" "M" "R" "S" "T")
@end example

Then, @code{(lcs-edit-list a b equal?)} returns the following list.
@example
(((- 0 "A"))
 ((+ 2 "D"))
 ((- 4 "H") (+ 4 "F"))
 ((+ 6 "K"))
 ((- 8 "N") (- 9 "P") (+ 9 "R") (+ 10 "S") (+ 11 "T"))
)
@end example
The result consists of five hunks.  The first hunk consists of
one directive, @code{(- 0 "A")}, which means the element @code{"A"}
at the position 0 of list @var{a} has to be deleted.
The second hunk also consists of one directive, @code{(+ 2 "D")},
meaning the element @code{"D"} at the position 2 of list @var{b}
has to be added.  The third hunk means @code{"H"} at the position
4 of list @var{a} should be removed and @code{"F"} at the position
4 of list @var{b} should be added, and so on.

If you are familiar with Perl's Algorithm::Diff module, you may 
notice that this is the same structure that its @code{diff} procedure
returns.
@end defun

@c ----------------------------------------------------------------------
@node Additional list library, Pattern matching, The longest common subsequence, Library modules - Utilities
@section @code{util.list} - Additional list library
@c NODE その他のリストライブラリ, @code{util.list} - その他のリストライブラリ

@deftp {Module} util.list
@mdindex util.list
This module provides list utility functions which are not in srfi-1
(@xref{List library}) but generally useful.

See also @ref{Collection framework}
and @ref{Sequence framework}, for
these modules also defines useful generic functions that can
be used for lists.
@end deftp

@defun take* list k &optional fill? padding
Returns a list that consists of the first @var{k} elements in
@var{list}, like SRFI-1's @code{take}, except this procedure
is more tolerant.  That is, if @var{list}
is shorter than @var{k}, @code{take*} doesn't signals an error.
Instead, it returns a copy of @var{list} by default (or the optional
argument @var{fill?} is @code{#f}).   If @var{fill?} is true,
@var{padding} is added to the result to make its length @var{k}.
The default value of @var{padding} is @code{#f}.

@example
(take* '(a b c d) 3)       @result{} (a b c)
(take* '(a b c d) 6)       @result{} (a b c d)
(take* '(a b c d) 6 #t)    @result{} (a b c d #f #f)
(take* '(a b c d) 6 #t 'z) @result{} (a b c d z z)
@end example

Note: For generic subsequence extraction from any sequence, 
see @code{subseq} in @ref{Slicing sequence}.
@end defun

@defun drop* list k
Returns a list that the first @var{k} elements of @var{list} is
dropped, like SRFI-1's @code{drop}, except this procedure
is more tolerant.  If @var{list} is shorter than @var{k},
an empty list is returned.

@example
(drop* '(a b c d) 3)       @result{} (d)
(drop* '(a b c d) 5)       @result{} ()
@end example
@end defun

@defun take-right* list k &optional fill? padding
Like @code{take*}, but counts from right of @var{list}.
If needed, @var{padding} is added on left of the result.
@end defun

@defun drop-right* list k
Like @code{drop*}, but counts from right of @var{list}.
@end defun

@defun split-at* list k &optional fill? padding
More tolerant version of SRFI-1's @code{split-at}.
Returns the results of @code{take*} and @var{drop*}.

@example
(split-at* '(a b c d) 6 #t 'z)
  @result{} (a b c d z z) @r{and} ()
@end example
@end defun

@defun slices list k &optional fill? padding
Splits @var{list} into the sublists (slices) where the length of
each slice is @var{k}.
If the length of @var{list} is not a multiple of @var{k},
the last slice is dealt in the same way as @code{take*}; that is,
it is shorter than @var{k} by default, or added @var{padding} if
@var{fill?} is true.

@example
(slices '(a b c d e f g) 3)
  @result{} ((a b c) (d e f) (g))
(slices '(a b c d e f g) 3 #t 'z)
  @result{} ((a b c) (d e f) (g z z))
@end example
@end defun

@defun intersperse item list
Inserts @var{item} between elements in the @var{list}.
(The order of arguments is taken from Haskell's intersperse).

@example
(intersperse '+ '(1 2 3))  @result{} (1 + 2 + 3)
(intersperse '+ '(1))      @result{} (1)
(intersperse '+ '())       @result{} ()
@end example
@end defun

@defmac cond-list clause @dots{}
Construct a list by conditionally adding entries.
Each @var{clause} has a test and expressions.  When its test
yields true, the result of associated expression is used to
construct the resulting list.  When the
test yields false, nothing is inserted.

@var{Clause} must be either one of the following form:
@table @code
@item (@var{test} @var{expr} @dots{})
@var{Test} is evaluated, and when it is true,
@var{expr} @dots{} are evaluated, and the return value
becomes a part of the result.  If no @var{expr} is given,
the result of @var{test} is used if it is not false.
@item (@var{test} => @var{proc})
@var{Test} is evaluated, and when it is true,
@var{proc} is called with the value, and the return
value is used to construct the result.
@item (@var{test} @@ @var{expr} @dots{})
Like @code{(test expr @dots{})}, except that the result of
the last @var{expr} must be a list, and it is spliced into
the resulting list, like unquote-splicing.
@item (@var{test} => @@ @var{proc})
Like @code{(test => proc)}, except that the result of
@var{proc} must be a list, and and it is spliced into
the resulting list, like unquote-splicing.
@end table

@example
(let ((alist '((x 3) (y -1) (z 6))))
 (cond-list ((assoc 'x alist) 'have-x)
            ((assoc 'w alist) 'have-w)
            ((assoc 'z alist) => cadr)))
  @result{} (have-x 6)

(let ((x 2) (y #f) (z 5))
  (cond-list (x @@ `(:x ,x))
             (y @@ `(:y ,y))
             (z @@ `(:z ,z))))
  @result{} (:x 2 :z 5)
@end example
@end defmac

@defun alist->hash-table alist &optional cmp
Creates and returns a hash table that has entries of
each element in alist, using its car as the key and
its cdr as the value.  @var{Cmp} is a symbol specifying
the comparison function of the created hash table;
currently @code{eq?}, @code{eqv?}, @code{equal?} and @code{string=?}
are supported.
@end defun

@defun hash-table->alist hash-table
@example
  (hash-table-map h cons)
@end example
@end defun

@defun rassoc key alist &optional eq-fn
@defunx rassq key alist
@defunx rassv key alist
Reverse associations---given @var{key} is matched to the @emph{cdr}
of each element in @var{alist}, instead of the @emph{car}.
Handy to realize bidirectional associative list.
@code{Rassoc} takes an optional comparison function, whose default is
@code{equal?}.  @code{Rassq} and @code{rassv} uses @var{eq?} and @var{eqv?}.
@end defun


@defun assoc-ref alist key &optional default eq-fn
@defunx assq-ref alist key &optional default
@defunx assv-ref alist key &optional default
These procedures provide the access to the assoc list
symmetric with other *-ref procedures.
This captures the common pattern of alist access:
@example
(assoc-ref alist key default eq-fn)
 @equiv{}
  (cond ((assoc key alist eq-fn) => cdr)
        (else default))))
@end example

If @var{default} is omitted, @code{#f} is used.

@code{Assoc-ref} takes an optional comparison function @var{eq-fn},
whose default is @code{equal?}.  @code{Assq-ref} and @code{assv-ref}
uses @code{eq?} and @code{eqv?}, respectively.
@end defun

@defun rassoc-ref alist key &optional default eq-fn
@defunx rassq-ref alist key &optional default
@defunx rassv-ref alist key &optional default
Reverse association version of @code{assoc-ref}.
@example
(rassoc-ref alist key default eq-fn)
 @equiv{}
  (cond ((rassoc key alist eq-fn) => car)
        (else default))))
@end example
The meanings of optional arguments are the same as @code{assoc-ref}.
@end defun

@defun assoc-set! alist key val &optional eq-fn
@defunx assq-set! alist key val
@defunx assv-set! alist key val
Returns an alist who has @code{(key . val)} pair added to the @code{alist}.
If @code{alist} already has an element with @var{key}, the element's
@emph{cdr} is destructively modified for @var{val}.
If @var{alist} doesn't have an element with @var{key}, a new pair
is created and appended in front of @var{alist}; so you should use
the return value to guarantee @var{key}-@var{val} pair is added.

@code{Assoc-set!} takes optional comparison function @var{eq-fn},
whose default is @code{equal?}.  @code{Assq-set!} and @code{assv-set!}
uses @code{eq?} and @code{eqv?}, respectively.
@end defun

@c ----------------------------------------------------------------------
@node Pattern matching, Queue, Additional list library, Library modules - Utilities
@section @code{util.match} - Pattern matching
@c NODE パターンマッチング, @code{util.match} - パターンマッチング

@deftp {Module} util.match
@mdindex util.match
This module is a port of Andrew Wright's pattern matching macro library.
It is widely used in Scheme world, and ported to various Scheme
implementations, including Chez Scheme, PLT Scheme, Scheme48, Chicken,
and SLIB.
It is similar to, but more powerful than
Common Lisp's @code{destructuring-bind}.

This version retains compatibility of the original Wright's macro,
except (1) @var{box} is not supported since Gauche doesn't have one,
and (2) structure matching is integrated to Gauche's object system.
@end deftp

We show a list of APIs first, then the table of complete syntax of 
patterns, followed by examples.

@subheading Pattern matching API

@defmac match expr clause @dots{}

Each @var{clause} is either one of the followings:
@example
(@var{pat} @var{body} @dots{})
(@var{pat} (=> @var{identifier}) @var{body} @dots{})
@end example

First, the @var{expr} is matched against @var{pat} of each clauses.
The detailed syntax of the pattern is explained below.

If a matching @var{pat} is found, the @emph{pattern variables} in
@var{pat} are bound to the corresponding elements in @var{expr}, then
@var{body} @dots{} are evaluated.  Then @code{match} returns the value(s)
of the last expression of @var{body} @dots{}.

If the clause is the second form, @var{identifier} is also bound
to the failure continuation of the @var{clause}.  It is a
procedure with no arguments, and when called, it jumps back to
the matcher as if the matching of @var{pat} is failed, and
@code{match} continues to try the rest of clauses.
So you can perform extra tests
within @var{body} @dots{} and if you're not satisfied you can reject
the match by calling @code{(@var{identifier})}.  See the examples
below for more details.

If no @var{pat} matches, @code{match} reports an error.
@end defmac

@defmac match-lambda clause @dots{}
Creates a function that takes one argument and performs @code{match} on it,
using @var{clause} @dots{}.  It's functionally equivalent to the following
expression:
@example
(lambda (expr) (match expr @var{clause} @dots{}))
@end example

Example:

@example
(map (match-lambda
       ((item price-per-lb (quantity 'lbs))
        (cons item (* price-per-lb quantity)))
       ((item price-per-lb (quantity 'kg))
        (cons item (* price-per-lb quantity 2.204))))
     '((apple      1.23 (1.1 lbs))
       (orange     0.68 (1.4 lbs))
       (cantaloupe 0.53 (2.1 kg))))
 @result{} ((apple . 1.353) (orange . 0.952)
            (cantaloupe . 2.4530520000000005))
@end example
@end defmac

@defmac match-lambda* clause @dots{}
Like @code{match-lambda}, but performs @code{match} on the list of
whole arguments.
It's functionally equivalent to the following expression:
@example
(lambda expr (match expr @var{clause} @dots{}))
@end example
@end defmac

@defmac match-let ((pat expr) @dots{}) body-expr @dots{}
@defmacx match-let name ((pat expr) @dots{}) body-expr @dots{}
@defmacx match-let* ((pat expr) @dots{}) body-expr @dots{}
@defmacx match-letrec ((pat expr) @dots{}) body-expr @dots{}
Generalize @code{let}, @code{let*}, and @code{letrec} to allow
patterns in the binding position rather than just variables.
Each @var{expr} is evaluated, and then matched to @var{pat},
and the bound pattern variables are visible in 
@var{body-expr} @dots{}.

@example
(match-let (
             (((ca . cd) ...)   '((a . 0) (b . 1) (c . 2)))
           )
  (list ca cd))
 @result{} ((a b c) (0 1 2))
@end example

If you're sick of parenthesis, try @code{match-let1} below.
@end defmac

@defmac match-let1 pat expr body-expr @dots{}
This is a Gauche extension and isn't found in the original Wright's code.
This one is equivalent to the following code:
@example
(match-let ((@var{pat} @var{expr})) @var{body-expr} @dots{})
@end example

Syntactically, @code{match-let1} is very close to the Common Lisp's
@code{destructuring-bind}.

@example
(match-let1 ('let ((var val) ...) body ...)
            '(let ((a b) (c d)) foo bar baz)
  (list var val body))
 @result{} ((a c) (b d) (foo bar baz))
@end example
@end defmac

@defmac match-define pat expr
Like toplevel @code{define}, but allows a pattern instead of variables.

@example
(match-define (x . xs) (list 1 2 3))

x  @result{} 1
xs @result{} (2 3)
@end example

@end defmac

@subheading Pattern syntax

Here's a summary of pattern syntax. The asterisk @code{(*)}
after explanation means Gauche's extension which does not present
in the original Wright's code.

@example
pat : patvar                       ;; anything, and binds pattern var
    | _                            ;; anything
    | ()                           ;; the empty list
    | #t                           ;; #t
    | #f                           ;; #f
    | string                       ;; a string
    | number                       ;; a number
    | character                    ;; a character
    | keyword                      ;; a keyword (*)
    | 'sexp                        ;; an s-expression
    | 'symbol                      ;; a symbol (special case of s-expr)
    | (pat1 ... patN)              ;; list of n elements
    | (pat1 ... patN . patN+1)     ;; list of n or more
    | (pat1 ... patN patN+1 ooo)   ;; list of n or more, each element
                                   ;;   of remainder must match patN+1
    | #(pat1 ... patN)             ;; vector of n elements
    | #(pat1 ... patN patN+1 ooo)  ;; vector of n or more, each element
                                   ;;   of remainder must match patN+1
    | ($ class pat1 ... patN)      ;; an object (patK matches in slot order)
    | (struct class pat1 ... patN) ;; ditto (*)
    | (@@ class (slot1 pat1) ...)   ;; an object (using slot names) (*)
    | (object class (slot1 pat1) ...) ;; ditto (*)
    | (= proc pat)                 ;; apply proc, match the result to pat
    | (and pat ...)                ;; if all of pats match
    | (or pat ...)                 ;; if any of pats match
    | (not pat ...)                ;; if all pats don't match at all
    | (? predicate pat ...)        ;; if predicate true and all pats match
    | (set! patvar)                ;; anything, and binds setter
    | (get! patvar)                ;; anything, and binds getter
    | `qp                          ;; a quasi-pattern

patvar : a symbol except _, quote, $, struct, @@, object, =, and, or,
         not, ?, set!, get!, quasiquote, ..., ___, ..k, __k.

ooo : ...                          ;; zero or more
    | ___                          ;; zero or more
    | ..k                          ;; k or more
    | __k                          ;; k or more
@end example

@itemize @bullet
@item
A bare symbol is a "pattern variable"; it matches anything, and
the matched part of the expression is bound to the symbol.
The following symbols have special meanings and cannot be used
as a pattern variable: @code{_}, @code{quote}, @code{$}, @code{struct},
@code{@@}, @code{object}, @code{=}, @code{and}, @code{or},
@code{not}, @code{?}, @code{set!}, @code{get!}, @code{quasiquote},
@code{...}, @code{___}, and @code{..k} and @code{__k} where @emph{k} is
an integer.

@item
A symbol @code{_} matches anything, without binding a patter variable.
It can be used to show "don't care" placeholder.

@item
Literals such as emptylist, booleans, strings, numbers, characters and
keywords match the same object (in the sense of @code{equal?}).

@item
Quoted expression matches the same experssion (in the sense of @code{equal?}).
You can use a quoted symbol to match the symbol itself.

@item
A list and a vector in general match a list or a vector whose elements
matches the elements in the pattern recursively, unless the first element
of the list is one of the special symbols listed above, it has a special
meaning.

As a special case, the last element of a vector or a list can be
followed by a symbol @code{...}.  In that case, the pattern just before
the symbol @code{...} can be applied repeatedly until it consumes all the
elements in the given expression.  A symbol @code{___} can be used
in place of @code{...}; it is useful when you want to produce a pattern
by syntax-rules macro.

For a list pattern, you can also use a symbol @code{..1}, @code{..2},
@dots{}, which specifies the minimum number of repetition.

@item
@code{($ class pat1 @dots{})} matches an instance of a class @code{class}.
Each pattern @code{pat1} @dots{} matches each value of slots,
in order of @code{(class-slots class)}.

@code{(struct class pat1 @dots{})} has the same meaning.  Although
the original Wright's code doesn't have @code{struct}, PLT Scheme has
it in its extended match feature, and it is more descriptive.

This is an adaptation of the original feature that can match structures.
It is useful to match a simple instance that you know the order of
slots; for example, a simple record created by srfi-9
(@xref{Record types}) would be easy to match by positioned values.

If the instance's class uses inheritances, it is a bit difficult to
match by positions.  You can use @code{@@} or @code{object} pattern
below to match using slot names.

@item
@code{(object class (slot1 pat1) @dots{})} matches an instance
of a class @code{class} whose value of @var{slot1} @dots{} matches
@var{pat1} @dots{}.  This is Gauche's extension.  @code{@@} can be
used in place of @code{object}, but @code{object} is recommended
because of descriptiveness.

@item
@code{(= proc pat)} first applies @var{proc} to the corresponding
expression, then match the result with @var{pat}.

@item
@code{(and pat @dots{})}, @code{(or pat @dots{})}, and
@code{(not pat @dots{})} are boolean operations of patterns.

@item
@code{(? predicate pat @dots{})} first applies a predicate to the
corresponding expression, and if it returns true, applies each
@code{pat} @dots{} to the expression.

@item
@code{(set! patvar)} matches anything, and binds an one-argument
procedure to a pattern variable @var{patvar}.  If the procedure is
called, it replaces the value of matched pattern for the given argument.

@item
@code{(get! patvar)} matches anything, and binds a zero-argument
procedure to a pattern variable @var{patvar}.  If the procedure is
called, it returns the matched value.

@item
@code{`qp} is a quasipattern.  @var{qp} is quoted, in the sense
that it matches itself, @emph{except} the pattern that is unquoted.
(Don't confuse quasipatern to quasiquote, though the functions are
similar.  Quasiquote turns off evaluation except unquoted subtree.
Quasiquote turns off the special pattern syntax except unquoted subtree.
See the examples below).
@end itemize

@subheading Pattern examples

A simple structure decomposition:
@example
(match '(0 (1 2) (3 4 5))
  ((a (b c) (d e f))
   (list a b c d e f)))
 @result{} (0 1 2 3 4 5)
@end example

Using predicate patterns:
@example
(match 123
  ((? string? x) (list 'string x))
  ((? number? x) (list 'number x)))
 @result{} (number 123)
@end example

Extracting variables and expressions from @code{let}.
Uses repetition and predicate patterns:
@example
(define let-analyzer
  (match-lambda
    (('let (? symbol?)
           ((var expr) ...)
       body ...)
     (format "named let, vars=~s exprs=~s" var expr))
    (('let ((var expr) ...)
       body ...)
     (format "normal let, vars=~s exprs=~s" var expr))
    (_
     (format "malformed let"))))

(let-analyzer '(let ((a b) (c d)) e f g))
 @result{} "normal let, vars=(a c) exprs=(b d)"

(let-analyzer '(let foo ((x (f a b)) (y (f c d))) e f g))
 @result{} "named let, vars=(x y) exprs=((f a b) (f c d))"

(let-analyzer '(let (a) b c d))
 @result{} "malformed let"
@end example

Using @code{=} function application.  The pattern variable @var{m}
is matched to the result of application of the regular expression.
@example
(match "gauche-ref.texi"
  ((? string? (= #/(.*)\.([^.]+)$/ m))
   (format "base=~a suffix=~a" (m 1) (m 2))))
 @result{} "base=gauche-ref suffix=texi"
@end example

An example of quasipattern.   In the first expression, the
pattern except @code{value} is quoted, so the symbols @code{the},
@code{answer}, and @code{is} are not pattern variables but literal
symbols.   The second expression shows that; input symbol @code{was} 
does not match the literal symbol @code{is} in the pattern.
If we don't use quasiquote, all symbols in the pattern are pattern
variables, so any four-element list matches as the third expression shows.
@example
(match '(the answer is 42)
  (`(the answer is ,value) value)
  (else #f))
 @result{} 42

(match '(the answer was 42)
  (`(the answer is ,value) value)
  (else #f))
 @result{} #f

(match '(a b c d)
  ((the answer is value) value)
  (else #f))
 @result{} d
@end example


@c ----------------------------------------------------------------------
@node Queue, Red black tree, Pattern matching, Library modules - Utilities
@section @code{util.queue} - Queue
@c NODE キュー, @code{util.queue} - キュー

@deftp {Module} util.queue
@mdindex util.queue
Provides a queue (FIFO).   This implementation is tuned for speed
than safety; a queue is simply a pair that keeps head and tail of
the queue, and minimal check is done in most of the operations.

SLIB (@xref{SLIB}) provides the queue library that is safer.
This API is upper compatible to the SLIB's.
The idea is that this queue is used inside other procedure or
structure that you know you don't need the strict checks.
Use either one depending on your requirement.
@end deftp

@defun make-queue
Creates and returns an empty queue.
@end defun

@defun queue? obj
Returns @code{#t} if @var{obj} is a queue.  This operation checks
@var{obj} is really in a shape of the queue.
@end defun

@defun queue-empty? queue
Returns @code{#t} if @var{obj} is an empty queue.
@end defun

@defun queue-length queue
Returns the number of the items in the queue.
@end defun

@defun copy-queue queue
Returns a copy of the queue.
@end defun

@defun enqueue! queue obj &optional more-objs @dots{}
Add @var{obj} to the end of @var{queue}.  You may give more than
one object, and each of them are enqueued in order.
(Note: SLIB version doesn't take the optional arguments).
@end defun

@defun queue-push! queue obj &optional more-objs @dots{}
Add @var{obj} in front of @var{queue}.  You may give more than
one object, and each of them are pushed in order.
(Note: SLIB version doesn't take the optional arguments).
@end defun

@defun enqueue-unique! queue eq-proc obj &optional more-objs @dots{}
@defunx queue-push-unique! queue eq-proc obj &optional more-objs @dots{}
Like @code{enqueue!} and @code{queue-push!}, respectively, except that these
don't modify @var{queue} if it already contains @var{obj}
(elements are compared by two-argument procedure @var{eq-proc}).
@end defun

@defun dequeue! queue
@defunx queue-pop! queue
Take one object from the front of the queue @var{queue} and returns it.
Both function works the same, but @code{queue-pop!} may be used to
emphasize it works with @code{queue-push!}.  An error is signalled
if @var{queue} is empty.
@end defun

@defun dequeue-all! queue
Returns the whole content of the queue by a list, with emptying
@var{queue}.   If @var{queue} is already empty, returns an empty list.
See also @code{queue->list} below.
@end defun

@defun queue-front queue
@defunx queue-rear queue
Peek the head or the tail of the queue and returns the object, respectively.
@var{util.queue - Queue} is not modified.  An error is signalled
if @var{queue} is empty.
@end defun

@defun list->queue list
Returns a new queue whose content is the elements in @var{list},
in the given order.
@end defun

@defun queue->list queue
Returns a list whose content is the items in the queue in order.
Unlike @code{dequeue-all!}, the content of @var{queue} remains intact.

In Gauche, @code{queue->list} copies the content of the queue to a
freshly allocated list, while @code{dequeue-all!} doesn't copy but
directly returns the queue's internal list.   There are some Scheme
systems that has @code{queue->list} but doesn't guarantee the content
is copied, so if you're planning to share the code among these
implementations, it's better not to rely on the fact that
@code{queue->list} copies the content.
@end defun

@defun find-in-queue pred queue
Returns the first item in @var{queue} that satisfies a
predicate @var{pred}.  The order of arguments follows
@code{find} in SRFI-1 (@xref{SRFI-1 Searching}).
@end defun

@defun remove-from-queue! pred queue
Removes all items in the queue that satisfies @var{pred}.
Returns @code{#t} if any item is removed.  Otherwise returns @code{#f}.
The order of arguments follows
@code{remove} in SRFI-1 (@xref{SRFI-1 Filtering & Partitioning}).
@end defun

Note on portability:
Scheme48 has @code{delete-from-queue!}, which takes object to remove
rather than predicate, and also takes arguments in reversed order
(i.e. queue comes first).   Avoid conflicting with that I intentionally
left out @code{delete-from-queue!}; it's easy to write one in either
Scheme48 compatible way or consistent to SRFI-1 argument order.

@c ----------------------------------------------------------------------
@node Red black tree, SLIB-compatible record type, Queue, Library modules - Utilities
@section @code{util.rbtree} - Red black tree
@c NODE 赤黒木, @code{util.rbtree} - 赤黒木

As of version 0.8.10, a balanced-tree object is built-in as @code{<tree-map>}
(@xref{Treemaps}), which uses red-black tree internally.  It is recommended
for applications to use @code{<tree-map>} instead of @code{<rbtree>}.
This module is only kept for backward compatibility.

@deftp {Module} util.rbtree
@mdindex util.rbtree
This module provides procedures to handle red black trees.

Red black tree is a kind of balanced binary tree.
For a tree with @var{n} nodes, the basic operations
such as searching, inserting, deleting, obtaining minimum
and maximum element, and sequential access, can be done in
O(log @var{n}).  The keys used for red black trees
must have total order.

API of @code{util.rbtree} is similar to the hash table API
(@xref{Hashtables}), so the user can use a red black tree
as if it is a hashtable, with its entries are ordered 
by the keys.
@end deftp

@deftp {Class} <rbtree>
A class for red black trees.  Inherits @code{<sequence>},
so that you can apply sequence APIs on a red black tree.
When treated as a sequence, each element is a pair of
a key and a value.
@end deftp

@defun make-rbtree key=? key<?
Creates and returns an instance of @code{<rbtree>}.
The arguments @var{key=?} and @var{key<?} are both
procedures that take two arguments, which are the keys.
The @code{key=?} procedure should return @code{#t} if
two arguments are equivalent, or @code{#f} otherwise.
The @code{key<?} procedure should return @code{#t} if
the first argument is strictly less than the second argument,
or @code{#f} otherwise.
@end defun

@defun rbtree-copy rbtree
Copies and returns a red black tree @var{rbtree}.  Modification
on the returned tree doesn't affect the original tree.
@end defun

@defun rbtree-empty? rbtree
Returns @code{#t} if @var{rbtree} doesn't have any elements,
or @code{#f} otherwise.
@end defun

@defun rbtree-num-entries rbtree
Returns the number of elements in @var{rbtree}.
@end defun

@defun rbtree-exists? rbtree key
Returns @code{#t} if @var{rbtree} has an entry with @var{key},
or @code{#f} otherwise.
@end defun

@defun rbtree-get rbtree key &optional fallback
Looks for @var{key} in @var{rbtree}.  If the entry is found,
returns a value corresponding to the key.  Otherwise, returns
@var{fallback} if it is provided, or signals an error.
@end defun

@defun rbtree-put! rbtree key value
Inserts an entry with a @var{key} and corresponding @var{value}
into @var{rbtree}.  If there already exists an entry with a
key which is equivalent (under @var{key=?}), the entry is modified
to have @var{value}.
@end defun

@defun rbtree-delete! rbtree key
Delets an entry with @var{key} from @var{rbtree} if such an entry
exists, and returns @code{#t}.
If @var{rbtree} doesn't have such an entry, @code{#f} is returned.
@end defun

@defun rbtree-update! rbtree key proc &optional fallback
A generalized version of @code{rbtree-push!} etc.
It works like the following code, except that searching
for the key is done only once.
@example
(let ((tmp (proc (rbtree-get @var{rbtree} @var{key} @var{fallback}))))
  (rbtree-put! @var{rbtree} @var{key} tmp)
  tmp)
@end example
@end defun

@defun rbtree-push! rbtree key value
Looks for an entry with @var{key} in @var{rbtree}.  If it exists,
the procedure conses @var{value} to the original value and makes
it as a new value.
Otherwise, the procedure creates a new entry for the @var{key}
and makes @code{(list @var{value})} its value.
@end defun

@defun rbtree-pop! rbtree key &optional fallback
Looks for an entry with @var{key} in @var{rbtree}.  If it exists
and its value is a pair, then the procedure updates
its value with @code{cdr} of the original value, and returns
@code{car} of the original entry.   If such an entry does not
exist, or has a non-pair value, the procedure doesn't
modify @var{rbtree} and returns @var{fallback} if it is given,
otherwise reports an error.
@end defun

@defun rbtree-min rbtree &optional fallback
@defunx rbtree-max rbtree &optional fallback
Returns a pair of a key and its value with the minimum
or maximum key, respectively.   If @var{rbtree} is empty,
returns @var{fallback} if it is given, otherwise reports
an error.
@end defun

@defun rbtree-extract-min! rbtree &optional fallback
@defunx rbtree-extract-max! rbtree &optional fallback
Looks for an entry with minimum or maximum key, respectively,
then deletes the entry from @var{rbtree} and returns 
a pair of the key and its value of the original entry.
If @var{rbtree} is empty,
returns @var{fallback} if it is given, otherwise reports
an error.
@end defun

@defun rbtree-fold rbtree proc seed
@defunx rbtree-fold-right rbtree proc seed
Iterate over elements in @var{rbtree}, applying 
@var{proc} which has a type @code{(key, value, seed) -> seed}.
The difference of @code{rbtree-fold} and @code{rbtree-fold-right}
is the same as @code{fold} and @code{fold-right}---that is,
the associative order of applying @code{proc}.
@example
rbtree-fold:
  (proc Kn Vn (proc Kn-1 Vn-1 ... (proc K0 V0 seed)))

rbtree-fold-right
  (proc K0 V0 (proc K1 V1 ... (proc Kn Vn seed)))
@end example

Some examples:
@example
(define tree (alist->rbtree '((3 . a) (7 . b) (5 . c)) = <))

(rbtree-fold tree list* '()) 
   @result{} (7 b 5 c 3 a)
(rbtree-fold-right tree list* '()) 
   @result{} (3 a 5 c 7 b)
@end example
@end defun

@defun rbtree-keys rbtree
@defunx rbtree-values rbtree
Returns a list of all keys and all values, respectively.
The keys and values are in ascending order of the keys.
@end defun

@defun rbtree->alist rbtree
Returns a list of pairs of keys and values for all entries.
The pairs are in ascending order of the keys.
@end defun

@defun alist->rbtree alist key=? key<?
Creates a new red black tree with @var{key=?} and @var{key<?},
then populates it with @var{alist}, each pair in which are
interpreted as a cons of a key and its value.  Returns the
created red black tree.
@end defun


@c ----------------------------------------------------------------------
@node SLIB-compatible record type, Relation framework, Red black tree, Library modules - Utilities
@section @code{util.record} - SLIB-compatible record type
@c NODE SLIB-互換のレコード型, @code{util.record} - SLIB-互換のレコード型

@deftp {Module} util.record
@mdindex util.record
This module provides a Guile and SLIB compatible record type API.
It is built on top of Gauche's object system.

See also @ref{Record types}, which provides a convenience macro
@code{define-record-type}.
@end deftp

@defun make-record-type type-name field-names
Returns a new class which represents a new record type.
(It is what is called @emph{record-type descriptor} in SLIB).
In Gauche, the new class is a subclass of @code{<record>}
(see @ref{Record types}).

@var{type-name} is a string that is used for debugging purposes.
It is converted to a symbol and set as the name of the new class.
@var{field-names} is a list of symbols of the names of fields.
Each field is implemented as a slot of the new class.
@end defun

In the following procedures, @var{rtd} is the record class
created by @code{make-record-type}.

@defun record-constructor rtd &optional field-names
Returns a procedure that constructs an instance
of the record type of given @var{rtd}.  The returned
procedure takes exactly as many arguments as @var{field-names},
which defaults to @code{'()}.  Each argument sets the initial
value of the corresponding field in @var{field-names}.
@end defun

@defun record-predicate rtd
Returns a procedure that takes one argument, which returns @code{#t}
iff the given argument is of type of @var{rtd}.
@end defun

@defun record-accessor rtd field-name
Returns an accessor procedure for the field named by @var{field-name}
of type @var{rtd}.  The accessor procedure takes an instance of
@var{rtd}, and returns the value of the field.
@end defun

@defun record-modifier rtd field-name
Returns a modifier procedure for the field named by @var{field-name}
of type @var{rtd}.  The modifier procedure takes two arguments,
an instance of @var{rtd} and a value, and sets the value to
the specified field.
@end defun

@example
(define rtd (make-record-type "my-record" '(a b c)))

rtd @result{} #<class my-record>

(define make-my-record (record-constructor rtd '(a b c)))

(define obj (make-my-record 1 2 3))

obj @result{} #<my-record 0x819d9b0>

((record-predicate? rtd) obj)  @result{} #t

((record-accessor rtd 'a) obj) @result{} 1
((record-accessor rtd 'b) obj) @result{} 2
((record-accessor rtd 'c) obj) @result{} 3

((record-modifier rtd 'a) obj -1)

((record-accessor rtd 'a) obj) @result{} -1
@end example

@c ----------------------------------------------------------------------
@node Relation framework, Stream library, SLIB-compatible record type, Library modules - Utilities
@section @code{util.relation} - Relation framework
@c NODE @code{util.relation} - リレーションフレームワーク

@deftp {Module} util.relation
@mdindex util.relation
Provides a set of common operations for relations.

Given set of values S1, S2, ..., Sn, a relation R is a set of tuples
such that the first element of a tuple is from S1, the second from
S2, ..., and the n-th from Sn.  In another word, R is a subset of
Cartesian product of S1, ..., Sn.
(The definition, as well as the term @emph{relation}, is taken 
from the Codd's 1970 paper, 
"A Relational Model of Data for Large Shared Data Banks", in
CACM 13(6) pp.377--387.)

This definition can be applied to various datasets: A set of Gauche
object system instances is a relation, if you view each instance as
a tuple and each slot value as the actual values.  A list of lists can be a
relation.  A stream that reads from CSV table produces a relation.
Thus it would be useful to provide a module that implements generic
operations on relations, no matter how the actual representation is.

From the operational point of view, we can treat any datastructure
that provides the following four methods; @code{relation-rows},
which retrieves a collection of tuples (rows);
@code{relation-column-names}, @code{relation-accessor}, and
@code{relation-modifier}, which provide the means to access
meta-information.
All the rest of relational operations are built on top of
those primitive methods.

A concrete implementation of relation can use duck typing,
i.e. it doesn't need to inherit a particular base class to
use the relation methods.  However, for the convenience,
a base class @code{<relation>} is provided in this module.
It works as a mixin class---a concrete class typically wants
to inherit @code{<relation>} and @code{<collection>} or
@code{<sequence>}.  Check out the sample implementations
in the @file{lib/util/relation.scm} in the source tree, if
you're curious.

This module is still under development.
The plan is to build useful relational operations on top of the
common methods.
@end deftp

@subheading Basic class and methods

@deftp {Class} <relation>
An abstract base class of relations.
@end deftp

@deffn {Method} relation-column-names (r <relation>)
A subclass must implement this method.
It should return a sequence of names of the columns.
The type of column names is up to the relation; we don't
place any restriction on it, as far as they are different
each other in terms of @code{equal?}.
@end deffn

@deffn {Method} relation-accessor (r <relation>)
A subclass must implement this method.
It should return a procedure that takes two arguments, a row from
the relation @var{r} and a column name, and returns the value
of the specified column.
@end deffn

@deffn {Method} relation-modifier (r <relation>)
A subclass must implement this method. It should returns a procedure
that takes three arguments, a row from the relation @var{r}, a column
name, and a value to set. 

If the relation is read-only, this method returns @code{#f}.
@end deffn

@deffn {Method} relation-rows (r <relation>)
A subclass must implement this method.
It should return the underlying instance of @code{<collection>} or
its subclass (e.g.  @code{<sequence>}) 
@end deffn

The rest of method are built on top of the above four methods.
A subclass of @code{<relation>} may overload some of the
methods below for better performance, though.

@deffn {Method} relation-column-name? (r <relation>) column
Returns true iff @var{column} is a valid column name for the relation
@var{r}.
@end deffn

@deffn {Method} relation-column-getter (r <relation>) column
@deffnx {Method} relation-column-setter (r <relation>) column
Returns a procedure to access the specified column of a row
from the relation @var{r}.  @code{Relation-column-getter}
should return a procedure that takes one argument, a row.
@code{Relation-column-setter} should return a procedure that
takes two arguments, a row and a new value to set.

If the relation is read-only, @code{relation-column-setter}
returns @code{#f}.
@end deffn

@deffn {Method} relation-ref (r <relation>) row column &optional default
@var{Row} is a row from the relation @var{r}.  Returns value of
the @var{column} in @var{row}.  If @var{column} is not a valid
column name, @var{default} is returned if it is given, otherwise
an error is signalled.
@end deffn

@deffn {Method} relation-set! (r <relation>) row column value
@var{Row} is a row from the relation @var{r}.  Sets @var{value}
as the value of @var{column} in @var{row}.  This may signal
an error if the relation is read-only.
@end deffn

@deffn {Method} relation-column-getters (r <relation>)
@deffnx {Method} relation-column-setters (r <relation>)
Returns full list of getters and setters.  Usually the default
method is sufficient, but the implementation may want to cache
the list of getters, for example.
@end deffn

@deffn {Method} relation-coercer (r <relation>)
Returns a procedure that coerces a row into a sequence.
If the relation already uses a sequence to represent a row,
it can return row as is.
@end deffn

@deffn {Method} relation-insertable? (r <relation>)
Returns true iff new rows can be inserted to the relation @var{r}.
@end deffn

@deffn {Method} relation-insert! (r <relation>) row
Insert a row @var{row} to the relation @var{r}.
@end deffn

@deffn {Method} relation-deletable? (r <relation>)
Returns true iff rows can be deleted from the relation @var{r}.
@end deffn

@deffn {Method} relation-delete! (r <relation>) row
Deletes a row @var{row} from the relation @var{r}.
@end deffn

@deffn {Method} relation-fold (r <relation>) proc seed column @dots{}
Applies @var{proc} to the values of @var{column} @dots{} of each row,
passing @var{seed} as the state value.  That is, for each row in 
@var{r}, @var{proc} is called as follows:
@example

(@var{proc} @var{v_0} @var{v_1} @dots{} @var{v_i} @var{seed})

 where @var{v_k} = (relation-ref @var{r} @var{row} @var{column_k})

@end example

The result of the call becomes a new seed value, and the final result
is returned from @var{relation-fold}.

For example, if a relation has a column named @code{amount},
and you want to sum up all of them in a relation @var{r},
you can write like this:
@example
(relation-fold r + 0 'amount)
@end example
@end deffn

@subheading Concrete classes

@deftp {Class} <simple-relation>
@end deftp

@deftp {Class} <object-set-relation>
@end deftp


@c ----------------------------------------------------------------------
@node Stream library, Trie, Relation framework, Library modules - Utilities
@section @code{util.stream} - Stream library
@c NODE ストリームライブラリ, @code{util.stream} - ストリームライブラリ

@deftp {Module} util.stream
@mdindex util.stream
This module provides a library of lazy streams, including the
functions and syntaxes defined in srfi-40.
@end deftp

@defun stream? obj
[SRFI-40]
Returns @code{#t} iff @var{obj} is a stream created by a procedure
of @code{util.stream}.
@end defun

@defvar stream-null
[SRFI-40]
The singleton instance of NULL stream.
@end defvar

@defmac stream-cons object stream
[SRFI-40]
A fundamental constructor of a stream.  Adds @var{object} to the
head of a @var{stream}, and returns a new stream.
@end defmac

@defun stream-null? obj
[SRFI-40]
Returns @code{#t} iff @var{obj} is the null stream.
@end defun

@defun stream-pair? obj
[SRFI-40]
Returns @code{#t} iff @var{obj} is a non-null stream.
@end defun

@defun stream-car s
[SRFI-40]
Returns the first element of the stream @var{s}.
@end defun

@defun stream-cdr s
[SRFI-40]
Returns the remaining elements of the stream @var{s}, as a stream.
@end defun

@defmac stream-delay expr
[SRFI-40]
Returns a stream which is a delayed form of @var{expr}.

As a rule of thumb, any stream-producing functions should
wrap the resulting expression by @code{stream-delay}.
@end defmac

@defun stream obj @dots{}
[SRFI-40]
Returns a new stream whose elements are @var{obj} @dots{}.
@end defun

@defun stream-unfoldn generator seed n
[SRFI-40]
Creates @var{n} streams related each other, whose contents are
generated by @var{generator} and @var{seed}.

The @var{generator} is called with the current seed value,
and returns @code{@var{n}+1} values:
@example
(@var{generator} @var{seed})
  => seed result_0 result_1 @dots{} result_n-1
@end example

The first value is to be the next seed value.
@var{Result_k} must be one of the following forms:
@table @code
@item (val)
@var{val} will be the next car of @var{k}-th stream.
@item #f
No new information for @var{k}-th stream.
@item ()
The end of @var{k}-th stream has been reached.
@end table

The following example creates two streams, the first one produces
an infinite series of odd numbers and the second produces evens.

@example
gosh> (define-values (s0 s1)
        (stream-unfoldn (lambda (i)
                          (values (+ i 2)          ;; next seed
                                  (list i)         ;; for the first stream
                                  (list (+ i 1)))) ;; for the second stream
                        0 2))
#<undef>
gosh> (stream->list (stream-take s0 10))
(0 2 4 6 8 10 12 14 16 18)
gosh> (stream->list (stream-take s1 10))
(1 3 5 7 9 11 13 15 17 19)
@end example

@end defun

@defun stream-map func . streams
[SRFI-40]
Returns a new stream, whose elements are calculated by
applying @var{func} to each element of @var{streams}.
@end defun

@defun stream-for-each func . streams
[SRFI-40]
Applies @var{func} for each element of @var{streams}.
Terminates if one of @var{streams} reaches the end.
@end defun

@defun stream-filter pred? stream
[SRFI-40]
Returns a new stream including only elements passing @var{pred?}.
@end defun

The following procedures are taken from the library written by
Alejandro Forero Cuervo for Chicken Scheme.  They follow
the naming conventions of srfi-1 (@ref{List library}).

@defun stream-xcons a b
@code{(stream-cons b a)}.  Just for convenience.
@end defun

@defun stream-cons* elt @dots{} stream
Creates a new stream which appends @var{elt} @dots{} before @var{stream}.
@end defun

@defun make-stream n &optional init
Creates a new stream of @var{n} elements of @var{init}.
If @var{init} is omitted, @code{#f} is used.
Specifying a negative number to @var{n} creates an infinite stream.
@end defun

@defun stream-tabulate n init-proc
Creates a new stream of @var{n} elements.
The @var{k}-th element is obtained by applying @var{init-proc}
to @var{k}.  Specifying a negative number to @var{n} creates
an infinite stream.
Creates a new stream of integers, starting from @var{start}
and incrementing @var{step}.  The length of stream is @var{count}
if it is positive, or infinite if @var{count} is negative.
The default values of @var{start} and @var{step} are 0 an 1,
respectively.
@end defun

@defun stream-format fmt arg @dots{}
Returns a stream which is a result of applying @code{string->stream}
to @code{(format fmt arg @dots{})}.
@end defun

@defun stream->list stream
@defunx stream->string stream
Converts a stream to a list or a string.  All of @var{stream}'s
elements are @code{force}d; if @var{stream} is infinite, these
procedures won't terminate.  For @code{stream->string},
all @var{stream} must be characters, or an error is signalled.
@end defun

@defun list->stream list
Converts a list to a stream of its elements.
@end defun

@defun string->stream string &optional stream
Convers a string to a stream of characters.  If an optional
@var{stream} is given, it becomes the tail of the resulting
stream.

@example
@end example
(stream->list (string->stream "abc" (list->stream '(1 2 3))))
 @result{} (#\a #\b #\c 1 2 3)
@end defun

@defun port->stream &optional iport reader closer
Creates a stream, whose elements consist of the items
read from the input port @var{iport}.
The default @var{iport} is the current input port.
The default @var{reader} is @code{read-char}.

The result stream terminates at the point where @var{reader}
returns EOF (EOF itself is not included in the stream).
If @var{closer} is given, it is called with @var{iport} as
an argument just after @var{reader} reads EOF.
@end defun

@defun iterator->stream iter
A generic procedure to turn an internal iterator @var{iter}
into a stream of iterated results.

The @var{iter} argument is a procedure that takes two arguments,
@var{next} and @var{end}, where @var{next} is a procedure that takes
one argument and @var{end} is a thunk.
@var{Iter} is supposed to iterate over some set and call @var{next}
for each argument, then call @var{end} to indicate the end of
the iteration.  Here's a contrived example:

@example
(stream->list
 (iterator->stream 
  (lambda (next end) (for-each next '(1 2 3 4 5)) (end))))
 @result{} (1 2 3 4 5)
@end example

Internally @code{iterator->stream} uses the ``inversion of iterator''
technique, so that @var{iter} only iterates to the element that
are needed by the stream.  Thus @var{iter} can iterate over 
an infinite set.  In the following example, @var{iter} is
an infinite loop calling @var{next} with increasing integers,
but only the first 10 elements are calculated because of
@code{stream-take}:

@example
(stream->list 
 (stream-take
  (iterator->stream
   (lambda (next end)
     (let loop ((n 0)) (next n) (loop (+ n 1))))) 
  10))
 @result{} (0 1 2 3 4 5 6 7 8 9)
@end example
@end defun

@defun stream-lines stream
Splits @var{stream} where its element equals to @code{#\n}, and 
returns a stream of splitted streams.

@example
(stream->list 
 (stream-map stream->string 
             (stream-lines (string->stream "abc\ndef\nghi"))))
 @result{} ("abc" "def" "ghi")
@end example
@end defun

@defun stream= elt= stream @dots{}
Returns true iff each corresponding element of @var{stream} @dots{}
are the same in terms of @var{elt=}.  This procedure won't terminate
if any of @var{stream}s is infinite.
@end defun

@defun stream-prefix= stream prefix &optional elt=
Compares initial elements of @var{stream} against
a list @var{prefix} by @var{elt=}.  Only as many elements of @var{stream}
as @var{prefix} has are checked.
@end defun

@defun stream-caar s
@defunx stream-cadr s
@findex stream-cdar
@findex stream-cddr
@findex stream-caaar
@findex stream-caadr
@findex stream-cadar
@findex stream-caddr
@findex stream-cdaar
@findex stream-cdadr
@findex stream-cddar
@findex stream-cdddr
@findex stream-caaaar
@findex stream-caaadr
@findex stream-caadar
@findex stream-caaddr
@findex stream-cadaar
@findex stream-cadadr
@findex stream-caddar
@findex stream-cadddr
@findex stream-cdaaar
@findex stream-cdaadr
@findex stream-cdadar
@findex stream-cdaddr
@findex stream-cddaar
@findex stream-cddadr
@dots{}
@end defun
@defun stream-cdddar s
@defunx stream-cddddr s
@code{(stream-caar s)} = @code{(stream-car (stream-car s))} etc.
@end defun

@defun stream-ref stream pos
Returns the @var{pos}-th element in the stream.  @var{Pos}
must be a nonnegative exact integer.
@end defun

@defun stream-first s
@defunx stream-second s
@defunx stream-third s
@defunx stream-fourth s
@defunx stream-fifth s
@defunx stream-sixth s
@defunx stream-seventh s
@defunx stream-eighth s
@defunx stream-ninth s
@defunx stream-tenth s
@code{(stream-first s)} = @code{(stream-ref s 0)} etc.
@end defun

@defun stream-take stream count
@defunx stream-take-safe stream count
Returns a new stream that consists of the first @var{count} elements 
of the given stream.   If the given stream has less than
@var{count} elements, the stream returned by @code{stream-take} 
would raise an error when the elements beyond the original stream
is accessed.  On the other hand, the stream returned by 
@code{stream-take-safe} will return a shortened stream when
the given steram has less than @var{count} elements.

@example
(stream->list (stream-take (stream-iota -1) 10))
 @result{} (0 1 2 3 4 5 6 7 8 9)

(stream-take (stream 1 2) 5)
 @result{} @r{stream}

(stream->list (stream-take (stream 1 2) 5))
 @result{} @r{error}

(stream->list (stream-take-safe (stream 1 2) 5))
 @result{} (1 2)
@end example

@end defun

@defun stream-drop stream count
@defunx stream-drop-safe stream count
Returns a new stream that consists of the elements in the given 
stream except the first @var{count} elements.
If the given stream has less than @var{count} elements,
@code{stream-drop} returns a stream that raises an error
if its element is accessed, and @code{stream-drop-safe}
returns an empty stream.
@end defun

@defun stream-intersperse stream element
Returns a new stream in which @var{element} is
inserted between elements of @var{stream}.
@end defun

@defun stream-split stream pred
@end defun

@defun stream-last stream
@end defun

@defun stream-last-n stream count
@end defun

@defun stream-butlast stream
@end defun

@defun stream-butlast-n stream count
@end defun

@defun stream-length stream
@end defun

@defun stream-length>= stream n
@end defun

@defun stream-append stream @dots{}
@end defun

@defun steram-concatenate streams
@end defun

@defun stream-reverse stream &optional tail-stream
@end defun

@defun stream-count pred stream @dots{}
@end defun

@defun stream-remove pred stream
@end defun

@defun stream-partition pred stream
@end defun

@defun stream-find pred stream
@end defun

@defun stream-find-tail pred stream
@end defun

@defun stream-take-while pred stream
@end defun

@defun stream-drop-while pred stream
@end defun

@defun stream-span pred stream
@end defun

@defun stream-break pred stream
@end defun

@defun stream-any pred stream @dots{}
@end defun

@defun stream-every pred stream @dots{}
@end defun

@defun stream-index pred stream @dots{}
@end defun

@defun stream-member obj stream &optional elt=
@defunx stream-memq obj stream
@defunx stream-memv obj stream
@end defun

@defun stream-delete obj stream &optional elt=
@end defun

@defun stream-delete-duplicates stream &optional elt=
@end defun

@defun stream-grep re stream
@end defun

@defun write-stream stream &optional oport writer
@end defun

@c ----------------------------------------------------------------------
@node Trie, Topological sort, Stream library, Library modules - Utilities
@section @code{util.trie} - Trie
@c NODE @code{util.trie} - Trie

@deftp {Module} util.trie
@mdindex util.trie
This module provides @emph{Trie}, a dictionary-like data
structure that maps keys to values, where a key is an arbitrary sequence.
Internally it stores the data as a tree where each node corresponds 
to each element in the key sequence.
Key lookup is O(n) where n is the length of the key, and not affected
much by the number of total entries.
Also it is easy to find a set of values whose keys have a common prefix.

The following example may give you the idea.

@example
(define t (make-trie))   ;; create a trie

(trie-put! t "pho" 3)    ;; populate the trie
(trie-put! t "phone" 5)
(trie-put! t "phrase" 6)

(trie-get t "phone")  @result{} 5  ;; lookup

(trie-common-prefix t "pho")       ;; common prefix search
  @result{} (("phone" . 5) ("pho" . 3))
(trie-common-prefix-keys t "ph")
  @result{} ("phone" "pho" "phrase")
@end example

Tries are frequently used with string keys, but you are not
limited to do so; any sequence (@xref{Sequence framework}) can be
a key.  If the types of keys differ, they are treated as different
keys:

@example
(trie-put! t '(#\p #\h #\o) 8)  ;; different key from "pho"
@end example

Trie inheris @code{<collection>} and implements collection framework
including the builder. So you can apply generic collection 
operations on a trie (@xref{Collection framework}).
When iterated, each element of a trie appears as a pair of a key
and a value.
@end deftp

@deftp {Class} <trie>
A class for Trie.  No slots are intended for public.  
Use the following procedures to operate on tries.
@end deftp

@defun make-trie &optional tab-make tab-get tab-put! tab-fold
Creates and returns an empty trie.  The optional four arguments
are procedures to customize how the nodes of the internal
tree are managed.

Each node can have a table to store its child nodes, indexed
by an element of the key sequence (e.g. if the trie uses strings
as keys, a node's table is indexed by characters).

@table @code
@item tab-make
A procedure with no arguments.  When called, creates and
returns an empty table for a node.
@item tab-get @var{tab} @var{elt}
Returns a child node indexed by @var{elt}, or returns @code{#f}
if the table doesn't have a child for @var{elt}.
@item tab-put! @var{tab} @var{elt} @var{child-node}
If @var{child-node} isn't @code{#f}, 
stores a @var{child-node} with index @var{elt}.  
If @var{child-node} is @code{#f}, 
removes the entry with index @var{elt}. 
In both cases, this procedure should return the updated table.
@item tab-fold @var{tab} @var{proc} @var{seed}
Calls @var{proc} for every index and node in @var{tab}, while
passing a seed value, whose initial value is @var{seed}.
That is, @var{proc} has a type of @code{(index, node, seed) -> seed}.
Should return the last result of @var{proc}.
@end table

The default assumes @code{eqv?}-hashtables, i.e. the
following procedures are used.

@example
tab-make: (lambda () (make-hash-table 'eqv?))

tab-get:  (lambda (tab k) (hash-table-get tab k #f))

tab-put!: (lambda (tab k v)
            (if v
              (hash-table-put! tab k v)
              (hash-table-delete! tab k))
            tab)

tab-fold: hash-table-fold
@end example

The following example creates a trie using
assoc list to manage children, while comparing
string keys with case-insensitive way:

@example
(make-trie list
           (cut assoc-ref <> <> #f char-ci=?)
           (lambda (t k v)
             (if v
               (assoc-set! t k v char-ci=?)
               (alist-delete! k t char-ci=?)))
           (lambda (t f s) (fold f s t)))
@end example

It is important that @code{tab-put!} must return an updated
table---by that, you can replace the table structure on the fly.
For example, you may design a table which uses assoc list when
the number of children are small, and then switches to a vector
(indexed by character code) once the number of children grows over
a certain threshold.
@end defun

@defun trie params kv @dots{}
Construct a trie with the initial contents
@var{kv} @dots{}, where each @var{kv} is a pair of a key and a value.
@var{Params} are a list of arguments
which will be given to @code{make-trie} to create the trie.
The following example creates a trie with two entries
and the default table procedures.

@example
(trie '() '("foo" . a) '("bar" . b))
@end example
@end defun

@defun trie-with-keys params key @dots{}
A convenient version of @code{trie} when you only concern
the keys.  Each value is the same as its key.
The following example creates a trie with two entries
and the default table procedures.

@example
(trie-with-keys '() "foo" "bar")
@end example
@end defun

@defun trie? obj
Returns @code{#t} if @var{obj} is a trie, or @code{#f} otherwise.
@end defun

@defun trie-num-entries trie
Returns the number of entries in @var{trie}.
@end defun

@defun trie-exists? trie key
Returns @code{#t} if @var{trie} contains an entry with @var{key},
or returns @code{#f} otherwise.
@end defun

@defun trie-get trie key &optional fallback
Returns the value associated with @var{key} in @var{trie}, if 
such an entry exists.  When there's no entry for @var{key},
if @var{fallback} is given, it is returned; otherwise,
an error is signalled.
@end defun

@defun trie-put! trie key value
Puts @var{value} associated to @var{key} into @var{trie}.
@end defun

@defun trie-update! trie key proc &optional fallback
Works like the following code, except that the
lookup of entry in @var{trie} is done only once.

@example
(let ((val (trie-get trie key fallback)))
  (trie-put! trie key (proc val)))
@end example
@end defun

@defun trie-delete! trie key
Removes an entry associated with @var{key} from @var{trie}.
If there's no such entry, this procedure does nothing.
@end defun

@defun trie->list trie
Makes each entry in @var{trie} to a pair @code{(@var{key} . @var{value})}
and returns a list of pairs of all entries.  The order of entries
are undefined.
@end defun

@defun trie-keys trie
@defunx trie-values trie
Returns a list of all keys and values in @var{trie}, respectively.
The order of keys/values are undefined.
@end defun

@defun trie->hash-table trie ht-type
Creates a hash table with type @var{ht-type} (see @ref{Hashtables}, 
about hash table types), and populates it with every key and value
pair in @var{trie}.
@end defun

@defun trie-common-prefix trie prefix
@defunx trie-common-prefix-keys trie prefix
@defunx trie-common-prefix-values trie prefix
Gathers all entries whose keys begin with @var{prefix};
@code{trie-common-prefix} returns those entries in a list of
pairs @code{(key . value)}; @code{trie-common-prefix-keys} returns
a list of keys; and @code{trie-common-prefix-values} returns a list
of values.   The order of entries in a returned list is undefined.
If @var{trie} contains no entry whose key has @var{prefix}, an
empty list is returned.

Note that prefix matching doesn't consider the type of sequence;
if @var{trie} has entries for @code{"foo"} and @code{(#\f #\o #\o)},
@code{(trie-common-prefix trie "foo")} will return both entries.
@end defun

@defun trie-common-prefix-fold trie prefix proc seed
For each entry whose key begins with @var{prefix},
calls @var{proc} with three argments, the entry's key,
its value, and the current seed value.  @var{Seed} is
used for the first seed value, and the value @var{proc}
returns is used for the seed value of the next call of @var{proc}.
The last returned value from @var{proc} is returned from 
@code{trie-common-prefix-fold}.
The order of entries on which @var{proc} is called is undefined.
If @var{trie} contains no entry whose key has @var{prefix}, 
@var{proc} is never called and @var{seed} is returned.
@end defun

@defun trie-common-prefix-map trie prefix proc
@defunx trie-common-prefix-for-each trie prefix proc
These are to @var{trie-common-prefix-fold} as @code{map} and @code{for-each}
are to @code{fold}; @code{trie-common-prefix-map} calls
@var{proc} with key and value for matching entries and
gathers its result to a list; @code{trie-common-prefix-for-each}
also applies @var{proc}, but discards its results.
@end defun

@defun trie-fold trie proc seed
@defunx trie-map trie proc
@defunx trie-for-each trie proc
These procedures are like their common-prefix versions, but
traverse entire @var{trie} instead.
@end defun


@c ----------------------------------------------------------------------
@node Topological sort, CGI Utility, Trie, Library modules - Utilities
@section @code{util.toposort} - Topological sort
@c NODE トポロジカルソート, @code{util.toposort} - トポロジカルソート

@deftp {Module} util.toposort
@mdindex util.toposort
Implements topological sort algorithm.
@end deftp

@defun topological-sort graph &optional eqproc
@var{Graph} represents a directed acyclic graph (DAG) by a list
of connections, where each connection is the form
@example
(<node> <downstream> <downstream2> ...)
@end example
that means a node @code{<node>} is connected to other nodes
@code{<downstream>} etc.   @code{<node>} can be arbitrary
object, as far as it can be compared by the procedure @var{eqproc},
which is @var{eqv?} by default (@xref{Equivalence}).
Returns a list of @code{<node>}s sorted topologically.

If the graph contains circular reference, an error is signalled.
@end defun

@c ----------------------------------------------------------------------
@node CGI Utility, CGI testing, Topological sort, Library modules - Utilities
@section @code{www.cgi} - CGI utility
@c NODE CGIユーティリティ, @code{www.cgi} - CGIユーティリティ

@deftp {Module} www.cgi
@mdindex www.cgi
Provides a few basic functions useful to write a CGI script.

In order to write CGI script easily, you may want to use
other modules, such as @code{rfc.uri} (@xref{URI parsing and construction}),
@code{text.html-lite} (@xref{Simple HTML document construction}) and
@code{text.tree} (@xref{Lazy text construction}).

Note: it seems that there is no active formal specification for CGI.
See @uref{http://w3c.org/CGI/} for more information.
@end deftp

@subheading Metavariables

@deffn {Parameter} cgi-metavariables &optional metavariables
Normally, httpd passes a cgi program various information
via environment variables.
Most procedures in @code{www.cgi} refer to them (meta-variables). 
However, it is sometimes inconvenient to require environment variable access
while you're developing cgi-related programs.
With this parameter, you can overrides the information of meta-variables.

@var{Metavariables} should be a list of two-element lists.
Car of each inner list names the variable, and its cadr gives the
value of the variable by string.

For example, the following code overrides @code{REQUEST_METHOD}
and @code{QUERY_STRING} meta-variables during execution of
@code{my-cgi-procedure}.  (@xref{Parameters},
for the details of @code{parameterize}).

@example
(parameterize ((cgi-metavariables '(("REQUEST_METHOD" "GET")
                                    ("QUERY_STRING" "x=foo"))))
  (my-cgi-procedure))
@end example
@end deffn

@defun cgi-get-metavariable name
Returns a value of cgi metavariable @var{name}.
This function first searches the parameter @code{cgi-metavariables},
and if the named variable is not found, calls @code{sys-getenv}.

CGI scripts may want to use @code{cgi-get-metavariable} instead
of directly calling @code{sys-getenv}; doing so makes reuse of
the script easier. 
@end defun

@subheading Parameter extraction

@defun cgi-parse-parameters &keyword :query-string :merge-cookies :part-handlers
Parses query string and returns associative list of parameters.
When a keyword argument @var{query-string} is given, it is used
as a source query string.  Otherwise, the function checks the 
metavariable @code{REQUEST_METHOD} and obtain the query string
depending on the value (either from stdin or from the
metavariable @code{QUERY_STRING}).
If such a metavariable is not defined and
the current input port is a terminal, the function prompts the user
to type parameters; it is useful for interactive debugging.

If @code{REQUEST_METHOD} is @code{POST}, this procedure can handle
both @code{application/x-www-from-urlencoded} and 
@code{multipart/form-data} as the enctype.  The latter is usually
used if the form has file-uploading capability.

When the post data is sent by @code{multipart/form-data}, 
each content of the part is treated as a value of the parameter.
That is, the content of uploaded file will be seen as one big 
chunk of a string.  The other information, such as the original file
name, is discarded.   If it is not desirable to read entire file
into a string, you can customize the behavior by the @var{part-handler}
argument.  The details are explained in the "Handling file uploads"
section below.

When a true value is given to @var{merge-cookies}, the cookie
values obtained from the metavariable @code{HTTP_COOKIE}
are appended to the result.

Note that the query parameter may have multiple values,
so @code{cdr} of each element in the result is a list, not an atom.
If no value is given to the parameter, @code{#t} is placed as its value.
See the following example:
@example
(cgi-parse-parameters
  :query-string "foo=123&bar=%22%3f%3f%22&bar=zz&buzz")
 @result{} (("foo" "123") ("bar "\"??\"" "zz") ("buzz" #t))
@end example
@end defun


@defun cgi-get-parameter name params &keyword :default :list :convert
A convenient function to obtain a value of the parameter @var{name} from
parsed query string @var{params}, which is the value
@code{cgi-parse-parameters} returns.  @var{Name} should be a string.

Unless true value is given to @var{list}, the returned value is
a scalar value.  If more than one value is associated to @var{name},
only the first value is returned.  If @var{list} is true, the
returned value is always a list, even @var{name} has only one value.

After the value is retrieved, you can apply a procedure to
convert the string value to the appropriate type by giving
a procedure to the @var{convert} argument.  The procedure must
take one string argument.  If @var{list} is true, the convert
procedure is applied to each values.

If the parameter @var{name} doesn't appear in the query,
a value given to the keyword argument @var{default} is returned;
the default value of @var{default}
is @code{#f} if @var{list} is false, or @code{()} otherwise.
@end defun

@subheading Output generation


@defun cgi-header &keyword status content-type location cookies
Creates a text tree (@xref{Lazy text construction}) for the
HTTP header of the reply message.  The most simple form is
like this:
@example
(tree->string (cgi-header))
  @result{} "Content-type: text/html\r\n\r\n"
@end example

You can specify alternative content-type by the keyword argument
@var{content-type}.   If you want to set cookies to the client,
specify a list of cookie strings to the keyword argument @var{cookies}.
You can use @code{construct-cookie-string} (@xref{HTTP cookie handling})
to build such a list of cookie strings.

The keyword argument @var{location} may be used to generate
a @code{Location:} header to redirect the client to the specified URI.
You can also specify the @code{Status:} header by the keyword argument
@var{status}.   A typical way to redirect the client is as follows:

@example
(cgi-header :status "302 Moved Temporarily"
            :location target-uri)
@end example

@end defun

@deffn {Parameter} cgi-output-character-encoding &optional encoding
The value of this parameter specifies the character encoding scheme (CES)
used for CGI output by @code{cgi-main} defined below.
The default value is Gauche's native encoding.
If the parameter is set other than the native encoding, @code{cgi-main}
converts the output
encoding by @code{gauche.charconv} module
(@xref{Character code conversion}).
@end deffn


@subheading Convenience procedures

@defun cgi-main proc &keyword on-error merge-cookies output-proc part-handlers
A convenient wrapper function for CGI script.
This function calls @code{cgi-parse-parameters}, then calls
@var{proc} with the result of @code{cgi-parse-parameters}.
The keyword argument @var{merge-cookies} is passed to
@code{cgi-parse-parameters}.

@var{proc} has to return a tree of strings
(@xref{Lazy text construction}), including the HTTP header.
@code{cgi-main} outputs the returned tree to the current output port
by @code{write-tree}, then returns zero.

If an error is signalled in @var{proc}, it is caught and an HTML
page reporting the error is generated.  You can customize the
error page by providing a procedure to the @var{on-error} keyword argument.
The procedure takes an @code{<condition>} object (@xref{Conditions}),
and has to return a tree of string for the error reporting HTML
page, including an HTTP header.

When output the result, @code{cgi-main} refers to
the value of the parameter @code{cgi-output-character-encoding}, 
and converts the character encoding if necessary.

The output behavior of @code{cgi-main} can be customized
by a keyword argument @var{output-proc}; if it is given,
the text tree (either the normal return value of @var{proc},
or an error page constructed by ther error handler) is passed
to the procedure given to @var{output-proc}.  The procedure
is responsible to format and output a text to the current
output port, including character conversions, if necessary.

The keyword argument @var{part-handlers} are simply passed to
@code{cgi-parse-parameters}, by which you can customize
how the file uploads should be handled.  See the "Handling file
uploads" section below for the details.

If you specify to use temporary file(s) by it, @code{cgi-main}
makes sure to clean up them whenever @var{proc} exits,
even by error.   See @code{cgi-add-temporary-file} below
to utilize this feature for other purpose.

The following example shows the parameters given to the CGI program.

@example
#!/usr/local/bin/gosh

(use text.html-lite)
(use www.cgi)

(define (main args)
  (cgi-main
    (lambda (params)
      `(,(cgi-header)
        ,(html-doctype)
        ,(html:html
          (html:head (html:title "Example"))
          (html:body
           (html:table
            :border 1
            (html:tr (html:th "Name") (html:th "Value"))
            (map (lambda (p)
                   (html:tr
                    (html:td (html-escape-string (car p)))
                    (html:td (html-escape-string (x->string (cdr p))))))
                 params))))
       ))))
@end example
@end defun


@defun cgi-add-temporary-file filename
This is supposed to be called inside @var{proc} of @code{cgi-main}.
It registers @var{filename} as a temporary file, which should be
unlinked when @var{proc} exits.  It is a convenient way to ensure
that your cgi script won't leave garbages even if it throws an error.
It is OK in @var{proc} to unlink or rename @var{filename} after
calling this procedure.
@end defun

@deffn {Parameter} cgi-temporary-files
Keeps a list of filenames registered by @code{cgi-add-temporary-file}.
@end deffn

@subheading Handling file uploads

As explained in @code{cgi-parse-parameters} above, file uploads
are handled transparently by default, taking the file content
as the value of the parameter.   Sometimes you might want to change this
behavior, for the file might be quite big and you don't want 
to keep around a huge chunk of a string in memory.  It is possible to
customize handling of file uploads of @code{cgi-parse-parameters}
and @code{cgi-main} by @var{part-handlers} argument.
(The argument is only effective for the form data submitted by
@code{multipart/form-data} enctype)

The @var{part-handlers} argument is, if given, a list of lists;
each inner list is a form of 
@code{(@var{name-pattern} @var{action} @var{kv-list} @dots{})}.
Each uploaded file with a matching parameter name with @var{name-pattern} is
handled according to @var{action}.  (Here, a parameter name
is the 'name' attribute given to the @code{input} element in the
submitted form, not the name of the uploaded file).

@var{Name-pattern} must be either a list of string (matches one of them),
a regexp, or @code{#t} (matches anything).

@var{Action} must be either one of the followings:
@table @code
@item #f
Default action, i.e. the content of the uploaded file is turned into
a string and becomes the value of the parameter.
@item ignore
The uploaded content is discarded.
@item file
The uploaded content is saved in a temporary file.  The value of
the parameter is the pathname of the temporary file.

For this action, you can write an entry like
@code{(@var{name-pattern} file @var{prefix})}, to specify the
prefix of the pathname of the temporary file.  For example, if you
specify @code{("image" file "/var/mycgi/incoming/img")}, 
the file uploaded as @code{"image"} parameter will be stored as
something like @file{/var/mycgi/incoming/img49g2Ua}.

The application should move the temporary file to appropriate
location; if you're using @code{cgi-main}, the temporary files
created by this action will be unlinked when @code{cgi-main} exits.

@item file+name
Like @code{file}, but the value of the parameter is a list of
tempoary filename and the filename passed by the client.
It is useful if you want to use client's filename (but do not
blindly assume the client sends a valid pathname; for example,
you shouldn't use it to rename the uploaded file without 
validating it).

@item @var{procedure}
In this case, @var{procedure} is called to handle the uploaded
contents.  It is called with four arguments:
@code{(procedure @var{name} @var{filename} @var{part-info} @var{iport})}.

@var{Name} is the name of the parameter.  @var{Filename} is
the name of the original file (pathname in the client).
@var{Part-info} is a @code{<mime-part>} object that keeps information
about this mime part,  and @var{iport} is where the body can be
read from.
For the details about these arguments, 
see @ref{MIME message handling}; you might be able to
use procedures provided by @code{rfc.mime}, such as @code{mime-retrieve-body},
to construct your own procedure.

If you create a temporary file in @var{procedure}, you can call
@code{cgi-add-temporary-file} to make sure it is removed even if
an error occurs during cgi processing.
@end table

If @var{kv-list} is given after @var{action}, it must be a
keyword-value list and further modifies action.  The following
keywords are supported.

@table @code
@item :prefix
Valid only if @var{action} is either @code{file} or @code{file+name}.
Specifies the prefix of the temporary file.  If you give
@code{:prefix "/tmp/foo"}, for example, the file is saved
as something like @file{/tmp/fooxAgjeQ}.
@item :mode
Valid only if @var{action} is either @code{file} or @code{file+name}.
Specifies the mode of the temporary file in unix-style integer.  By default 
it is @code{#o600}.
@end table


Note that the parameters that are not file uploads are not the subject
of @var{part-handlers}; such parameter values are always turned into a string.


Here's a short example.  Suppose you have a form like this:

@example
<form enctype="multipart/form-data" method="POST" action="mycgi.cgi">
<input type="file" name="imagefile" />
<input type="text" name="description" />
<input type="hidden" name="mode" value="normal" />
</form>
@end example

If you use @code{cgi-parse-parameters} in @file{mycgi.cgi}
without @var{part-handlers} argument,
you'll get something like the following as the result.
(The actual values depend on how the web client filled the form).

@example
(("imagefile" #*".....(image file content as a string)....")
 ("description" "my image")
 ("mode" "normal"))
@end example

If you pass @code{'(("imagefile" file :prefix "/tmp/mycgi"))}
to @var{part-handlers} 
instead,
you might get something like the following, with the
content of uploaded file saved in @file{/tmp/mycgi7gq0B}

@example
(("imagefile" "/tmp/mycgi7gq0B")
 ("description" "my image")
 ("mode" "normal"))
@end example

If you use a symbol @code{file+name} instead of @code{file} above,
you'll get something like @code{("/tmp/mycgi7gq0B" "logo.jpg")} as
the value of @code{"imagefile"}, where @code{"logo.jpg"} is the
client-side filename.   (Note: the client can send any string
as the name of the file, so @emph{never} assume it is a valid
pathname).

@c @c EN
@c Now, you pass the following structure to @var{part-handlers}:
@c @c JP
@c 次のような構造を@var{part-handlers}に渡した場合：
@c @c COMMON

@c @example
@c `(("imagefile" 
@c   ,(lambda (name fname info iport)
@c      (receive (outp tmpfile) (sys-mkstemp "/var/log/mycgi/tmp")
@c        (mime-retrieve-body info iport outp)
@c        (close-output-port outp)
@c        (cgi-add-temporary-file tmpfile)
@c        (string-append fname ":" tmpfile))))
@c  )
@c @end example

@c @c EN
@c You'll get something like the following; i.e. the cgi application
@c can see the client-side file name as well as the temporary file name.
@c @c JP
@c 例えば次のようなパーズ結果が得られるでしょう。つまり、
@c cgiアプリケーションは一時ファイル名と同時に
@c クライアント側でのファイル名も参照することができます。
@c @c COMMON

@c @example
@c (("imagefile" "logo.jpg:/var/log/mycgi/tmp820iQj")
@c  ("description" "my image")
@c  ("mode" "normal"))
@c @end example


@c ----------------------------------------------------------------------
@node CGI testing,  , CGI Utility, Library modules - Utilities
@section @code{www.cgi.test} - CGI testing
@c NODE CGIのテスト, @code{www.cgi.test} - CGIのテスト

@deftp {Module} www.cgi.test
@mdindex www.cgi.test
This module defines a useful procedures to test CGI script.
The test actually runs the named script, with specified enviornment
variable settings, and retrieve the output.  Your test procedure
then examine whether the output is as expected or not.
@end deftp

@defun cgi-test-enviornment-ref envvar-name
@defunx {(setter cgi-test-enviornment-ref)} envvar-name value
The module keeps a table of default values of enviornment variables
with which the cgi script will be run.  These procedures allow
the programmer to get/set those default values.

Note that you can override these default values and/or pass additional
environment variables for each call of cgi script.
The following environment variables are set by default.
@multitable @columnfractions .5 .5
@item Name @tab Value
@item @code{SERVER_SOFTWARE}   
@tab @code{cgitest/1.0}
@item @code{SERVER_NAME}       
@tab @code{localhost}
@item @code{GATEWAY_INTERFACE} 
@tab @code{CGI/1.1}
@item @code{SERVER_PROTOCOL}   
@tab @code{HTTP/1.1}
@item @code{SERVER_PORT}       
@tab @code{80}
@item @code{REQUEST_METHOD}    
@tab @code{GET}
@item @code{REMOTE_HOST}       
@tab @code{remote}
@item @code{REMOTE_ADDR}       
@tab @code{127.0.0.1}
@end multitable
@end defun

@defun call-with-cgi-script script proc &keyword (environment ()) (parameters #f)
Runs a script with given enviornment, and calls @var{proc} with
one argument, an input port which is connected to the pipe of script's
standard output.
The argument @var{script} should be a list of 
program name and its arguments.  Each element are
passed to @code{x->string} first to stringify.
The script is run under the enviornment given by @var{enviornment}
variable and the default test environment described above.
The @var{environment} argument must be an associative list, in which each
key (@code{car}) is the name of the enviornment variable and
its @code{cdr} is the value.  Both are passed to @code{x->string} first.
If the same environment variable appears in @var{environment} and
the default test enviornment, the one in @var{environment} is used.
Additionally, if an associative list is given to the @var{parameters}
argument, a query string is built from it and passed the script.
The actual method to pass the query string depends on the value
of @code{REQUEST_METHOD} environment variable in the setting.
If @code{REQUEST_METHOD} is either @code{GET} or @code{HEAD},
the query string is put in an environment variable @code{QUERY_STRING}.
If it is @code{POST}, the query string is fed to the standard
input of the script.  In the latter case, @code{CONTENT_TYPE}
is set to @code{application/x-www-form-urlencoded} and
@code{CONTENT_LENGTH} are set to the length of @code{QUERY_STRING}
automatically.  If @code{REQUEST_METHOD} is other values,
@var{parameters} is ignored.
You can bypass this mechanism and set up enviornment variable
@code{QUERY_STRING} directly, if you wish.
@end defun

@defun run-cgi-script->header&body script reader &keyword environment parameters
A convenient wrapper of @code{call-with-cgi-script}.
The @var{script}, @var{environment} and @var{parameters} are passed
to @code{call-with-cgi-script} as they are.
The output of the script is parsed by 
@code{run-cgi-script->header&body}.  
First, the RFC2822 header fields are parsed by 
@code{rfc822-read-headers} (@xref{RFC822 message parsing}).
Then, the @var{reader} is called with an input port which
is piped to the script's output.
@code{Run-cgi-script->header&body} returns two values,
the list of headers (as parsed by @code{rfc822-read-headers}),
and the return value of @var{reader}.
@end defun

@defun run-cgi-script->sxml script &keyword environment parameters
This is a procedure that uses @code{ssax:xml->sxml}
(@xref{Functional XML parser}) as the @var{reader}
in @code{run-cgi-script->header&body}.  
Useful when you're testing a cgi script that produces
well-formed HTML and/or XML document.
@end defun

@defun run-cgi-script->string script &keyword environment parameters
@defunx run-cgi-script->string-list script &keyword environment parameters
These procedures use @code{port->string} 
and @code{port->string-list}
(@xref{Input utility functions}) as the @var{reader}
in @code{run-cgi-script->header&body}, respectively.
@end defun

An example:
@example
(run-cgi-script->string-list "bbs.cgi"
                             :environment '((REMOTE_ADDR . "12.34.56.78"))
                             :parameters '((command . "view")
                                           (page . 1234)))
@end example


@node References, C to Scheme mapping, Library modules - Utilities, Top
@appendix References
@c NODE 参考文献

@table @asis
@anchor{r5rs}
@item [R5RS]
R. Kelsey, W. Clinger, J. Rees (eds.),
Revised^5 Report on the Algorithmic Language Scheme,
Higher-Order and Symbolic Computation, 11(1), September, 1998
and ACM SIGPLAN Notices, 33(9), October, 1998. @*
@url{http://www.schemers.org/Documents/Standards/R5RS/}.

@anchor{onecont}
@item [1CC]
Carl Bruggeman, Oscar Waddell and R. Kent Dybvig,
Representing control in the presence of one-shot continuations,
in @i{Proceedings of SIGPLAN '96}, pp. 99--107, 1996.

@anchor{myers86}
@item [Myers86]
Eugene Myers, 
An O(ND) Difference Algorithm and Its Variations,
@i{Algorithmica} Vol. 1 No. 2, pp. 251-266, 1986.

@anchor{mop}
@item [MOP]
Gregor Kiczales, Jim Des Rivieres, Daniel Bobrow,
The Art of Metaobject Protocol, 
The MIT Press.

@anchor{dylan}
@item [Dylan]
Kim Barrett, Bob Cassels, Paul Haahr,
David A. Moon, Keith Playford, P. Tucker Withington,
A Monotonic Superclass Linearization for Dylan,
in @i{Proceedings of OOPSLA 96}, October 1996.@*
@url{http://www.webcom.com/~haahr/dylan/linearization-oopsla96.html}.

@anchor{fairthreads}
@item [FairThreads]
F. Boussinot, Java Fair Threads, @*
@url{http://www-sop.inria.fr/mimosa/rp/FairThreads/html/FairThreads.html}.

@anchor{rfc1321}
@item [RFC1321]
R. Rivest,
The MD5 Message-Digest Algorithm. @*
April 1992. @*
@url{ftp://ftp.isi.edu/in-notes/rfc1321.txt}.

@anchor{rfc2045}
@item [RFC2045]
N. Freed, N. Borenstein: Multipurpose Internet Mail Extension
(MIME) Part One: Format of Internet Message Bodies,
November 1996. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2045.txt}.

@anchor{rfc2396}
@item [RFC2396]
T. Berners-Lee, R. Fielding, L. Masinter,
Uniform Resource Identifiers (URI): Generic Syntax,
August 1998. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2396.txt}.

@anchor{rfc2616}
@item [RFC2616]
R. Fielding et al, Hypertext Transfer Protocol -- HTTP/1.1, June 1999. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2616.txt}.

@anchor{rfc2822}
@item [RFC2822]
P. Resnick (ed.), Internet Message Format, April 2001. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2822.txt}.

@anchor{rfc2965}
@item [RFC2965]
D. Kristol, L. Montulli, HTTP State Management Mechanism,
October 2000. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2965.txt}.

@anchor{rfc3174}
@item [RFC3174]
D. Eastlake, 3rd and P. Jones,
US Secure Hash Algorithm 1 (SHA1). @*
September 2001. @*
@url{ftp://ftp.isi.edu/in-notes/rfc3174.txt}.

@anchor{rfc3548}
@item [RFC3548]
S. Josefsson, Ed.: The Base16, Base32, and Base64 Data Encodings
July 2003. @*
@url{ftp://ftp.isi.edu/in-notes/rfc3548.txt}.

@anchor{srfi-0}
@item [SRFI-0]
Marc Feeley, Feature-based conditional expansion construct, May  1999.@*
@url{http://srfi.schemers.org/srfi-0/srfi-0.html}.

@anchor{srfi-1}
@item [SRFI-1]
Olin Shivers, List Library, October 1999. @*
@url{http://srfi.schemers.org/srfi-1/srfi-1.html}.

@anchor{srfi-2}
@item [SRFI-2]
Oleg Kiselyov, @code{AND-LET*}: an @code{AND} with local bindings, a guarded 
@code{LET*} special form, March 1998. @*
@url{http://srfi.schemers.org/srfi-2/srfi-2.html}.

@anchor{srfi-4}
@item [SRFI-4]
Marc Feeley, Homogeneous numeric vector types, May 1999.@*
@url{http://srfi.schemers.org/srfi-4/srfi-4.html}.

@anchor{srfi-6}
@item [SRFI-6]
William D Clinger, Basic String Ports, July 1999. @*
@url{http://srfi.schemers.org/srfi-6/srfi-6.html}.

@anchor{srfi-8}
@item [SRFI-8]
John David Stone, receive: Binding to multiple values, August 1999. @*
@url{http://srfi.schemers.org/srfi-8/srfi-8.html}.

@anchor{srfi-9}
@item [SRFI-9]
Richard Kelsey, Defining Record Types, September 1999.@*
@url{http://srfi.schemers.org/srfi-9/srfi-9.html}.

@anchor{srfi-10}
@item [SRFI-10]
Oleg Kiselyov, @code{#,} external form, January 2000.@*
@url{http://srfi.schemers.org/srfi-10/srfi-10.html}.

@anchor{srfi-11}
@item [SRFI-11]
Lars T Hansen, Syntax for receiving multiple values, March 2000. @*
@url{http://srfi.schemers.org/srfi-11/srfi-11.html}.

@anchor{srfi-13}
@item [SRFI-13]
Olin Shivers, String Libraries, December 2000. @*
@url{http://srfi.schemers.org/srfi-13/srfi-13.html}.

@anchor{srfi-14}
@item [SRFI-14]
Olin Shivers, Character-set Library, December 2000. @*
@url{http://srfi.schemers.org/srfi-14/srfi-14.html}.

@anchor{srfi-17}
@item [SRFI-17]
Per Bothner, Generalized @code{set!}, July 2000. @*
@url{http://srfi.schemers.org/srfi-17/srfi-17.html}.

@anchor{srfi-18}
@item [SRFI-18]
Marc Feeley, Multithreading Support, April 2000. @*
@url{http://srfi.schemers.org/srfi-18/srfi-18.html}.

@anchor{srfi-19}
@item [SRFI-19]
Will Fitzgerald, Time Data Types and Procedures, August 2000. @*
@url{http://srfi.schemers.org/srfi-19/srfi-19.html}.

@anchor{srfi-21}
@item [SRFI-21]
Marc Feeley, Readl-time Multithreading Support, April 2000. @*
@url{http://srfi.schemers.org/srfi-21/srfi-21.html}.

@anchor{srfi-22}
@item [SRFI-22]
Martin Gasbichler and Michael Sperber, 
Running Scheme Scripts on Unix, January 2002. @*
@url{http://srfi.schemers.org/srfi-22/srfi-22.html}.

@anchor{srfi-23}
@item [SRFI-23]
Stephan Housen, Error reporting mechanism, April 2001.@*
@url{http://srfi.schemers.org/srfi-23/srfi-23.html}.

@anchor{srfi-25}
@item [SRFI-25]
Jussi Piitulainen, Multi-dimensional Array Primitives, June 2002.@*
@url{http://srfi.schemers.org/srfi-25/srfi-25.html}.

@anchor{srfi-26}
@item [SRFI-26]
Sebastian Egner, Notation for Specializing Parameters without Currying, June 2002.@*
@url{http://srfi.schemers.org/srfi-26/srfi-26.html}.

@anchor{srfi-27}
@item [SRFI-27]
Sebastian Egner, Sources of Random Bits, June 2002.@*
@url{http://srfi.schemers.org/srfi-27/srfi-27.html}.

@anchor{srfi-28}
@item [SRFI-28]
Scott G. Miller, Basic Format Strings, June 2002.@*
@url{http://srfi.schemers.org/srfi-28/srfi-28.html}.


@anchor{srfi-37}
@item [SRFI-37]
Anthony Carrico, Args-fold: a program argument processor, Jan. 2003.@*
@url{http://srfi.schemers.org/srfi-37/srfi-37.html}.

@anchor{ssax}
@item [SSAX]
Oleg Kiselyov, XML and Scheme, @*
@url{http://pobox.com/~oleg/ftp/Scheme/xml.html}.@*
The SSAX distribution is also available at sourceforge:@*
@url{http://ssax.sourceforge.net/}.

@anchor{MT}
@item [MT]
M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-dimensionally
equidistributed uniform pseudorandom number generator", ACM Trans. on
Modeling and Computer Simulation Vol. 8, No. 1, Januray pp.3-30 1998.@*
@url{http://www.math.keio.ac.jp/~matumoto/emt.html}

@anchor{oleg1}
@item [OLEG1]
Oleg Kiselyov, Making sense of an input stream,@*
@url{http://pobox.com/~oleg/ftp/Scheme/parsing.html}.

@anchor{oleg2}
@item [OLEG2]
Oleg Kiselyov, General ways to traverse collections,,@*
@url{http://pobox.com/~oleg/ftp/Scheme/enumerators-callcc.html}.
2000.
@end table
@node C to Scheme mapping, Function and Syntax Index, References, Top
@appendix C to Scheme mapping
@c NODE CとSchemeの関数の対応

For the convenience of the programmers familiar to C, 
I composed a simple table of C operators and library functions with
the corresponding Scheme functions.

@table @code
@item +
R5RS arithmetic procedure @code{+}.   @xref{Arithmetics}.
@item +=
Gauche @code{inc!} macro.  @xref{Assignments}.
@item -
R5RS arithmetic procedure @code{-}.   @xref{Arithmetics}.
@item -=
Gauche @code{dec!} macro.  @xref{Assignments}.
@item ->
Gauche @code{slot-ref} is something close to this.  @xref{Accessing instance}.
@item * (binary)
R5RS arithmetic procedure @code{*}.   @xref{Arithmetics}.
@item * (unary)
No equivalent procedure.  Scheme doesn't have explicit notation of
pointers.
@item *=
No equivalent procedure.
@item /
R5RS arithmetic procedure @code{/}.   @xref{Arithmetics}.
@item /=
No equivalent procedure.
@item & (binary)
Gauche @code{logand}.  @xref{Bitwise operations}.
@item & (unary)
No equivalent procedure.  Scheme doesn't have explicit notation of
pointers.
@item &&
R5RS syntax @code{and}.  @xref{Conditionals}.
@item &=
No equivalent procedure.
@item |
Gauche @code{logior}.  @xref{Bitwise operations}.
@item ||
R5RS syntax @code{or}.  @xref{Conditionals}.
@item |=
No equivalent procedure.
@item ^
Gauche @code{logxor}.  @xref{Bitwise operations}.
@item =
R5RS syntax @code{set!}.  @xref{Assignments}.
@item ==
R5RS equivalence procedure, @code{eq?}, @code{eqv?} and @code{equal?}.
@xref{Equivalence}.
@item <
@itemx <=
R5RS arithmetic procedure @code{<} and @code{<=}.
@xref{Numerical comparison}.  Unlike C operator, Scheme version
is transitive.
@item <<
Gauche @code{ash}.  @xref{Bitwise operations}.
@item <<=
No equivalent procedure.
@item >
@itemx >=
R5RS arithmetic procedure @code{>} and @code{>=}.
@xref{Numerical comparison}.  Unlike C operator, Scheme version
is transitive.
@item >>
Gauche @code{ash}.  @xref{Bitwise operations}.
@item >>=
No equivalent procedure.
@item %
R5RS operator @code{modulo} and @code{remainder}.  @xref{Arithmetics}.
@item %=
No equivalent procedure.
@item []
R5RS @code{vector-ref} (@xref{Vectors}) is something close.
Or you can use Gauche's generic function @code{ref} (@xref{Sequence framework})
for arbitrary sequences.
@item .
Gauche @code{slot-ref} is something close to this.  @xref{Accessing instance}.
@item ~
Gauche @code{lognot}.  @xref{Bitwise operations}.
@item ~=
No equivalent procedure.
@item !
R5RS procedure @code{not}.  @xref{Booleans}.
@item !=
No equivalent procedure.
@item abort
Gauche @code{sys-abort}.   @xref{Program termination}.
@item abs
R5RS @code{abs}.  @xref{Arithmetics}.
@item access
Gauche @code{sys-access}.  @xref{File stats}.
@item acos
R5RS @code{acos}.  @xref{Arithmetics}.
@item alarm
Gauche @code{sys-alarm}.   @xref{Miscellaneous system calls}.
@item asctime
Gauche @code{sys-asctime}.  @xref{Time}.
@item asin
R5RS @code{asin}.  @xref{Arithmetics}.
@item assert
No equivalent function in Gauche.
@item atan
@itemx atan2
R5RS @code{atan}.  @xref{Arithmetics}.
@item atexit
No equivalent function in Gauche, but the "after" thunk of active
dynamic handlers are called when @code{exit} is called.
@xref{Program termination}, and @xref{Continuation}.
@item atof
@itemx atoi
@itemx atol
You can use @code{string->number}.  @xref{Numerical conversions}.
@item bsearch
You can use SRFI-43's @code{vector-binary-search}.
@xref{Vector library}.
@item calloc
Allocation is handled automatically in Scheme.
@item ceil
R5RS @code{ceiling}.  @xref{Arithmetics}.
@item cfgetispeed
@itemx cfgetospeed
@itemx cfsetispeed
@itemx cfsetospeed
Gauche's @code{sys-cfgetispeed}, @code{sys-cfgetospeed},
@code{sys-cfsetispeed}, @code{sys-cfsetospeed}.  @xref{Termios}.
@item chdir
Gauche's @code{sys-chdir}.   @xref{Other file operations}.
@item chmod
Gauche's @code{sys-chmod}.   @xref{File stats}.
@item chown
Gauche's @code{sys-chown}.   @xref{File stats}.
@item clearerr
Not supported yet.
@item clock
No equivalent function in Gauche.  You can use @code{sys-times}
to get information about CPU time.
@item close
You can't directly close the file descriptor, but when you use
@code{close-input-port} or @code{close-output-port}, underlying
file is closed.  Some port-related functions, such as
@code{call-with-output-file}, automatically closes the file
when operation is finished.  The file is also closed when
its governing port is garbage collected.
@xref{Common port operations}.
@item closedir
No equivalent function in Gauche.  You can use
@code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item cos
@itemx cosh
@code{cos} and @code{cosh}.  @xref{Arithmetics}.
@item creat
A file is implictly created by default when you open it for writing.
See @ref{File ports} for more control over the creation of files.
@item ctermid
Gauche @code{sys-ctermid}.  @xref{System inquiry}.
@item ctime
Gauche @code{sys-ctime}.  @xref{Time}.
@item cuserid
No equivalent function.  This is removed from the newer POSIX.
You can use alternative functions, such as @code{sys-getlogin} or
@code{sys-getpwuid} with @code{sys-getuid}.
@item difftime
Gauche @code{sys-difftime}.  @xref{Time}.
@item div
You can use R5RS @code{quotient} and @code{remainder}.
@xref{Arithmetics}.
@item dup
@itemx dup2
Not directly supported, but you can use @code{port-fd-dup!}.
@item execl
@itemx execle
@itemx execlp
@itemx execv
@itemx execve
@itemx execvp
Gauche @code{sys-exec}.  @xref{Unix process management}.
For higher level interface, @ref{High Level Process Interface}.
@item exit
@item _exit
Use @code{exit} or @code{sys-exit}, depends on what you need.
@xref{Program termination}.
@item exp
R5RS @code{exp}.  @xref{Arithmetics}.
@item fabs
R5RS @code{abs}.  @xref{Arithmetics}.
@item fclose
You can't directly close the file stream, but when you use
@code{close-input-port} or @code{close-output-port}, underlying
file is closed.  Some port-related functions, such as
@code{call-with-output-file}, automatically closes the file
when operation is finished.  The file is also closed when
its governing port is garbage collected.
@item fcntl
Implemented as @code{sys-fcntl} in @code{gauche.fcntl} module.
@xref{Low-level file operations}.
@item fdopen
Gauche's @code{open-input-fd-port} or @code{open-output-fd-port}.
@xref{File ports}.
@item feof
Not supported yet.
@item ferror
Not supported yet.
@item fflush
Gauche's @code{flush}.   @xref{Output}.
@item fgetc
Use @code{read-char} or @code{read-byte}.  @xref{Input}.
@item fgetpos
Use Gauche's @code{port-tell} (@xref{Common port operations})
@item fgets
Use @code{read-line} or @code{read-block}.    @xref{Input}.
@item fileno
@code{port-file-numer}.   @xref{Common port operations}.
@item floor
R5RS @code{floor}.   @xref{Arithmetics}.
@item fmod
Gauche's @code{fmod}.
@item fopen
R5RS @code{open-input-file} or @code{open-output-file}
corresponds to this operation.  @xref{File ports}.
@item fork
Gauche's @code{sys-fork}.   @xref{Unix process management}.
@item forkpty
Use @code{sys-forkpty}.  @xref{Termios}.
@item fpathconf
Not supported.
@item fprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item fputc
Use @code{write-char} or @code{write-byte}.  @xref{Output}.
@item fputs
Use @code{display}.  @xref{Output}.
@item fread
Not directly supported.  
To read binary numbers, see @ref{Binary I/O}.
If you want to read a chunk of bytes, you may be 
able to use @code{read-block!}.
@xref{Uvector block I/O}.
@item free
You don't need this in Scheme.
@item freopen
Not supported.
@item frexp
Gauche's @code{frexp}
@item fscanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{String library}),
and/or regular expression stuff (@ref{Regular expression}).
@item fseek
Use Gauche's @code{port-seek} (@xref{Common port operations})
@item fsetpos
Use Gauche's @code{port-seek} (@xref{Common port operations})
@item fstat
Gauche's @code{sys-stat}.  @xref{File stats}.
@item ftell
Use Gauche's @code{port-tell} (@xref{Common port operations})
@item fwrite
Not directly supported.  
To write binary numbers, see @ref{Binary I/O}.
If you want to write a chunk of bytes,
you can simply use @code{display} or @code{write-block}
(@xref{Uvector block I/O}).
@item getc
@itemx getchar
Use @code{read-char} or @code{read-byte}.  @xref{Input}.
@item getcwd
Gauche's @code{sys-getcwd}.   @xref{System inquiry}.
@item getdomainname
Gauche's @code{sys-getdomainname}.  @xref{System inquiry}.
@item getegid
Gauche's @code{sys-getegid}.   @xref{System inquiry}.
@item getenv
Gauche's @code{sys-getenv}.   @xref{Environment Inquiry}.
@item geteuid
Gauche's @code{sys-geteuid}.   @xref{System inquiry}.
@item gethostname
Gauche's @code{sys-gethostname}.  @xref{System inquiry}.
@item getgid
Gauche's @code{sys-getgid}.   @xref{System inquiry}.
@item getgrgid
@itemx getgrnam
Gauche's @code{sys-getgrgid} and @code{sys-getgrnam}.  @xref{Unix groups and users}.
@item getgroups
Gauche's @code{sys-getgroups}.   @xref{System inquiry}.
@item getlogin
Gauche's @code{sys-getlogin}.  @xref{System inquiry}.
@item getpgrp
Gauche's @code{sys-getpgrp}.   @xref{System inquiry}.
@item getpid
@itemx getppid
Gauche's @code{sys-getpid}.   @xref{System inquiry}.
@item getpwnam
@itemx getpwuid
Gauche's @code{sys-getpwnam} and @code{sys-getpwuid}.  @xref{Unix groups and users}.
@item gets
Use @code{read-line} or @code{read-block}.  @xref{Input}.
@item gettimeofday
Gauche's @code{sys-gettimeofday}.   @xref{Time}.
@item getuid
Gauche's @code{sys-getuid}.  @xref{System inquiry}.
@item gmtime
Gauche's @code{sys-gmtime}.   @xref{Time}.
@item isalnum
Not directly supported, but you can use R5RS @code{char-alphabetic?} and
@code{char-numeric?}.  @xref{Characters}.   You can also use
character set.  @xref{Character set}, also @ref{Character-set library}.
@item isalpha
R5RS @code{char-alphabetic?}.  @xref{Characters}.  See also
@ref{Character set} and @ref{Character-set library}.
@item isatty
Gauche's @code{sys-isatty}.   @xref{Other file operations}.
@item iscntrl
Not directly supported, but you can use
@code{(char-set-contains? char-set:iso-control c)} with @code{srfi-14}.
@xref{Character-set library}.
@item isdigit
R5RS @code{char-numeric?}.  @xref{Characters}. 
You can also use @code{(char-set-contains? char-set:digit c)}
with @code{srfi-14}.   @xref{Character-set library}.
@item isgraph
Not directly supported, but you can use
@code{(char-set-contains? char-set:graphic c)} with @code{srfi-14}.
@xref{Character-set library}.
@item islower
R5RS @code{char-lower-case?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:lower-case c)}
with @code{srfi-14}.   @xref{Character-set library}.
@item isprint
Not directly supported, but you can use
@code{(char-set-contains? char-set:printing c)} with @code{srfi-14}.
@xref{Character-set library}.
@item ispunct
Not directly supported, but you can use
@code{(char-set-contains? char-set:punctuation c)} with @code{srfi-14}.
@xref{Character-set library}.
@item isspace
R5RS @code{char-whitespace?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:whitespace c)}
with @code{srfi-14}.   @xref{Character-set library}.
@item isupper
R5RS @code{char-upper-case?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:upper-case c)}
with @code{srfi-14}.   @xref{Character-set library}.
@item isxdigit
Not directly supported, but you can use
@code{(char-set-contains? char-set:hex-digit c)} with @code{srfi-14}.
@xref{Character-set library}.
@item kill
Gauche's @code{sys-kill}.  @xref{Signal}.
@item labs
R5RS @code{abs}.  @xref{Arithmetics}.
@item ldexp
Gauche's @code{ldexp}.
@item ldiv
Use R5RS @code{quotient} and @code{remainder}.
@xref{Arithmetics}.
@item link
Gauche's @code{sys-link}.  @xref{Directory manipulation}.
@item localeconv
Gauche's @code{sys-localeconv}. @xref{Locale}.
@item localtime
Gauche's @code{sys-localtime}.  @xref{Time}.
@item log
R5RS @code{log}.  @xref{Arithmetics}.
@item log10
Not directly supported.  @code{log10(z)} @equiv{} @code{(/ (log z) (log 10))}.
@item longjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item lseek
Use Gauche's @code{port-seek} (@xref{Common port operations})
@item malloc
Not necessary in Scheme.
@item mblen
@itemx mbstowcs
@itemx mbtowc
Gauche handles multibyte strings internally, so generally you don't 
need to care about multibyte-ness of the string.   @code{string-length}
always returns a number of characters for a string in supported
encoding.   If you want to convert the character encoding,
see @ref{Character code conversion}.
@item memcmp
@itemx memcpy
@itemx memmove
@itemx memset
No equivalent functions.
@item mkdir
Gauche's @code{sys-mkdir}.  @xref{Directory manipulation}.
@item mkfifo
Gauche's @code{sys-mkfifo}.
@item mkstemp
Gauche's @code{sys-mkstemp}.   @xref{Directory manipulation}.
Use this instead of tmpnam.
@item mktime
Gauche's @code{sys-mktime}.  @xref{Time}.
@item modf
Gauche's @code{modf}.
@item open
Not directly supported.
R5RS @code{open-input-file} or @code{open-output-file}
corresponds to this operation.  @xref{File ports}.
@item opendir
Not directly supported.
You can use @code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item openpty
Use @code{sys-openpty}.  @xref{Termios}.
@item pathconf
Not supported.
@item pause
Gauche's @code{sys-pause}.  @xref{Miscellaneous system calls}.
@item perror
No equivalent function in Gauche.  System calls generally throws an
error (@code{<system-error>}), including the description of the reason
of failure.
@item pipe
Gauche's @code{sys-pipe}.  @xref{Other file operations}.
@item pow
R5RS @code{expt}.  @xref{Arithmetics}.
@item printf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item putc
@itemx putchar
Use @code{write-char} or @code{write-byte}.  @xref{Output}.
@item puts
Use @code{display}.   @xref{Output}.
@item qsort
Gauche's @code{sort} and @code{sort!} provides a convenient way to sort
list of items.  @xref{Comparison and sorting}.
@item raise
No equivalent function in Gauche.  Scheme function @code{raise} (SRFI-18)
is to raise an exception.   You can use @code{(sys-kill (sys-getpid) SIG)}
to send a signal @code{SIG} to the current process.
@item rand
Not supported directly, but on most platforms a better RNG is available
as @code{sys-random}.  @xref{Miscellaneous system calls}.
@item read
Not supported directly, but you may be able to use
@code{read-block} (@xref{Input}) or
@code{read-block!} (@xref{Uvector block I/O}).
@item readdir
Not supported directly.   Gauche's @code{sys-readdir} reads
the directory at once.  @xref{Directories}.
@item readlink
Gauche's @code{sys-readlink}.  @xref{Directory manipulation}.
This function is available on systems that support symbolink links.
@item realloc
Not necessary in Scheme.
@item realpath
Gauche's @code{sys-normalize-pathname} or @code{sys-realpath}.
@xref{Pathnames}.
@item remove
Gauche's @code{sys-remove}.  @xref{Directory manipulation}.
@item rename
Gauche's @code{sys-rename}.  @xref{Directory manipulation}.
@item rewind
Not directly supported, but you can use @code{port-seek} instead.
@xref{Common port operations}.
@item rewinddir
Not supported directly.
You can use @code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item rmdir
Gauche's @code{sys-rmdir}.  @xref{Directory manipulation}.
@item scanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{String library}),
and/or regular expression stuff (@ref{Regular expression}).
@item select
Gauche's @code{sys-select}.  @xref{I/O multiplexing}.
@item setbuf
Not necessary.
@item setgid
Gauche's @code{sys-setgid}.
@item setjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item setlocale
Gauche's @code{sys-setlocale}.  @xref{Locale}.
@item setpgid
Gauche's @code{sys-setpgid}.  @xref{System inquiry}.
@item setsid
Gauche's @code{sys-setsid}.  @xref{System inquiry}.
@item setuid
Gauche's @code{sys-setuid}.  @xref{System inquiry}.
@item setvbuf
Not necessary.
@item sigaction
You can use @code{set-signal-handler!} to install signal handlers.
@xref{Handling signals}.
@item sigaddset
@itemx sigdelset
@itemx sigemptyset
@itemx sigfillset
Gauche's @code{sys-sigset-add!} and @code{sys-sigset-delete!}.
@xref{Signals and signal sets}.
@item sigismember
Not supported yet.
@item siglongjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item signal
You can use @code{with-signal-handlers} to install signal handlers.
@xref{Handling signals}.
@item sigpending
Not supported yet.
@item sigprocmask
Signal mask is handled internally.  @xref{Handling signals}.
@item sigsetjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item sigsuspend
Gauche's @code{sys-sigsuspend}.  @xref{Masking and waiting signals}.
@item sigwait
Gauche's @code{sys-sigwait}.  @xref{Masking and waiting signals}.
@item sin
@itemx sinh
Use @code{sin} and @code{sinh}.   @xref{Arithmetics}.
@item sleep
Gauche's @code{sys-sleep}.  @xref{Miscellaneous system calls}.
@item sprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item sqrt
R5RS @code{sqrt}.  @xref{Arithmetics}.
@item srand
Not supported directly, but on most platforms a better RNG is available
as @code{sys-srandom} (@xref{Miscellaneous system calls}).
The @code{math.mt-random} module provides much superior RNG
(@xref{Mersenne-Twister random number generator}).
@item sscanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{String library}),
and/or regular expression stuff (@ref{Regular expression}).
@item stat
Gauche's @code{sys-stat}.  @xref{File stats}.
@item strcasecmp
R5RS @code{string-ci=?} and other comparison functions.
@xref{String Comparison}.
@item strcat
R5RS @code{string-append}.  @xref{String utilities}.
@item strchr
SRFI-13 @code{string-index}.  @xref{SRFI-13 String searching}.
@item strcmp
R5RS @code{string=?} and other comparison functions.
@xref{String Comparison}.
@item strcoll
Not supported yet.
@item strcpy
R5RS @code{string-copy}.    @xref{String utilities}.
@item strcspn
Not directly supported, but you can use SRFI-13 @code{string-skip}
with a character set.  @xref{SRFI-13 String searching}.
@item strerror
Gauche's @code{sys-strerror}.  @xref{System inquiry}.
@item strftime
Gauche's @code{sys-strftime}.  @xref{Time}.
@item strlen
R5RS @code{string-length}.  @xref{String Accessors & Modifiers}.
@item strncat
Not directly supported, but you can use @code{string-append} and
@code{substring}.
@item strncasecmp
SRFI-13 @code{string-compare-ci} provides the most flexible
(but a bit difficult to use) functionality.
@xref{SRFI-13 String Comparison}.
If what you want is just to check the fixed-length prefixes of two
string matches, you can use SRFI-13 @code{string-prefix-ci?}.
@item strncmp
SRFI-13 @code{string-compare} provides the most flexible
(but a bit difficult to use) functionality.
@xref{SRFI-13 String Comparison}.
If what you want is just to check the fixed-length prefixes of two
string matches, you can use SRFI-13 @code{string-prefix?}.
@xref{SRFI-13 String Prefixes & Suffixes}.
@item strncpy
SRFI-13 @code{substring}.  @xref{String utilities}.
@item strpbrk
Not directly supported, but you can use SRFI-13 @code{string-skip}
with a character set.  @xref{SRFI-13 String searching}.
@item strrchr
SRFI-13 @code{string-index-right}.  @xref{SRFI-13 String searching}.
@item strspn
Not directly supported, but you can use SRFI-13 @code{string-index}
with a character set.  @xref{SRFI-13 String searching}.
@item strstr
SRFI-13 @code{string-contains}.  @xref{SRFI-13 String searching}.
@item strtod
You can use R5RS @code{string->number}.   @xref{Numerical conversions}.
@item strtok
SRFI-13 @code{string-tokenize}.  @xref{SRFI-13 other string operations}.
@item strtol
@itemx strtoul
You can use R5RS @code{string->number}.   @xref{Numerical conversions}.
@item strxfrm
Not supported yet.
@item symlink
Gauche's @code{sys-symlink}.  @xref{Directory manipulation}.
This function is available on systems that support symbolink links.
@item sysconf
Not supported yet.
@item system
Gauche's @code{sys-system}.   @xref{Unix process management}.
It is generally recommended to use the process library
(@ref{High Level Process Interface}).
@item tan
@itemx tanh
R5RS @code{tan} and Gauche @code{tanh}.  @xref{Arithmetics}.
@item tcdrain
@item tcflow
@item tcflush
@item tcgetattr
@item tcgetpgrp
@item tcsendbreak
@item tcsetattr
@item tcsetpgrp
Corresponding functions are: @code{sys-tcdrain}, @code{sys-tcflow},
@code{sys-tcflush}, @code{sys-tcgetattr}, @code{sys-tcgetpgrp},
@code{sys-tcsendbreak}, @code{sys-tcsetattr}, @code{sys-tcsetpgrp}.
@xref{Termios}
@item time
Gauche's @code{sys-time}.  @xref{Time}.
@item times
Gauche's @code{sys-times}.  @xref{System inquiry}.
@item tmpfile
Not exactly supported.
@item tmpnam
Gauche's @code{sys-tmpnam}.
This function is provided since it is in POSIX, but its use is
discouraged for the potential security risk.  Use @code{sys-mkstemp}
instead.   @xref{Directory manipulation}.
@item tolower
@itemx toupper
R5RS @code{char-upcase} and @code{char-downcase}.   @xref{Characters}.
@item ttyname
Gauche's @code{sys-ttyname}.  @xref{Other file operations}.
@item tzset
Not supported yet.
@item umask
Gauche's @code{sys-umask}.  @xref{Directory manipulation}.
@item uname
Gauche's @code{sys-uname}.  @xref{System inquiry}.
@item ungetc
Not directly supported.  You can use @code{peek-char} to look
one character ahead, instead of pushing back.
@item unlink
Gauche's @code{sys-unlink}.  @xref{Directory manipulation}.
@item utime
Gauche's @code{sys-utime}. @xref{File stats}.
@item va_arg
@itemx va_end
@itemx va_start
Not necessary, for Scheme handles variable number of arguments naturally.
@item vfprintf
@itemx vprintf
@itemx vsprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item wait
Gauche's @code{sys-wait}.  @xref{Unix process management}.
@item waitpid
Gauche's @code{sys-waitpid}.  @xref{Unix process management}.
@item wcstombs
@itemx wctomb
Gauche handles multibyte strings internally, so generally you don't 
need to care about multibyte-ness of the string.   @code{string-length}
always returns a number of characters for a string in supported
encoding.   If you want to convert the character encoding,
see @ref{Character code conversion}.
@item write
R5RS @code{display} (@xref{Output}).
Or @code{write-block} (@xref{Uvector block I/O}).
@end table

@c Appendix : Common Lisp to Scheme mapping
@c Appendix : Perl to Scheme mapping
@c Appendix : Python to Scheme mapping?
@node Function and Syntax Index, Module Index, C to Scheme mapping, Top
@appendix Function and Syntax Index
@c NODE Index - 手続きと構文索引
@printindex fn
@node Module Index, Class Index, Function and Syntax Index, Top
@appendix Module Index
@c NODE Index - モジュール索引
@printindex md
@node Class Index, Variable Index, Module Index, Top
@appendix Class Index
@c NODE Index - クラス索引

For readability, the surrounding @code{<} and @code{>} are stripped off.

@printindex cl

@node Variable Index, , Class Index, Top
@appendix Variable Index
@c NODE Index - 変数索引
@printindex vr


@contents
@bye

