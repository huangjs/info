This is gauche-refe.info, produced by makeinfo version 4.13 from
gauche-refe.texi.

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* Gauche: (gauche-refe.info).	        An R5RS Scheme implementation.
END-INFO-DIR-ENTRY


File: gauche-refe.info,  Node: Common port operations,  Next: File ports,  Prev: Port and threads,  Up: Input and output

6.19.3 Common port operations
-----------------------------

 -- Function: port? obj
 -- Function: input-port? obj
 -- Function: output-port? obj
     [R5RS] Returns true if OBJ is a port, an input port and an output
     port, respectively.  `Port?' is not listed in the R5RS standard
     procedures, but mentioned in the "Disjointness of Types" section.

 -- Function: port-closed? port
     Returns true if OBJ is a port and it is already closed.  A closed
     port can't be reopened.

 -- Function: current-input-port
 -- Function: current-output-port
     [R5RS] Returns the current input port and the current output port,
     respectively.

 -- Function: current-error-port
     Returns the current output port.

 -- Function: standard-input-port
 -- Function: standard-output-port
 -- Function: standard-error-port
     Returns ports that are bound initially to current input, output and
     error port, respectively.

 -- Function: with-input-from-port port thunk
 -- Function: with-output-to-port port thunk
 -- Function: with-error-to-port port thunk
     Calls THUNK.  During evaluation of thunk, the current input port,
     current output port and current error port are set to PORT,
     respectively.

 -- Function: with-ports iport oport eport thunk
     Does the above three functions at once.  Calls THUNK while the
     current input, output, and error ports are set to IPORT, OPORT,
     and EPORT, respectively.  You may pass `#f' to any port
     argument(s) if you don't need to alter the port(s).

 -- Function: close-input-port port
 -- Function: close-output-port port
     [R5RS] Closes input and output PORT, respectively

 -- Function: port-type port
     Returns the type of PORT in one of the symbols `file', `string' or
     `proc'.

 -- Function: port-name port
     Returns the name of PORT.  If the port is associated to a file, it
     is the name of the file.   Otherwise, it is some description of
     the port.

 -- Function: port-buffering port
 -- Function: (setter port-buffering) port buffering-mode
     If PORT is type of file port (i.e. `(port-type PORT)' returns
     `file'), these procedures gets and sets the port's buffering mode.
     For input ports, the port buffering mode may be either one of
     `:full', `:modest' or `:none'.  For output ports,
     `port-buffering', it may be one of `:full', `:line' or `:none'.
     *Note File ports::, for explanation of those modes.

     If `port-buffering' is applied to ports other than file ports, it
     returns `#f'.  If the setter of port-buffering is applied to ports
     other than file ports, it signals an error.

 -- Function: port-current-line port
     Returns the current line count of PORT.  This information is only
     available on file-based port, and as long as you're doing
     sequential character I/O on it.  Otherwise, this returns -1.

 -- Function: port-file-number port
     Returns an integer file descriptor, if the PORT is associated to
     the system file I/O.  Returns `#f' otherwise.

 -- Function: port-seek port offset &optional whence
     If the given PORT allows random access, this procedure sets the
     read/write pointer of the PORT according to the given OFFSET and
     WHENCE, then returns the updated offset (number of bytes from the
     beginning of the data).  If PORT is not random-accessible, `#f' is
     returned.  In the current version, file ports and input string
     ports are fully random-accessible.  You can only query the current
     byte offset of output string ports.

     Note that port position is represented by byte count, not
     character count.

     It is allowed to seek after the data if PORT is an output file
     port.  See POSIX lseek(2) document for details of the behavior.
     For input file port and input string port, you can't seek after
     the data.

     The WHENCE argument must be a small integer that represents from
     where OFFSET should be counted.   The following constant values
     are defined.

    `SEEK_SET'
          OFFSET represents the byte count from the beginning of the
          data.  This is the default behavior when WHENCE is omitted.

    `SEEK_CUR'
          OFFSET represents the byte count relative to the current
          read/write pointer.  If you pass 0 to OFFSET, you can get the
          current port position without changing it.

    `SEEK_END'
          OFFSET represents the byte count relative to the end of the
          data.

 -- Function: port-tell port
     Returns the current read/write pointer of PORT in byte count, if
     PORT is random-accessible.   Returns `#f' otherwise.  This is
     equivalent to the following call:
          (port-seek PORT 0 SEEK_CUR)

   _Note on the names_:  `Port-seek' is called `seek', `file-position'
or `input-port-position'/ `output-port-position' on some
implementations.  `Port-tell' is called `tell', `ftell' or
`set-file-position!'.   Some implementations have `port-position' for
different functionality.  CommonLisp has `file-position', but it is not
suitable for us since PORT need not be a file port.  `Seek' and `tell'
reflects POSIX name, and with Gauche naming convention we could use
`sys-seek' and `sys-tell'; however, PORT deals with higher level of
abstraction than system calls, so I dropped those names, and adopted
new names.

 -- Function: copy-port src dst &keyword (unit 0)
     Copies data from an input port SRC to an output port DST, until
     eof is read from SRC.

     The keyword argument UNIT may be zero, a positive exact integer, a
     symbol `byte' or a symbol `char', to specify the unit of copying.
     If it is an integer, a buffer of the size (in case of zero, a
     system default size) is used to copy, using block I/O.  Generally
     it is the fastest if you copy between normal files.   If UNIT is a
     symbol `byte', the copying is done byte by byte, using C-verson of
     `read-byte' and `write-byte'.  If UNIT is a symbol `char', the
     copying is done character by character, using C-version of
     `read-char' and `write-char'.


File: gauche-refe.info,  Node: File ports,  Next: String ports,  Prev: Common port operations,  Up: Input and output

6.19.4 File ports
-----------------

 -- Function: open-input-file filename &keyword if-does-not-exist
          buffering element-type
 -- Function: open-output-file filename &keyword if-does-not-exist
          if-exists buffering element-type
     [R5RS+] Opens a file FILENAME for input or output, and returns an
     input or output port associated with it, respectively.

     The keyword arguments specify precise behavior on the exceptional
     case.

    `:if-exists'
          This keyword argument can be specified only for
          `open-output-file', and specifies the action when the
          FILENAME already exists.  One of the following value can be
          given.
         `:supersede'
               The existing file is truncated.  This is the default
               behavior.

         `:append'
               The output data will be appended to the existing file.

         `:overwrite'
               The output data will overwrite the existing content.  If
               the output data is shorter than the existing file, the
               rest of existing file remains.

         `:error'
               An error is signalled.

         `#f'
               No action is taken, and the function returns `#f'.

    `:if-does-not-exist'
          This keyword argument specifies the action when FILENAME does
          not exist.
         `:error'
               An error is signalled.  This is the default behavior of
               `open-input-file'.

         `:create'
               A file is created.  This is the default behavior of
               `open-output-file'.  The check of file existence and
               creation is done atomically; you can exclusively create
               the file by specifying `:error' or `#f' to IF-EXISTS,
               along this option.  You can't specify this value for
               `open-input-file'.

         `#f'
               No action is taken, and the function returns `#f'.

    `:buffering'
          This argument specifies the buffering mode.  The following
          values are allowed.  The port's buffering mode can be get/set
          by `port-buffering'.  (*Note Common port operations::).
         `:full'
               Buffer the data as much as possible.  This is the
               default mode.

         `:none'
               No buffering is done.  Every time the data is written
               (to an output port) or read (from an input port), the
               underlying system call is used.  Process's standard
               error port is opened in this mode by default.

         `:line'
               This is valid only for output ports.  The written data
               is buffered, but the buffer is flushed whenever a
               newline character is written.  This is suitable for
               interactive output port.  Process's standard output port
               is opened in this mode by default.  (Note that this
               differs from the line buffering mode of C stdio, which
               flushes the buffer as well when input is requested from
               the same file descriptor.)

         `:modest'
               This is valid only for input ports.  This is almost the
               same as the mode `:full', except that `read-block' may
               return less data than requested if the requested amount
               of data is not immediately available.  (In the `:full'
               mode, `read-block' waits the entire data to be read).
               This is suitable for the port connected to a pipe or
               network.

    `:element-type'
          This argument specifies the type of the file.
         `:character'
               The file is opened in "character" (or "text") mode.

         `:binary'
               The file is opened in "binary" mode.
          _In the current version, this argument is ignored and all
          files are opened in binary mode.  It doesn't make difference
          in the Unix platforms._

     By combination of IF-EXISTS and IF-DOES-NOT-EXIST flags, you can
     implement various actions:
          (open-output-file "foo" :if-exists :error)
           => ;opens "foo" exclusively, or error

          (open-output-file "foo" :if-exists #f)
           => ;opens "foo" exclusively, or returns #f

          (open-output-file "foo" :if-exists :append
                                  :if-does-not-exist :error)
           => ;opens "foo" for append only if it already exists

     To check the existence of a file without opening it, use
     `sys-access' or `file-exists?' (*Note File stats::).

     Note: `gauche.charconv' module extends these procedures to take
     ENCODING keyword argument so that they can read or write in
     different character encoding scheme.  *Note Character code
     conversion::.

     Note for portability: Some Scheme implementations (e.g. STk) allows
     you to specify a command to FILENAME and reads from, or writes to,
     the subprocess standard input/output.  Some other scripting
     languages (e.g. Perl) have similar features.  In Gauche,
     `open-input-file' and `open-output-file' strictly operates on
     files (what the underlying OS thinks as files).  However, you can
     use "process ports" to invoke other command in a subprocess and to
     communicate it.  *Note Process ports::, for details.

 -- Function: call-with-input-file string proc &keyword
          if-does-not-exist buffering element-type
 -- Function: call-with-output-file string proc &keyword
          if-does-not-exist if-exists buffering element-type
     [R5RS] Opens a file specified by STRING for input/output, and call
     PROC with one argument, the file port.  When PROC returns, or an
     error is signalled from PROC that is not captured within PROC, the
     file is closed.

     The keyword arguments `if-exists', `element-type' and
     `if-does-not-exist' have the same meanings of `open-input-file'
     and `open-output-file''s.  Note that if you specify `#f' to
     IF-EXISTS and/or IF-DOES-NOT-EXIST, PROC may receive `#f' instead
     of a port object when the file is not opened.

     Returns the value(s) `proc' returned.

 -- Function: with-input-from-file string thunk &keyword
          if-does-not-exist buffering element-type
 -- Function: with-output-to-file string thunk &keyword
          if-does-not-exist if-exists buffering element-type
     [R5RS] Opens a file specified by STRING for input or output and
     makes the opened port as the current input or output port, then
     calls THUNK.  The file is closed when THUNK returns or an error is
     signalled from THUNK that is not captured within THUNK.

     Returns the value(s) `thunk' returns.

     The keyword arguments have the same meanings of `open-input-file'
     and `open-output-file''s, except that when `#f' is given to
     IF-EXISTS and IF-DOES-NOT-EXIST and the opening port is failed,
     THUNK isn't called at all and `#f' is returned as the result of
     `with-input-from-file' and `with-output-to-file'.

   _Notes on semantics of closing file ports:_ R5RS states, in the
description of `call-with-input-file' et al., that _"If _proc_ does not
return, then the port will not be closed automatically unless it is
possible to prove that the port will never again be used for read or
write operation."_

   Gauche's implementation slightly misses this criteria; the mere fact
that an uncaptured error is thrown in PROC does not prove the port will
never be used.  Nevertheless, it is very difficult to think the
situation that you can do meaningful operation on the port after such
an error is signalled; you'd have no idea what kind of state the port
is in.  In practical programs, you should capture error explicitly
inside PROC if you still want to do some meaningful operation with the
port.

   Note that if a continuation captured outside `call-with-input-file'
et al. is invoked inside PROC, the port is not closed.  It is possible
that the control returns later into the PROC, if a continuation is
captured in it (e.g. coroutines).  The low-level exceptions (*Note
Handling exceptions::) also doesn't ensure closing the port.

 -- Function: open-input-fd-port fd &keyword buffering name owner?
 -- Function: open-output-fd-port fd &keyword buffering name owner?
     Creates and returns an input or output port on top of the given
     file descriptor.  BUFFERING specifies the buffering mode as
     described in `open-input-file' entry above; the default is
     `:full'.  NAME is used for the created port's name and returned by
     `port-name'.  A boolean flag `owner?' specifies whether FD should
     be closed when the port is closed.

 -- Function: port-fd-dup! toport fromport
     Interface to the system call `dup2(2)'.  Atomically closes the
     file descriptor associated to TOPORT, creates a copy of the file
     descriptor associated to FROMPORT, and sets the new file
     descriptor to TOPORT.  Both TOPORT and FROMPORT must be file ports.
     Before the original file descriptor of TOPORT is closed, any
     buffered output (when TOPORT is an output port) is flushed, and
     any buffered input (when TOPORT is an input port) is discarded.

     `Copy' means that, even the two file descriptors differ in their
     values, they both point to the same system's open file table
     entry.  For example they share the current file position; after
     PORT-FD-DUP!, if you call `port-seek' on FROMPORT, the change is
     also visible from TOPORT, and vice versa.  Note that this
     'sharing' is in the system-level; if either TOPORT or FROMPORT is
     buffered, the buffered contents are not shared.

     This procedure is mainly intended for programs that needs to
     control open file descriptos explicitly; e.g. a daemon process
     would want to redirect its I/O to a harmless device such as
     `/dev/null', and a shell process would want to set up file
     descriptors before executing the child process.


File: gauche-refe.info,  Node: String ports,  Next: Coding-aware ports,  Prev: File ports,  Up: Input and output

6.19.5 String ports
-------------------

String ports are the ports that you can read from or write to memory.

 -- Function: open-input-string string
     [SRFI-6] Creates an input string port that has the content STRING.
     This is a more efficient way to access a string in order rather
     than using `string-ref' with incremental index.

          (define p (open-input-string "foo x"))
          (read p) => foo
          (read-char p) => #\space
          (read-char p) => #\x
          (read-char p) => #<eof>
          (read-char p) => #<eof>

 -- Function: get-remaining-input-string port
     PORT must be an input string port.  Returns the remaining content
     of the input port.  The internal pointer of PORT isn't moved, so
     the subsequent read from PORT isn't affected.  If PORT has already
     reached to EOF, a null string is returned.

          (define p (open-input-string "abc\ndef"))
          (read-line p)                  => "abc"
          (get-remaining-input-string p) => "def"
          (read-char p)                  => #\d
          (read-line p)                  => "ef"
          (get-remaining-input-string p) => ""

 -- Function: open-output-string
     [SRFI-6] Creates an output string port.   Anything written to the
     port is accumulated in the buffer, and can be obtained as a string
     by `get-output-string'.  This is a far more efficient way to
     construct a string sequentially than pre-allocate a string and
     fill it with `string-set!'.

 -- Function: get-output-string port
     [SRFI-6] Takes an output string port `port' and returns a string
     that has been accumulated to `port' so far.  If a byte data has
     been written to the port, this function re-scans the buffer to see
     if it can consist a complete string; if not, an incomplete string
     is returned.

     This doesn't affect the PORT's operation, so you can keep
     accumulating content to PORT after calling `get-output-string'.

 -- Function: call-with-input-string string proc
 -- Function: call-with-output-string proc
 -- Function: with-input-from-string string thunk
 -- Function: with-output-to-string thunk
     These utility functions are trivially defined as follows.  The
     interface is parallel to the file port version.
          (define (call-with-output-string proc)
            (let ((out (open-output-string)))
              (proc out)
              (get-output-string out)))

          (define (call-with-input-string str proc)
            (let ((in (open-input-string str)))
              (proc in)))

          (define (with-output-to-string thunk)
            (let ((out (open-output-string)))
              (with-output-to-port out thunk)
              (get-output-string out)))

          (define (with-input-from-string str thunk)
            (with-input-from-port (open-input-string str) thunk))

 -- Function: call-with-string-io str proc
 -- Function: with-string-io str thunk
          (define (call-with-string-io str proc)
            (let ((out (open-output-string))
                  (in  (open-input-string str)))
              (proc in out)
              (get-output-string out)))

          (define (with-string-io str thunk)
            (with-output-to-string
              (lambda ()
                (with-input-from-string str
                  thunk))))

 -- Function: write-to-string obj &optional writer
 -- Function: read-from-string string &optional start end
     These convenience functions cover common idioms using string ports.
          (write-to-string obj writer)
            ==
            (with-output-to-string (lambda () (writer obj)))

          (read-from-string string)
            ==
            (with-input-from-string string read)
     The default value of WRITER is the procedure `write'.  The default
     values of START and END is 0 and the length of STRING.

     Portability note: Common Lisp has these functions, with different
     optional arguments.  STk has `read-from-string' without optional
     argument.


File: gauche-refe.info,  Node: Coding-aware ports,  Next: Input,  Prev: String ports,  Up: Input and output

6.19.6 Coding-aware ports
-------------------------

A coding-aware port is a special type of procedural input port that is
used by `load' to read a program source.  The port recognizes the magic
comment to specify the character encoding of the program source, such
as `;; -*- coding: utf-8 -*-', and makes an appropriate character
encoding conversion.  See *note Multibyte scripts:: for the details of
coding magic comment.

 -- Function: open-coding-aware-port iport
     Takes an input port and returns an input coding aware port, which
     basically just pass through the data from IPORT to its reader.
     However, if a magic comment appears within the first two lines of
     data from IPORT, the coding aware port applies the necessary
     character encoding conversion to the rest of the data as they are
     read.

     The passed port, IPORT, is "owned" by the created coding-aware
     port.  That is, when the coding-aware port is closed, IPORT is
     also closed.  The content read from IPORT is buffered in the
     coding-aware port, so other code shouldn't read from IPORT.

     By default, Gauche's `load' uses a coding aware port to read the
     program source, so that the coding magic comment works for the
     Gauche source programs (see *note Loading Scheme file::).
     However, since the mechanism itself is independent from `load',
     you can use this port for other purposes; it is particularly
     useful to write a function that processes Scheme source programs
     which may have the coding magic comment.


File: gauche-refe.info,  Node: Input,  Next: Output,  Prev: Coding-aware ports,  Up: Input and output

6.19.7 Input
------------

For the input-related procedures, the optional IPORT argument must be
an input port, and when omitted, the current input port is assumed.

* Menu:

* Reading data::
* Read-time constructor::
* Input utility functions::


File: gauche-refe.info,  Node: Reading data,  Next: Read-time constructor,  Prev: Input,  Up: Input

6.19.7.1 Reading data
.....................

 -- Function: read &optional iport
     [R5RS] Reads an S-expression from IPORT and returns it.  Gauche
     recognizes the lexical structure specified in R5RS, and some
     additional lexical structures listed in *note Lexical structure::.

     If IPORT has already reached to the end of file, an eof object is
     returned.

     The procedure reads up to the last character that consists the
     S-expression, and leaves the rest in the port.  It's not like
     CommonLisp's `read', which consumes whitespaces after S-expression
     by default.

 -- Function: read-with-shared-structure &optional iport
 -- Function: read/ss &optional iport
     [SRFI-38] These procedures are defined in srfi-38 to recognize
     shared substructure notation (`#n=', `#n#').   Gauche's builtin
     `read' recognizes the srfi-38 notation, so these are just synonyms
     to `read'; these are only provided for srfi-38 compatibility.

 -- Function: read-char &optional iport
     [R5RS] Reads one character from IPORT and returns it.  If IPORT
     has already reached to the end, returns an eof object.  If the
     byte stream in IPORT doesn't consist a valid character, the
     behavior is undefined.  (In future, a port will have a option to
     deal with invalid characters).

 -- Function: peek-char &optional iport
     [R5RS] Reads one character in IPORT and returns it, keeping the
     character in the PORT.  If the byte stream in IPORT doesn't
     consist a valid character, the behavior is undefined.  (In future,
     a port will have a option to deal with invalid characters).

 -- Function: read-byte &optional iport
     Reads one byte from an input port IPORT, and returns it as an
     integer in the range between 0 and 255.  If IPORT has already
     reached EOF, an eof object is returned.

 -- Function: peek-byte &optional iport
     Peeks one byte at the head of an input port IPORT, and returns it
     as an integer in the range between 0 and 255.  If IPORT has
     already reached EOF, an eof object is returned.

 -- Function: read-line &optional iport allow-byte-string?
     Reads one line (a sequence of characters terminated by newline or
     EOF) and returns a string.  The terminating newline is not
     included.  This function recognizes popular line terminators (LF
     only, CRLF, and CR only).  If IPORT has already reached EOF, an
     eof object is returned.

     If a byte sequence is read from IPORT which doesn't constitute a
     valid character in the native encoding, `read-line' signals an
     error by default.  However, if a true value is given to the
     argument ALLOW-BYTE-STRING?, `read-line' returns a byte string
     (incomplete string) in such case, without reporting an error.  It
     is particularly useful if you read from a source whose character
     encoding is not yet known; for example, to read XML document, you
     need to check the first line to see if there is a charset parameter
     so that you can then use an appropriate character conversion port.

 -- Function: read-block nbytes &optional iport
     Reads NBYTES bytes from IPORT, and returns an incomplete string
     consisted by those bytes.  The size of returned string may shorter
     than NBYTES when IPORT doesn't have enough bytes to fill.  If
     NBYTES is zero, a null string is always returned.

     If IPORT has already reached EOF, an eof object is returned.

     If IPORT is a file port, the behavior of `read-block' differs by
     the buffering mode of the port (*Note File ports::, for the detail
     explanation of buffering modes).
        * If the buffering mode is `:full', `read-block' waits until
          NBYTES data is read, except it reads EOF.

        * If the buffering mode is `:modest' or `:none', `read-block'
          returns shorter string than NBYTES even if it doesn't reach
          EOF, but the entire data is not available immediately.

     `Read-block' returns newly allocated string every time.  If you
     want to avoid allocation and read the data into a pre-allocated
     fixed-length buffer, you can use `read-block!' in `gauche.uvector'
     module (*Note Uvector block I/O::).  It uses a uniform vector as
     the buffer.

     If you want to write a chunk of bytes to a port, you can use
     either `display' if the data is in string, or `write-block' in
     `gauche.uvector' (*Note Uvector block I/O::) if the data is in
     uniform vector.

 -- Function: eof-object
     [R6RS] Returns an EOF object.

 -- Function: eof-object? obj
     [R5RS] Returns true if OBJ is an EOF object.

 -- Function: char-ready? port
     [R5RS] If a character is ready to be read from PORT, returns `#t'.

     For now, this procedure actually checks only if next _byte_ is
     immediately available from PORT.   If the next byte is a part of a
     multibyte character, the attempt to read the whole character may
     block, even if `char-ready?' returns `#t' on the port.  (It is
     unlikely to happen in usual situation, but theoretically it can.
     If you concern, use `read-block' to read the input as a byte
     sequence, then use input string port to read characters.)

 -- Function: byte-ready? port
     If one byte (octet) is ready to be read from PORT, returns `#t'.


File: gauche-refe.info,  Node: Read-time constructor,  Next: Input utility functions,  Prev: Reading data,  Up: Input

6.19.7.2 Read-time constructor
..............................

Read-time constructor, defined in SRFI-10, provides an easy way to
create an external representation of user-defined structures.

 -- Reader Syntax: `#,(TAG ARG ...)'
     [SRFI-10] Gauche maintains a global table that associates a TAG
     (symbol) to _a constructor procedure_.

     When the reader encounters this syntax, it reads ARG ..., finds a
     reader constructor associated with TAG, and calls the constructor
     with ARG ... as arguments, then inserts the value returned by the
     constructor as the result of reading the syntax.

     Note that this syntax is processed inside the reader--the
     evaluator doesn't see any of ARGs, but only sees the object the
     reader returns.

 -- Function: define-reader-ctor TAG PROCEDURE
     [SRFI-10] Associates a reader constructor PROCEDURE with TAG.

     Examples:
          (define-reader-ctor 'pi (lambda () (* (atan 1) 4)))

          #,(pi) => 3.141592653589793

          '(#,(pi)) => (3.141592653589793)

          (define-reader-ctor 'hash
            (lambda (type . pairs)
              (let ((tab (make-hash-table type)))
                (for-each (lambda (pair)
                            (hash-table-put! tab (car pair) (cdr pair)))
                          pairs)
                tab)))

          (define table
           #,(hash eq? (foo . bar) (duh . dah) (bum . bom)))

          table => #<hash-table eq? 0x80f9398>
          (hash-table-get table 'duh) => dah

     Combined with `write-object' method (*Note Output::), it is easy
     to make a user-defined class written in the form it can be read
     back:

          (define-class <point> ()
            ((x :init-value 0 :init-keyword :x)
             (y :init-value 0 :init-keyword :y)))

          (define-method write-object ((p <point>) out)
            (format out "#,(<point> ~s ~s)" (ref p 'x) (ref p 'y)))

          (define-reader-ctor '<point>
            (lambda (x y) (make <point> :x x :y y)))


   _NOTE:_ The extent of the effect of `define-reader-ctor' is not
specified in SRFI-10, and might pose a compatibility problem among
implementations that support SRFI-10.  (In fact, the very existence of
`define-reader-ctor' is up to an implementation choice.)

   In Gauche, at least for the time being, `define-reader-ctor' take
effects as soon as the form is compiled and evaluated.  Since Gauche
compiles and evaluates each toplevel form in order, TAG specified in
`define-reader-ctor' can be used immediately after that.  However, it
doesn't work if the call of `define-reader-ctor' and the use of TAG is
enclosed in a `begin' form, for the entire `begin' form is compiled at
once before being evaluated.

   Other implementations may require to read the entire file before
making its `define-reader-ctor' call effective.  If so, it effectively
prevents one from using `define-reader-ctor' and the defined TAG in the
same file.   It is desirable to separate the call of
`define-reader-ctor' and the use of TAG in the different files if
possible.

   Another issue about the current `define-reader-ctor' is that it
modifies the global table of Gauche system, hence it is not modular.
The code written by different people might use the same tags, and yield
an unexpected result.   In future versions, Gauche may have some way to
encapsulate the scope of TAG, although the author doesn't have clear
idea yet.


File: gauche-refe.info,  Node: Input utility functions,  Prev: Read-time constructor,  Up: Input

6.19.7.3 Input utility functions
................................

 -- Function: port->string port
 -- Function: port->list reader port
 -- Function: port->string-list port
 -- Function: port->sexp-list port
     Generally useful input procedures.  The API is taken from scsh and
     STk.

     `port->string' reads PORT until EOF and returns the accumulated
     data as a string.

     `port->list' applies READER on PORT repeatedly, until READER
     returns an EOF, then returns the list of objects READER returned.

     `(port->string-list port)' == `(port->list read-line port)' , and
     `(port->sexp-list port)' == `(port->list read port)' .

 -- Function: port-fold fn knil reader
 -- Function: port-fold-right fn knil reader
 -- Function: port-for-each fn reader
 -- Function: port-map fn reader
     Convenient iterators over the input read by READER.  Basically,
     READER is called repeatedly without arguments and FN is called for
     each item it returns, until READER returns EOF.   Actually READER
     can be any thunk; it doesn't need to be related to input port.

     Suppose READER returns a series of items {X0, X1, ..., Xn}.
     `port-fold' returns the following:
          (fn Xn (fn Xn-1 ... (fn X0 knil)))
     while PORT-FOLD-RIGHT returns the following:
          (fn X0 (fn X1 ... (fn Xn knil)))
     That is, `(port-fold cons '() read)' returns a reverse list of all
     the inputs, while `(port-fold-right cons '() read)' returns the
     same thing as `(port->list read port)'.

     On the other hand, `port-for-each' and `port-map' applies FN to
     each item.  The former discards the results FN returns, while the
     latter returns a list of results.


File: gauche-refe.info,  Node: Output,  Prev: Input,  Up: Input and output

6.19.8 Output
-------------

For the following procedures, the optional PORT argument must be an
output port, and when omitted, the current output port is assumed.

 -- Function: write obj &optional port
 -- Function: display obj &optional port
     [R5RS] Produces a printable representation of an object OBJ to the
     output port.  `Write' uses object's standard external
     representation whenever possible, so that the written output would
     be read back by `read', whereas `display' produces more
     human-readable output.

     When `write' and `display' encounter an object of a user-defined
     class, they call the generic function `write-object'.

     These procedures may not stop when OBJ contains a cyclic structure.
     See `write/ss' below.

 -- Function: write-with-shared-structure obj &optional port
 -- Function: write/ss obj &optional port
 -- Function: write* obj &optional port
     [SRFI-38] Produces the output like `write', except that they
     recognize shared substructures and/or cyclic structures, and use
     `#n=' and `#n#' syntax to indicate them.

          (write/ss
            (let ((x (list 'a)))
              (list x x)))
           => ;; writes (#0=(a) #0#)

          (write/ss
            (let ((x (list 'a)))
              (set-cdr! x x)
              x))
           => ;; writes #0=(a . #0#)

     The `read' procedure can recognize this syntax, so when you read
     it back, you can get a structure which is isomorphic to the
     original one.

     Three procedures are the same.  Gauche has been used the name
     `write*' for long, which is taken from STklos.  However,
     `write-with-shared-structure' and `write/ss' have been introduced
     in srfi-38, so these names will be more portable.

     Note: The user-defined `write-object' methods work transparently
     for these procedures as well.

 -- Function: print expr ...
     Displays EXPRs (using `display') to the current output port, then
     writes a newline.

 -- Method: write-object (obj <object>) port
     You can customize how the object is printed out by this method.

 -- Function: newline &optional port
     [R5RS] Writes a newline character to PORT

 -- Function: flush &optional port
 -- Function: flush-all-ports
     Output the buffered data in PORT, or all ports, respectively.

     The function "flush" is called in variety of ways on the various
     Scheme implementations: `force-output' (Scsh, SCM), `flush-output'
     (Gambit), or `flush-output-port' (Bigloo).  The name `flush' is
     taken from STk and STklos.

 -- Function: write-char char &optional port
     [R5RS] Write a single character CHAR to the output port PORT.

 -- Function: write-byte byte &optional port
     Write a byte BYTE to the port.  BYTE must be an exact integer in
     range between 0 and 255.

 -- Function: format port string arg ...
 -- Function: format string arg ...
     [SRFI-28+] Format ARG ... according to STRING.  This function is a
     subset of CommonLisp's `format' function, with a bit of extension.
     It is also a superset of SRFi-28, Basic format strings (*note
     [SRFI-28]: srfi-28.).

     PORT specifies the destination; if it is an output port, the
     formatted result is written to it; if it is `#t', the result is
     written to the current output port; if it is `#f', the formatted
     result is returned as a string.  PORT can be omitted, as SRFI-28
     `format'; it has the same effects as giving `#f' to the PORT.

     STRING is a string that contains format directives.  A format
     directive is a character sequence begins with tilda, ``~'', and
     ends with some specific characters.  A format directive takes the
     corresponding ARG and formats it.  The rest of string is copied to
     the output as is.

          (format #f "the answer is ~s" 42)
            => "the answer is 42"

     The format directive can take one or more PARAMETERS, separated by
     comma characters.  A parameter may be an integer or a character;
     if it is a character, it should be preceded by a quote character.
     Parameter can be omitted, in such case the system default value is
     used.  The interpretation of the parameters depends on the format
     directive.

     Furthermore, a format directive can take two additional flags:
     atmark ``@'' and colon ``:''.  One or both of them may modify the
     behavior of the format directive.  Those flags must be placed
     immediately before the directive character.

     If a character ``v'' or ``V'' is in the place of the parameter,
     the value of the parameter is taken from the format's argument.
     The argument must be either an integer, a character, or `#f'
     (indicating that the parameter is effectively omitted).

     Some examples:

    `~10,2s'
          A format directive `~s', with two parameters, 10 and 2.

    `~12,,,'*A'
          A format directive `~a', with 12 for the first parameter and
          a character ``*'' for the fourth parameter.  The second and
          third parameters are omitted.

    `~10@d'
          A format directive `~d', with 10 for the first parameter and
          ``@'' flag.

    `~v,vx'
          A format directive `~x', whose first and second parameter will
          be taken from the arguments.

     The following is a complete list of the supported format
     directives.  Either upper case or lower case character can be used
     for the format directive; usually they have no distinction, except
     noted.

    ~MINCOL,COLINC,MINPAD,PADCHAR,MAXCOLA
          Ascii output.  The corresponding argument is printed by
          `display'.  If an integer MINCOL is given, it specifies the
          minimum number of characters to be output; if the formatted
          result is shorter than MINCOL, a whitespace is padded to the
          right (i.e. the result is left justified).

          The COLINC, MINPAD and PADCHAR parameters control, if given,
          further padding.  A character PADCHAR replaces the padding
          character for the whitespace.  If an integer MINPAD is given
          and greater than 0, at least MINPAD padding character is
          used, regardless of the resulting width.  If an integer COLINC
          is given, the padding character is added (after MINPAD) in
          chunk of COLINC characters, until the entire width exceeds
          MINCOL.

          If atmark-flag is given, the format result is right
          justified, i.e.  padding is added to the left.

          The MAXCOL parameter, if given, limits the maximum number of
          characters to be written.  If the length of formatted string
          exceeds MAXCOL, only MAXCOL characters are written.  If
          colon-flag is given as well and the length of formatted string
          exceeds MAXCOL, MAXCOL - 4 characters are written and a
          string "` ...'" is attached after it.

               (format #f "|~a|" "oops")
                 => "|oops|"
               (format #f "|~10a|" "oops")
                 => "|oops      |"
               (format #f "|~10@a|" "oops")
                 => "|      oops|"
               (format #f "|~10,,,'*@a|" "oops")
                 => "|******oops|"

               (format #f "|~,,,,10a|" '(abc def ghi jkl))
                 => "|(abc def gh|"
               (format #f "|~,,,,10:a|" '(abc def ghi jkl))
                 => "|(abc de ...|"

    ~MINCOL,COLINC,MINPAD,PADCHAR,MAXCOLS
          S-expression output.  The corresponding argument is printed
          by `write'.  The semantics of parameters and flags are the
          same as `~A' directive.

               (format #f "|~s|" "oops")
                 => "|\"oops\"|"
               (format #f "|~10s|" "oops")
                 => "|\"oops\"    |"
               (format #f "|~10@s|" "oops")
                 => "|    \"oops\"|"
               (format #f "|~10,,,'*@s|" "oops")
                 => "|****\"oops\"|"

    ~MINCOL,PADCHAR,COMMACHAR,INTERVALD
          Decimal output.  The argument is formatted as an decimal
          integer.  If the argument is not an integer, all parameters
          are ignored (after processing ``v'' parameters) and it is
          formatted by `~A' directive.

          If an integer parameter MINCOL is given, it specifies minimum
          width of the formatted result; if the result is shorter than
          it, PADCHAR is padded on the left (i.e. the result is right
          justified).  The default of PADCHAR is a whitespace.

               (format #f "|~d|" 12345)
                 => "|12345|"
               (format #f "|~10d|" 12345)
                 => "|     12345|"
               (format #f "|~10,'0d|" 12345)
                 => "|0000012345|"

          If atmark-flag is given, the sign ``+'' is printed for the
          positive argument.

          If colon-flag is given, every INTERVAL-th digit of the result
          is grouped and COMMACHAR is inserted between them.  The
          default of COMMACHAR is ``,'', and the default of INTERVAL is
          3.

               (format #f "|~:d|" 12345)
                 => "|12,345|"
               (format #f "|~,,'_,4:d|" -12345678)
                 => "|-1234_5678|"

    ~MINCOL,PADCHAR,COMMACHAR,INTERVALB
          Binary output.  The argument is formatted as a binary integer.
          The semantics of parameters and flags are the same as the
          `~D' directive.

    ~MINCOL,PADCHAR,COMMACHAR,INTERVALO
          Octal output.  The argument is formatted as an octal integer.
          The semantics of parameters and flags are the same as the
          `~D' directive.

    ~MINCOL,PADCHAR,COMMACHAR,INTERVALX

    ~MINCOL,PADCHAR,COMMACHAR,INTERVALx
          Hexadecimal output.  The argument is formatted as a
          hexadecimal integer.  If ``X'' is used, upper case alphabets
          are used for the digits larger than 10.  If ``x'' is used,
          lower case alphabets are used.  The semantics of parameters
          and flags are the same as the `~D' directive.

               (format #f "~8,'0x" 259847592)
                 => "0f7cf5a8"
               (format #f "~8,'0X" 259847592)
                 => "0F7CF5A8"

    ~COUNT*
          Moves the argument counter COUNT times forward, effectively
          skips next COUNT arguments.  The default value of COUNT is 1,
          hence skip the next argument.  If a colon-flag is given,
          moves the argument counter backwards, e.g. `~:*' makes the
          next directive to process last argument again.  If an
          atmark-flag is given, COUNT specifies absolute position of
          the arguments, starting from 0.



File: gauche-refe.info,  Node: Loading Programs,  Next: Comparison and sorting,  Prev: Input and output,  Up: Core library

6.20 Loading Programs
=====================

* Menu:

* Loading Scheme file::
* Loading dynamic library::
* Require and provide::
* Autoload::
* Operations on libraries::


File: gauche-refe.info,  Node: Loading Scheme file,  Next: Loading dynamic library,  Prev: Loading Programs,  Up: Loading Programs

6.20.1 Loading Scheme file
--------------------------

 -- Function: load file &keyword paths (error-if-not-found #t)
          environment ignore-coding
     [R5RS+] Loads FILE, that is, read Scheme expressions in FILE and
     evaluates them.  An extension "`.scm'" may be omitted from FILE.

     If FILE doesn't begin with "/" or "./" or "../", it is searched
     from the system file search list, stored in a variable
     `*load-path*'.  Or you can explicitly specify the search path by
     passing a list of directory names to the keyword argument PATHS.

     On success, `load' returns `#t'.  If the specified file is not
     found, an error is signalled unless the keyword argument
     ERROR-IF-NOT-FOUND is `#f', in which case `load' returns `#f'.

     By default, `load' uses a coding-aware port (*Note Coding-aware
     ports::) so that the "`coding:'" magic comment at the beginning of
     the source file is effective.  (See *note Multibyte scripts::, for
     the details of the coding magic comment).  If a true value is
     given to the keyword argument IGNORE-CODING, `load' doesn't create
     the coding-aware port and directly reads from the file port.

     If a module is given to the keyword argument ENVIRONMENT, `load'
     works as if the given module is selected at the beginning of the
     loaded file.

     The current module is preserved; even `select-module' is called in
     FILE, the module in which `load' is called is restored afterwards.

     If you want to load a library file, it's better to use ``use''
     (*Note Defining and selecting modules::), or ``require'' described
     below.  *Note Compilation::, for difference between `load' and
     `require'.

 -- Variable: *load-path*
     Keeps a list of directories that are searched by `load' and
     `require'.

     If you want to add other directories to the search path, do not
     modify this variable directly; use `add-load-path', described
     below, instead.

 -- Special Form: add-load-path path &optional (afterp #f)
     Adds a path PATH to the library load path list.  If a true value
     is given to AFTERP, PATH is added after the existing paths;
     otherwise, PATH is added before the existing paths.

     Use this form instead of changing `*load-path*' directly.  This
     form is a special form and recognized by the compiler; if you
     change `*load-path*', it is in effect at run time, and that may be
     too late for "use" or "require".

     Furthermore, `add-load-path' looks for the architecture dependent
     directories under the specified path and if it exists, sets up the
     internal path list for dynamic loading correctly.   Suppose you
     have your Scheme module in `/home/yours/lib', and that requires a
     dynamic loadable library.  You can put the library under
     `/home/yours/lib/ARCH/', where ARCH is the value
     `(gauche-architecture)' returns (*Note Environment Inquiry::).
     Then you can have compiled libraries for multiple platforms and
     Gauche can still find the right library.

 -- Function: load-from-port port
     Reads Scheme expressions from an input port PORT and evaluates
     them, until EOF is read.

     Note that unless you pass a coding-aware port to PORT, the
     "`coding:'" magic comment won't be handled.

 -- Function: current-load-port
 -- Function: current-load-history
 -- Function: current-load-next
     These procedures allows you to query the current context of
     loading.  They returns the following values when called inside a
     file being loaded:
    `current-load-port'
          Returns the port object from which the file is being read.

    `current-load-history'
          Returns a list of pairs of a port and a line number (integer),
          representing the nesting of loads.  Suppose you load
          `foo.scm', and from its line 7 it loads `bar.scm', and from
          its line 18 it loads `baz.scm'.   If you call
          `current-load-history' in the file `baz.scm', you'll get
               ((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))

    `current-load-next'
          Returns a list of remaining directories to be searched at the
          time this file is found.   Suppose the `*load-path*' is `("."
          "../lib" "/home/gauche/lib" "/share/gauche/lib")' and you
          load `foo.scm', which happens to be in `../lib/'.  Then,
          inside `foo.scm', `current-load-next' returns:
               ("/home/gauche/lib" "/share/gauche/lib")

     When called outside of `load', these procedures returns `#f', `()'
     and `()', respectively.


File: gauche-refe.info,  Node: Loading dynamic library,  Next: Require and provide,  Prev: Loading Scheme file,  Up: Loading Programs

6.20.2 Load dynamic library
---------------------------

 -- Function: dynamic-load file &keyword init-function export-symbols
     Loads and links a dynamic loadable library (shared library) FILE.
     FILE shouldn't contain the suffix (".so" on most systems);
     `dynamic-load' adds it, for it may differ among platforms.

     The keyword argument INIT-FUNCTION specifies the initialization
     function name of the library in a string.  By default, if the file
     basename (without extension) is "foo", the initialization function
     name is "Scm_Init_foo".

     The keyword argument EXPORT-SYMBOLS tells whether the dynamic
     loader that the external symbols in FILE should be appended to the
     symbol table of the running process.  (Note: I'm talking about C
     function and variable names, not Scheme symbols).  By default, the
     symbols in FILE are not visible from other dynamically loaded
     libraries.  If you want to allow other dynamically loaded
     libraries to call C function in your library, you should give `#t'
     to this argument.  It sets `RTLD_GLOBAL' flag for `dlopen()'.

     Usually a dynamic loadable library is provided with wrapping Scheme
     module, so the user doesn't have to call this function directly.

     There's no way to unload the loaded libraries.


File: gauche-refe.info,  Node: Require and provide,  Next: Autoload,  Prev: Loading dynamic library,  Up: Loading Programs

6.20.3 Require and provide
--------------------------

`Require' and `provide' are a traditional Lisp way to ensure loading a
library file only once.  If you require a _feature_ for the first time,
a library file that provides it is loaded and the fact that the
_feature_ is provided is memorized.  Subsequent request of the same
feature doesn't need to load the file.

   In Gauche, the `use' syntax (*Note Using modules::) hides the
require mechanism under the hood so you hardly need to see these forms.
These are provided just in case if you want to do some non-trivial
management of libraries and thus want to bypass Gauche's standard
mechanism.

 -- Special Form: require feature
     If FEATURE is not loaded, load it.  FEATURE must be a string, and
     it is taken as a file name (without suffix) to be loaded.  This
     loading takes place at compile time.

     If you load SLIB module, `require' is extended.  *Note SLIB:: for
     details.

     If the loaded file does not contain `provide' form at all, the
     FEATURE is automatically provided, as if `(provide FEATURE)' is
     called at the end of the loaded file.  We call this _autoprovide_
     feature.

 -- Function: provide feature
     Adds FEATURE to the system's provided feature list, so that the
     subsequent `require' won't load the same file again.

     Because of the autoproviding, i.e. `require' automatically
     provides the required feature, you hardly need to use a `provide'
     form explcitily.   There are a couple of scenarios that you may
     want to use a `provide' form:

        * To provide a feature (or features) that is/are different from
          the one that caused loading the file.

          Suppose feature X supesedes feature Y and providing
          compatible APIs of Y but with different implementation.  Once
          `X.scm' is loaded, you don't want `Y.scm' to be loaded; so
          you want to tell the user that `X.scm' also provides the
          feature Y.  Adding `(provide "X")' and `(provide "Y")' at the
          end of `X.scm' accomplish that.  (Note: If you add a provide
          form, `require' no longer autoprovides the feature, so you
          need to specify `(provide "X")' in `X.scm' explicitly to
          provide X as well.)

          Of course, this doens't prevent users from loading `Y.scm' by
          specifing `(require "Y")' before `(require "X")'.  It should
          be considered just as a workaround in a production where
          other solutions are costly, instead of a permanent solution.

        * To provide no features at all.  Passing `#f' as FEATURE
          prevents autoproviding by `require' without providing any
          feature.

          This should also be a temporary solution.  One possible
          scenario is that you are changing `X.scm' very frequently
          during development and you want `(require "X")' always causes
          loading the file.  Don't forget to remove `(provide #f)' when
          you release the file, though.  Besides, for interactive
          reloading, consider using `gauche.reload' (*Note Reloading
          modules::) instead.


 -- Function: provided? feature
     Returns `#t' if FEATURE is already provided.


File: gauche-refe.info,  Node: Autoload,  Next: Operations on libraries,  Prev: Require and provide,  Up: Loading Programs

6.20.4 Autoload
---------------

 -- Macro: autoload file/module item ...
     Sets up ITEM ... to be autoloaded.  That is, when an ITEM is
     referenced for the first time, FILE/MODULE is loaded before the
     ITEM is evaluated.  This delays the loading of FILE/MODULE until
     it is needed.

     You can specify either a string file name or a symbol module name
     to FILE/MODULE.  If it is a string, the named file is loaded.  If
     it is a symbol, the named module is loaded (using the same rule as
     of `use'), then the binding of ITEM in the FILE/MODULE is imported
     to the module used the autoload (*Note Defining and selecting
     modules::, for details of `use').

     ITEM can be either a variable name (symbol), or a form `(:macro
     SYMBOL)'.  If it is a variable, the named file/module is loaded
     when the variable is about to be evaluated.  If it is the latter
     form, the named file/module is loaded when a form `(SYMBOL arg
     ...)' is about to be _compiled_, which enables autoloading macros.

     FILE/MODULE must define SYMBOL in it, or an error is signalled
     when FILE/MODULE is autoloaded.

     The following is an example of autoloading procedures.
          (autoload "foo" foo0 foo1)
          (autoload "bar" bar0 bar1)

          (define (foobar x)
            (if (list? x)
                (map bar0 x)
                (foo0)))

          (foobar '(1 2)) ; "bar" is loaded at this moment

          (foobar #f)     ; "foo" is loaded at this moment

     Note that if you set to autoload macro, the file/module is loaded
     immediately when such form that uses the macro is compiled,
     regardless of the piece of the code is executed or not.


File: gauche-refe.info,  Node: Operations on libraries,  Prev: Autoload,  Up: Loading Programs

6.20.5 Operations on libraries
------------------------------

There are several procedures you can use to check if certain libraries
and/or modules are installed in the system.

   In the following descriptions, PATTERN is either a symbol or a
string.  If it is a symbol, it specifies a module name (e.g.
`foo.bar').  If it is a string, it specifies a partial pathname of the
library (e.g. `"foo/bar"'), which will be searched under library search
paths.  You can also use glob-like metacharacters '`*'' and '`?'' in
PATTERN.

 -- Function: library-fold pattern proc seed &keyword paths strict?
          allow-duplicates?
     A basic iterator for library/module files.  This procedure
     searches Scheme program files which matches PATTERN, under
     directories listed in PATHS (the default is the standard file load
     paths, `*load-path*').  For each matched file, it calls PROC with
     three arguments: the matched module or library name, the full path
     of the program file, and the state value.  SEED is used as the
     initial state value, and the value PROC returns is used as the
     state value for the next call of PROC.  The value returned from
     the last PROC becomes the return value of `library-fold'.

     If PATTERN is a symbol and the keyword argument STRICT?  is `#t'
     (which is the default), this procedure calls `library-has-module?'
     on the files whose name seems to match the given pattern of module
     name, in order to find out the file really implements the module.
     It can be a time consuming process if you try to match large
     number of modules; you can pass `#f' to STRICT? to avoid the extra
     check.  If PATTERN is a string, matching is done only for file
     names so STRICT? is ignored.

     By default, if there are more than one files that have the same
     name that matches PATTERN in PATHS, only the first one appears in
     PATHS is taken.  This gives you the file you'll get if you use
     `require' or `use' for that library.  If you want to iterate all
     of matching files, pass `#t' to the ALLOW-DUPLICATES? keyword
     argument.

     Here are some examples (the result may differ in your environment).
          (library-fold 'srfi-1 acons '())
           => ((srfi-1 . "../lib/srfi-1.scm"))

          (library-fold "srfi-1" acons '())
           => (("srfi-1" . "../lib/srfi-1.scm"))

          ;; Note the returned list is in a reverse order of
          ;; how `acons' is called.
          (library-fold 'srfi-1 acons '() :allow-duplicates? #t)
           => ((srfi-1 . "/usr/share/gauche/0.7.1/lib/srfi-1.scm")
             (srfi-1 . "../lib/srfi-1.scm"))

          ;; In the following cases, the module name doesn't match,
          ;; but the filename does.
          (library-fold 'srfi-19.* acons '())
           => ()

          (library-fold "srfi-19/*" acons '())
           => (("srfi-19/read-tai" . "../lib/srfi-19/read-tai.scm")
             ("srfi-19/format" . "../lib/srfi-19/format.scm"))

          ;; Finds available dbm implementations
          (library-fold 'dbm.* acons '())
           => ((dbm.cdb . "/usr/share/gauche/0.7.1/lib/dbm/cdb.scm")
             (dbm.gdbm . "../lib/dbm/gdbm.scm")
             (dbm.ndbm . "../lib/dbm/ndbm.scm")
             (dbm.odbm . "../lib/dbm/odbm.scm"))

 -- Function: library-map pattern proc &keyword paths allow-duplicates?
          strict?
 -- Function: library-for-each pattern proc &keyword paths
          allow-duplicates? strict?
     `Map' and `for-each' version of iterator over matched
     libraries/modules.  See `library-fold' above for detailed
     operation of matching and the meanings of keyword arguments.

     PROC receives two arguments, the matched module/library name and
     full path of the file.  `Library-map' returns a list of results of
     PROC.  `Library-for-each' discards the results.

          (library-map 'srfi-4 list :allow-duplicates? #t)
           => ((srfi-4 "../lib/srfi-4.scm")
                      (srfi-4 "/usr/share/gauche/0.7.1/lib/srfi-4.scm"))

          (library-map 'dbm.* (lambda (m p) m))
           => (dbm.odbm dbm.ndbm dbm.gdbm dbm.cdb)

 -- Function: library-exists? mod/path &keyword paths force-search?
          strict?
     Search a library or a module specified by MOD/PATH, and returns a
     true value if it finds one.  PATHS and STRICT?  keyword arguments
     have the same meaning as `library-fold'.

     Unlike the iterator procedures above, this procedure first checks
     loaded libraries and modules in the calling process, and returns
     true if it finds MOD/PATH in it, without looking into the
     filesystem.   Passing `#t' to FORCE-SEARCH? keyword arguments
     skips the checking of loaded libraries and modules.

 -- Function: library-has-module? path module
     Returns `#t' iff a file specified by PATH exists and appears to
     implement a module named by `module'.  PATH must be an actual
     filename.

          (library-has-module? "./test/foo/bar.scm" 'foo.bar)
           => #t ;; if ./test/foo/bar.scm implements module foo.bar.

     This procedure assumes a typical layout of the source code to
     determine if the given file implements the module, i.e., it reads
     the first form of the code and see if it is a `define-module' form
     that is defining the given module.


File: gauche-refe.info,  Node: Comparison and sorting,  Next: System interface,  Prev: Loading Programs,  Up: Core library

6.21 Comparison and sorting
===========================

 -- Function: compare obj1 obj2
     A general comparison procedure.  Returns -1 if OBJ1 is less than
     OBJ2, 0 if OBJ1 is equal to OBJ2, and 1 if OBJ1 is greater than
     OBJ2.  Signals an error if OBJ1 and OBJ2 are incomparable.

     Some built-in types are handled by this procedure reflecting
     "natural" order of comparison.  Other built-in types are generally
     uncomparable.  For Scheme-defined classes, this procedure calls a
     generic function `object-compare'.

 -- Generic Function: object-compare obj1 obj2
     Specializing this generic function extends `compare' procedure for
     user-defined classes.

 -- Function: sort seq &optional cmpfn
 -- Function: sort! seq &optional cmpfn
     Sorts elements in a sequence SEQ (a list or a vector) in ascending
     order and returns the sorted sequence.  `sort!' destructively
     reuses the original sequence.  The sorting order is specified by
     `cmpfn', which is a procedure takes two elements of SEQ, and
     returns `#t' if the first argument strictly precedes the second.

     Note that it is not guaranteed that, after `sort!', SEQ points to
     a sorted sequence.  if SEQ is a list, the first pair of the
     original SEQ may no longer be the first in the sorted sequence.
     Always use the returned value of `sort!'.

          (sort '(("Chopin" "Frederic")
                  ("Liszt" "Franz")
                  ("Alkan" "Charles-Valentin"))
                (lambda (x y) (string<? (car x) (car y))))
            => (("Alkan" "Charles-Valentin")
                ("Chopin" "Frederic")
                ("Liszt" "Franz"))

     When CMPFN is omitted, the `compare' procedure is used to
     determine which element is _less_.

     In the current implementation, quicksort and heapsort algorithm is
     used when CMPFN is omitted, and merge sort algorithm is used when
     CMPFN is given.  This might be changed later.

     If you want to keep a sorted set of objects to which you add
     objects one at at time, you can also use treemaps (*Note
     Treemaps::).

 -- Function: stable-sort seq &optional cmpfn
 -- Function: stable-sort! seq &optional cmpfn
     Sort a sequence SEQ (a list or a vector), using stable sort
     algorithm (currently they are using merge sort).  The sorting
     order is specified by `cmpfn', which is a procedure takes two
     elements of LIST, and returns `#t' if the first argument strictly
     precedes the second.

 -- Function: sort-by seq key &optional cmpfn
 -- Function: sort-by! seq key &optional cmpfn
 -- Function: stable-sort-by seq key &optional cmpfn
 -- Function: stable-sort-by! seq key &optional cmpfn
     Sorts SEQ, by comparing the key values obtained by applying the
     KEY procedure to each element of SEQ.  The code `(stable-sort-by
     seq key cmp)' returns the same result as the following code:

          (stable-sort seq (lambda (a b) (cmp (key a) (key b))))

     Besides more compact notation, `sort-by' family procedures
     guarantee that KEY procedure is called at most the number of
     elements in SEQ.  In the above example using `stable-sort', KEY
     may be called NlogN or even more times where N is the number of
     elements in SEQ.  So `sort-by' etc. are good if the KEY procedure
     is a relatively heavy operation.

     The trade-off is the space; `sort-by' family consumes extra space
     to save all the key values, which is proportional to the number of
     elements.


File: gauche-refe.info,  Node: System interface,  Next: Development helper API,  Prev: Comparison and sorting,  Up: Core library

6.22 System interface
=====================

Gauche supports most of POSIX.1 functions and other system functions
popular among Unix variants as built-in procedures.

   Lots of Scheme implementations provide some sort of system interface
under various APIs.  Some are just called by different names (e.g,
`delete-file' or `remove-file' or `unlink' to delete a file), some do
more abstraction introducing new Scheme objects.  Instead of just
picking one of such interfaces, I decided to implement Gauche's system
interface API in two layers; the lower level layer, described in this
section, follows the operating system's API as close as possible.  On
top of that, the higher-level APIs are provided, with considering
compatibility to the existing systems.

   The low level system interface has the name `sys-'NAME and usually
correspond to the system call NAME.  I tried to keep the interface
similar whenever reasonable.

   Gauche restarts a system call after it is interrupted by a signal.
See *note Signal:: for the details.

   If you are familiar with system programming in C, see also *note C
to Scheme mapping::, which shows correspondence between C standard
library functions and Gauche procedures.

* Menu:

* Program termination::
* Environment Inquiry::
* Filesystems::
* Unix groups and users::
* Locale::
* Signal::
* System inquiry::
* Time::
* Unix process management::
* I/O multiplexing::
* Miscellaneous system calls::


File: gauche-refe.info,  Node: Program termination,  Next: Environment Inquiry,  Prev: System interface,  Up: System interface

6.22.1 Program termination
--------------------------

Gauche has a few ways to terminate itself (other than returning from
`main').  The `exit' procedure is a graceful way with all proper
cleanups.  `sys-exit' and `sys-abort' may be used in emergency where
proper cleanup is impossible.

 -- Function: exit &optional (code 0) (fmtstr #f) args ...
     [POSIX] Terminates the current process with the exit code CODE.
     CODE must be zero or positive exact integer.  When a string is
     given to FMTSTR, it is passed to `format' (*Note Output::), with
     the rest arguments ARGS, to produce a message to the standard
     error port (_not_ the current error port; see *note Common port
     operations::).

     In fact, the exitting procedure is a bit more complicated.  The
     precise steps of exitting is as follow.

       1. The value of parameter `exit-handler' is checked.  If it is
          not `#f', the value is called as a procedure with three
          arguments: CODE, FMTSTR, and a list of rest arguments.  It is
          the default procedure of `exit-handler' that prints out the
          message to the standard error port.  If an error occurs
          within exit handler, it is captured and discarded.  Other
          exceptions are not caught.

       2. The AFTER thunks of the active dynamic winds are invoked.
          Any exceptions raised in AFTER thunks are captured and
          discarded.

       3. The clean-up handlers registered via C API
          `Scm_AddCleanupHandler' are invoked.  These are usually
          responsible for under-the-hood cleanup jobs for each
          application that embeds Gauche.  From the Scheme world
          there's not much to care.

       4. The unclosed output buffered ports are flushed.

       5. The process exits with CODE as an exit code, via `exit(3)'.

     The `exit-handler' mechanism allows the application to hook its
     exit operation.   Note that it is not for simple cleanup jobs;
     `dynamic-wind', `guard' or `unwind-protect' are more appropriate.
     `exit-handler' is for more specific use just upon application exit.
     For example, GUI applications may want to post a dialog instead of
     printing to stderr.

     For this reason, the library code shouldn't change `exit-handler';
     only the application knows what to do when it exits.

     Another useful case is when you want to call a third-party code
     which calls `exit' inside.  In that case you may swap the
     `exit-handler' for the one that raises a non-error exception while
     calling the third-party code.  Non-error exception isn't caught in
     `exit', effectivelly interrupts the steps explained above.   (Yet
     the AFTER thunks of dynamic handlers are processed just like
     normal exception handling case.)  Your appication code can then
     capture the exception.  You can use `parameterize' to swap
     `exit-handler' dynamically and thread-safely (*Note Parameters::).

          (guard (e [(eq? e 'exit-called) (handle-exit-as-desired)])
            (parameterize ((exit-handler (lambda (c f a) (raise 'exit-called))))
              (call-third-party-library)))

     Generally, calling `exit' while other threads are running should
     be avoided, since it only rewinds the dynamic handlers active in
     the calling threads, and other threads will be killed abruptly.
     If you have to do so for some reason, you may be able to use
     `exit-handler' to tell to other threads that the application is
     exitting.  (There's no general way, and Gauche doesn't even have a
     list of all running threads; it's application's responsibility).

     Note on design: Some languages integrates exit handling into
     exception handling, treating exit as a kind of exception.  It is a
     tempting idea, so much that we've tried it.  It didn't work out
     well in Gauche; a big annoyance was that when an AFTER thunk
     raised an exception during rewinding `dynamic-wind's, it shadowed
     the original _exit_ exception.

 -- Function: exit-handler &optional new-handler
     When called without argument, returns the value of the current exit
     handler.  When called with an argument, sets NEW-HANDLER as the
     value of the exit handler, and returns the previous value of the
     exit handler.    NEW-HANDLER must be a procedure that takes three
     arguments, or `#f'.

     The value of exit handler is thread-specific, and the default value
     is inherited from the value of the current exit handler of the
     parent thread.  `exit-handler' can be used as if it's a parameter
     in the `parameterize' macro (*Note Parameters::).

 -- Function: sys-exit code
     [POSIX] Terminates the current process with the exit code CODE.
     CODE must be zero or positive exact integer.  This procedure calls
     `_exit(2)' directly.  No cleanup is done.  Unflushed file output
     is discarded.

 -- Function: sys-abort
     [POSIX] Calls POSIX abort().  This usually terminates the running
     process and dumps core.  No cleanup is done.


File: gauche-refe.info,  Node: Environment Inquiry,  Next: Filesystems,  Prev: Program termination,  Up: System interface

6.22.2 Environment Inquiry
--------------------------

 -- Function: sys-getenv name
     [POSIX] Returns the value of the environment variable NAME as a
     string, or `#f' if the environment variable is not defined.

 -- Function: sys-environ
     Returns the current environment as a list of strings.  Each string
     is a form of `NAME=VALUE', where `NAME' is the name of the
     environment variable and `VALUE' is its value.  `NAME' never
     contains a character `#\='.  This is useful when you want to
     obtail the all enviroment variables of the current process.  Use
     `sys-getenv' if you want to query a specific environment variable.

 -- Function: sys-environ->alist &optional envlist
     A convenience procedure for `sys-environ'.  When the list of
     environment strings (like what `sys-environ' returns) is given to
     ENVLIST, this procedure splits name and value of each environment
     variable and returns an assoc list.

     When ENVLIST is omitted, this procedure calls `sys-environ' to get
     the current environment variables.

          (sys-environ->alist '("A=B" "C=D=E"))
            => (("A" . "B") ("C" . "D=E"))

 -- Function: sys-putenv name value
     Add environment variable NAME with VALUE to the current process's
     environment.  If the system doesn't support putenv(3), this
     function signals an error.

 -- Function: gauche-version
 -- Function: gauche-architecture
 -- Function: gauche-library-directory
 -- Function: gauche-architecture-directory
 -- Function: gauche-site-library-directory
 -- Function: gauche-site-architecture-directory
     These functions returns a string that tells information about
     Gauche interpreter itself.


File: gauche-refe.info,  Node: Filesystems,  Next: Unix groups and users,  Prev: Environment Inquiry,  Up: System interface

6.22.3 Filesystems
------------------

System calls that deal with filesystems.  See also *note Filesystem
utilities::, which defines high-level APIs on top of the procedures
described here.

* Menu:

* Directories::
* Directory manipulation::
* Pathnames::
* File stats::
* Other file operations::


File: gauche-refe.info,  Node: Directories,  Next: Directory manipulation,  Prev: Filesystems,  Up: Filesystems

6.22.3.1 Directories
....................

See also *note Directory utilities:: for high-level API.

 -- Function: sys-readdir path
     PATH must be a string that denotes valid pathname of an existing
     directory.  This function returns a list of strings of the
     directory entries.  The returned list is not sorted.  An error is
     signalled if PATH doesn't exists or is not a directory.

 -- Function: glob pattern &keyword separator folder
 -- Function: sys-glob pattern &keyword separator folder
     Provides a traditional Unix glob(3) functionality; returns a list
     of pathnames that matches the given PATTERN.

     This feature used to be a wrapper of system-provided `glob'
     function, hence it was named `sys-glob'.  However, as of Gauche
     version 0.8.12, it was reimplemented in Scheme on top of other
     system calls, to overcome incompatibilies between platforms and
     for the opportunity to put more functionalities.  So we renamed it
     `glob'.  The old name `sys-glob' is kept for compatibility, but new
     programs should use `glob'.

     The PATTERN argument may be a single _glob pattern_, or a list of
     glob patterns.  If a list is given, pathnames that matches any one
     of the pattern are returned.  If you're a unix user, you already
     know how it works.

          gosh> (glob "*.scm")
          ("test.scm" "ext.scm")
          gosh> (glob "src/*.[ch]")
          ("src/ext.c" "src/ext.h")
          gosh> (glob '("*.scm" "src/*.c"))
          ("src/ext.c" "test.scm" "ext.scm")

     Unlike shell's glob, if there's no matching pathnames, `()' is
     returned.

     In fact, globbing is a very useful tool to search hierarchical
     data structure in general, not limited to the filesystems.  So the
     `glob' function is implemented separately from the filesystem.
     Using keyword arguments, you can glob from any kind of tree data
     structure.  It is just that their default values are set to look at
     the filesystems.

     The SEPARATOR argument should be a char-set, and used to split the
     PATTERN into components.  Its default is `#[/]'.  It is not used
     to the actual pathnames to match.

     The FOLDER is a procedure that walks through the data structure.
     It is called with five arguments:

          (folder PROC SEED PARENT REGEXP NON-LEAF?)

     PROC is a procedure that takes two arguments.  The FOLDER should
     call PROC with every node in the PARENT whose component name
     matches REGEXP, passing around the seed value just like `fold'.
     It should return the final value returned by PROC.  For example,
     if `cons' is given to PROC and `()' is given to SEED, the return
     value of the folder is a list of nodes that matches the REGEXP.

     The representation of a node is up to the implementation of
     FOLDER.  It can be a pathname, or some sort of objects, or
     anything.  The `glob' procedure does not care what it is; the
     `glob' procedure merely passes the node to subsequent call to
     `folder' as PARENT argument, or returns a list of nodes as the
     result.

     The PARENT argument is basically a node, and FOLDER traverses its
     children to find the match.  The exception is the initial call of
     FOLDER-- at the beginning `glob' knows nothing about each node.
     When `glob' needs to match an absolute path, it passes `#t', and
     when `glob' needs to match a relative path, it passes `#f', as the
     initial PARENT value.

     The REGEXP argument is used to filter the child nodes.  It should
     be matched against the component name of the child, not including
     its directory names.  As a special case, it can be a symbol `dir';
     if that's the case, the folder should return NODE itself, but it
     may indicate NODE _as a directory_; e.g. if NODE is represented as
     a pathname, the folder returns a pathname with trailing directory
     separator.  As special cases, if NODE is a boolean value and
     REGEXP is `dir', the folder should return the node representing
     root node or current node, respectively; e.g. if NODE is
     represented as a pathname, the folder may return `"/"' and `"./"'
     for those cases.

     The NON-LEAF argument is a boolean flag.  If it is true, the
     filter should omit the leaf nodes from the result (e.g. only
     include the directories).

     Now, here's the precise spec of glob pattern matching.

     Each glob pattern is a string to match pathname-like strings.

     A pathname-like string is a string consists of one or more
     _components_, separated by _separator_s.  The default separator is
     `#[/]'; you can change it with SEPARATOR keyword argument.  A
     component cannot contain separators, and cannot be a null string.
     Consecutive separators are regarded as a single separator.  A
     pathname-like string optionally begins with, and/or ends with a
     separator character.

     A glob pattern is also consists of components and separator
     characters.  In a component, following characters/syntax have
     special meanings.

    `*'
          When it appears at the beginning of a component, it matches
          zero or more characters except a period (`.').  And it won't
          match if the component of the input string begins with a
          period.

          Otherwise, it matches zero or more sequence of any characters.

    `**'
          If a component is just `**', it matches zero or more number
          of components that match `*'.  For example, `src/**/*.h'
          matches all of the following patterns.
               src/*.h
               src/*/*.h
               src/*/*/*.h
               src/*/*/*/*.h
               ...

    `?'
          When it appears at the beginning of a component, it matches a
          character except a period (`.').  Othewrise, it matches any
          single character.

    `[chars]'
          Specifies a character set.  Matches any one of the set.  The
          syntax of chars is the same as Gauche's character set syntax
          (*Note Character set::).  For the compatibility of the
          traditional glob, the `!' character can be used to complement
          the character set, e.g. `[!abc]' is the same as `[^abc]'.

 -- Function: glob-fold pattern proc seed &keyword separator folder
     This is actually a low-level construct of the glob function.
     Actually, GLOB is simply written like this:
          (define (glob patterns . opts)
            (apply glob-fold patterns cons '() opts))

     The meaning of PATTERN, SEPARATOR and FOLDER is the same as
     explained above.

     For each pathname that matches PATTERN, `glob-fold' calls PROC
     with the pathname and a seed value.  The initial seed value is
     SEED, and the value PROC returns becomes the next seed value.  The
     result of the last call to PROC becomes the result of `glob-fold'.
     If there's no matching pathnames, PROC is never called and SEED is
     returned.

 -- Function: make-glob-fs-fold &keyword root-path current-path
     This is a utility function to generate a procedure suitable to
     pass the FOLDER keyword argument of `glob-fold' and `glob'.
     Without arguments, this returns the same procedure which is used
     in `glob-fold' and `glob' by default.

     The keyword arguments ROOT-PATH and CURRENT-PATH specify the paths
     where `glob-fold' starts to search.

          gosh> (glob "/tmp/*.scm")
          ("/tmp/x.scm" "/tmp/y.scm")
          gosh> (glob "/*.scm"
                      :folder (make-glob-fs-fold :root-path "/tmp"))
          ("/tmp/x.scm" "/tmp/y.scm")
          gosh> (glob "*.scm"
                      :folder (make-glob-fs-fold :current-path "/tmp"))
          ("/tmp/x.scm" "/tmp/y.scm")

   *Note File stats::, to check if a path is actually a directory.


File: gauche-refe.info,  Node: Directory manipulation,  Next: Pathnames,  Prev: Directories,  Up: Filesystems

6.22.3.2 Directory manipulation
...............................

 -- Function: sys-remove filename
     [POSIX] If FILENAME is a file it is removed.  On some systems this
     may also work on an empty directory, but portable scripts
     shouldn't depend on it.

 -- Function: sys-rename old new
     [POSIX] Renames a file OLD to NEW.  The new name can be in
     different directory from the old name, but both paths must be on
     the same device.

 -- Function: sys-tmpnam
     [POSIX] Creates a file name which is supposedly unique, and
     returns it.  This is in POSIX, but its use is discouraged because
     of potential security risk.  Use `sys-mkstemp' below if possible.

 -- Function: sys-mkstemp template
     Creates and opens a file that has unique name, and returns two
     values; opened port and the created filename.  The file is created
     exclusively, avoiding race conditions.   TMPNAME is used as the
     prefix of the file.  Unlike Unix's mkstemp, you don't need padding
     characters.  The file is opened for writing, and its permission is
     set to 600.

 -- Function: sys-link existing new
     [POSIX] Creates a hard link named NEW to the existing file
     EXISTING.

 -- Function: sys-unlink pathname
     [POSIX] Removes PATHNAME.  It can't be a directory.  Returns `#t'
     if it is successfully removed, or #F if PATHNAME doesn't exist.
     An error is signalled otherwise.

 -- Function: sys-symlink existing new
     Creates a symbolic link named NEW to the pathname EXISTING.  On
     systems that doesn't support symbolic links, this function is
     unbound.

 -- Function: sys-readlink path
     If a file specified by PATH is a symbolic link, its content is
     returned.  If PATH doesn't exist or is not a symbolic link, an
     error is signalled.  On systems that don't support symbolic links,
     this function is unbound.

 -- Function: sys-mkdir pathname mode
     [POSIX] Makes a directory PATHNAME with mode MODE.  (Note that
     MODE is masked by the current umask; see `sys-umask' below).  The
     parent directory of PATHNAME must exist and be writable by the
     process.  To create intermediate directories at once, use
     `make-directory*' in `file.util' (*note Directory utilities::).

 -- Function: sys-rmdir pathname
     [POSIX] Removes a directory PATHNAME.  The directory must be empty.
     To remove a directory with its contents, use `remove-directory*'
     in `file.util' (*note Directory utilities::).

 -- Function: sys-umask &optional mode
     [POSIX] Sets umask setting to MODE.  Returns previous umask
     setting.  If MODE is omitted or `#f', just returns the current
     umask without changing it.  See `man umask' for more details.


File: gauche-refe.info,  Node: Pathnames,  Next: File stats,  Prev: Directory manipulation,  Up: Filesystems

6.22.3.3 Pathnames
..................

See also *note Pathname utilities::, for high-level APIs.

 -- Function: sys-normalize-pathname pathname &keyword absolute expand
          canonicalize
     Converts PATHNAME according to the way specified by keyword
     arguments.  More than one keyword argument can be specified.
    `absolute'
          If this keyword argument is given and true, and PATHNAME is
          not   an absolute pathname, it is converted to an absolute
          pathname by   appending the current working directory in
          front of PATHNAME.

    `expand'
          If this keyword argument is given and true, and PATHNAME
          begins   with ``~'', it is expanded as follows:
             *     If PATHNAME is consisted entirely by "`~'", or begins
                  with "`~/'", then the character "`~'" is replaced
               for the pathname of the current user's home directory.

             *     Otherwise, characters following ``~'' until either
               ``/'' or     the end of PATHNAME are taken as a user
               name, and the user's     home directory is replaced in
               place of it.  If there's no such     user, an error is
               signalled.

    `canonicalize'
          Tries to remove pathname components "`.'" and "`..'".    The
          pathname interpretation is done purely in textural level, i.e.
           it doesn't access filesystem to see the conversion reflects
          the   real files.  It may be a problem if there's a symbolic
          links to   other directory in the path.

 -- Function: sys-basename pathname
 -- Function: sys-dirname pathname
     `sys-basename' returns a basename, that is the last component of
     PATHNAME.  `sys-dirname' returns the components of PATHNAME but
     the last one.   If PATHNAME has a trailing ``/'', it is simply
     ignored.
          (sys-basename "foo/bar/bar.z") => "bar.z"
          (sys-basename "coo.scm") => "coo.scm"
          (sys-basename "x/y/") => "y"
          (sys-dirname "foo/bar/bar.z") => "foo/bar"
          (sys-dirname "coo.scm") => "."
          (sys-dirname "x/y/") => "x"
     These functions doesn't check if PATHNAME really exists.

     Some boundary cases:
          (sys-basename "") => ""
          (sys-dirname "") => "."

          (sys-basename "/") => ""
          (sys-dirname "/") => "/"
     Note: The above behavior is the same as Perl's `basename' and
     `dirname'.   On some systems, the command `basename' may return
     `"/"' for the argument `"/"', and `"."' for the argument `"."'.

 -- Function: sys-realpath pathname
     `sys-realpath' returns an absolute pathname of PATHNAME that does
     not include "`.'", "`..'" or symbolic links.  If PATHNAME does not
     exist, it includes a dangling symbolic link, or the caller doesn't
     have enough permission to access to the path, an error is
     signalled.

     Note: the POSIX `realpath(3)' function is known to be unsafe, so
     Gauche avoids using it and implements `sys-realpath' in its own.


File: gauche-refe.info,  Node: File stats,  Next: Other file operations,  Prev: Pathnames,  Up: Filesystems

6.22.3.4 File stats
...................

See also *note File attribute utilities::, for high-level APIs.

 -- Function: file-exists? path
 -- Function: file-is-regular? path
 -- Function: file-is-directory? path
     Returns true if PATH exists, is a regular file, or is a directory,
     respectively.   The latter two returns false if PATH doesn't exist
     at all.

     These functions are built on top of primitive system interfaces
     described below; I provide these for convenience and compatibility
     (STk has the same functions).

 -- Builtin Class: <sys-stat>
     An object that represents `struct stat', attributes of an entry in
     the filesystem.   It has the following read-only slots.

      -- Instance Variable of <sys-stat>: type
          A symbol represents the type of the file.
          `regular'         a regular file
          `directory'       a directory
          `character'       a character device
          `block'           a block device
          `fifo'            a fifo
          `symlink'         a symbolic link
          `socket'          a socket
          If the file type is none of the above, `#f' is returned.

          Note: Some operating systems don't have the `socket' file type
          and returns `fifo' for socket files.   Portable programs
          should check both possibilities to see if the given file is a
          socket.

      -- Instance Variable of <sys-stat>: perm
          An exact integer for permission bits of `struct stat'.  It is
          the same as lower 9-bits of "mode" slot; provided for the
          convenience.

      -- Instance Variable of <sys-stat>: mode
      -- Instance Variable of <sys-stat>: ino
      -- Instance Variable of <sys-stat>: dev
      -- Instance Variable of <sys-stat>: rdev
      -- Instance Variable of <sys-stat>: nlink
      -- Instance Variable of <sys-stat>: uid
      -- Instance Variable of <sys-stat>: gid
      -- Instance Variable of <sys-stat>: size
          An exact integer for those information of `struct stat'.

      -- Instance Variable of <sys-stat>: atime
      -- Instance Variable of <sys-stat>: mtime
      -- Instance Variable of <sys-stat>: ctime
          A number of seconds since Unix Epoch for those information of
          `struct stat'.

 -- Function: sys-stat path
 -- Function: sys-fstat port-or-fd
     [POSIX] Returns a `<sys-stat>' object of PATH, or the underlying
     file of PORT-OR-FD, which may be a port or a positive exact
     integer file descriptor, respectively.

     If PATH is a symbolic link, a stat of the file the link points to
     is returned from `sys-stat'.

     If PORT-OR-FD is not associated to a file, `sys-fstat' returns
     `#f'.

 -- Function: sys-lstat path
     Like `sys-stat', but it returns a stat of a symbolic link if PATH
     is a symbolic link.

     gosh> (describe (sys-stat "gauche.h"))
     #<<sys-stat> 0x815af70> is an instance of class <sys-stat>
     slots:
       type      : regular
       perm      : 420
       mode      : 33188
       ino       : 845140
       dev       : 774
       rdev      : 0
       nlink     : 1
       uid       : 400
       gid       : 100
       size      : 79549
       atime     : 1020155914
       mtime     : 1020152005
       ctime     : 1020152005

 -- Function: sys-stat->mode stat
 -- Function: sys-stat->ino stat
 -- Function: sys-stat->dev stat
 -- Function: sys-stat->rdev stat
 -- Function: sys-stat->nlink stat
 -- Function: sys-stat->size stat
 -- Function: sys-stat->uid stat
 -- Function: sys-stat->gid stat
 -- Function: sys-stat->atime stat
 -- Function: sys-stat->mtime stat
 -- Function: sys-stat->ctime stat
 -- Function: sys-stat->file-type stat
     *Deprecated*.  Use `slot-ref' to access information of
     `<sys-stat>' object.

 -- Function: sys-access pathname amode
     [POSIX] Returns a boolean value of indicating whether access of
     PATHNAME is allowed in AMODE.   This procedure signals an error if
     used in a suid/sgid program (see the note below).  AMODE can be a
     combinations (logical or) of following predefined flags.
    `R_OK'
          Checks whether PATHNAME is readable by the current user.

    `W_OK'
          Checks whether PATHNAME is writable by the current user.

    `X_OK'
          Checks whether PATHNAME is executable (or searchable in case
          PATHNAME is a directory) by the current user.

    `F_OK'
          Checks whether PATHNAME exists or not, regardless of the
          access permissions of PATHNAME.  (But you need to have access
          permissions of the directories containing PATHNAME).

     _Note:_ Access(2) is known to be a security hole if used in
     suid/sgid program to check the real user's priviledge of accessing
     the file.

 -- Function: sys-chmod path mode
 -- Function: sys-fchmod port-or-fd mode
     Change the mode of the file named PATH or an opened file specified
     by PORT-OR-FD to MODE.  MODE must be a small positive integer
     whose lower 9 bits specifies POSIX style permission.

 -- Function: sys-chown path owner-id group-id
     Change the owner and/or group of the file named PATH to OWNER-ID
     and GROUP-ID respectively.  OWNER-ID and GROUP-ID must be an exact
     integer.  If either of them is -1, the corresponding ownership is
     not changed.

 -- Function: sys-utime path &optional atime mtime
     Change the file's access time and modification time to ATIME and
     MTIME, respectively.   If ATIME and MTIME is omitted, they are set
     to the current time.  See also `touch-file' (*Note File
     operations::).


File: gauche-refe.info,  Node: Other file operations,  Prev: File stats,  Up: Filesystems

6.22.3.5 Other file operations
..............................

 -- Function: sys-chdir dir
     [POSIX] An interface to `chdir(2)'.  See also `current-directory'
     (*Note Directory utilities::).

 -- Function: sys-pipe &keyword (buffering :line)
     [POSIX] Creates a pipe, and returns two ports.  The first returned
     port is an input port and the second is an output port.  The data
     put to the output port can be read from the input port.

     BUFFERING can be `:full', `:line' or `:none', and specifies the
     buffering mode of the ports opened on the pipe.  *Note File
     ports::, for details of the buffering mode.  The default mode is
     sufficient for typical cases.

          (receive (in out) (sys-pipe)
            (display "abc\n" out)
            (flush out)
            (read-line in)) => "abc"

     Note: the returned value is changed from version 0.3.15, in which
     `sys-pipe' returned a list of two ports.

 -- Function: sys-mkfifo path mode
     [POSIX] creates a fifo (named pipe) with a name PATH and mode
     MODE.  MODE must be a positive exact integer to represent the file
     mode.

 -- Function: sys-isatty port-or-fd
     [POSIX] PORT-OR-FD may be a port or an integer file descriptor.
     Returns `#t' if the port is connected to the console, `#f'
     otherwise.

 -- Function: sys-ttyname port-or-fd
     [POSIX] PORT-OR-FD may be a port or an integer file descriptor.
     Returns the name of the terminal connected to the port, or `#f' if
     the port is not connected to a terminal.

 -- Function: sys-truncate path length
 -- Function: sys-ftruncate port-or-fd length
     [POSIX] Truncates a regular file named by PATH or referenced by
     PORT-OR-FD to a size of LENGTH bytes.  If the file is larger than
     LENGTH bytes, the extra data is discarded.  If the file is smaller
     than that, zero is padded.


File: gauche-refe.info,  Node: Unix groups and users,  Next: Locale,  Prev: Filesystems,  Up: System interface

6.22.4 Unix groups and users
----------------------------

Unix groups
...........

 -- Builtin Class: <sys-group>
     Unix group information.  Has following slots.

      -- Instance Variable of <sys-group>: name
          Group name.

      -- Instance Variable of <sys-group>: gid
          Group id.

      -- Instance Variable of <sys-group>: passwd
          Group password.

      -- Instance Variable of <sys-group>: mem
          List of user names who are in this group.


 -- Function: sys-getgrgid gid
 -- Function: sys-getgrnam name
     [POSIX] Returns `<sys-group>' object from an integer group id GID
     or a group name NAME, respectively.  If the specified group
     doesn't exist, `#f' is returned.

 -- Function: sys-gid->group-name gid
 -- Function: sys-group-name->gid name
     Convenience function to convert between group id and group name.

Unix users
..........

 -- Builtin Class: <sys-passwd>
     Unix user information.  Has following slots.

      -- Instance Variable of <sys-passwd>: name
          User name.

      -- Instance Variable of <sys-passwd>: uid
          User ID.

      -- Instance Variable of <sys-passwd>: gid
          User's primary group id.

      -- Instance Variable of <sys-passwd>: passwd
          User's (encrypted) password.  If the system uses the shadow
          password file, you just get obscure string like "x".

      -- Instance Variable of <sys-passwd>: gecos
          Gecos field.

      -- Instance Variable of <sys-passwd>: dir
          User's home directory.

      -- Instance Variable of <sys-passwd>: shell
          User's login shell.

      -- Instance Variable of <sys-passwd>: class
          User's class (only available on some systems).


 -- Function: sys-getpwuid uid
 -- Function: sys-getpwnam name
     [POSIX] Returns `<sys-passwd>' object from an integer user id UID
     or a user name NAME, respectively.  If the specified user doesn't
     exist, `#f' is returned.

 -- Function: sys-uid->user-name uid
 -- Function: sys-user-name->uid name
     Convenience functions to convert between user id and user name.

Password encryption
...................

 -- Function: sys-crypt key salt
     This is the interface to `crypt(3)'.   KEY and SALT must be a
     string, and an encrypted string is returned.  On systems where
     `crypt(3)' is not available, call to this function signals an
     error.


File: gauche-refe.info,  Node: Locale,  Next: Signal,  Prev: Unix groups and users,  Up: System interface

6.22.5 Locale
-------------

 -- Function: sys-setlocale category locale
     [POSIX] Sets the locale of the category CATEGORY to the locale
     LOCALE.  CATEGORY must be an exact integer; the following
     pre-defined variables are available.  LOCALE must be a string
     locale name.  Returns the locale name on success, or `#f' if the
     system couldn't change the locale.

 -- Variable: LC_ALL
 -- Variable: LC_COLLATE
 -- Variable: LC_CTYPE
 -- Variable: LC_MONETARY
 -- Variable: LC_NUMERIC
 -- Variable: LC_TIME
     Predefined variables for possible CATEGORY value of
     `sys-setlocale'.

 -- Function: sys-localeconv
     [POSIX] Returns an assoc list of various information for
     formatting numbers in the current locale.

   An example session.  It may differ on your system settings.
     (sys-localeconv)
      =>
        ((decimal_point . ".") (thousands_sep . "")
         (grouping . "") (int_curr_symbol . "")
         (currency_symbol . "") (mon_decimal_point . "")
         (mon_thousands_sep . "") (mon_grouping . "")
         (positive_sign . "") (negative_sign . "")
         (int_frac_digits . 127) (frac_digits . 127)
         (p_cs_precedes . #t) (p_sep_by_space . #t)
         (n_cs_precedes . #t) (n_sep_by_space . #t)
         (p_sign_posn . 127) (n_sign_posn . 127))

     (sys-setlocale LC_ALL "fr_FR")
      => "fr_FR"

     (sys-localeconv)
      =>
       ((decimal_point . ",") (thousands_sep . "")
        (grouping . "") (int_curr_symbol . "FRF ")
        (currency_symbol . "F") (mon_decimal_point . ",")
        (mon_thousands_sep . " ") (mon_grouping . "\x03\x03")
        (positive_sign . "") (negative_sign . "-")
        (int_frac_digits . 2) (frac_digits . 2)
        (p_cs_precedes . #f) (p_sep_by_space . #t)
        (n_cs_precedes . #f) (n_sep_by_space . #t)
        (p_sign_posn . 1) (n_sign_posn . 1))


File: gauche-refe.info,  Node: Signal,  Next: System inquiry,  Prev: Locale,  Up: System interface

6.22.6 Signal
-------------

Gauche can send out operating system's signals to the other processes
(including itself) and can handle the incoming signals.

   In multithread environment, all threads share the signal handlers,
and each thread has its own signal mask.  See *note Signals and
threads::, for details.

   When a system call is interrupted by a signal, and a programmer
defines a handler for the signal that doesn't transfer control to other
context, the system call is restarted after the handler returns.

* Menu:

* Signals and signal sets::
* Sending signals::
* Handling signals::
* Masking and waiting signals::
* Signals and threads::


File: gauche-refe.info,  Node: Signals and signal sets,  Next: Sending signals,  Prev: Signal,  Up: Signal

6.22.6.1 Signals and signal sets
................................

Each signal is referred by its signal number (a small integer) defined
on the underlying operating system.  Variables are pre-defined to the
system's signal number.  System's signal numbers may be architecture
dependent, so you should use those variables rather than using literal
integers.

 -- Variable: SIGABRT
 -- Variable: SIGALRM
 -- Variable: SIGCHLD
 -- Variable: SIGCONT
 -- Variable: SIGFPE
 -- Variable: SIGHUP
 -- Variable: SIGILL
 -- Variable: SIGINT
 -- Variable: SIGKILL
 -- Variable: SIGPIPE
 -- Variable: SIGQUIT
 -- Variable: SIGSEGV
 -- Variable: SIGSTOP
 -- Variable: SIGTERM
 -- Variable: SIGTSTP
 -- Variable: SIGTTIN
 -- Variable: SIGTTOU
 -- Variable: SIGUSR1
 -- Variable: SIGUSR2
     These variables are bound to the signal numbers of POSIX signals.

 -- Variable: SIGTRAP
 -- Variable: SIGIOT
 -- Variable: SIGBUS
 -- Variable: SIGSTKFLT
 -- Variable: SIGURG
 -- Variable: SIGXCPU
 -- Variable: SIGXFSZ
 -- Variable: SIGVTALRM
 -- Variable: SIGPROF
 -- Variable: SIGWINCH
 -- Variable: SIGPOLL
 -- Variable: SIGIO
 -- Variable: SIGPWR
     These variables are bound to the signal numbers of system-dependent
     signals.  Not all of them may be defined on some systems.

   Besides each signal numbers, you can refer to a set of signals using
a `<sys-sigset>' object.  It can be used to manipulate the signal mask,
and to install a signal handler to a set of signals at once.

 -- Class: <sys-sigset>
     A set of signals.   An empty sigset can be created by
          (make <sys-sigset>) => #<sys-sigset []>

 -- Function: sys-sigset signal ...
     Creates and returns an instance of `<sys-sigset>' with members
     SIGNAL ....  Each SIGNAL may be either a signal number, another
     `<sys-sigset>' object, or `#t' for all available signals.

          (sys-sigset SIGHUP SIGINT) => #<sys-sigset [HUP|INT]>

 -- Function: sys-sigset-add! sigset signal ...
 -- Function: sys-sigset-delete! sigset signal ...
     SIGSET must be a `<sys-sigset>' object.  Those procedures adds and
     removes the specified signals from SIGSET respectively, and
     returns the result.  SIGSET itself is also modified.

     SIGNAL may be either a signal number, another `<sys-sigset>'
     object, or `#t' for all available signals.

 -- Function: sys-sigset-fill! sigset
 -- Function: sys-sigset-empty! sigset
     Fills SIGSET by all available signals, or empties SIGSET.

 -- Function: sys-signal-name signal
     Returns the human-readable name of the given signal number.  (Note
     that signal numbers are system-dependent.)

          (sys-signal-name 2) => "SIGINT"


File: gauche-refe.info,  Node: Sending signals,  Next: Handling signals,  Prev: Signals and signal sets,  Up: Signal

6.22.6.2 Sending signals
........................

To send a signal, you can use `sys-kill' which works like `kill(2)'.

 -- Function: sys-kill pid sig
     [POSIX] Sends a signal SIG to the specified process(es).  SIG must
     be a positive exact integer.  PID is an exact integer and
     specifies the target process(es):
        * If PID is positive, it is the target process id.

        * If PID is zero, the signal is sent to every process in the
          process group of the current process.

        * If PID is less than -1, the signal is sent to every process in
          the process group -PID.

   There's no Scheme equivalence for `raise()', but you can use
`(sys-kill (sys-getpid) SIG)'.


File: gauche-refe.info,  Node: Handling signals,  Next: Masking and waiting signals,  Prev: Sending signals,  Up: Signal

6.22.6.3 Handling signals
.........................

You can register signal handling procedures in Scheme.  (In multithread
environment, signal handlers are shared by all threads; see *note
Signals and threads:: for details).

   When a signal is delivered to the Scheme process, the VM just
records it and processes it later at a 'safe point' where the state of
VM is consistent.  We call the signal is _pending_ when it is
registered by the VM but not processed yet.

   (Note that this makes handling of some signals such as `SIGILL'
useless, for the process can't continue sensible execution after
recording the signal).

   If the same signal is delivered more than once before VM processes
the first one, the second one and later have no effect.  (This is
consistent to the traditioncal Unix signal model.)  In other words, for
each VM loop a signal handler can be invoked at most once per each
signal.

   When too many signals of the same kind are pending, Gauche assumes
something has gone wrong (e.g. infinite loop inside C-routine) and
aborts the process.  The default of this limit is set rather low (3),
to allow unresponsive interactive script to be terminated by typing
Ctrl-C three times.  Note that the counter is individual for each
signal; Gauche won't abort if one `SIGHUP' and two `SIGINT's are
pending, for example.  You can change this limit by
`set-signal-pending-limit' described below.

   When you're using the `gosh' interpreter, the default behavior for
each signal is as in the following table.

`SIGABRT, SIGILL, SIGKILL, SIGCONT, SIGSTOP, SIGSEGV, SIGBUS'
     Cannot be handled in Scheme.  `Gosh' follows the system's default
     behavior.

`SIGCHLD, SIGTSTP, SIGTTIN, SIGTTOU, SIGWINCH'
     No signal handles are installed for these signals by `gosh',
     so the process follows the system's default behavior.
     Scheme programs can install its own signal handler if necessary.

`SIGHUP, SIGQUIT, SIGTERM'
     `Gosh' installs a signal handler for these signals        that
     exits from the application with code 0.

`SIGPWR, SIGXCPU, SIGUSR1, SIGUSR2'
     On Linux platforms with thread support, these signals are used
       by the system and not available for Scheme.  On other systems,
         these signals behaves the same as described below.

`other signals'
     `Gosh' installs the default signal handler, which raises
     `<unhandled-signal-error>' condition (see *note Conditions::).
     Scheme programs can override it by its own signal handler.

   If you're using Gauche embedded in some other application, it may
redefine the default behavior.

   Use the following procedures to get/set signal handlers from Scheme.

 -- Function: set-signal-handler! signals handler &optional sigmask
     SIGNALS may be a single signal number or a `<sys-sigset>' object,
     and HANDLER should be either `#t', `#f' or a procedure that takes
     one argument.  If HANDLER is a procedure, it will be called when
     the process receives one of specified signal(s), with the received
     signal number as an argument.

     By default, the signals in SIGNALS are blocked (in addition to the
     signal mask in effect at that time) during HANDLER is executed, so
     that HANDLER won't be reentered by the same signal(s).  You can
     provide a `<sys-sigset>' object to the SIGMASK arg to specify the
     signals to be blocked explicitly.  Note that the signal mask is
     per-thread; if more than one thread unblocks a signal, the handler
     may still be invoked during execution of the handler (in other
     thread) even if you specify SIGMASK.  You have to set the threads'
     signal mask properly to avoid such situation.

     It is safe to do anything in HANDLER, including throwing an error
     or invoking continuation captured elsewhere.  (However,
     continuations captured inside HANDLER will be invalid once you
     return from HANDLER).

     If HANDLER is `#t', the operating system's default behavior is set
     to the specified signal(s).  If HANDLER is `#f', the specified
     signals(s) will be ignored.

     Note that signal handler setting is shared among threads in
     multithread enviornment.  The handler is called from the thread
     which is received the signal.  See *note Signals and threads:: for
     details.

 -- Function: get-signal-handler signum
 -- Function: get-signal-handler-mask signum
     Returns the handler setting, or signal mask setting, of a signal
     SIGNUM, respectively.

 -- Function: get-signal-handlers
     Returns an associative list of all signal handler settings.  Car
     of each element of returned list is a `<sys-sigset>' object, and
     cdr of it is the handler (a procedure or a boolean value) of the
     signals in the set.

 -- Function: get-signal-pending-limit
 -- Function: set-signal-pending-limit limit
     Gets/sets the maximum number of pending signals per each signal
     type.  If the number of pending signals exceeds this limit, Gauche
     aborts the process.  See the explanation at the beginning of this
     section for the details.  LIMIT must be a nonnegative exact
     integer.  In the current implementaiton the maximum number of
     LIMIT is 255.  Setting limit to zero makes the number of pending
     signals unlimited.

 -- Macro: with-signal-handlers (handler-clause ...) thunk
     A convenience macro to install signal handlers temporarily during
     execution of THUNK.  (Note: though this is convenient, this has
     certain dangerous properties described below.  Use with caution.)

     Each HANDLER-CLAUSE may be one of the following forms.
    `(SIGNALS EXPR ...)'
          SIGNALS must be an expression that will yield either a signal,
          a list of signals, or a `<sys-sigset>' object.  Installs a
          signal handler for SIGNALS that evaluates EXPR ... when one
          of the signals in SIGNALS is delivered.

    `(SIGNALS => HANDLER)'
          This form sets the handler of SIGNALS to HANDLER, where
          HANDLER should be either `#t', `#f' or a procedure that takes
          one argument.

          If HANDLER is a procedure, it will be called when the process
          receives one of specified signal(s), with the received signal
          number as an argument.  If HANDLER is `#t', the operating
          system's default behavior is set to the specified signal(s).
          If HANDLER is `#f', the specified signals(s) will be ignored.

     When the control exits from THUNK, the signal handler setting
     before `with-signal-handlers' are recovered.

     _CAVEAT:_ If you're setting more than one signal handlers, they
     are installed in serial.  If a signal is delivered before all the
     handlers are installed, the signal handler state may be left
     inconsistent.  Also note that the handler setting is a global
     state; you can't set "thread local" handler by
     `with-signal-handlers', although the form may be misleading.


File: gauche-refe.info,  Node: Masking and waiting signals,  Next: Signals and threads,  Prev: Handling signals,  Up: Signal

6.22.6.4 Masking and waiting signals
....................................

A Scheme program can set a signal mask, which is a set of signals to be
blocked from delivery.   If a signal is delivered which is completely
blocked in the process, the signal becomes "pending".  The pending
signal may be delivered once the signal mask is changed not to block
the specified signal.  (However, it depends on the operating system
whether the pending signals are queued or not.)

   In multithread environment, each thread has its own signal mask.

 -- Function: sys-sigmask how mask
     Modifies the current thread's signal mask, and returns the previous
     signal mask.   MASK should be a `<sys-sigset>' object to specify
     the new mask, or `#f' if you just want to query the current mask
     without modifying one.

     If you give `<sys-sigset>' object to MASK, HOW argument should be
     one of the following integer constants:
    `SIG_SETMASK'
          Sets MASK as the thread's signal mask.

    `SIG_BLOCK'
          Adds signals in MASK to the thread's signal mask.

    `SIG_UNBLOCK'
          Removes signals in MASK from the thread's signal mask.

 -- Function: sys-sigsuspend mask
     Atomically sets thread's signal mask to MASK and suspends the
     calling thread.  When a signal that is not blocked and has a
     signal handler installed is delivered, the associated handler is
     called, then `sys-sigsuspend' returns.

 -- Function: sys-sigwait mask
     [POSIX] MASK must be a `<sys-sigset>' object.  If any of signals
     in MASK is/are pending in the OS, atomically clears one of them
     and returns the signal number of the cleared one.   If there's no
     signal in MASK pending, `sys-sigwait' blocks until any of the
     signals in MASK arrives.

     You have to block all signals in MASK in all threads before
     calling `sys-sigwait'.  If there's a thread that doesn't block the
     signals, the behavior of `sys-sigwait' is undefined.

     Note: `Sys-sigwait' uses system's `sigwait' function, whose
     behavior is not defined if there's a signal handler on the signals
     it waits.  To avoid complication, `sys-sigwait' resets the
     handlers set to the signals included in MASK before calling
     `sigwait' to `SIG_DFL', and restores them after `sigwait' returns.
     If another thread changes signal handlers while `sys-sigwait' is
     waiting, the behavior is undefined; you shouldn't do that.


File: gauche-refe.info,  Node: Signals and threads,  Prev: Masking and waiting signals,  Up: Signal

6.22.6.5 Signals and threads
............................

The semantics of signals looks a bit complicated in the multithread
environment.   Nevertheless, it is pretty comprehensible once you
remember a small number of rules.  Besides, Gauche sets up the default
behavior easy to use, while allowing programmers to do tricky stuff.

   If you don't want to be bothered by the details, just remember one
thing, with one sidenote.  *By default*, signals are handled by the
primordial (main) thread.  However, if the main thread is suspended on
mutex or condition variable, the signal may not be handled at all, so
be careful.

   Now, if you are curious about the details, here are the rules:
   * The signal handler setting is shared by all threads.

   * The signal mask is thread-specific.

   * If a process receives an asynchronous signal (think it as a signal
     delivered from other processes), one thread is chosen, out of
     threads which don't block that signal.

   * The signal handler is run on the chosen thread.  However, if the
     chosen thread is waiting for acquiring a mutex lock or a condition
     variable, the handling of signal will be delayed until the thread
     is restarted.   Signal delivery itself doesn't restart the thread.

   Now, these rules have several implications.

   If there are more than one thread that don't block a particular
signal, you can't know which thread receives the signal.  Such a
situation is much less useful in Gauche than C programs because of the
fact that the signal handling can be delayed indefinitely if the
receiver thread is waiting on mutex or condition variable.  So, it is
recommended to make sure, for each signal, there is only one thread
that can receive it.

   In Gauche, all threads created by `make-thread' (*Note Thread
procedures::) blocks all the signals by default (except the reserved
ones).   This lets all the signals to be directed to the primordial
(main) thread.

   Another strategy is to create a thread dedicated for handling
signals.  To do so, you have to block the signals in the primordial
thread, then create the signal-handling thread, and within that thread
you unblock all the signals.  Such a thread can just loop on
`sys-pause'.

     (thread-start!
       (make-thread
         (lambda ()
           (sys-sigmask SIG_SETMASK (make <sys-sigset>)) ;;empty mask
           (let loop () (sys-pause) (loop)))))

   Complicated application may want to control per-thread signal
handling precisely.   You can do so, just make sure that at any moment
only the designated thread unblocks the desired signal.


File: gauche-refe.info,  Node: System inquiry,  Next: Time,  Prev: Signal,  Up: System interface

6.22.7 System inquiry
---------------------

 -- Function: sys-uname
     [POSIX] Returns a list of five elements, `(SYSNAME NODENAME
     RELEASE VERSION MACHINE)'.

 -- Function: sys-gethostname
     Returns the host name.  If the system doesn't have gethostname(),
     the second element of the list returned by `sys-uname' is used.

 -- Function: sys-getdomainname
     Returns the domain name.  If the system doesn't have
     getdomainname(), `"localdomain"' is returned.

 -- Function: sys-getcwd
     [POSIX] Returns the current working directory by a string.  If the
     current working directory couldn't be obtained from the system, an
     error is signalled.   See also `sys-chdir'  (*Note Other file
     operations::), `current-directory' (*Note Directory utilities::).

 -- Function: sys-getgid
 -- Function: sys-getegid
     [POSIX] Returns integer value of real and effective group id of the
     current process, respectively.  Use `sys-gid->group-name' or
     `sys-getgrgid' to obtain the group's name and other information
     associated to the returned group id (*Note Unix groups and
     users::).

 -- Function: sys-setgid gid
     [POSIX] Sets the effective group id of the current process.

 -- Function: sys-getuid
 -- Function: sys-geteuid
     [POSIX] Returns integer value of real and effective user id of the
     current process, respectively.  Use `sys-uid->user-name' or
     `sys-getpwuid' to obtain the user's name and other information
     associated to the returned user id (*Note Unix groups and users::).

 -- Function: sys-setuid uid
     [POSIX] Sets the effective user id of the current process.

 -- Function: sys-getgroups
     [POSIX] Returns a list of integer ids of supplementary groups.

 -- Function: sys-getlogin
     [POSIX] Returns a string of the name of the user logged in on the
     controlling terminal of the current process.  If the system can't
     determine the information, `#f' is returned.

 -- Function: sys-getpgrp
     [POSIX] Returns a process group id of the current process.

 -- Function: sys-getpgid pid
     Returns a process group id of the process specified by PID.  If
     PID is zero, the current process is used.

     Note that `getpgid()' call is not in POSIX.  If the system doesn't
     have GETPGID(), SYS-GETPGID still works if PID is zero (it just
     calls `sys-getpgrp'), but signals an error if PID is not zero.

 -- Function: sys-setpgid pid pgid
     [POSIX] Sets the process group id of the process PID to PGID.  If
     PID is zero, the process ID of the current process is used.  If
     PGID is zero, the process ID of the process specified by `pid' is
     used.  (Hence `sys-setpgid(0, 0)' sets the process group id of the
     current process to the current process id).

 -- Function: sys-setsid
     [POSIX] Creates a new session if the calling process is not a
     process group leader.

 -- Function: sys-getpid
 -- Function: sys-getppid
     [POSIX] Returns the current process id and the parent process id,
     respectively.

 -- Function: sys-times
     [POSIX]

 -- Function: sys-ctermid
     [POSIX]  Returns the name of the controlling terminal of the
     process.  This may be just a `"/dev/tty"'.   See also
     `sys-ttyname'.

 -- Function: sys-getrlimit resource
 -- Function: sys-setrlimit resource current &optional maximum
     [POSIX] Get and set resource limits respectively.  RESOURCE is an
     integer constant to specify the resource of concern.  The
     following constants are defined.  (The constants marked as bsd
     and/or linux indicates that they are not defined in POSIX but
     defined in BSD and/or Linux.  Other systems may or may not have
     them.  Consult `getrlimit' manpage of your system for the details.)

          RLIMIT_AS                      RLIMIT_CORE
          RLIMIT_CPU                     RLIMIT_DATA
          RLIMIT_FSIZE                   RLIMIT_LOCKS
          RLIMIT_MEMLOCK (bsd/linux)     RLIMIT_MSGQUEUE (linux)
          RLIMIT_NICE (linux)            RLIMIT_NOFILE
          RLIMIT_NPROC (bsd/linux)       RLIMIT_RSS (bsd/linux)
          RLIMIT_RTPRIO (linux)          RLIMIT_SIGPENDING (linux)
          RLIMIT_SBSIZE                  RLIMIT_STACK
          RLIMIT_OFILE

 -- Function: sys-strerror errno
     ERRNO must be an exact nonnegative integer representing a system
     error number.  This function returns a string describing the error.

     To represent ERRNO, the following constants are defined.  Each
     constant is bound to an exact integer representing the system's
     error number.  Note that the actual value may differ among systems,
     and some of these constants may not be defined on some systems.

          E2BIG             EHOSTDOWN         ENETDOWN          ENXIO
          EACCES            EHOSTUNREACH      ENETRESET         EOPNOTSUPP
          EADDRINUSE        EIDRM             ENETUNREACH       EOVERFLOW
          EADDRNOTAVAIL     EILSEQ            ENFILE            EPERM
          EADV              EINPROGRESS       ENOANO            EPFNOSUPPORT
          EAFNOSUPPORT      EINTR             ENOBUFS           EPIPE
          EAGAIN            EINVAL            ENOCSI            EPROTO
          EALREADY          EIO               ENODATA           EPROTONOSUPPORT
          EBADE             EISCONN           ENODEV            EPROTOTYPE
          EBADF             EISDIR            ENOENT            ERANGE
          EBADFD            EISNAM            ENOEXEC           EREMCHG
          EBADMSG           EKEYEXPIRED       ENOKEY            EREMOTE
          EBADR             EKEYREJECTED      ENOLCK            EREMOTEIO
          EBADRQC           EKEYREVOKED       ENOLINK           ERESTART
          EBADSLT           EL2HLT            ENOMEDIUM         EROFS
          EBFONT            EL2NSYNC          ENOMEM            ESHUTDOWN
          EBUSY             EL3HLT            ENOMSG            ESOCKTNOSUPPORT
          ECANCELED         EL3RST            ENONET            ESPIPE
          ECHILD            ELIBACC           ENOPKG            ESRCH
          ECHRNG            ELIBBAD           ENOPROTOOPT       ESRMNT
          ECOMM             ELIBEXEC          ENOSPC            ESTALE
          ECONNABORTED      ELIBMAX           ENOSR             ESTRPIPE
          ECONNREFUSED      ELIBSCN           ENOSTR            ETIME
          ECONNRESET        ELNRNG            ENOSYS            ETIMEDOUT
          EDEADLK           ELOOP             ENOTBLK           ETOOMANYREFS
          EDEADLOCK         EMEDIUMTYPE       ENOTCONN          ETXTBSY
          EDESTADDRREQ      EMFILE            ENOTDIR           EUCLEAN
          EDOM              EMLINK            ENOTEMPTY         EUNATCH
          EDOTDOT           EMSGSIZE          ENOTNAM           EUSERS
          EDQUOT            EMULTIHOP         ENOTSOCK          EWOULDBLOCK
          EEXIST            ENAMETOOLONG      ENOTTY            EXDEV
          EFAULT            ENAVAIL           ENOTUNIQ          EXFULL
          EFBIG


File: gauche-refe.info,  Node: Time,  Next: Unix process management,  Prev: System inquiry,  Up: System interface

6.22.8 Time
-----------

Gauche has two representations of time, one is compatible to POSIX API,
and the other is compatible to SRFI-18, SRFI-19 and SRFI-21.  Most
procedures accept both representations; if not, the representation the
procedure accepts is indicated as either 'POSIX time' or 'SRFI time'.

   POSIX time is represented by a real number which is a number of
seconds since Unix Epoch (Jan 1, 1970, 0:00:00GMT).  Procedure
`sys-time', which corresponds to POSIX `time(2)', returns this time
representation.

   SRFI-compatible time is represented by an object of `<time>' class,
which keeps seconds and nanoseconds, as well as the type of the time
(UTC, TAI, duration, process time, etc).  `Current-time' returns this
representation.

POSIX time
..........

 -- Function: sys-time
     [POSIX] Returns the current time in POSIX time (the time since
     Epoch (00:00:00 UTC, January 1, 1970), measured in seconds).  It
     may be a non-integral number, depending on the architecture.

     Note that POSIX's definition of "seconds since the Epoch" doesn't
     take leap seconds into account.

 -- Function: sys-gettimeofday
     Returns two values.  The first value is a number of seconds, and
     the second value is a fraction in a number of microseconds, since
     1970/1/1 0:00:00 UTC.   If the system doesn't have `gettimeofday'
     call, this function calls `time()'; in that case, microseconds
     portion is always zero.

 -- Builtin Class: <sys-tm>
     Represents `struct tm', a calendar date.  It has the following
     slots.

      -- Instance Variable of <sys-tm>: sec
          Seconds. 0-61.

      -- Instance Variable of <sys-tm>: min
          Minutes. 0-59.

      -- Instance Variable of <sys-tm>: hour
          Hours.  0-23.

      -- Instance Variable of <sys-tm>: mday
          Day of the month, counting from 1.  1-31.

      -- Instance Variable of <sys-tm>: mon
          Month, counting from 0.  0-11.

      -- Instance Variable of <sys-tm>: year
          Years since 1900, e.g. 102 for the year 2002.

      -- Instance Variable of <sys-tm>: wday
          Day of the week.  Sunday = 0 .. Saturday = 6.

      -- Instance Variable of <sys-tm>: yday
          Day of the year.  January 1 = 0 .. December 31 = 364 or 365.

      -- Instance Variable of <sys-tm>: isdst
          A flag that indicates if the daylight saving time is in
          effect.  Positive if DST is in effect, zero if not, or
          negative if unknown.

 -- Function: sys-gmtime time
 -- Function: sys-localtime time
     [POSIX] Converts TIME to `<sys-tm>' object, represented in GMT or
     local timezone, respectively.   TIME can be either POSIX-time or
     SRFI-time.

 -- Function: sys-ctime time
     [POSIX] Converts TIME to it string representation, using POSIX
     ctime().  TIME can be either POSIX-time or SRFI-time.

 -- Function: sys-difftime time1 time0
     [POSIX] Returns the difference of two times in the real number of
     seconds.  TIME0 and TIME1 can be either POSIX-time or SRFI-time.

 -- Function: sys-asctime tm
     [POSIX] Converts `<sys-tm>' object TM to a string representation.

 -- Function: sys-strftime format tm
     [POSIX] Converts `<sys-tm>' object TM to a string representation,
     according to a format string FORMAT.

 -- Function: sys-mktime tm
     [POSIX] Converts `<sys-tm>' object TM, expressed as local time, to
     the POSIX-time (number of seconds since Epoch).

 -- Function: sys-tm->alist tm
     (Deprecated function)

SRFI time
.........

 -- Builtin Class: <time>
     The `<time>' object also represents a point of time.

      -- Instance Variable of <time>: type
          Indicates time type.  `time-utc' is the default, and that
          represents the number of seconds since Unix Epoch.  SRFI-19
          (*Note Time data types and procedures::) adds more types.

      -- Instance Variable of <time>: second
          Second part of the time.

      -- Instance Variable of <time>: nanosecond
          Nanosecond part of the time.

 -- Function: current-time
     [SRFI-18][SRFI-21] Returns the `<time>' object representing the
     current time in `time-utc'.   *Note Time data types and
     procedures::, for it redefines `current-time' to allow optional
     argument to specify time type.

 -- Function: time? obj
     [SRFI-18][SRFI-19][SRFI-21] Returns `#t' if OBJ is a time object.

 -- Function: time->seconds time
 -- Function: seconds->time seconds
     [SRFI-18][SRFI-21] Converts between time object and the number of
     seconds (POSIX-time).  TIME argument of `time->seconds' has to be
     a `<time>' object.


File: gauche-refe.info,  Node: Unix process management,  Next: I/O multiplexing,  Prev: Time,  Up: System interface

6.22.9 Unix process management
------------------------------

The following procedures provide pretty raw, direct interface to the
system calls.  See also *note High Level Process Interface::, which
provides more convenient process handling on top of these primitives.

Fork and exec
.............

 -- Function: sys-system command
     [POSIX] Runs COMMAND in a subprocess.   COMMAND is usually passed
     to `sh', so the shell metacharacters are interpreted.

     This function returns an integer value `system()' returned.  Since
     POSIX doesn't define what `system()' returns, you can't interpret
     the returned value in a portable way.

 -- Function: sys-fork
     [POSIX] Fork the current process.  Returns 0 if you're in the
     child process, and a child process' pid if you're in the parent
     process.  All the opened file descriptors are shared between the
     parent and the child.  See `fork(2)' of your system for details.

     If the child process runs some Scheme code and exits instead of
     calling `sys-exec', it should call `sys-exit' instead of `exit' to
     terminate itself.  Normal exit call tries to flush the file
     buffers, and on some OS it messes up the parent's file buffers.

     It should be noted that `sys-fork' is not safe when multiple
     threads are running.  Because `fork(2)' copies the process' memory
     image which includes any mutex state, a mutex which is locked by
     another thread at the time of `sys-fork' remains locked in the
     child process, nevertheless the child process doesn't have the
     thread that unlock it!  (This applies to the internal mutexes as
     well, so even you don't use Scheme mutex explicitly, this
     situation can always happen.)

     If what you want is to spawn another program in a multi-threaded
     application, use `sys-fork-and-exec' explained below.  If you
     absolutely need to run Scheme code in the child process, a typical
     technique is that you fork a manager process at the beginning of
     application, and whenever you need a new process you ask the
     manager process to fork one for you.

 -- Function: sys-exec command args &keyword directory iomap sigmask
     [POSIX+] Execute COMMAND with ARGS, a list of arguments.  The
     current process image is replaced by COMMAND, so this function
     never returns.

     All elements of ARGS must be strings.  The first element of ARGS
     is used as `argv[0]', i.e. the program name.

     The keyword argument DIRECTORY must be a string of a directory
     name or `#f'.  If it is a string, `sys-exec' change current
     working directory there before executing the program.

     The IOMAP keyword argument, when provided, specifies how the open
     file descriptors are treated.  It must be the following format:
          ((to-fd . from-port-or-fd) ...)
     To-fd must be an integer, and from-port-or-fd must be an integer
     file descriptor or a port.  Each element of the list makes the
     file descriptor of from-port-or-fd of the current process be
     mapped to the file descriptor to-fd in the executed process.

     If IOMAP is provided, any file descriptors other than specified in
     the iomap list will be closed before `exec()'.  Otherwise, all
     file descriptors in the current process remain open.

          (sys-exec "ls" '("ls" "-l")) => ;; ls is executed.

          (let ((out (open-output-file "ls.out")))
            (sys-exec "ls" '("ls" "-l") :iomap `((2 . 1) (1 . ,out)))
             =>
            ;; ls is executed, with its stderr redirected
            ;; to the current process's stdout, and its
            ;; stdout redirected to the file "ls.out".

     The SIGMASK keyword argument can be an instance of `<sys-sigset>'
     or `#f' (*Note Signal::, for the details of signal masks).  If it
     is an instance of `<sys-sigset>', the signal mask of calling
     thread is replaced by it just before `exec(2)' is called.  It is
     useful, for example, to run an external program from a thread where
     all signals are blocked (which is the default; see *note Signals
     and threads::).  Without setting SIGMASK, the `exec'ed process
     inherits calling thread's signal mask and become a process that
     blocks all signals, which is not very convenient in most cases.

     When `sys-exec' encounters an error, most of the time it raises an
     error condition.  Once the file descriptors are permuted, however,
     it would be impractical to handle errors in reasonable way (you
     don't even know stderr is still available!), so Gauche simply
     exits on the error.

 -- Function: sys-fork-and-exec command args &keyword directory iomap
          sigmask
     Like `sys-exec', but executes `fork(2)' just before remapping I/O,
     altering signal mask and call `execvp(2)'.  Returns child's
     process id.  The meanings of arguments are the same as `sys-exec'.

     It is strongly recommended to use this procedure instead of
     `sys-fork' and `sys-exec' combination when you need to spawn
     another program while other threads are running.  No memory
     allocation nor lock acquisition is done between `fork(2)' and
     `execvp(2)', so it's pretty safe in the multithreaded environment.

Wait
....

 -- Function: sys-wait
     [POSIX] Calls system's `wait(2)'.  The process suspends its
     execution until one of the child terminates.  Returns two exact
     integer values, the first one is the child's process id, and the
     second is a status code.  The status code can be interpreted by
     the following functions.

 -- Function: sys-waitpid pid &keyword nohang untraced
     [POSIX] This is an interface to `waitpid(3)', an extended version
     of wait.

     PID is an exact integer specifying which child(ren) to be waited.
     If it is a positive integer, it waits fot that specific child.  If
     it is zero, it waits for any member of this process group.  If it
     is -1, it waits for any child process.  If it is less than -1, it
     waits for any child process whose process group id is equal to the
     absolute value of PID.

     If there's no child process to wait, or a specific PID is given
     but it's not a child process of the current process, an error
     (`<system-error>', `ECHILD') is signalled.

     The calling process suspends until one of those child process is
     terminated, unless true is specified to the keyword argument
     NOHANG.

     If true is specified to the keyword argument UNTRACED, the status
     of stopped child process can be also returned.

     The return values are two exact integers, the first one is the
     child process id, and the second is a status code.  If NOHANG is
     true and no child process status is available, the first value is
     zero.

 -- Function: sys-wait-exited? status
 -- Function: sys-wait-exit-status status
     [POSIX] The argument is an exit status returned as a second value
     from `sys-wait' or `sys-waitpid'.  `sys-wait-exited?' returns `#t'
     if the child process is terminated normally.
     `sys-wait-exit-status' returns the exit code the child process
     passed to `exit(2)', or the return value of `main()'.

 -- Function: sys-wait-signaled? status
 -- Function: sys-wait-termsig status
     [POSIX] The argument is an exit status returned as a second value
     from `sys-wait' or `sys-waitpid'.  `sys-wait-signaled?' returns
     `#t' if the child process is terminated by an uncaught signal.
     `sys-wait-termsig' returns the signal number that terminated the
     child.

 -- Function: sys-wait-stopped? status
 -- Function: sys-wait-stopsig status
     [POSIX] The argument is an exit status returned as a second value
     from `sys-waitpid'.  `sys-wait-stopped?' returns `#t' if the child
     process is stopped.   This status can be caught only by
     `sys-waitpid' with true UNTRACED argument.  `sys-wait-stopsig'
     returns the signum number that stopped the child.


File: gauche-refe.info,  Node: I/O multiplexing,  Next: Miscellaneous system calls,  Prev: Unix process management,  Up: System interface

6.22.10 I/O multiplexing
------------------------

The interface functions for `select(2)'.  The higher level interface is
provided on top of these primitives; see *note Simple dispatcher::.

 -- Builtin Class: <sys-fdset>
     Represents `fd_set', a set of file descriptors.  You can make an
     empty file descriptor set by make method:
          (make <sys-fdset>)

 -- Function: sys-fdset elt ...
     Creates a new `<sys-fdset>' instance with file descriptors
     specified by ELT ....  Each ELT can be an integer file descriptor,
     a port, or a `<sys-fdset>' instance.  In the last case, the
     descriptors in the given fdset is copied to the new fdset.

 -- Function: sys-fdset-ref fdset port-or-fd
 -- Function: sys-fdset-set! fdset port-or-fd flag
     Gets and sets specific file descriptor bit of FDSET.  PORT-OR-FD
     may be a port or an integer file descriptor.  If PORT-OR-FD is a
     port that doesn't have associated file descriptor, `sys-fdset-ref'
     returns `#f', and `sys-fdset-set!' doesn't modify FDSET.  FLAG
     must be a boolean value.

     You can use generic setter of `sys-fdset-ref' as this:
          (set! (sys-fdset-ref fdset port-or-fd) flag)
            == (sys-fdset-set! fdset port-or-fd flag)

 -- Function: sys-fdset-copy! dest-fdset src-fdset
     Copies the content of SRC-FDSET into DEST-FDSET.  Returns
     DEST-FDSET.

 -- Function: sys-fdset-clear! fdset
     Empties and returns FDSET.

 -- Function: sys-fdset->list fdset
 -- Function: list->sys-fdset fds
     Converts an fdset to a list of integer file descriptors and vice
     versa.  In fact, `list->sys-fdset' works just like `(lambda (fds)
     (apply sys-fdset fds))', so it accepts ports and other fdsets as
     well as integer file descriptors.

 -- Function: sys-fdset-max-fd fdset
     Returns the maximum file descriptor number in FDSET.

 -- Function: sys-select readfds writefds exceptfds &optional timeout
 -- Function: sys-select! readfds writefds exceptfds &optional timeout
     Waits for a set of file descriptors to change status.  READFDS,
     WRITEFDS, and EXCEPTFDS are `<fdset>' objects to represent a set
     of file descriptors to watch.  File descriptors in READFDS are
     watched to see if characters are ready to be read.   File
     descriptors in WRITEFDS are watched if writing to them is ok.
     File descriptors in EXCEPTFDS are watched for exceptions.  You can
     pass `#f' to one or more of those arguments if you don't care
     about watching the condition.

     TIMEOUT specifies maximum time `sys-select' waits for the
     condition change.  It can be a real number, for number of
     microseconds, or a list of two integers, the first is the number
     of seconds and the second is the number of microseconds.  If you
     pass `#f', `sys-select' waits indefinitely.

     `sys-select' returns four values.  The first value is a number of
     descriptors it detected status change.  It may be zero if timeout
     expired.  The second, third and fourth values are `<fdset>' object
     that contains a set of descriptors that changed status for
     reading, writing, and exception, respectively.  If you passed `#f'
     to one or more of READFDS, WRITEFDS and EXCEPTFDS, the
     corresponding return value is `#f'.

     `sys-select!' variant works the same as `sys-select', except it
     modifies the passed `<fdset>' arguments.  `sys-select' creates new
     `<fdset>' objects and doesn't modify its arguments.


File: gauche-refe.info,  Node: Miscellaneous system calls,  Prev: I/O multiplexing,  Up: System interface

6.22.11 Miscellaneous system calls
----------------------------------

 -- Function: sys-pause
     [POSIX] Suspends the process until it receives a signal whose
     action is to either execute a signal-catching function or to
     terminate the process.  This function only returns when the
     signal-catching function returns.  The returned value is undefined.

     Note that just calling `pause()' doesn't suffice the above
     semantics in Scheme-level.  Internally this procedure calls
     `sigsuspend()' with the current signal mask.

 -- Function: sys-alarm seconds
     [POSIX] Arranges a SIGALRM signal to be delivered after SECONDS.
     The previous settings of the alarm clock is cancelled.  Passing
     zero to SECONDS doesn't schedule new alarm.  Returns the number of
     seconds remaining until previously scheduled alarm was due to be
     delivered (or zero if no alarm is active).

 -- Function: sys-sleep seconds
     [POSIX] Suspends the process until the specified number of seconds
     elapses, or the process receives a signal.  Returns zero if it
     sleeps well, or the number of unslept seconds if it is woke up by
     a signal.

     To be portable across POSIX implementation, keep SECONDS less than
     65536.

 -- Function: sys-nanosleep nanoseconds
     [POSIX] Suspends the process until the specified number of
     nanoseconds elapses, or the process receives a signal.  The
     argument NANOSECONDS can be a `<time>' object (*Note Time::), or a
     real number.  Returns `#f' if NANOSECONDS elapsed, or a `<time>'
     object that indicates the remaining time if `sys-nanosleep' is
     interrupted by a signal.

          ;wait for 0.5 sec
          (sys-nanosleep 500000000)

          ;wait for 1.3 sec
          (sys-nanosleep (make <time> :second 1 :nanosecond 300000000))

 -- Function: sys-random
 -- Function: sys-srandom seed
     A pseudo random number generator.  `sys-random' returns a random
     number between 0 and a positive integer RAND_MAX, inclusive.  This
     is a straightforward interface to `random(3)'.  If the underlying
     system doesn't have `random(3)', `lrand48(3)' is used.

     `sys-srandom' sets the seed of the random number generator.  It
     uses either `srandom(3)' or `srand48(3)', depending on the system.

     The intention of these functions are to provide an off-the-stock
     handy random number generator (RNG) for applications that doesn't
     sensitive to the quality and/or speed of RNG.  For serious
     statistics analysis, use Mersenne Twister RNG in `math.mt-random'
     module (*Note Mersenne-Twister random number generator::).

 -- Variable: RAND_MAX
     Bound to a positive integer that `sys-random' may return.


File: gauche-refe.info,  Node: Development helper API,  Prev: System interface,  Up: Core library

6.23 Development helper API
===========================

Gauche has some basic built-in APIs to help developers to analyze the
program.

* Menu:

* Debugging aid::
* Profiler API::


File: gauche-refe.info,  Node: Debugging aid,  Next: Profiler API,  Prev: Development helper API,  Up: Development helper API

6.23.1 Debugging aid
--------------------

 -- Macro: debug-print expr
     This macro prints EXPR in a source form, then evaluates it, then
     prints out the result(s), and returns them.

     The special reader syntax `#?=EXPR' is expanded into `(debug-print
     EXPR)'.  See *note Debugging::, for the details.

 -- Parameter: debug-print-width
     This parameter specifies the maximum width of information to be
     printed by `debug-print'.  If the information takes more columns
     than the value of this parameter, it is truncated.

     To show all the information, set `#f' to this parameter.

 -- Function: debug-source-info obj
     Retrieves source information attached to OBJ.  The source
     information is returned as a list of source file name and an
     integer line number.  If no source information is available in
     OBJ, `#f' is returned.

 -- Function: disasm closure
     Disassemble the compiled body of CLOSURE and print it.  It may not
     be very useful unless you're tracking a compiler bug, or trying to
     tune the program to its limit.

     If you're reading the disassembler output, keep in mind that the
     compiled code vector may have some dead code; they are produced by
     the jump optimization, but the compiler doesn't bother to eliminate
     them.


File: gauche-refe.info,  Node: Profiler API,  Prev: Debugging aid,  Up: Development helper API

6.23.2 Profiler API
-------------------

These are the functions to control Gauche's built-in profiler.  See
*note Using profiler:: for the explanation of the profiler.

   Note that the profiler doesn't work correctly yet in multi-threaded
program.

 -- Function: profiler-start
     Starts the sampling profiler.   If the profiler is already started,
     nothing is done.

 -- Function: profiler-stop
     Stop the sampling profiler, and save the sampled data into the
     internal structure.   If there are already saved sampled data, the
     newly obtained data is added to it.  If the profiler isn't
     running, nothing is done.

 -- Function: profiler-reset
     Stop the profiler if it is running.  Then discard the saved
     sampled data.

 -- Function: profiler-show &keyword sort-by max-rows
     Show the saved sampled data.

     The keyword argument SORT-BY may be one of the symbols `time',
     `count', or `time-per-call', to specify how the result should be
     sorted.  The default is `time'.

     The keyword argument MAX-ROWS specifies the max number of rows to
     be shown.  If it is `#f', all the data is shown.


File: gauche-refe.info,  Node: Object system,  Next: Library modules - Overview,  Prev: Core library,  Up: Top

7 Object system
***************

Gauche's object system design is largely inspired by STklos, whose
design has come from TinyCLOS.  It supports multiple inheritance,
multimethods, and metaobject protocol.

   The type system is integrated to the object system, that is, a
string is an instance of the class `<string>', and so on.

* Menu:

* Introduction to the object system::
* General Inquiry::
* Class::
* Instance::
* Generic function and method::
* Metaobject protocol::


File: gauche-refe.info,  Node: Introduction to the object system,  Next: General Inquiry,  Prev: Object system,  Up: Object system

7.1 Introduction to the object system
=====================================

This section briefly explains the basic structure of Gauche's object
system.   It is strongly influenced by CLOS (Common-Lisp Object System).
If you have experience in CLOS or related systems such as TinyCLOS,
STklos or Guile's object system, you may skip to the next section.

   Three concepts play the central role in CLOS-like object systems: A
_class_, a _generic function_, and a _method_.

   A _class_ specifies a structure of object.  It also defines a
datatype (strictly speaking, it's not the same thing as a datatype, but
let's skip the complicated part for now).

   For example, a point in 2D space can be represented by x and y
coordinates.  A point class can be defined using `define-class' macro.
In the shortest form, it can be defined like this:

     (define-class <2d-point> () (x y))

   (You can find the code of definitions in the examples of this section
in `examples/oointro.scm' of Gauche's source distribution.)

   The symbol `<2d-point>' is the name of the class, and also the
global variable `<2d-point>' is bound to a class object.  Surrounding a
class name by `<' and `>' is just a convention; you can pass any symbol
to `define-class'.

   The second argument of `define-class' is a list of direct
superclasses, which specifies inheritance of the class.  We'll come
back to it later.

   The third argument of `define-class' is a list of _slots_.  A slot
is a storage space, usually in each object, where you can store a
value.  It is something similar to what is called a field or an
instance variable in other object-oriented languages; but slots can be
configured more than just a per-object storage space.

   Now we defined a 2D point class, so we can create an instance of a
point.  You can pass a class to a generic function `make' to create an
instance.  (Don't worry about what generic function is--think it as a
special type of function, just for now).

     (define a-point (make <2d-point>))

     a-point  => #<<2d-point> 0x8117570>

   If you are using `gosh' interactively, you can use a generic
function `describe' to inspect the internal of an instance.  A short
alias, `d', is defined to `describe' for the convenience.  (See *note
Interactive session:: for the details).

     gosh> (d a-point)
     #<<2d-point> 0x8117570> is an instance of class <2d-point>
     slots:
       x         : #<unbound>
       y         : #<unbound>

   In order to access or modify the value of the slot, you can use
`slot-ref' and `slot-set!', respectively.  These names are taken from
STklos.

     (slot-ref a-point 'x)  ;; access to the slot x of a-point
       => error, since slot 'x doesn't have a value yet

     (slot-set! a-point 'x 10.0)  ;; set 10.0 to the slot x of a-point

     (slot-ref a-point 'x)
       => 10.0

   Gauche also provides a shorter name, `ref', which can also be used
in srfi-17's generalized `set!' syntax:
     (ref a-point 'x) => 10.0

     (set! (ref a-point 'y) 20.0)

     (ref a-point 'y) => 20.0

   Now you can see slot values are set.
     gosh> (d a-point)
     #<<2d-point> 0x8117570> is an instance of class <2d-point>
     slots:
       x         : 10.0
       y         : 20.0

   In practice, it is usually convenient if you can specify the default
value for a slot, or give values for slots when you create an instance.
Such information can be specified by _slot options_.  Let's modify the
definition of `<2d-point>' like this:

     (define-class <2d-point> ()
       ((x :init-value 0.0 :init-keyword :x :accessor x-of)
        (y :init-value 0.0 :init-keyword :y :accessor y-of)))

   Note that each slot specification is now a list, instead of just a
symbol as in the previous example.  The list's car now specifies the
slot name, and its cdr gives various information.   The value after
`:init-value' defines the default value of the slot.  The keyword after
`:init-keyword' defines the keyword argument which can be passed to
`make' to initialize the slot at creation time.  The name after keyword
`:accessor' is bound to a generic function that can be used to
access/modify the slot, instead of using `slot-ref'/`slot-set!'.

   Let's see some interactive session.  You create an instance of the
new `<2d-point>' class, and you can see the slots are initialized by
the default values.
     gosh> (define a-point (make <2d-point>))
     a-point
     gosh> (d a-point)
     #<<2d-point> 0x8148680> is an instance of class <2d-point>
     slots:
       x         : 0.0
       y         : 0.0

   You create another instance, this time giving initialization values
by keyword arguments.
     gosh> (define b-point (make <2d-point> :x 50.0 :y -10.0))
     b-point
     gosh> (d b-point)
     #<<2d-point> 0x8155b80> is an instance of class <2d-point>
     slots:
       x         : 50.0
       y         : -10.0

   Accessors are less verbose than `slot-ref'/`slot-set!', thus
convenient.
     gosh> (x-of a-point)
     0.0
     gosh> (x-of b-point)
     50.0
     gosh> (set! (y-of a-point) 3.33)
     #<undef>
     gosh> (y-of a-point)
     3.33

   The full list of available slot options is described in *note
Defining class::.  At a first grance, the declarations of such slot
options may look verbose.  The system might have provide a static way
to define init-keywords or accessor names automatically; however,
CLOS-like systems prefer flexibility.  Using a mechanism called
metaobject protocol, you can customize how these slot options are
interpreted, and you can add your own slot options as well.  See *note
Metaobject protocol::, for details.

   We can also have `<2d-vector>' class in similar fashion.

     (define-class <2d-vector> ()
       ((x :init-value 0.0 :init-keyword :x :accessor x-of)
        (y :init-value 0.0 :init-keyword :y :accessor y-of)))

   Yes, we can use the same accessor name like `x-of', and it is
effectively overloaded.

   If you are familiar with mainstream object-oriented languages, you
may wonder where methods are.  Here they are.  The following form
defines a method `move-by!' of three arguments, PT, DX, DY, where PT is
an instance of `<2d-point>'.

     (define-method move-by! ((pt <2d-point>) dx dy)
       (inc! (x-of pt) dx)
       (inc! (y-of pt) dy))

   The second argument of `define-method' macro specifies a _method
specializer list_.  It indicates the first argument must be an instance
of `<2d-point>', and the second and third can be any type.   The syntax
to call a method is just like the one to call an ordinary function.

     gosh> (move-by! b-point 1.4 2.5)
     #<undef>
     gosh> (d b-point)
     #<<2d-point> 0x8155b80> is an instance of class <2d-point>
     slots:
       x         : 51.4
       y         : -7.5

   You can overload the method by different specializers; here you can
move a point using a vector.
     (define-method move-by! ((pt <2d-point>) (delta <2d-vector>))
       (move-by! pt (x-of delta) (y-of delta)))

   Specialization isn't limited to a user-defined classes.  You can
also specialize a method using Gauche's built-in type.
     (define-method move-by! ((pt <2d-point>) (c <complex>))
       (move-by! pt (real-part c) (imag-part c)))

   And here's the example session:
     gosh> (define d-vector (make <2d-vector> :x -9.0 :y 7.25))
     d-vector
     gosh> (move-by! b-point d-vector)
     #<undef>
     gosh> (d b-point)
     #<<2d-point> 0x8155b80> is an instance of class <2d-point>
     slots:
       x         : 42.4
       y         : -0.25
     gosh> (move-by! b-point 3+2i)
     #<undef>
     gosh> (d b-point)
     #<<2d-point> 0x8155b80> is an instance of class <2d-point>
     slots:
       x         : 45.4
       y         : -2.25

   You see that a method is dispatched not only by its primary receiver
(`<2d-point>'), but also other arguments.  In fact, the first argument
is no more special than the rest.  In CLOS-like system a method does
not belong to a particular class.

   So what is actually a method?  Inspecting `move-by!' reveals that it
is an instance of `<generic>', a generic function.  (Note that
`describe' truncates the printed value in `methods' slot for the sake
of readability).
     gosh> move-by!
     #<generic move-by! (3)>
     gosh> (d move-by!)
     #<generic move-by! (3)> is an instance of class <generic>
     slots:
       name      : move-by!
       methods   : (#<method (move-by! <2d-point> <complex>)> #<method (move-
     gosh> (ref move-by! 'methods)
     (#<method (move-by! <2d-point> <complex>)>
      #<method (move-by! <2d-point> <2d-vector>)>
      #<method (move-by! <2d-point> <top> <top>)>)

   I said a generic function is a special type of function.  It is
recognized by Gauche as an applicable object, but when applied, it
selects appropriate method(s) according to its arguments and calls the
selected method(s).

   What the `define-method' macro actually does is (1) to create a
generic function of the given name if it does not exist yet, (2) to
create a method object with the given specializers and the body, and
(3) to add the method object to the generic function.

   The accessors are also generic functions, created implicitly by the
`define-class' macro.
     gosh> (d x-of)
     #<generic x-of (2)> is an instance of class <generic>
     slots:
       name      : x-of
       methods   : (#<method (x-of <2d-vector>)> #<method (x-of <2d-point>)>)

   In the mainstream dynamic object-oriented languages, a class has
many roles; it defines a structure and a type, creates a namespace for
its slots and methods, and is responsible for method dispatch.  In
Gauche, namespace is managed by modules, and method dispatch is handled
by generic functions.

   The default printed representation of object is not very
user-friendly.  Gauche's `write' and `display' function call a generic
function `write-object' when they encounter an instance they don't know
how to print.  You can define its method specialized to your class to
customize how the instance is printed.
     (define-method write-object ((pt <2d-point>) port)
       (format port "[[~a, ~a]]" (x-of pt) (y-of pt)))

     (define-method write-object ((vec <2d-vector>) port)
       (format port "<<~a, ~a>>" (x-of vec) (y-of vec)))

   And what you'll get is:
     gosh> a-point
     [[0.0, 3.33]]
     gosh> d-vector
     <<-9.0, 7.25>>

   If you customize the printed representation to conform srfi-10
format, and define a corresponding read-time constructor, you can make
your instances to be written-out and read-back just like built-in
objects.  See *note Read-time constructor:: for the details.

   Several built-in functions have similar way to extend their
functionality for user-defined objects.  For example, if you specialize
a generic function `object-equal?', you can compare the instances by
`equal?':
     (define-method object-equal? ((a <2d-point>) (b <2d-point>))
       (and (equal? (x-of a) (x-of b))
            (equal? (y-of a) (y-of b))))

     (equal? (make <2d-point> :x 1 :y 2) (make <2d-point> :x 1 :y 2))
       => #t

     (equal? (make <2d-point> :x 1 :y 2) (make <2d-point> :x 2 :y 1))
       => #f

     (equal? (make <2d-point> :x 1 :y 2) 'a)
       => #f

     (equal? (list (make <2d-point> :x 1 :y 2)
                   (make <2d-point> :x 3 :y 4))
             (list (make <2d-point> :x 1 :y 2)
                   (make <2d-point> :x 3 :y 4)))
       => #t

   Let's proceed to more interesting examples.  Think of a class
`<shape>', which is an entity that can be drawn.  As a base class, it
keeps common attributes such as a color and line thickness in its slots.
     (define-class <shape> ()
       ((color     :init-value '(0 0 0) :init-keyword :color)
        (thickness :init-value 2 init-keyword :thickness)))

   When an instance is created, `make' calls a generic function
`initialize', which takes care of initializing slots such as processing
init-keywords and init-values.  You can customize the initialization
behavior by specializing the `initialize' method.   The `initialize'
method is called with two arguments, one is a newly created instance,
and another is a list of arguments passed to `make'.

   We define a `initialize' method for `<shape>' class, so that the
created shape will be automatically recorded in a global list.   Note
that we don't want to replace system's `initialize' behavior completely,
since we still need the init-keywords to be handled.

     (define *shapes* '())  ;; global shape list

     (define-method initialize ((self <shape>) initargs)
       (next-method)  ;; let the system to handle slot initialization
       (push! *shapes* self)) ;; record myself to the global list
   The trick is a special method, `next-method'.  It can only be used
inside a method body, and calls _less specific method_ of the same
generic function--typically, it means you call the same method of
superclass.  Most object-oriented languages have the concept of calling
superclass's method.  Because of multiple-argument dispatching and
multiple inheritance, `next-method' is a little bit more complicated,
but the basic idea is the same.

   So, what's the superclass of `<shape>'?  In fact, all Scheme-defined
class inherits a class called `<object>'.  And it is `<object>''s
initialize method which takes care of slot initialization.  After
calling `next-method' within your `initialize' method, you can assume
all the slots are properly initialized.  So it is generally the first
thing in your `initialize' method to call `next-method'.

   Let's inspect the above code.  When you call `(make <shape> args
...)', the system allocates memory for an instance of `<shape>', and
calls `initialize' generic function with the instance and `args ...'.
It is dispatched to the `initialize' method you just defined.  In it,
you call `next-method', which in turn calls `<object>' class's
`initialize' method.  It initializes the instance with init-values and
init-keywords.  After it returns, you register the new `<shape>'
instance to the global shape list `*shapes*'.

   The `<shape>' class represents just an abstract concept of shape.
Now we define some concrete drawable shapes, by _subclassing_ the
`<shape>' class.
     (define-class <point-shape> (<shape>)
       ((point  :init-form (make <2d-point>) :init-keyword :point)))

     (define-class <polyline-shape> (<shape>)
       ((points :init-value '() :init-keyword :points)
        (closed :init-value #f  :init-keyword :closed)))

   Note the second argument passed to `define-class'.  It indicates
that `<point-shape>' and `<polyline-shape>' inherit slots of `<shape>'
class, and also instances of those subclasses can be accepted wherever
an instance of `<shape>' class is accepted.

   The `<point-shape>' adds one slot, `point', which contains an
instance of `<2d-point>' defined in the beginning of this section.  The
`<polyline-shape>' class stores a list of points, and a flag, which
specifies whether the end point of the polyline is connected to its
starting point or not.

   Inheritance is a powerful mechanism that should be used with care,
or it easily result a code which is untractable ("Object-oriented
programming offers a sustainable way to write spaghetti code.", as Paul
Graham says in his article "The Hundred-Year Language").  The rule of
thumb is to make a subclass when you need a subtype.  The inheritance
of slots is just something that comes with, but it shouldn't be the
main reason to do subclassing.  You can always "include" the
substructure, as is done in `<point-shape>' class.

   There appeared a new slot option in `<point-shape>' class.  The
`:init-form' slot option specifies the default value of the slot when
init-keyword is not given to `make' method.  However, unlike
`:init-value', with which the value is evaluated at the time the class
is defined, the value with `:init-form' is evaluated when the system
actually needs the value.  So, in the `<point-shape>' instance, the
default `<2d-point>' instance is only created if the `<point-shape>'
instance is created without having `:point' init-keyword argument.

   A shape may be drawn in different formats for different devices.
For now, we just consider a PostScript output.  To make the `draw'
method polymorphic, we define a postscript output device class,
`<ps-device>'.

     (define-class <ps-device> () ())

   Then we can write a `draw' method, specialized for both `<shape>'
and `<ps-device>'.
     (define-method draw ((self <shape>) (device <ps-device>))
       (format #t "gsave\n")
       (draw-path self device)
       (apply format #t "~a ~a ~a setrgbcolor\n" (ref self 'color))
       (format #t "~a setlinewidth\n" (ref self 'thickness))
       (format #t "stroke\n")
       (format #t "grestore\n"))

   In this code, the DEVICE argument isn't used within the method body.
It is just used for method dispatching.  If we eventually have
different output devices, we can add a `draw' method that is
specialized for such devices.

   The above `draw' method does the common work, but actual drawing
must be done in specialized way for each subclasses.
     (define-method draw-path ((self <point-shape>) (device <ps-device>))
       (apply format #t "newpath ~a ~a 1 0 360 arc closepath\n"
              (point->list (ref self 'point))))

     (define-method draw-path ((self <polyline-shape>) (device <ps-device>))
       (let ((pts (ref self 'points)))
         (when (>= (length pts) 2)
           (format #t "newpath\n")
           (apply format #t "~a ~a moveto\n" (point->list (car pts)))
           (for-each (lambda (pt)
                       (apply format #t "~a ~a lineto\n" (point->list pt)))
                     (cdr pts))
           (when (ref self 'closed)
             (apply format #t "~a ~a lineto\n" (point->list (car pts))))
           (format #t "closepath\n"))))

     ;; utility method
     (define-method point->list ((pt <2d-point>))
       (list (x-of pt) (y-of pt)))

   Finally, we do a little hack.  Let `draw' method work on the list of
shapes, so that we can draw multiple shapes within a page in batch.
     (define-method draw ((shapes <list>) (device <ps-device>))
       (format #t "%%\n")
       (for-each (cut draw <> device) shapes)
       (format #t "showpage\n"))

   Then we can write some simple figures ....
     (use srfi-1)      ;; for iota
     (use math.const)  ;; for constant pi

     (define (shape-sample)

       ;; creates 5 corner points of pentagon
       (define (make-corners scale)
         (map (lambda (i)
                (let ((pt (make <2d-point>)))
                  (move-by! pt (make-polar scale (* i 2/5 pi)))
                  (move-by! pt 200 200)
                  pt))
              (iota 5)))

       (set! *shapes* '())  ;; clear the shape list
       (let* ((corners (make-corners 100)))
         ;; a pentagon in green
         (make <polyline-shape>
           :color '(0 1 0) :closed #t
           :points corners)
         ;; a star-shape in red
         (make <polyline-shape>
           :color '(1 0 0) :closed #t
           :points (list (list-ref corners 0)
                         (list-ref corners 2)
                         (list-ref corners 4)
                         (list-ref corners 1)
                         (list-ref corners 3)))
         ;; put dots in each corner of the star
         (for-each (cut make <point-shape> :point <>)
                   (make-corners 90))
         ;; draw the shapes
         (draw *shapes* (make <ps-device>)))
       )

   The function `shape-sample' writes out a PostScript code of simple
drawing to the current output port.  You can write it out to file by
the following expression, and then view the result by PostScript viewer
such as GhostScript.
     (with-output-to-file "oointro.ps" shape-sampe)


File: gauche-refe.info,  Node: General Inquiry,  Next: Class,  Prev: Introduction to the object system,  Up: Object system

7.2 General Inquiry
===================

 -- Function: class-of obj
     Returns a class metaobject of OBJ.

          (class-of 3)         => #<class <integer>>
          (class-of "foo")     => #<class <string>>
          (class-of <integer>) => #<class <class>>

 -- Function: is-a? obj class
     Returns true if OBJ is an instance of CLASS or an instance of
     descendants of CLASS.

          (is-a? 3 <integer>)   => #t
          (is-a? 3 <real>)      => #t
          (is-a? 5+3i <real>)   => #f
          (is-a? :foo <symbol>) => #f

If OBJ's class has been redefined, these procedures first updates OBJ
to change its class to the new class.  So `class-of' always returns the
new class.  This behavior is different from stklos 0.55, in which
`class-of' returns an old class if OBJ hasn't been updated.  If you
need to get the old class, you should use `current-class-of' below.
See *note Class redefinition:: for the details of the semantics of
redefined class.

 -- Function: current-class-of obj
     Returns a class metaobject of OBJ.  If OBJ's class has been
     redefined, but OBJ is not updated for the change, then this
     procedure returns the original class of OBJ without updating OBJ.

     You need this procedure in rare occasions, such as within
     `change-class' method, in which you don't want to trigger updating
     OBJ (which would cause infinite loop).


File: gauche-refe.info,  Node: Class,  Next: Instance,  Prev: General Inquiry,  Up: Object system

7.3 Class
=========

In this section, a class in Gauche is explained in detail.

* Menu:

* Defining class::
* Inheritance::
* Class object::
* Slot definition object::
* Class redefinition::
* Class definition examples::


File: gauche-refe.info,  Node: Defining class,  Next: Inheritance,  Prev: Class,  Up: Class

7.3.1 Defining class
--------------------

To define a class, use a macro `define-class'.

 -- Macro: define-class name supers (slot-spec ...) option ...
     Creates a class object according to the arguments, and globally
     bind it to a variable NAME.   This macro should be used at
     toplevel.

     SUPERS is a list of direct superclasses from which this class
     inherits.   You can use multiple inheritance.  All Scheme-defined
     classes implicitly inherits `<object>'.  It is implicitly added to
     the right of SUPERS list, so you don't need to specify it.  See
     *note Inheritance::, for the details about inheritance.

     SLOT-SPEC is a specification of a "slot", sometimes known as a
     "field" or an "instance variable" (but you can specify "class
     variable" in SLOT-SPEC as well).  The simplest form of SLOT-SPEC
     is just a symbol, which names the slot.  Or you can give a list,
     whose first element is a symbol and whose rest is an interleaved
     list of keywords and values.  The list form not only defines a
     name of the slot but specifies behavior of the slot.  It is
     explained below.

     Finally, OPTION ... is an interleaved list of keywords and values,
     specifies how class object should be created.  This macro
     recognizes one keyword, `:metaclass', whose corresponding value is
     used for metaclass (class that instantiates another class).
     Other options are passed to the `make' method to create the class
     object.  *Note Class instantiation::, for the usage of metaclass.

   If a slot specification is a list, it should be in the following
form:

     (SLOT-NAME :option1 value1 :option2 value2 ...)

   Each keyword (`option1' etc.) gives a _slot option_.  By default,
the following slot options are recognized.  You can add more slot
options by defining metaclass.

`:allocation'
     Specifies an allocation type of this slot, which specifies how the
     value for this slot is stored.  The following keyword values are
     recognized by the standard class.  A programmer can define his own
     metaclass to extend the class to recognize other allocation types.
    `:instance'
          A slot is allocated for each instance, so that every instance
          can have distinct value.  This realizes so-called "instance
          variable" behavior.  If `:allocation' slot option is omitted,
          this is the default.

    `:class'
          A slot is allocated in this class object, so that every
          instance will share the same value for this slot.  This
          realizes so-called "class variable" behavior.  The slot value
          is also shared by all subclasses (unless a subclass
          definition shadows the slot).

    `:each-subclass'
          Similar to `class' allocation, but a slot is allocated for
          each class; that is, it is shared by every instance of the
          class, but not shared by the instances of its subclasses.

    `:virtual'
          No storage is allocated for this type of slot.  Accessing the
          slot calls procedures given in `:slot-ref' and `:slot-set!'
          options described below.  In other words, you can make a
          procedural slot.  If a slot's allocation is specified as
          virtual, at least `:slot-ref' option has to be specified as
          well, or `define-class' raises an error.

    `:builtin'
          This type of allocation only appears in built-in classes, and
          you can't specify it in Scheme-defined class.

`:init-keyword'
     A keyword value given to this slot option can be used to pass an
     initial value to `make' method when an instance is created.

`:init-value'
     Gives an initial value of the slot, if the slot is not initialized
     by the keyword argument at the creation time.   The value is
     evaluated when `define-class' is evaluated.

`:init-form'
     Like `init-value', but the value given is wrapped in a thunk, and
     evaluated each time when the value is required.  If both
     `init-value' and `init-form' are given, `init-form' is ignored.
     Actually, `:init-form EXPR' is converted to `:init-thunk (lambda
     () EXPR)' by `define-class' macro.

`:initform'
     A synonym of `init-form'.  This is kept for compatibility to STk,
     and shouldn't be used in the new code.

`:init-thunk'
     Gives a thunk, which will be evaluated to obtain an initial value
     of the slot, if the slot is not initialized by the keyword argument
     at the creation time.  To give a value to `:init-form' is
     equivalent to give `(lambda () value)' to `:init-thunk'.

`:getter'
     Takes a symbol, and a getter method is created and bound to the
     generic function of that name.  The getter method takes an instance
     of the class and returns the value of the slot.

`:setter'
     Takes a symbol, and a setter method is created and bound to the
     generic function of that name.  The setter method takes an instance
     of the class and a value, and sets the value to the slot of the
     instance.

`:accessor'
     Takes a symbol, and create two methods; a getter method and a
     setter method.  A getter method is bound to the generic function
     of the given name, and a setter method is added as the _setter_ of
     that generic function (see *note Assignments:: for generic
     setters).

`:slot-ref'
     Specifies a value that evaluates to a procedure which takes one
     argument, an instance.  This slot option must be specified if the
     allocation of the slot is `virtual'.  Whenever a program tries to
     get the value of the slot, either using `slot-ref' or the getter
     method, the specified procedure is called, and its result is
     returned as the value of the slot.  The procedure can return an
     undef value (the return value of `undefined') to indicate the slot
     doesn't have a value.  If the slot allocation is not `virtual'
     this slot option is ignored.

`:slot-set!'
     Specifies a value that evaluates to a procedure which takes two
     arguments, an instance and a value.  Whenever a program tries to
     set the value of the slot, either using `slot-set!' or the setter
     method, the specified procedure is called with the value to be set.
     If the slot allocation is not `virtual' this slot option is
     ignored.  If this option isn't given to a virtual slot, the slot
     becomes read-only.

`:slot-bound?'
     Specifies a value that evaluates to a procedure which takes one
     argument, an instance.  This slot option is only meaningful when
     the slot allocation is `virtual'.  Whenever a program tries to
     determine whether the slot has a value, this procedure is called.
     It should return a true value if the slot has a value, or `#f'
     otherwise.  If this slot option is omitted for a virtual slot, the
     system calls the procedure given to `slot-ref' instead, and see
     whether its return value is `#<undef>' or not.


File: gauche-refe.info,  Node: Inheritance,  Next: Class object,  Prev: Defining class,  Up: Class

7.3.2 Inheritance
-----------------

Inheritance has two roles.  First, you can _extend_ the existing class
by adding more slots.  Second, you can _specialize_ the methods related
to the existing class so that those methods will do a little more
specific task than the original methods.

   Let's define some terms.  When a class `<T>' inherits a class `<S>',
we call `<T>' a _subclass_ of `<S>', and `<S>' a _superclass_ of `<T>'.
This relation is transitive: `<T>''s subclasses are also `<S>''s
subclasses, and `<S>''s superclasses are also `<T>''s superclasses.
Specifically, if `<T>' directly inherits `<S>', that is, `<S>' appeared
in the superclass list when `<T>' is defined, then `<S>' is a _direct
superclass_ of `<T>', and `<T>' is a _direct subclass_ of `<S>'.

   When a class is defined, it and its superclasses are ordered from
subclasses to superclasses, and a list of classes is created in such
order.   It is called _class precedence list_, or CPL.  Every class has
its own CPL.  A CPL of a class always begins with the class itself, and
ends with `<top>'.

   You can query a class's CPL by a procedure `class-precedence-list':

     gosh> (class-precedence-list <boolean>)
     (#<class <boolean>> #<class <top>>)
     gosh> (class-precedence-list <string>)
     (#<class <string>> #<class <sequence>> #<class <collection>> #<class <top>>)

   As you see, all classes inherits a class named `<top>'.  Some
built-in classes have several abstract classes in its CPL between
itself and `<top>'; the above example shows `<string>' class inherits
`<sequence>' and `<collection>'.  That means a string can behave both
as a sequence and a collection.

     gosh> (is-a? "abc" <string>)
     #t
     gosh> (is-a? "abc" <sequence>)
     #t
     gosh> (is-a? "abc" <collection>)
     #t

   How about inheritance of Scheme-defined classes?  If there's only
single inheritance, its CPL is straightforward: you can just follow the
class's super, its super's super, its super's super's super, ..., until
you reach `<top>'.  See the example:

     gosh> (define-class <a> () ())
     <a>
     gosh> (define-class <b> (<a>) ())
     <b>
     gosh> (class-precedence-list <b>)
     (#<class <b>> #<class <a>> #<class <object>> #<class <top>>)

   Scheme-defined class always inherits `<object>'.  It is
automatically inserted by the system.

   When multiple inheritance is involved, a story becomes a bit
complicated.  We have to merge multiple CPLs of the superclasses into
one CPL.  It is called _linearization_, and there are several known
linealization strategies.  By default, Gauche uses an algorithm called
_C3 linearization_, which is consistent with the local precedence order,
monotonicity, and the extended precedence graph.  We don't go into the
details here; as a general rule, the order of superclasses in a class's
CPL is always consistent to the order of direct superclasses of the
class, the order of CPL of each superclasses, and the order of direct
superclasses of each superclass, and so on.   See *note [Dylan]: dylan.
for the precise description.

   If a class inherits superclasses in a way that its CPL can't be
constructed with satisfying consistencies, an error is reported.

   Here's a simple example of multiple inheritance.

     (define-class <grid-layout> () ())

     (define-class <horizontal-grid> (<grid-layout>) ())

     (define-class <vertical-grid> (<grid-layout>) ())

     (define-class <hv-grid> (<horizontal-grid> <vertical-grid>) ())

     (map class-name (class-precedence-list <hv-grid>))
      => (<hv-grid> <horizontal-grid> <vertical-grid>
          <grid-layout> <object> <top>)

   Note that the order of direct superclasses of `<hv-grid>'
(`<horizontal-grid>' and `<vertical-grid>') is kept.

   The following is a little twisted example:

     (define-class <pane> () ())

     (define-class <scrolling-mixin> () ())

     (define-class <scrollable-pane> (<pane> <scrolling-mixin>) ())

     (define-class <editing-mixin> () ())

     (define-class <editable-pane> (<pane> <editing-mixin>) ())

     (define-class <editable-scrollable-pane>
        (<scrollable-pane> <editable-pane>) ())

     (map class-name (class-precedence-list <editable-scrollable-pane>))
      => (<editable-scrollable-pane> <scrollable-pane>
          <editable-pane> <pane> <scrolling-mixin> <editing-mixin>
          <object> <top>)

   Once the class precedence order is determined, the slots of defined
class is calculated as follows: the slot definitions are collected in
the direction from superclasss to subclass in CPL.  If a subclass has a
slot definition of the same name of the one in superclass, then the
slot definition of the subclass is taken and superclass's is discarded.
  Suppose a class `<S>' defines slots `a', `b', and `c', a class `<T>'
defines slots `c', `d', and `e', and a class `<U>' defines slots `b'
and `e'.  When `<U>''s CPL is `(<U> <T> <S> <object> <top>)', then
`<U>''s slots is calculated as the chart below; that is, `<U>' gets
five slots, of which `b' and `e''s definitions come from `<U>''s
definitions, `c' and `d''s come from `<T>', and `a''s comes from `<S>'.

        CPL      | slot definitions
                 |  () indicates shadowed slot
      -----------+-------------------
        <top>    |
        <object> |
        <S>      | a  (b) (c)
        <T>      |         c   d  (e)
        <U>      |     b           e
      -----------+--------------------
      <U>'s slots| a   b   c   d   e

   You can get a list of slot definitions of a class object using
`class-slots' function.

   Note that the behavior described above is mere a default behavior.
You can customize how the CPL is computed, or how slot definitions are
inherited, by defining metaclass.  For example, you can write a
metaclass that allows you to merge slot options of the same slot names,
instead of the one shadowing the other.  Or you can write a metaclass
that forbids a subclass shadows the superclass's slot.


File: gauche-refe.info,  Node: Class object,  Next: Slot definition object,  Prev: Inheritance,  Up: Class

7.3.3 Class object
------------------

What is a class?  In Gauche, a class is just an object that implements
a specific feature: to instantiate an object.  Because of that, you can
introspect the class by just looking into the slot values.  There are
some procedures provided for the convenience of such introspection.
Note that if those procedures return a list, it belongs to the class
and you shouldn't modify it.

 -- Function: class-name class
     Returns the name of CLASS.

          (class-name <string>) => <string>

 -- Function: class-precedence-list class
     Returns the class precedence list of CLASS.

          (class-precedence-list <string>)
            => (#<class <string>>
                #<class <sequence>>
                #<class <collection>>
                #<class <top>>)

 -- Function: class-direct-supers class
     Returns a list of direct superclasses of CLASS.  A direct
     superclass is a class from which CLASS inherits directly.

          (class-direct-supers <string>)
            => (#<class <sequence>>)

 -- Function: class-direct-subclasses class
     Returns a list of direct subclasses of CLASS.  A direct subclass
     is a class that directly inherits CLASS.  If `<T>' is a direct
     subclass of `<S>', then `<S>' is a direct superclass of `<T>'.

 -- Function: class-slots class
     Returns a list of _slot definitions_ of CLASS.  A slot definition
     is a list whose car is the name of the slot and whose cdr is a
     keyword-value list that specifies slot options.  You can further
     inspect a slot definition to know what characteristics the slot
     has.  See *note Slot definition object:: for the details.

     The standard way to get a list of slot names of a given class is
     `(map slot-definition-name (class-slots class))'.

 -- Function: class-slot-definition class slot-name
     Returns a slot definition of a slot specified by SLOT-NAME in a
     class CLASS.  If CLASS doesn't have a named slot, `#f' is returned.

 -- Function: class-direct-slots class
     Returns a list of slot definitions that are directly defined in
     this class (i.e. not inherited from superclasses).  This
     information is used to calculate slot inheritance during class
     initialization.

 -- Function: class-direct-methods class
     Returns a list of methods that has CLASS in its specializer.

 -- Function: class-slot-accessor class slot-name
     Returns a slot accessor object of the slot specified by SLOT-NAME
     in CLASS.  A slot accessor object is an internal object that
     encapsulates the information how to access, modify, and initialize
     the given slot.

     You don't usually need to deal with slot accessor objects unless
     you are defining some special slots using metaobject protocol.


File: gauche-refe.info,  Node: Slot definition object,  Next: Class redefinition,  Prev: Class object,  Up: Class

7.3.4 Slot definition object
----------------------------

A slot definition object, returned by `class-slots',
`class-direct-slots' and `class-slot-definition', keeps information
about a slot.  Currently Gauche uses a list to represent the slot
definition, as STklos and TinyCLOS do.  However, it is not guaranteed
that Gauche keeps such a structure in future; you should use the
following dedicated accessor methods to obtain information of a slot
definition object.

 -- Function: slot-definition-name slot-def
     Returns the name of a slot given by a slot definition object
     SLOT-DEF.

 -- Function: slot-definition-options slot-def
     Returns a keyword-value list of slot options of SLOT-DEF.

 -- Function: slot-definition-allocation slot-def
     Returns the value of `:allocation' option of SLOT-DEF.

 -- Function: slot-definition-getter slot-def
 -- Function: slot-definition-setter slot-def
 -- Function: slot-definition-accessor slot-def
     Returns the value of `:getter', `:setter' and `:accessor' slot
     options of SLOT-DEF, respectively.

 -- Function: slot-definition-option slot-def option &optional default
     Returns the value of slot option OPTION of SLOT-DEF.  If there's
     no such an option, DEFAULT is returned if given, or an error is
     signalled otherwise.


File: gauche-refe.info,  Node: Class redefinition,  Next: Class definition examples,  Prev: Slot definition object,  Up: Class

7.3.5 Class redefinition
------------------------

If the specified class name is bound to a class when `define-class' is
used, it is regarded as _redefinition_ of the original class.

   Redefinition of a class means the following operations:
   * A new class object is created based on the new definition, and
     bound to the variable given to `define-class'.

   * Methods defined on the original class (i.e. methods that have the
     original class in their specializers) are changed so that they are
     defined on the new class.

   * The direct-subclasses link of the direct superclasses of the
     original class is modified so that they will point to the new
     class.

   * All the subclasses of the original class are redefined recursively
     so that they reflect the changes of the class.  Each class
     remembers its initialization arguments, and each redefined
     subclass gets the same initialization arguments as the original
     subclass.

   * The original class is marked _redefined_.

   Note that the original class and the new class are different objects.
The original class object remembers which variable in which module it
is originally bound, and replaces the binding to a new class.  If you
keep the direct reference to the original class somewhere else, it
still refers to the original class; you might want to take extra care.
You can customize class redefinition behavior by defining the
`class-redefinition' method; see *note Metaobject protocol:: for the
details.

   If there are instances of the original class, such instances are
automatically _updated_ when it is about to be accessed or modified via
`class-of', `is-a?', `slot-ref', `slot-set!', `ref', a getter method,
or a setter method.

   Updating an instance means that the class of the instance is changed
(from the old class to the new class).  By default, the values of the
slots that are common in the original class and the new class are
carried over, and the slots added by the new class are initialized
according to the slot specification of the new class, and the values of
the slots that are removed from the original class are discarded.  You
can customize this behavior by writing the `change-class' method.  See
*note Changing classes::, for the details.

Notes on thread safety
......................

Class redefinition process is non-local operation with full of
side-effects.  It is difficult to guarantee that two threads safely run
class redefinition protocol simultaneously.   So Gauche uses a
process-wide lock to limit only one thread to enter the class
redefinition protocol at a time.

   If a thread tries to redefine a class while another thread is in the
redefinition protocol, the thread is blocked, even if it is redefining
a class different from the one that are being redefined; because
redefinition affects all the subclasses, and all the methods and
generic functions that are related to the class and subclasses, it is
not trivial to determine two classes are completely independent or not.

   If a thread tries to access an instance whose class is being
redefined by another thread, also the thread is blocked until the
redefinition is finished.

   Note that the instance update protocol isn't serialized.  If two
threads try to access an instance whose class has been redefined, both
trigger the instance update protocol, which would cause an undesired
race condition.  It is the application's responsibility to ensure such
a case won't happen.  It is natural since the instance access isn't
serialized by the system anyway.  However, an extra care is required to
have mutex within an instance; just accessing the mutex in it may
trigger the instance update protocol.

Notes on compatibility
......................

Class redefinition protocols subtlety differ among CLOS-like Scheme
systems.   Gauche's is very similar to STklos's, except that STklos
0.56 doesn't replace bindings of redefined subclasses, and also it
doesn't remember initialization arguments so the redefined subclass may
lose some of the information that the original subclass has.  Guile's
object system swaps identities of the original class and the redefined
class at the end of class redefinition protocol, so the reference to
the original class object will turn to the redefined class.  As far as
the author knows, class redefinition is not thread-safe in both STklos
0.56 and Guile 1.6.4.


File: gauche-refe.info,  Node: Class definition examples,  Prev: Class redefinition,  Up: Class

7.3.6 Class definition examples
-------------------------------

Let's see some examples.  Suppose you are defining a graphical toolkit.
A `<window>' is a rectangle region on the screen, so it has width and
height.  It can be organized hierarchically, i.e. a window can be
placed within another window; so it has a pointer to the parent window.
And we specify the window's position, x, y, by the coordinate relative
to its parent window.  Finally, we create a "root" window that covers
entire screen.  It also serves the default parent window.  So far, what
we get is something like this:

     ;; The first version
     (define-class <window> ()
       (;; Pointer to the parent window.
        (parent      :init-keyword :parent :init-form *root-window*)
        ;; Sizes of the window
        (width       :init-keyword :width  :init-value 1)
        (height      :init-keyword :height :init-value 1)
        ;; Position of the window relative to the parent.
        (x           :init-keyword :x :init-value 0)
        (y           :init-keyword :y :init-value 0)
        ))

     (define *screen-width* 1280)
     (define *screen-height* 1024)

     (define *root-window*
       (make <window> :parent #f :width *screen-width* :height *screen-height*))

   Note the usage of `:init-value' and `:init-form'.  When the
`<window>' class is defined, we haven't bound `*root-window*' yet, so
we can't use `:init-value' here.

     gosh> *root-window*
     #<<window> 0x80db1d0>
     gosh> (define window-a (make <window> :width 100 :height 100))
     window-a
     gosh> (d window-a)
     #<<window> 0x80db1b0> is an instance of class <window>
     slots:
       parent    : #<<window> 0x80db1d0>
       width     : 100
       height    : 100
       x         : 0
       y         : 0
     gosh> (define window-b
             (make <window> :parent window-a :width 50 :height 20 :x 10 :y 5))
     window-b
     gosh> (d window-b)
     #<<window> 0x80db140> is an instance of class <window>
     slots:
       parent    : #<<window> 0x80db1b0>
       width     : 50
       height    : 20
       x         : 10
       y         : 5

   If you're like me, you don't want to expose a global variable such
as `*root-window*' for users of your toolkit.  One way to encapsulate
it (to certain extent) is to keep the pointer to the root window in a
class variable.  Add the following slot option to the definition of
`<window>', and the slot `root-window' of the `<window>' class refers
to the same storage space.

     (define-class <window> ()
       (...
        ...
        (root-window :allocation :class)
        ...))

   You can use `slot-ref' and `slot-set!' on an instance of `<window>',
or use `class-slot-ref' and `class-slot-set!' on the `<window>' class
itself, to get/set the value of the `root-window' slot.

   The users of the toolkit may want to get the absolute position of
the window (the coordinates in the root window) instead of the relative
position.  You may provide virtual slots that returns the absolute
positions, like the following:

     (define-class <window> ()
       (...
        ...
        (root-x :allocation :virtual
                :slot-ref  (lambda (o)
                             (if (ref o 'parent)
                                 (+ (ref (ref o 'parent) 'root-x)
                                    (ref o 'x))
                                 (ref o 'x)))
                :slot-set! (lambda (o v)
                             (set! (ref o 'x)
                                   (if (ref o 'parent)
                                       (- v (ref (ref o 'parent) 'root-x))
                                       v)))
                 )
         ...))

   Whether providing such interface via methods or virtual slots is
somewhat a matter of taste.   Using virtual slots has an advantage of
being able to hide the change of implementation, i.e. you can change to
keep `root-x' in a real slot and make `x' a virtual slot later without
breaking the code using `<window>'.  (In the mainstream object-oriented
languages, such kind of "hiding implementation" is usually achieved by
hiding instance variables and exposing methods.  In Gauche and other
CLOS-like systems, slots are always visible to the users, so the
situation is a bit different.


File: gauche-refe.info,  Node: Instance,  Next: Generic function and method,  Prev: Class,  Up: Object system

7.4 Instance
============

In this section, we explain how to create and use an instance.

* Menu:

* Creating instance::
* Accessing instance::
* Changing classes::


File: gauche-refe.info,  Node: Creating instance,  Next: Accessing instance,  Prev: Instance,  Up: Instance

7.4.1 Creating instance
-----------------------

Using class object, you can create an instance of the class by a
generic function `make'.  A specialized method for standard `<class>'
is defined:

 -- Generic Function: make
 -- Method: make (class <class>) arg ...
     Creates an instance of CLASS and returns it.  ARG ... is typically
     a keyword-value list to initialize the instance.

   Conceptually, the default `make' method is defined as follows:

     (define-method make ((class <class>) . initargs)
       (let ((obj (allocate-instance class initargs)))
         (initialize obj initargs)
         obj))

   That is, first it allocates memory for CLASS's instance, then
initialize it with the `initialize' method.

 -- Generic Function: allocate-instance
 -- Method: allocate-instance (class <class>) initargs
     Returns a newly-allocated uninitialized instance of CLASS.

 -- Generic Function: initialize
 -- Method: initialize (obj <object>) initargs
     The default initialize method for `<object>' works as follows:

        * For each initializable slot of the class
             * If (the slot has the :init-keyword slot option AND the
               keyword appears in INITARGS): Then the corresponding
               value is used to initialize the slot

             * Else if the slot has :init-value slot option: Then the
               value given to the slot option is used to initialize the
               slot

             * Else if the slot has :init-thunk slot option: Then the
               thunk is called, and the returned value is used to
               initialize the slot.

             * Else: The slot is left unbound.

     Among the default slot allocation classes, only instance-allocated
     slots are initializable and are handled by the above sequence.
     Class-allocated slots (e.g. its slot allocation is either `:class'
     or `:each-subclass') are initialized when the class object is
     created, if `:init-value' or `:init-form' slot option is given.
     Virtual slots aren't initialized at all.

     An user-defined allocation class can be configured either
     initializable or not initializable; see *note Metaobject
     protocol:: for the details.

     If you specialize `initialize' method, make sure to call
     `next-method' so that the slots are properly initialized by the
     default sequence, before accessing any slot of the newly created
     instance.

   Typically you specialize `initialize' method for your class to
customize how the instance is initialized.

   It is not common to specialize `allocate-instance' method.  However,
knowing that how `make' works, you can specialize `make' itself to
avoid allocation of instance in some circumstances (e.g. using
pre-allocated instances).


File: gauche-refe.info,  Node: Accessing instance,  Next: Changing classes,  Prev: Creating instance,  Up: Instance

7.4.2 Accessing instance
------------------------

Standard accessors
..................

 -- Function: slot-ref obj slot
     Returns a value of the slot SLOT of object OBJ.

     If the specified slot is not bound to any value, a generic function
     `slot-unbound' is called with three arguments, OBJ's class, OBJ,
     and SLOT.  The default behavior of `slot-unbound' is to signal an
     error.

     If the object doesn't have the specified slot, a generic function
     `slot-missing' is called with three arguments, OBJ's class, OBJ,
     and SLOT.  The default behavior of `slot-missing' is to signal an
     error.

 -- Function: slot-set! obj slot value
     Alters the value of the slot SLOT of object OBJ to the value VALUE.

     If the object doesn't have the specified slot, a generic function
     `slot-missing' is called with four arguments, OBJ's class, OBJ,
     SLOT, VALUE.

 -- Function: slot-bound? obj slot
     Returns true if object OBJ's slot SLOT is bound, otherwise returns
     false.

     If the object doesn't have the specified slot, a generic function
     `slot-missing' is called with three arguments, OBJ's class, OBJ,
     SLOT.

 -- Function: slot-exists? obj slot
     Returns true if OBJ has the slot named SLOT.

 -- Function: slot-push! obj slot value
     This function implements the common idiom.  It can be defined like
     the following code (but it may be optimized in the future
     versions).
          (define (slot-push! obj slot value)
            (slot-set! obj slot (cons value (slot-ref obj slot))))

 -- Method: ref (obj <object>) (slot <symbol>)
 -- Method: (setter ref) (obj <object>) (slot <symbol>) value
     These methods just calls `slot-ref' and `slot-set!', respectively.
     They are slightly less efficient than directly calling `slot-ref'
     and `slot-set!', but more compact in the program code.

Fallback methods
................

 -- Generic Function: slot-unbound
 -- Method: slot-unbound (class <class>) obj slot
     This generic function is called when an unbound slot value is
     retrieved.  The return value of this generic function will be
     returned to the caller that tried to get the value.

     The default method just signals an error.

 -- Generic Function: slot-missing
 -- Method: slot-missing (class <class>) obj slot &optional value
     This generic function is called when a non-existent slot value is
     retrieved or set.  The return value of this generic function will
     be returned to the caller that tried to get the value.

     The default method just signals an error.

Special accessors
.................

 -- Function: class-slot-ref class slot-name
 -- Function: class-slot-set! class slot-name obj
 -- Function: class-slot-bound? class slot-name obj
     When slot's `:allocation' option is either `:class' or
     `:each-subclass', these procedures allow you to get/set the value
     of the slot without having an instance.

 -- Method: slot-ref-using-class (class <class>) (obj <object>)
          slot-name
 -- Method: slot-set-using-class! (class <class>) (obj <object>)
          slot-name value
 -- Method: slot-bound-using-class? (class <class>) (obj <object>)
          slot-name
     Generic function version of `slot-ref', `slot-set!' and
     `slot-bound?'.   CLASS must be the class of OBJ.

     Besides being generic, these functions are different from their
     procedural versions that they don't trigger class redefinition
     when OBJ's class has been redefined (i.e. in which case, CLASS
     should be the original class of OBJ).

     Note: Unlike CLOS, `slot-ref' etc. don't call the generic function
     version in it, so you can't customize the behavior of `slot-ref'
     by specializing `slot-ref-using-class'.  So the primary purpose of
     those generic functions are to be used within `change-class'
     method; especially, `slot-ref' etc.  can't be used during OBJ's
     being redefined, since they trigger class redefinition again (see
     *note Changing classes:: for details).


File: gauche-refe.info,  Node: Changing classes,  Prev: Accessing instance,  Up: Instance

7.4.3 Changing classes
----------------------

Class change protocol
.....................

An unique feature of CLOS-family object system is that you can change
classes of an existing instance.  The two classes doesn't need to be
related; you can change a sewing machine into an umbrella, if you like.

 -- Generic Function: change-class
 -- Method: change-class (obj <object>) (new-class <class>)
     Changes an object OBJ's class to NEW-CLASS.  The default method
     just calls `change-object-class' procedure.

 -- Function: change-object-class obj orig-class new-class
     Changes an object OBJ's class from ORIG-CLASS to NEW-CLASS.  This
     isn't a generic function--changing object's class needs some
     secret magic, and this procedure encapsulates it.

     The precise steps of changing class are as follow:

       1. A new instance of NEW-CLASS is allocated by
          `allocate-instance'.

       2. For each slot of NEW-CLASS:
            1. If the slot also exists in OLD-CLASS, and is bound in
               OBJ, the value is retrieved from OBJ and set to the new
               instance.  (The slot is _carried over_).

            2. Otherwise, the slot of the new instance is initialized
               by standard slot initialization protocol, as described
               in *note Creating instance::.

       3. Finally, the content of the new instance is _transplanted_ to
          the OBJ--that is, OBJ becomes the instance of NEW-CLASS
          without changing its identity.

     Note that `initialize' method of NEW-CLASS isn't called on OBJ.
     If you desire, you can call it by your own `change-class' method.

     `Change-object-class' returns OBJ.

   Usually a user is not supposed to call `change-object-class'
directly.  Instead, she can define a specialized `change-class'.  For
example, if she wants to carry over the slot `x' of old class to the
slot `y' of new class, she may write something like this:

     (define-method change-class ((obj <old-class>) <new-class>)
       (let ((old-val (slot-ref obj 'x)))
         (next-method)               ;; calls default change-class
         (slot-set! obj 'y old-val)  ;; here, obj's class is already <new-class>.
         obj))

Customizing instance update
...........................

Updating an instance for a redefined class is also handled as class
change.  When an object is accessed via normal slot accessor/modifier,
its class is checked whether it has been redefined.  And if it has
indeed been redefined, `change-class' is called with the redefined
class as NEW-CLASS; that is, updating an instance is regarded as
changing object's class from the original one to the redefined one.

   By specializing `change-class', you can customize the way an
instance is updated for a redefined class.  However, you need a special
care to write `change-class' for class redefinition.

   First, the redefinition changes global binding of the class object.
So you need to keep the reference to the old class before redefining
the class, and use the old class to specialize `change-class' method:

     ;; save old <myclass>
     (define <old-myclass> <myclass>)

     ;; redefine <myclass>
     (define-class <myclass> ()
       ...)

     ;; define customized change-class method
     (define-method change-class ((obj <old-myclass>) <myclass>)
       ...
       (next-method)
       ...)

   Next, note that the above `change-class' method may be triggered
implicitly when you access to OBJ via `slot-ref', `slot-set!',
`class-of', etc.  If you use such procedures like `slot-ref' on OBJ
again within `change-class', it would trigger the instance update
protocol recursively, which would cause an infinite loop.  You can only
use the methods that doesn't trigger instance update, that is,
`slot-ref-using-class', `slot-set-using-class!',
`slot-bound-using-class?' and `current-class-of'.

   If you want to carry over a slot whose value is calculated
procedurally, such as a virtual slot, then `slot-ref' etc.  might be
called implicitly on OBJ during calculating the slot value.  Actually
`change-object-class' has a special protection to detect such a
recursion.  If that happens, `change-object-class' gives up to retrieve
the slot value and just initializes the slot of the new instance as if
the old slot were unbound.

   Customizing instance update is highly tricky business, although very
powerful.   You can find some nontrivial cases in the test program of
Gauche source code; take a look at `test/object.scm'.


File: gauche-refe.info,  Node: Generic function and method,  Next: Metaobject protocol,  Prev: Instance,  Up: Object system

7.5 Generic function and method
===============================

Defining methods
----------------

 -- Macro: define-generic name &keyword class
     Creates a generic function and bind it to NAME.

     You don't usually need to use this, since the `define-method'
     macro implicitly creates a generic function if it doesn't exist
     yet.

     You can pass a subclass of `<generic>' to the CLASS keyword
     argument so that the created generic function will be the instance
     of the passed class, instead of the default `<generic>' class.  It
     is useful when you defined a subclass of `<generic>' to customize
     generic function application behavior.

 -- Macro: define-method name specs body
     Defines a method whose name is NAME.  If there's already a generic
     function object globally bound to NAME, the created method is
     added to the generic function.  If NAME is unbound, or bound to an
     object except a generic function, then a new generic function is
     created, bound to NAME, then a new method is added to it.

     SPECS specifies the arguments and their types for this method.
     It's like the argument list of lambda form, except you can specify
     the type of each argument.

          specs : ( arg ... )
                | ( arg ... . symbol )
                | symbol

          arg   : ( symbol class )
                | symbol

     Class specifies the class that the argument has to belong to.  If
     `arg' is just a symbol, it is equivalent to `(arg <top>)'.  You
     can't specify the type for the "rest" argument, for it is always
     bound to a list.

     The list of classes of the argument list is called _method
     specializer list_, based on which the generic function will select
     appropriate methods(s).  Here are some examples of SPECS and the
     corresponding specializer list:

          specs:        ((self <myclass>) (index <integer>) value)
          specializers: (<myclas> <integer> <top>)

          specs:        ((self <myclass>) obj . options)
          specializers: (<myclas> <top> . <top>)

          specs:        (obj (attr <string>))
          specializers: (<top> <string>)

          specs:        args
          specializers: <top>

     If you define a method on NAME whose specializer list matches with
     one in the generic function's methods, then the existing method is
     replaced by the newly defined one.

Applying generic function
-------------------------

When a generic function is applied, first it selects methods whose
specializer list matches the given arguments.  For example, suppose a
generic function `foo' has three methods, whose specializer lists are
`(<string> <top>)', `(<string> <string>)', and `(<top> <top>)',
respectively.  When `foo' is applied like `(foo "abc" 3)', the first
and the third method will be selected.

   Then the selected methods are sorted from the most _specific_ method
to the least specific method.  It is calculated as follows:

   * Suppose we have a method `a' that has specializers `(A1 A2 ...)',
     and a method `b' that has `(B1 B2 ...)'.

   * Find the minimum N where the classes `An' and `Bn' differ.   Then
     the class of N-th argument is taken, and its class precedence list
     is checked.  If `An' comes before `Bn' in the CPL, then method `a'
     is more specific than `b'.  Otherwise, `b' is more specific than
     `a'.

   * If all the specializers of `a' and `b' are the same, except that
     one has an improper tail ("rest" argument) and another doesn't,
     then the method that doesn't have an improper tail is more
     specific than the one that has.

   Once methods are sorted, the body of the first method is called with
the actual argument.

   Within the method body, a special local variable `next-method' is
bound implicitly.

 -- Next method: next-method
 -- Next method: next-method args ...
     This variable is bound within a method body to a special object
     that encapsulates the next method in the sorted method list.

     Calling without arguments invokes the next method with the same
     arguments as this method is called with.  Passing ARGS ...
     explicitly invokes the next method with the passed arguments.

     If `next-method' is called in the least specific method, i.e.
     there's no "next method", an error is signalled.


File: gauche-refe.info,  Node: Metaobject protocol,  Prev: Generic function and method,  Up: Object system

7.6 Metaobject protocol
=======================

In CLOS-like object systems, the object system is built on top of
itself--that is, things such as the structure of the class, how a class
is created, how an instance is created and initialized, and how a
method is dispatched and called, are all defined in terms of the object
system.  For example, a class is just an instance of the class
`<class>' that defines a generic structure and behavior of standard
classes.  If you subclass `<class>', then you can create your own set
of classes that behaves differently than the default behavior; in
effect, you are creating your own object system.

   _Metaobject protocols_ are the definitions of APIs concerning about
how the object systems are built--building-block classes, and the names
and orders of generic functions to be called during operations of the
object system.  Subclassing these classes and specializing these
methods are the means of customizing object system behaviors.

* Menu:

* Class instantiation::
* Customizing slot access::
* Method instantiation::
* Customizing method application::


File: gauche-refe.info,  Node: Class instantiation,  Next: Customizing slot access,  Prev: Metaobject protocol,  Up: Metaobject protocol

7.6.1 Class instantiation
-------------------------

Every class is an instance of a group of special classes.  A class that
can be a class of another class is called _metaclass_.  In Gauche, only
the `<class>' class or its subclasses can be a metaclass.

Expansion of `define-class'
...........................

The `define-class' macro is basically a wrapper of the code that
creates an instance of `<class>' (or specified metaclass) and bind it
to the given name.  Suppose you have the following `define-class' form.
     (define-class NAME (SUPERS)
       SLOT-SPECS
       OPTIONS ...)

   It is expanded into a form like this (you can see the exact form by
looking at the definition of `define-class' macro in ``gauche-config
--syslibdir`/gauche/object.scm').
     (define NAME
       (let ((tmp1 (make METACLASS
                      :name 'NAME :supers (list SUPERS)
                      :slots (map PROCESS-SLOT-DEFINITIONS
                                  SLOT-SPECS)
                      :defined-modules (list (current-module))
                      OPTIONS ...)))
         ... CHECK CLASS REDEFINITION ...
         ... REGISTERING ACCESSOR METHODS ...
         tmp1))

   The created class's class, i.e. METACLASS, is determined by the
following rules.

  1. If `:metaclass' option is given to the `define-class' macro, its
     value is used.  The value must be the `<class>' class or its
     descendants.

  2. Otherwise, the metaclasses of the classes in the class precedence
     list is examined.
        * If all the metaclasses are `<class>', then the created
          class's metaclass is also `<class>'.

        * If all the metaclasses are either `<class>' or another
          metaclass `A', then the created class' metaclass is `A'.

        * If the set of metaclasses contains more than one metaclass
          (`A', `B', `C' ...) other than `<class>', then the created
          class' metaclass is a metaclass that inherits all of those
          metaclasses `A', `B', `C' ....

   The class's name, superclasses, and slot definitions are passed as
the initialization arguments to the `make' generic function, with other
arguments passed to `define-class'.  The initialization argument
`defined-modules' is passed to remember which module the class is
defined, for the redefinition of this class.

   The slot specifications SLOT-SPECS are processed by internal method
PROCESS-SLOT-DEFINITIONS (which can't be directly called) to be turned
into slot definitions.  Specifically, an `:init-form' slot option is
turned into an `:init-thunk' option, and `:getter', `:setter' and
`:accessor' slot options are quoted.

   After the class (an instance of METACLASS) is created, the global
binding of NAME is checked.  If it is bound to a class, then the class
redefinition protocol is invoked (see *note Class redefinition::).

   Then, the methods given to `:getter', `:setter' and `:accessor' slot
options in SLOT-SPEC are collected and registered to the corresponding
generic functions.

Class structure
...............

 -- Class: <class>
     The base class of all metaclasses, `<class>', has the following
     slots.  Note that these slots are for internal management, and
     users shouldn't change their values after the class is
     initialized.  It is recommended to obtain information about a
     class by procedures described in *note Class object::, instead of
     directly accessing those slots.

      -- Instance Variable of <class>: name
          The name of the class; the symbol given to `define-class'
          macro.  `class-name' returns this value.

      -- Instance Variable of <class>: cpl
          Class precedence list.  `class-precedence-list' returns this
          value.

      -- Instance Variable of <class>: direct-supers
          The list of direct superclasses.  `class-direct-supers'
          returns this value.

      -- Instance Variable of <class>: accessors
          An assoc list of slot accessors--it encapsulates how each slot
          should be accessed.

      -- Instance Variable of <class>: slots
          A list of slot definitions.  `class-slots' returns this value.
          See *note Slot definition object::, for the details of slot
          definitions.

      -- Instance Variable of <class>: direct-slots
          A list of slot definitions that is directly specified in this
          class definition (i.e. not inherited).  `class-direct-slots'
          returns this value.

      -- Instance Variable of <class>: num-instance-slots
          The number of instance allocated slots.

      -- Instance Variable of <class>: direct-subclasses
          A list of classes that directly inherits this class.
          `class-direct-subclasses' returns this value.

      -- Instance Variable of <class>: direct-methods
          A list of methods that has this class in its specializer list.
          `class-direct-methods' returns this value.

      -- Instance Variable of <class>: initargs
          The initialization argument list when this class is created.
          The information is used to initialize redefined class (see
          *note Class redefinition::).

      -- Instance Variable of <class>: defined-modules
          A list of modules where this class has a global binding.

      -- Instance Variable of <class>: redefined
          If this class has been redefined, this slot contains a
          reference to the new class.  Otherwise, this slot has `#f'.

      -- Instance Variable of <class>: category
          The value of this slot indicates how this class is created.
          Scheme defined class has a symbol `scheme'.  Other values are
          for internal use.

The make method for `<class>'
.............................

 -- Method: make (class <class>) &rest initargs


File: gauche-refe.info,  Node: Customizing slot access,  Next: Method instantiation,  Prev: Class instantiation,  Up: Metaobject protocol

7.6.2 Customizing slot access
-----------------------------

 -- Generic Function: compute-slots

 -- Generic Function: compute-get-n-set

 -- Function: slot-ref-using-accessor obj slot-accessor
 -- Function: slot-set-using-accessor obj slot-accessor value


File: gauche-refe.info,  Node: Method instantiation,  Next: Customizing method application,  Prev: Customizing slot access,  Up: Metaobject protocol

7.6.3 Method instantiation
--------------------------

 -- Method: make (class <method>) &rest initargs


File: gauche-refe.info,  Node: Customizing method application,  Prev: Method instantiation,  Up: Metaobject protocol

7.6.4 Customizing method application
------------------------------------

 -- Generic Function: apply-generic gf args

 -- Generic Function: sort-applicable-methods gf methods args

 -- Generic Function: method-more-specific? method1 method2 classes

 -- Generic Function: apply-methods gf methods args

 -- Generic Function: apply-method gf method build-next args


File: gauche-refe.info,  Node: Library modules - Overview,  Next: Library modules - Gauche extensions,  Prev: Object system,  Up: Top

8 Library modules - Overview
****************************

In the following chapters, we explain library modules bundled with
Gauche's distribution.  These modules should generally be loaded and
imported (usually using `use' - *Note Using modules::, for details),
unless otherwise noted.

   Some modules are described as "autoloaded".  That means you don't
need to `load' or `use' the module explicitly; at the first time the
bindings are used in the program, the module is automatically loaded
and imported.  See *note Autoload::, for the details of autoloading.

   As the number of bundled libraries grows, it becomes harder to find
the one you need.  If you feel lost, check out the section *note
Finding libraries you need::, in which we categorize libraries by their
purposes.

   The following three chapters describe bundled modules, grouped by
their names.  *note Library modules - Gauche extensions:: contains a
description of `gauche.*' modules, which are more or less considered
the core features of Gauche but separated since less frequently used.
(Some modules are rather ad-hoc, but here for historical reasons).
*note Library modules - SRFIs:: describes the modules which provide
SRFI functionalities.  They have the names beginning with `srfi-'.
Note that some of SRFI features are built in Gauche core and not listed
here.  *Note Standard conformance::, for the entire list of supported
SRFIs.  *note Library modules - Utilities:: describes other modules
--including database interface, filesystem utilities, network protocol
utilities, and more.

   There are a few procedures that help your program to check the
existence of certain modules or libraries at run-time.  See *note
Operations on libraries::, for the details.

* Menu:

* Finding libraries you need::
* Naming convention of libraries::


File: gauche-refe.info,  Node: Finding libraries you need,  Next: Naming convention of libraries,  Prev: Library modules - Overview,  Up: Library modules - Overview

8.1 Finding libraries you need
==============================

Each module is named more or less after what it implements rather than
what it is implemented _for_.  If the module solves one problem, both
are the same.  However, sometimes there are multiple ways to solve a
problem, or one implementation of an algorithm can solve multiple
different problems; thus it is difficult to name the modules in
problem-oriented (or purpose-oriented) way.

   Because of this, it may not be straightforward for a newcomer to
Gauche to find an appropriate Gauche module to solve her problem, since
there may be multiple algorithms to do the job, and each algorithm can
be implemented in different modules.

   The modules are also designed in layers; some low-level modules
provide direct interface to the system calls, while some higher-level
ones provide more abstract, easy-to-use interface, possibly built on
top of more than one low-level modules.   Which one should you use?
Generally you want to use the highest level, for the very purpose of
libraries are to provide easy, abstract interface.  However there are
times that you have to break the abstraction and to go down to tweak
the machinery in the basement; then you need to use low-level modules
directly.

   The purpose of this section is to group the libraries by their
purposes.  Each category lists relevant modules with brief descriptions.

* Menu:

* Library directory - data containers::
* Library directory - strings and characters::
* Library directory - data exchange::
* Library directory - files::
* Library directory - processes::
* Library directory - networking::
* Library directory - input and output::
* Library directory - time::
* Library directory - bits and bytes::


File: gauche-refe.info,  Node: Library directory - data containers,  Next: Library directory - strings and characters,  Prev: Finding libraries you need,  Up: Finding libraries you need

8.1.1 Library directory - data containers
-----------------------------------------

Generic container operations
............................

Some data containers have similar properties; for example, lists,
vectors and hash tables can be seen as a collection of data.  So it is
handy to have generic operators, such as applying a procedure to all
the elements.

   Gauche provides such mechanism to a certain degree, mainly using its
object system.

   * _Collection_ - Generic functions applicable for unordered set of
     values.  *Note Collection framework::.

   * _Sequence_ - Generic functions applicable for ordered set of
     values.  *Note Sequence framework::.

   * _Relation_ - Generic functions to handle relations (in a sense of
     Codd's definition).  *Note Relation framework::.

   * _Comprehension_ - This is a collection of macros very handy to
     construct and traverse collections/sequences in concise code.
     *Note Eager comprehensions::.

Container implementations
.........................

   * _List_ - the universal data structure.  You want to check *note
     Pairs and Lists::, *note List library::, and *note Additional list
     library::.

   * _Vector_ - a one-dimensional array of arbitrary Scheme values.
     See *note Vectors:: and *note Vector library::.

   * _Uniform vector_ - a special kind of vectors that can hold limited
     types of values (e.g. integers representable in 8bits).  It tends
     to be used in performance sensitive applications, such as
     graphics.  See *note Uniform vectors::.

   * _Array_ - multi-dimensional arrays that can hold arbitrary Scheme
     values.  See *note Arrays::.

   * _Uniform array_ - multi-dimensional arrays that can hold limited
     types of values.  This is also supported by *note Arrays::.

   * _String_ - a sequence of characters.  See *note Strings:: and
     *note String library::.  Gauche handles multibyte strings-- see
     *note Multibyte Strings:: for the defatils.

   * _Character set_ - a set of characters.  See *note Character set::
     and *note Character-set library::.

   * _Hash table_ - hash tables.  See *note Hashtables::.  There are
     also some conversion functions in *note Additional list library::.

   * _Queue_ - a simple queue is provided in *note Queue::.

   * _Record_ - a simple data structure.  Although Gauche's object
     system can be used to define arbitrary data structures, you might
     want to look at *note Record types:: and *note SLIB-compatible
     record type::, for they are more portable and potentially more
     efficient.

   * _Stream_ - you can implement cool lazy algorithms with it.  See
     *note Stream library::.

   * _Balanced tree_ - Red-black tree implementation is available.  See
     *note Treemaps::.

   * _Trie_ - Another tree structure for efficient common-prefix
     search.  See *note Trie::.

   * _Database interface_ - dbm interface can be used as a persistent
     hash table; see *note Generic DBM interface::.  For generic RDBMS
     interface, see *note Database independent access layer::.


File: gauche-refe.info,  Node: Library directory - strings and characters,  Next: Library directory - data exchange,  Prev: Library directory - data containers,  Up: Finding libraries you need

8.1.2 Library directory - string and character
----------------------------------------------

Basic string operations are covered in *note Strings:: and *note String
library::.  A string is also a sequence of characters, so you can apply
methods in *note Collection framework:: and *note Sequence framework::.

   Character and character set operations are covered in *note
Characters::, *note Character set::, and *note Character-set library::.

   If you scan or build strings sequentially, do not use index access.
String ports (see *note String ports::) provides more efficient, and
elegant way.

   You can use regular expressions to search and extract character
sequences from strings; see *note Regular expression::.

   If you need to deal with low-level (i.e. byte-level) representation
of strings, *note Uniform vectors:: has some tools to convert strings
and byte vectors back and forth.

   Are you dealing with a structure higher than a mere sequence of
characters?  Then take a look at  `text.*' modules.  *note Parsing
input stream:: has some basic scanners.  *note Transliterate
characters:: implements a feature similar to Unix's `tr(1)'.  You can
take `diff' of two texts; see *note Calculate difference of text
streams::.  And if you want to construct large text from string
fragments, do not use `string-append'--see *note Lazy text
construction::.

   Last but not least, Gauche has support of various character encoding
schemes.  See *note Character code conversion:: for the basic
utilities.  Most higher-level functions such as `open-input-file' can
take `:encoding' keyword argument to perform character conversion
implicitly.  Also see *note Multibyte scripts:: if you write Scheme
program in non-ASCII characters.  If you want to process Gauche source
code which may contain "encoding" magic comment, see *note Coding-aware
ports::.  Gauche also has GNU gettext compatible module (*note
Localized messages::) if you need localization.


File: gauche-refe.info,  Node: Library directory - data exchange,  Next: Library directory - files,  Prev: Library directory - strings and characters,  Up: Finding libraries you need

8.1.3 Library directory - data exchange
---------------------------------------

Most useful programs need to communicate with outside world (other
programs or humans).  That involves reading the external data into your
program understanding whatever format the data is in, and also writing
the data in the format the others can understand.

   Lots of network-related external formats are defined in RFC, and
there are corresponding `rfc.*' module that handle some of them.  See
*note RFC822 message parsing::, for example, to handle the pervasive
RFC2822 message format.

   When you exchange table-formatted data, one of the easiest way may
be the plain text, one row per line, and columns are separeted by some
specific characters (e.g. comma).  See *note CSV tables:: for basic
parser/writer for them.

   Oh, and nowadays every business user wants XML, right?  You know
they are just S-expressions with extra redundancy and pointy
parentheses.  So why don't you read XML as if they're S-exprs, process
them with familiar cars and cdrs and maps, then write them out with
extra redundancy and pointy parens?  Module `sxml.ssax' (*note
Functional XML parser::) implements SAX XML parser, with which you can
parse XML and process them on the fly, or convert it to SXML,
S-expression XML.  You can query SXML using SXPath, an XPath
counterparts of S-expression (*note SXML Query Language::).  You can
output all kinds of XML and HTML using the SXML serializer (*note
Serializing XML and HTML from SXML::).

   It is planned that various file format handling routines would be
available as `file.*' modules, though we have none ready yet.  If you
plan to write one, please go ahead and let us know!


File: gauche-refe.info,  Node: Library directory - files,  Next: Library directory - processes,  Prev: Library directory - data exchange,  Up: Finding libraries you need

8.1.4 Library directory - files
-------------------------------

Files and directories.  Roughly speaking, there are two places you want
to look at.

   *note Filesystems::, in the core, has routines close to the
underlying OS provides.  If you have experience with Unix system
programming you'll find familiar function names there.   The `fcntl'
functionality is splitted to `gauche.fcntl' (*note Low-level file
operations::), FYI.

   Also you definitely want to look at `file.util' (*note Filesystem
utilities::), which implements higher-level routines on top of
system-level ones.


File: gauche-refe.info,  Node: Library directory - processes,  Next: Library directory - networking,  Prev: Library directory - files,  Up: Finding libraries you need

8.1.5 Library directory - processes
-----------------------------------

Process-related routines also come in two levels.

   The `gauche.process' module provides high-level routines (*note High
Level Process Interface::); you can pipe the data into and out of child
processes easily, for example.

   Gauche core provides the primitive `fork' and `exec' interface as
well as the convenient `system' call (see *note Unix process
management::).  Use them when you want a precise control over what
you're doing.


File: gauche-refe.info,  Node: Library directory - networking,  Next: Library directory - input and output,  Prev: Library directory - processes,  Up: Finding libraries you need

8.1.6 Library directory - networking
------------------------------------

We have multi-layer abstraction here.  At the bottom, we have APIs
corresponding to socket-level system calls.  In the middle, a
convenience library that automates host name lookups, connection and
shutdown, etc.  On top of them we have several modules that handles
specific protocols (e.g. http).

   The `gauche.net' module (*note Networking::) provides the bottom and
middle layer.  For the top layer, look for `rfc.*' modules, e.g.
`rfc.http' (*note HTTP::).  More protocol support is coming (there are
`rfc.ftp' and `rfc.imap4' written by users, which are waiting for being
integrated into Gauche--maybe in next release).

   There's a plan of even higher level of libraries, under the name
`net.*', which will abstract more than one network protocols.  The
planned ones include sending emails, or universal resource access by
uri.  Code contributions are welcome.


File: gauche-refe.info,  Node: Library directory - input and output,  Next: Library directory - time,  Prev: Library directory - networking,  Up: Finding libraries you need

8.1.7 Library directory - input and output
------------------------------------------


File: gauche-refe.info,  Node: Library directory - time,  Next: Library directory - bits and bytes,  Prev: Library directory - input and output,  Up: Finding libraries you need

8.1.8 Library directory - time
------------------------------


File: gauche-refe.info,  Node: Library directory - bits and bytes,  Prev: Library directory - time,  Up: Finding libraries you need

8.1.9 Library directory - bits and bytes
----------------------------------------

Binary I/O
..........

As the bottom level, Gauche includes primitive byte I/O (`read-byte',
`write-byte') as well as block I/O (`read-block!', `write-block') in
its core.  (See *note Reading data::, *note Output::, and *note Uvector
block I/O::).

   As the middle level, the module `binary.io' (*note Binary I/O::) has
routines to retrieve specific datatype with optional endian
specification.

   And as the top level, the module `binary.pack' (*note Packing Binary
Data::) allows packing and unpacking structured binary data, a la
Perl's `pack'/`unpack'.

Bit manipulation
................

Gauche core provides bitshift and mask operations.  See *note Bitwise
operations::.


File: gauche-refe.info,  Node: Naming convention of libraries,  Prev: Finding libraries you need,  Up: Library modules - Overview

8.2 Naming convention of libraries
==================================

The following table summarizes naming categories of the modules,
including external ones and planned ones.

`binary.*'
     Utilities to treat binary data.

`compat.*'
     Provides compatibility layers.

`dbi.*, dbd.*'
     Database independent interface layer and drivers.

`dbm.*'
     DBM interface

`gauche.*'
     Stuffs more or less considered as Gauche core features.

`gl.*'
     OpenGL binding and related libraries (external package).

`gtk.*'
     GTk+ binding and related libraries (external package).

`file.*'
     Manipulating files and directories.

`lang.*'
     Language-related libraries, artificial and/or natural (planned).

`math.*'
     Mathematics.

`compat.*'
     Compatibility libraries

`rfc.*'
     Implementations of net protocols defined in RFC's.

`srfi-*'
     SRFI implementations.

`sxml.*'
     SXML libraries.

`text.*'
     Libraries dealing with text data.

`util.*'
     Generic implementations of various algorithms.

`www.*'
     Implementations of various protocols and formats mainly used in
     WWW.


File: gauche-refe.info,  Node: Library modules - Gauche extensions,  Next: Library modules - SRFIs,  Prev: Library modules - Overview,  Up: Top

9 Library modules - Gauche extensions
*************************************

* Menu:

* Arrays::                      gauche.array
* Character code conversion::   gauche.charconv
* Collection framework::        gauche.collection
* Configuration parameters::    gauche.config
* Dictionary framework::        gauche.dictionary
* Low-level file operations::   gauche.fcntl
* Hooks::                       gauche.hook
* Interactive session::         gauche.interactive
* Listener::                    gauche.listener
* User-level logging::          gauche.logger
* Singleton::                   gauche.mop.singleton
* Slot with validator::         gauche.mop.validator
* Networking::                  gauche.net
* Parameters::                  gauche.parameter
* Parsing command-line options::  gauche.parseopt
* High Level Process Interface::  gauche.process
* Reloading modules::           gauche.reload
* Simple dispatcher::           gauche.selector
* Sequence framework::          gauche.sequence
* Syslog::                      gauche.syslog
* Termios::                     gauche.termios
* Unit testing::                gauche.test
* Threads::                     gauche.threads
* Measure timings::             gauche.time
* Uniform vectors::             gauche.uvector
* Comparing version numbers::   gauche.version
* Virtual ports::               gauche.vport


File: gauche-refe.info,  Node: Arrays,  Next: Character code conversion,  Prev: Library modules - Gauche extensions,  Up: Library modules - Gauche extensions

9.1 `gauche.array' - Arrays
===========================

 -- Module: gauche.array
     This module provides multi-dimensional array data type and
     operations.  The primitive API follows SRFI-25.  Besides a generic
     srfi-25 array that can store any Scheme objects, this module also
     provides array classes that stores numeric objects efficiently,
     backed up by homogeneous numeric vectors (*Note Uniform vectors::).
     An external representation of arrays, using SRFI-10 mechanism, is
     also provided.

     Each element of an N-dimensional array can be accessed by N
     integer indices, `[ I_0 I_1 ... I_N-1 ]'.  An array has associated
     SHAPE that knows lower-bound S_K and upper-bound E_K of index of
     each dimension, where S_K <= E_K, and the index I_K must satisfy
     S_K <= I_K < E_K.  (Note: it is allowed to have S_K == E_K, but
     such array can't store any data.  It is also allowed to have
     zero-dimensional array, that can store a single data.).  The shape
     itself is a [ D x 2 ] array, where D is the dimension of the array
     which the shape represents.

     You can pass index(es) to array access primitives in a few ways;
     each index can be passed as individual argument, or can be
     'packed' in a vector or one-dimensional array.  In the latter
     case, such a vector or an array is called an "index object".
     Using a vector is efficient in Gauche when you iterate over the
     elements by changing the vector elements, for it won't involve
     memory allocation.

     Arrays can be compared by the `equal?' procedure.  `Equal?'
     returns `#t' if two arrays have the same shape and their
     corresponding elements are the same in the sense of `equal?'.

     Internally, an array consists of a backing storage and a mapping
     procedure.  A backing storage is an object of aggregate type that
     can be accessed by an integer index.  A mapping procedure takes
     multi-dimensional indices (or index object) and returns a scalar
     index into the backing storage.

 -- Class: <array-base>
     An abstract base class of array types, that implements generic
     operations on the array.   To create an array instance, you should
     use one of the following concrete array classes.

 -- Class: <array>
 -- Class: <u8array>
 -- Class: <s8array>
 -- Class: <u16array>
 -- Class: <s16array>
 -- Class: <u32array>
 -- Class: <s32array>
 -- Class: <u64array>
 -- Class: <s64array>
 -- Class: <f16array>
 -- Class: <f32array>
 -- Class: <f64array>
     Concrete array classes.  The `<array>' class implements srfi-25
     compatible array, i.e. an array that can store any Scheme objects.
     The `<u8array>' class through `<f64array>' classes uses a
     `<u8vector>' through `<f64vector>' as a backing storage, and can
     only store a limited range of integers or inexact real numbers,
     but they are space efficient.

 -- Reader syntax: `#,(<array> SHAPE OBJ ...)'
     An array is written out in this format.  (Substitute `<array>' for
     `<u8array>' if the array is `<u8array>', etc.)  SHAPE is a list of
     even number of integers, and each 2N-th integer and 2N+1-th
     integer specifies the inclusive lower-bound and exclusive
     upper-bound of N-th dimension, respectively.  The following OBJ
     ... are the values in the array listed in row-major order.

     When read back, this syntax is read as an array with the same shape
     and content, so it is `equal?' to the original array.

          ; an array such that:
          ;   8 3 4
          ;   1 5 9
          ;   6 7 2
          #,(<array> (0 3 0 3) 8 3 4 1 5 9 6 7 2)

          ; a 4x4 identity matrix
          #,(<array> (0 4 0 4) 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1)

 -- Function: array? obj
     [SRFI-25] Returns `#t' if OBJ is an array, #F otherwise.  It is
     equivalent to `(is-a? obj <array-base>)'.

 -- Function: make-array shape &optional init
     [SRFI-25] Creates an array of shape SHAPE.  SHAPE must be a [ D x
     2 ] array, and for each K (0 <= K < D), the [ K 0 ] element must
     be less than or equal to the [ K 1] element.  If INIT is given,
     all the elements are initialized by it.  Otherwise, the initial
     value of the elements are undefined.

          (make-array (shape 0 2 0 2 0 2) 5)
           => #,(<array> (0 2 0 2 0 2) 5 5 5 5 5 5 5 5)

 -- Function: make-u8array shape &optional init
 -- Function: make-s8array shape &optional init
     ...

 -- Function: make-f32array shape &optional init
 -- Function: make-f64array shape &optional init
     Like `make-array', but creates and returns an uniform numeric
     array.

 -- Function: shape bound ...
     [SRFI-25] Takes even number of exact integer arguments, and returns
     a two-dimensional array that is suitable for representing the shape
     of an array.

          (shape 0 2 1 3 3 5)
           => #,(<array> (0 3 0 2) 0 2 1 3 3 5)

          (shape)
           => #,(<array> (0 0 0 2))

 -- Function: array shape init ...
     [SRFI-25] Creates an array of shape SHAPE, initializing its
     elements by INIT ....

          (array (shape 0 2 1 3) 'a 'b 'c 'd)
           => #,(<array> (0 2 1 3) a b c d)

 -- Function: array-rank array
     [SRFI-25] Returns the number of dimensions of an array ARRAY.

          (array-rank (make-array (shape 0 2 0 2 0 2))) => 3
          (array-rank (make-array (shape))) => 0

 -- Function: array-shape array
     Returns a shape array of ARRAY.

 -- Function: array-start array dim
 -- Function: array-end array dim
 -- Function: array-length array dim
     [SRFI-25+] `Array-start' returns the inclusive lower bound of
     index of DIM-th dimension of an array ARRAY.  `Array-end' returns
     the exclusive upper bound.  And `array-length' returns the
     difference between two.  `Array-start' and `array-end' are defined
     in SRFI-25.

          (define a (make-array (shape 1 5 0 2)))

          (array-start a 0)  => 1
          (array-end a 0)    => 5
          (array-length a 0) => 4
          (array-start a 1)  => 0
          (array-end a 1)    => 2
          (array-length a 1) => 2

 -- Function: array-size array
     Returns the total number of elements in the array ARRAY.

          (array-size (make-array (shape 5 9 1 3))) => 8
          (array-size (make-array (shape))) => 1
          (array-size (make-array (shape 0 0 0 2))) => 0

 -- Function: array-ref array k ...
 -- Function: array-ref array index
     [SRFI-25] Gets the element of array `array'.  In the first form,
     the element is specified by indices K ....  In the second form,
     the element is specified by an index object INDEX, which must be a
     vector or an one-dimensional array.

 -- Function: array-set! array k ... value
 -- Function: array-set! array index value
     [SRFI-25] Sets the element of array ARRAY to VALUE.  In the first
     form, the element is specified by indices K ....  In the second
     form, the element is specified by an index object INDEX, which
     must be a vector or an one-dimensional array.

 -- Function: share-array array shape proc
     [SRFI-25] Creates and returns a new array of shape SHAPE, that
     shares the backing storage with the given array ARRAY.  The
     procedure PROC maps the indices of the new array to the indices to
     the original array, i.e. PROC must be a N-ary procedure that
     returns M values, where N is the dimension of the new array and M
     is the one of the original array.  Furthermore, PROC must be an
     affine function; each mapping has to be a linear combination of
     input arguments plus optional constant.  (`Share-array' optimizes
     the mapping function based on the affinity assumption, so PROC
     won't be called every time the new array is accessed).

 -- Function: array-for-each-index array proc &optional index

 -- Function: shape-for-each shape proc &optional index

 -- Function: tabulate-array shape proc &optional index

 -- Function: array-retabulate! array shape proc &optional index
 -- Function: array-retabulate! array proc &optional index

 -- Function: array-map! array shape proc array0 array1 ...
 -- Function: array-map! array proc array0 array1 ...

 -- Function: array-map shape proc array0 array1 ...
 -- Function: array-map proc array0 array1 ...

 -- Function: array->vector array
 -- Function: array->list array

 -- Function: array-concatenate a b &optional dimension

 -- Function: array-transpose array &optional dim1 dim2

 -- Function: array-rotate-90 array &optional dim1 dim2

 -- Function: array-flip array &optional dimension
 -- Function: array-flip! array &optional dimension

 -- Function: identity-array dimension &optional class

 -- Function: array-inverse array

 -- Function: determinant array
 -- Function: determinant! array

 -- Function: array-mul a b

 -- Function: array-expt array pow

 -- Function: array-div-left a b
 -- Function: array-div-right a b

 -- Function: array-add-elements array array-or-scalar ...
 -- Function: array-add-elements! array array-or-scalar ...

 -- Function: array-sub-elements array array-or-scalar ...
 -- Function: array-sub-elements! array array-or-scalar ...
 -- Function: array-mul-elements array array-or-scalar ...
 -- Function: array-mul-elements! array array-or-scalar ...
 -- Function: array-div-elements array array-or-scalar ...
 -- Function: array-div-elements! array array-or-scalar ...


File: gauche-refe.info,  Node: Character code conversion,  Next: Collection framework,  Prev: Arrays,  Up: Library modules - Gauche extensions

9.2 `gauche.charconv' - Character Code Conversion
=================================================

 -- Module: gauche.charconv
     This module defines a set of functions that converts character
     encoding schemes (CES) of the given data stream.  This module also
     overloads Gauche's file stream creating functions (such as
     `open-input-file' and `call-with-output-file') so that they accept
     `:encoding' keyword argument.

     As of release 0.5.6, Gauche natively supports conversions between
     typical Japanese character encodings: ISO2022JP, ISO2022JP-3,
     EUC-JP (EUC-JISX0213), Shift_JISX0213, UTF-8 (Unicode 3.2).
     Conversions between other encodings are handled by `iconv(3)'.
     *Note Supported character encoding schemes::, for details.

* Menu:

* Supported character encoding schemes::
* Autodetecting the encoding scheme::
* Conversion ports::
* Extended port procedures::


File: gauche-refe.info,  Node: Supported character encoding schemes,  Next: Autodetecting the encoding scheme,  Prev: Character code conversion,  Up: Character code conversion

9.2.1 Supported character encoding schemes
------------------------------------------

A CES is represented by its name as a string or a symbol.  Case is
ignored.  There may be several aliases defined for a single encoding.

   A CES name "none" is special.  When Gauche's native encoding is
`none', Gauche just treats a string as a byte sequence, and it's up to
the application to interpret the sequence in an appropriate encoding.
So, conversion to and from CES "none" does nothing.

   You can check whether the specific conversion is supported on your
system or not, by the following function.

 -- Function: ces-conversion-supported? from-ces to-ces
     Returns `#t' if conversion from the character encoding scheme
     (CES) FROM-CES to TO-CES is supported in this system.

     Note that this procedure may return true even if system only
     supports partial conversion between FROM-CES and TO-CES.  In such
     case, actual conversion might lose information by coercing
     characters in FROM-CES which are not supported in TO-CES.  (For
     example, conversion from Unicode to EUC-JP is "supported",
     although Unicode has characters that are not in EUC-JP).

     Also note that this procedure always returns `#t' if FROM-CES
     and/or TO-CES is "none", for conversion to/from CES "none" always
     succeeds (in fact, it does nothing).

          ;; see if you can convert the internal encoding to EUC-JP
          (ces-conversion-supported? (gauche-character-encoding) "euc-jp")

   Also there are two useful procedures to deal with CES names.

 -- Function: ces-equivalent? ces-a ces-b &optional unknown-value
     Returns true if two CESes CES-A and CES-B are equivalent to the
     knowledge of the system.  Returns false if they are not.  If the
     system doesn't know about equivalency, UNKNOWN-VALUE is returned,
     whose default is `#f'.

     CES "none" works like a wild card; it is "equivalent" to any CES.
     (Thus, `ces-equivalent?' is not transitive.  The intended use of
     `ces-equivalent?' is to compare two given CES names and see if
     conversion is required or not).

          (ces-equivalent? 'eucjp "EUC-JP")            => #t
          (ces-equivalent? 'shift_jis "EUC-JP")        => #f
          (ces-equivalent? "NoSuchEncoding" 'utf-8 '?) => ?

 -- Function: ces-upper-compatible? ces-a ces-b &optional unknown-value
     Returns true if a string encoded in CES CES-B can also be regarded
     as a string encoded in CES-A without conversion, to the knowledge
     of the system.  Returns false if not.  Returns UNKNOWN-VALUE if
     the system can't determine which is the case.

     Like `ces-equivalent?', CES "none" works like a wildcard.  It is
     upper-compatible to any CES, and any CES is upper-compatible to
     "none".

          (ces-upper-compatible? "eucjp" "ASCII")             => #t
          (ces-upper-compatible? "eucjp" "utf-8")             => #f
          (ces-upper-compatible? "utf-8" "NoSuchEncoding" '?) => ?

   Conversion between common japanese CESes (EUC_JP, Shift JIS, UTF-8
and ISO2022-JP) of the character set JIS X 0201 and JIS X 0213 is
handled by Gauche's built-in algorithm (see below for details).  When
other CES name is given, Gauche uses `iconv(3)' if it is linked.

   When Gauche's conversion routine encounters a character that can't
be mapped, it replaces the character for "geta mark" (U+3013) if it's a
multibyte character in the input encoding, or for '?' if it's a
singlebyte character in the input encoding.  If that happens in iconv,
handling of such character depends on iconv implementation (glibc
implementation returns an error).

   If the conversion routine encounters an input sequence that is
illegal in the input CES, an error is signalled.

   *Details of Gauche's native conversion algorithm:* Between EUC_JP,
Shift JIS and ISO2022JP, Gauche uses arithmetic conversion whenever
possible.  This even maps the undefined codepoint properly.  Between
Unicode (UTF-8) and EUC_JP, Gauche uses lookup tables.  Between Unicode
and Shift JIS or ISO2022JP, Gauche converts the input CES to EUC_JP,
then convert it to the output CES.  If the same CES is specified for
input and output, Gauche's conversion routine just copies input
characters to output characters, without checking the validity of the
encodings.

`EUC_JP, EUCJP, EUCJ, EUC_JISX0213'
     Covers ASCII, JIS X 0201 kana, JIS X 0212 and JIS X 0213 character
     sets.  JIS X 0212 character set is supported merely because it uses
     the code region JIS X 0213 doesn't use, and JIS X 0212 characters
     are not converted properly to Shift JIS and UTF-8.  Use JIS X 0213.

`SHIFT_JIS, SHIFTJIS, SJIS'
     Covers Shift_JISX0213, except that 0x5c and 0x7e is mapped to ASCII
     character set (REVERSE SOLIDUS and TILDE), instead of JIS X 0201
     Roman (YEN SIGN and OVERLINE).

`UTF-8, UTF8'
     Unicode 3.2.  Note that some JIS X 0213 characters are mapped to
     Extension B (U+20000 and up).  Some JIS X 0213 characters are
     mapped to two unicode characters (one base character plus a
     combining character).

`ISO2022JP, CSISO2022JP, ISO2022JP-1, ISO2022JP-2, ISO2022JP-3'
     These encodings differ a bit (except ISO2022JP and CSISO2022JP,
     which are synonyms), but Gauche handles them same.  If one of
     these CES is specified as input, Gauche recognizes escape
     sequences of any of CES.  ISO2022JP-2 defines several non-Japanese
     escape sequences, and they are recognized by Gauche, but mapped to
     substitution character ('?' or geta mark).

     For output, Gauche assumes ISO2022JP first, and uses ISO2022JP-1
     escape sequence to put JIS X 0212 character, or uses ISO2022JP-3
     escape sequence to put JIS X 0213 plane 2 character.  Thus, if the
     string contains only JIS X 0208 characters, the output is
     compatible to ISO2022JP.  Precisely speaking, JIS X 0213 specifies
     some characters in JIS X 0208 codepoint that shouldn't be mixed
     with JIS X 0208 characters; Gauche output those characters as JIS
     X 0208 for compatibility.  (This is the same policy as
     Emacs-Mule's iso2022jp-3-compatible mode).


File: gauche-refe.info,  Node: Autodetecting the encoding scheme,  Next: Conversion ports,  Prev: Supported character encoding schemes,  Up: Character code conversion

9.2.2 Autodetecting the encoding scheme
---------------------------------------

There are cases that you don't know the CES of the input, but you know
it is one of several possible encodings.  The charconv module has a
mechanism to guess the input encoding.  There can be multiple
algorithms, and each algorithm has the name.  Right now, there's only
one algorithm implemented:
`"*JP"'
     To guess the character encoding from japanese text, among either
     ISO2022-JP(-1,2,3), EUCJP, SHIFT_JIS or UTF-8.

   This name can be used in place of CES name for some conversion
functions.

 -- Function: ces-guess-from-string string scheme
     Guesses the CES of STRING by the character guessing scheme SCHEME
     (e.g. "*JP").  Returns CES name that can be used by other charconv
     functions.   It may return `#f' if the guessing scheme finds no
     possible encoding in STRING.  Note that if there may be more than
     one possible encoding in STRING, the guessing scheme returns one
     of them, usually in favor of the native CES.


File: gauche-refe.info,  Node: Conversion ports,  Next: Extended port procedures,  Prev: Autodetecting the encoding scheme,  Up: Character code conversion

9.2.3 Conversion ports
----------------------

 -- Function: open-input-conversion-port source from-code &keyword
          to-code buffer-size owner?
     Takes an input port SOURCE, which feeds characters encoded in
     FROM-CODE, and returns another input port, from which you can read
     characters encoded in TO-CODE.

     If TO-CODE is omitted, the native CES is assumed.

     BUFFER-SIZE is used to allocate internal buffer size for
     conversion.  The default size is about 1 kilobytes and it's
     suitable for typical cases.

     If you don't know the SOURCE's CES, you can specify CES guessing
     scheme, such as `"*JP"', in place of FROM-CODE.  The conversion
     port tries to guess the encoding, by prefetching the data from
     SOURCE up to the buffer size.  It signals an error if the code
     guessing routine finds no appropriate CES.  If the guessing
     routine finds ambiguous input, however, it silently assume one of
     possible CES's, in favor of the native CES.  Hence it is possible
     that the guessing is wrong if the buffer size is too small.  The
     default size is usually enough for most text documents, but it may
     fail if the large text contains mostly ASCII characters and
     multibyte characters appear only at the very end of the document.
     To be sure for the worst case, you have to specify the buffer size
     large enough to hold entire text.

     By default, `open-input-conversion-port' leaves SOURCE open.  If
     you specify true value to OWNER?, the function closes SOURCE after
     it reads EOF from the port.

     For example, the following code copies a file `unknown.txt' to a
     file `eucjp.txt', converting unknown japanese CES to EUC-JP.
          (call-with-output-file "eucjp.txt"
            (lambda (out)
              (copy-port (open-input-conversion-port
                           (open-input-file "unknown.txt")
                           "*jp"             ;guess code
                           :to-code "eucjp"
                           :owner? #t)       ;close unknown.txt afterwards
                         out)))

 -- Function: open-output-conversion-port sink to-code &keyword
          from-code buffer-size owner?
     Creates and returns an output port that converts given characters
     from FROM-CODE to TO-CODE and feed to an output port SINK.  If
     FROM-CODE is omitted, the native CES is assumed.  You can't
     specify a character guessing scheme (such as "*JP") to neither
     FROM-CODE nor TO-CODE.

     BUFFER-SIZE specifies the size of internal conversion buffer.  The
     characters put to the returned port may stay in the buffer, until
     the port is explicity flushed (by `flush') or the port is closed.

     By default, the returned port doesn't closes SINK when itself is
     closed.  If a keyword argument OWNER? is provided and true,
     however, it closes SINK when it is closed.

 -- Function: ces-convert string from-code &optional to-code
     Convert STRING's character encoding from FROM-CODE to TO-CODE, and
     returns the converted string.  The returned string may be a
     byte-string if TO-CODE is different from the native CES.

     FROM-CODE can be a name of character guessing scheme (e.g. "*JP").
     when TO-CODE is omitted, the native CES is assumed.

 -- Function: call-with-input-conversion iport proc &keyword encoding
          conversion-buffer-size
 -- Function: call-with-output-conversion oport proc &keyword encoding
          conversion-buffer-size
     These procedures can be used to perform character I/O with
     different encoding temporary from the original port's encoding.

     `call-with-input-conversion' takes an input port IPORT which uses
     the character encoding ENCODING, and calls PROC with one argument,
     a conversion input port.  From the port, PROC can read characters
     in Gauche's internal encoding.  Note that once PROC is called, it
     has to read all the characters until EOF; see the note below.

     `call-with-output-conversion' takes an output port OPORT which
     expects the character encoding ENCODING, and calls PROC with one
     argument, a temporary conversion output port.  To the port, PROC
     can write characters in Gauche's internal encoding.  When PROC
     returns, or it exits with an error, the temporary conversion
     output port is flushed and closed.  The caller of
     `call-with-output-conversion' can continue to use OPORT with
     original encoding afterwards.

     Both procedure returns the value(s) that PROC returns.  The
     default value of ENCODING is Gauche's internal encoding.  Those
     procedures don't create a conversion port when it is not
     necessary.   If CONVERSION-BUFFER-SIZE is given, it is used as the
     BUFFER-SIZE argument when the conversion port is open.

     You shouldn't use IPORT/OPORT directly while PROC is
     active--character encoding is a stateful process, and mixing I/O
     from/to the conversion port and the underlying port will screw up
     the state.

     _Note:_ for the `call-with-input-conversion', you can't use IPORT
     again unless PROC reads EOF from it.  It's because a conversion
     port needs to buffer the input, and there's no way to undo the
     buffered input to IPORT when PROC returns.

 -- Function: with-input-conversion iport thunk &keyword encoding
          conversion-buffer-size
 -- Function: with-output-conversion oport thunk &keyword encoding
          conversion-buffer-size
     Similar to `call-with-*-conversion', but these procedures call
     THUNK without arguments, while the conversion port is set as the
     current input or output port, respectively.  The meaning of
     keyword arguments are the same as `call-with-*-conversion'.

 -- Function: wrap-with-input-conversion port from-code &keyword
          to-code owner? buffer-size
 -- Function: wrap-with-output-conversion port to-code &keyword
          from-code owner? buffer-size
     Convenient procedures to avoid adding unnecessary conversion port.
     Each procedure works like `open-input-conversion-port' and
     `open-output-conversion-port', respectively, except if system
     knows no conversion is needed, no conversion port is created and
     PORT is returned as is.

     When a conversion port is created, PORT is always owned by the
     port.  When you want to close the port, always close the port
     returned by `wrap-with-*-conversion', instead the original PORT.
     If you close the original PORT first, the pending conversion won't
     be flushed.  (Some conversion requires trailing sequence that is
     generated only when the conversion port is closing, so simply
     calling `flush' isn't enough.)

     The BUFFER-SIZE argument is passed to the `open-*-conversion-port'.


File: gauche-refe.info,  Node: Extended port procedures,  Prev: Conversion ports,  Up: Character code conversion

9.2.4 Extended port procedures
------------------------------

 -- Function: open-input-file filename &keyword encoding
          conversion-buffer-size ...
 -- Function: call-with-input-file filename proc &keyword encoding
          conversion-buffer-size ...
 -- Function: with-input-from-file filename thunk &keyword encoding
          conversion-buffer-size ...
 -- Function: open-output-file filename &keyword encoding
          conversion-buffer-size ...
 -- Function: call-with-output-file filename proc &keyword encoding
          conversion-buffer-size ...
 -- Function: with-output-to-file filename thunk &keyword encoding
          conversion-buffer-size ...
     These Gauche built-in procedures are extended to accept two extra
     keyword arguments, ENCODING and CONVERSION-BUFFER-SIZE.  (*Note
     File ports::, for their default behavior).

     You can give a CES of the file FILENAME to ENCODING, and the port
     automatically converts the file CES to the Gauche's native CES.
     You can use a CES guessing algorithm name for input file port.

     The keyword argument CONVERSION-BUFFER-SIZE has the same meaning
     as BUFFER-SIZE of `open-input-conversion-port'.


File: gauche-refe.info,  Node: Collection framework,  Next: Configuration parameters,  Prev: Character code conversion,  Up: Library modules - Gauche extensions

9.3 `gauche.collection' - Collection framework
==============================================

 -- Module: gauche.collection
     This module provides a set of generic functions (GFs) that iterate
     over various collections.   The Scheme standard [R5RS] has some
     iterative primitives such as `map' and `for-each', and SRFI-1
     (*Note List library:: adds a rich set of such functions, but they
     work only on lists.

     Using the method dispatch of the object system, this module
     efficiently extends those functions for other collection classes
     such as vectors and hash tables.  It also provides a simple way
     for user-defined class to adapt those operations.  So far, the
     following operations are defined.

    Mapping
          `fold', `fold2', `fold3', `map', `map-to', `map-accumf,
          '`for-each'

    Selection and searching
          `find', `find-min', `find-max', `find-min&max', `filter',
          `filter-to', `remove', `remove-to', `partition',
          `partition-to' `group-collection'

    Conversion
          `coerce-to'

    Miscellaneous
          `size-of', `lazy-size-of'

    Fundamental iterator creator
          `call-with-iterator', `call-with-builder', `with-iterator',
          `with-builder', `call-with-iterators'.

     Those operations work on _collections_ and its subclass,
     _sequences_.  A collection is a certain form of a set of objects
     that you can traverse all the object in it in a certain way.  A
     sequence is a collection that all its elements are ordered, so that
     you can retrieve its element by index.

     The following Gauche built-in objects are treated as collections
     and/or sequences.
    `<list>'
          A sequence.

    `<vector>'
          A sequence.

    `<string>'
          A sequence (of characters)

    `<hash-table>'
          A collection.  Each element is a pair of a key and a value.

    `<s8vector>, <u8vector>, ... <f64vector>'
          A sequence (methods defined in `srfi-4' module, *Note
          Homogeneous vectors::).

     *Note Sequence framework::, for it adds more sequence specific
     methods.

     The methods that needs to return a set of objects, i.e.  `map',
     `filter', `remove' and `partition'.  returns a list (or lists).
     The corresponding "-to" variant (`map-to', `filter-to',
     `remove-to' and `partition-to'.  takes a collection class argument
     and returns the collection of the class.

* Menu:

* Mapping over collection::
* Selection and searching in collection::
* Miscellaneous operations on collection::
* Fundamental iterator creators::
* Implementing collections::


File: gauche-refe.info,  Node: Mapping over collection,  Next: Selection and searching in collection,  Prev: Collection framework,  Up: Collection framework

9.3.1 Mapping over collection
-----------------------------

These generic functions extends the standard mapping procedures.  See
also *note Mapping over sequences::, if you care the index as well as
elements.

 -- Generic function: fold proc knil coll coll2 ...
     This is a natural extension of FOLD in SRFI-1 (*Note SRFI-1
     Fold::).

     For each element EI in the collection COLL, PROC is called as
     (PROC EI RI-1), where RI-1 is the result of (I-1)-th invocation of
     PROC for I > 0, and R0 is KNIL.  Returns the last invocation of
     PROC.
          (fold + 0 '#(1 2 3 4)) => 10
          (fold cons '() "abc")  => (#\c #\b #\a)

     If the COLL is a sequence, it is guaranteed that the elements are
     traversed in order.  Otherwise, the order of iteration is
     undefined.

     Note: We don't provide `fold-right' on collections, since the order
     of elements doesn't matter, so only `fold' is sufficient for
     meaningful traversal.  However, sequences do have `fold-right';
     see *note Mapping over sequences::.

     You can fold more than one collection, although it doesn't make
     much sense unless all of the collections are sequences.  Suppose
     E(K, I) for I-th element of K-th collection.  PROC is called as
          (PROC E(0,I) E(1,I) ... E(K-1,I) RI-1)

     Different types of collections can be mixed together.

          (fold acons '() "abc" '#(1 2 3))
            => ((#\c 3) (#\b 2) (#\a 1))

          ;; calculates dot product of two vectors
          (fold (lambda (a b r) (+ (* a b) r)) 0
                '#(3 5 7) '#(2 4 6))
            => 68

     When more than one collection is given, `fold' terminates as soon
     as at least one of the collections exhausted.

 -- Generic function: fold2 proc knil1 knil2 coll coll2 ...
 -- Generic function: fold3 proc knil1 knil2 knil3 coll coll2 ...
     Like `fold', but they can carry two and three state values instead
     of one, respectively.  The state values are initialized by KNILN.
     The procedure PROC is called with each element of COLLN, and the
     state values.  It must return two (`fold2') or three (`fold3')
     values, which will be used as the state values of next iteration.
     The values returned in the last iteration will be the return
     values of `fold2' and `fold3'.

          (fold2 (lambda (elt a b) (values (min elt a) (max elt b)))
                 256 0 '#u8(33 12 142 1 74 98 12 5 99))
           => 1 and 142  ;; find minimum and maximum values

     See also `map-accum' below.

 -- Generic function: map proc coll coll2 ...
     This extends the built-in `map' (*Note Procedures::).  Apply PROC
     for each element in the collection COLL, and returns a list of the
     results.

     If the COLL is a sequence, it is guaranteed that the elements are
     traversed in order.  Otherwise, the order of iteration is
     undefined.

     If more than one collection is passed, PROC is called with
     elements for each collection.  In such case, `map' terminates as
     soon as at least one of the collection is exhausted.  Note that
     passing more than one collection doesn't make much sense unless
     all the collections are sequences.

          (map (lambda (x) (* x 2)) '#(1 2 3))
            => #(2 4 6)

          (map char-upcase "abc")
            => (#\A #\B #\C)

          (map + '#(1 2 3) '#(4 5 6))
            => (5 7 9)

     `map' _always_ returns a list.  If you want to get the result in a
     different type of collection, use `map-to' described below.  If
     you wonder why `(map char-upcase "abc")' doesn't return `"ABC"',
     read the discussion in the bottom of this subsection.

 -- Generic function: map-to class proc coll coll2 ...
     This works the same as `map', except the result is returned in a
     collection of class CLASS.   `Class' must be a collection class
     and have a builder interface (*Note Fundamental iterator
     creators::).

          (map-to <vector> + '#(1 2 3) '#(4 5 6))
            => #(5 7 9)

          (map-to <string> char-upcase "def")
            => "DEF"

          (map-to <vector> char=? "bed" "pet")
            => #(#f #t #f)

 -- Generic function: map-accum proc seed coll1 coll2 ...
     Collects results of PROC over collections, while passing a state
     value.  PROC is called like this:
          (PROC ELT1 ELT2 ... SEED)
     Where ELT1 ELT2 ... are the elements of COLL1 COLL2 ....  It must
     return two values; the first value is collected into a list (like
     `map'), while the second value is passed as SEED to the next call
     of PROC.

     When one of the collections is exhausted, `map-accum' returns two
     values, the list of the first return values from PROC, and the
     second return value of the last call of PROC.

     If the given collections are sequences, it is guaranteed that PROC
     is applied in order of the sequence.

     This is similar to Haskell's `mapAccumL', but note that the order
     of `proc''s argument and return values are reversed.

 -- Generic function: for-each proc coll coll2 ...
     Extension of built-in `for-each' (*Note Procedures::).  Applies
     PROC for each elements in the collection(s).  The result of PROC
     is discarded.  The return value of `for-each' is undefined.

     If the COLL is a sequence, it is guaranteed that the elements are
     traversed in order.  Otherwise, the order of iteration is
     undefined.

     If more than one collection is passed, PROC is called with
     elements for each collection.  In such case, `for-each' terminates
     as soon as one of the collection is exhausted.  Note that passing
     more than one collection doesn't make much sense unless all the
     collections are sequences.

 -- Generic Function: fold$ proc
 -- Generic Function: fold$ proc knil
 -- Generic Function: map$ proc
 -- Generic Function: for-each$ proc
     Partial-application version of `fold', `map' and `for-each'.

   _Discussion:_  It is debatable what type of collection `map' should
return when it operates on the collections other than lists.  It may
seem more "natural" if `(map * '#(1 2) '#(3 4))' returns a vector, and
`(map char-upcase "abc")' returns a string.

   Although such interface seems work for simple cases, it'll become
problematic for more general cases.  What type of collection should be
returned if a string and a vector are passed?  Furthermore, some
collection may only have iterator interface but no builder interface,
so that the result can't be coerced to the argument type (suppose
you're mapping over database records, for example).  And Scheme
programmers are used to think `map' returns a list, and the result of
`map' are applied to the procedures that takes list everywhere.

   So I decided to add another method, `map-to', to specify the return
type explicitly The idea of passing the return type is taken from
CommonLisp's `map' function, but taking a class metaobject, `map-to' is
much flexible to extend using method dispatch.  This protocol ("-to"
variant takes a class metaobject for the result collection) is used
thoughout the collection framework.


File: gauche-refe.info,  Node: Selection and searching in collection,  Next: Miscellaneous operations on collection,  Prev: Mapping over collection,  Up: Collection framework

9.3.2 Selection and searching in collection
-------------------------------------------

 -- Generic function: find pred coll
     Applies PRED for each element of a collection COLL until PRED
     returns a true value.  Returns the element on which PRED returned
     a true value, or `#f' if no element satisfies PRED.

     If COLL is a sequence, it is guaranteed that PRED is applied in
     order.  Otherwise the order of application is undefined.

          (find char-upper-case? "abcDe") => #\D
          (find even? '#(1 3 4 6)) => 4
          (find even? '(1 3 5 7))  => #F

 -- Generic function: find-min coll &keyword key compare default
 -- Generic function: find-max coll &keyword key compare default
     Returns a minimum or maximum element in the collection COLL.

     A one-argument procedure KEY, whose default is `identity', is
     applied for each element to obtain a comparison value.  Then a
     compaison value is compared by a two-argument procedure COMPARE,
     whose default is `<'.  If the collection has zero or one element,
     the COMPARE procedure is never called.

     When the collection is empty, a value given to DEFAULT is
     returned, whose default is `#f'.

          (find-min '((a . 3) (b . 9) (c . -1) (d . 7)) :key cdr) => (c . -1)

 -- Generic function: find-min&max coll &keyword key compare default
          default-min default-max
     Does `find-min' and `find-max' simultaneously, and returns two
     values, the minimum element and the maximum element.  The keyword
     arguments KEY, COMPARE, and DEFAULT are the same as `find-min' and
     `find-max'.  Alternatively you can give default values for minimum
     and maximum separately, by DEFAULT-MIN and DEFAULT-MAX.

 -- Generic function: filter pred coll
     Returns a list of elements of collection COLL that satisfies the
     predicate PRED.   If the collection is a sequence, the order is
     preserved in the result.

          (filter char-upper-case? "Hello, World")
            => (#\H #\W)
          (filter even? '#(1 2 3 4)) => (2 4)

 -- Generic function: filter-to class pred coll
     Same as `filter', but the result is returned as a collection of
     class CLASS.

          (filter-to <vector> even? '#(1 2 3 4)) => #(2 4)
          (filter-to <string> char-upper-case? "Hello, World")
            => "HW"

 -- Generic function: remove pred coll
     Returns a list of elements of collection COLL that does not
     satisfy the predicate PRED.   If the collection is a sequence, the
     order is preserved in the result.

          (remove char-upper-case? "Hello, World")
            => (#\e #\l #\l #\o #\, #\space #\o #\r #\l #\d)
          (remove even? '#(1 2 3 4)) => (1 3)

 -- Generic function: remove-to class pred coll
     Same as `remove', but the result is returned as a collection of
     class CLASS.

          (remove-to <vector> even? '#(1 2 3 4)) => #(1 3)
          (remove-to <string> char-upper-case? "Hello, World")
            => "ello, orld"

 -- Generic function: partition pred coll
     Does `filter' and `remove' the same time.  Returns two lists, the
     first consists of elements of the collection COLL that satisfies
     the predicate PRED, and the second consists of elements that
     doesn't.

          (partition char-upper-case? "PuPu")
            => (#\P #\P) and (#\u #\u)
          (partition even? '#(1 2 3 4))
            => (2 4) and (1 3)

 -- Generic function: partition-to class pred coll
     Same as `partition', except the results are returned in the
     collections of class CLASS.

          (partition-to <string> char-upper-case? "PuPu")
            => "PP" and "uu"
          (partition-to <vector> even? '#(1 2 3 4))
            => #(2 4) and #(1 3)

 -- Generic function: group-collection coll &keyword key test
     Generalized `partition'.  Groups elements in COLL into those who
     has the same key value, and returns the groups as of lists.  Key
     values are calculated by applying the procedure KEY to each
     element of COLL.  The default value of KEY is `identity'.   For
     each element of COLL, KEY is applied exactly once.  The equal-ness
     of keys are compared by TEST procedure, whose default is `eqv?'.

     If COLL is a sequence, then the order of elements in each group of
     the result is the same order in COLL.

          (group-collection '(1 2 3 2 3 1 2 1 2 3 2 3))
            => ((1 1 1) (2 2 2 2 2) (3 3 3 3))

          (group-collection '(1 2 3 2 3 1 2 1 2 3 2 3) :key odd?)
            => ((1 3 3 1 1 3 3) (2 2 2 2 2))

          (group-collection '(("a" 2) ("b" 5) ("c" 1) ("b" 3) ("a" 6))
            :key car :test string=?)
            => ((("a" 2) ("a" 6)) (("b" 5) ("b" 3)) (("c" 1)))

     See also `group-sequence' in `gauche.sequence' (*Note Other
     operations over sequences::), which only groups adjacent elements.


File: gauche-refe.info,  Node: Miscellaneous operations on collection,  Next: Fundamental iterator creators,  Prev: Selection and searching in collection,  Up: Collection framework

9.3.3 Miscellaneous operations on collection
--------------------------------------------

 -- Generic function: size-of coll
     Returns the number of elements in the collection.  Default method
     iterates over the collection to calculate the size, which is not
     very efficient and may diverge if the collection is infinite.
     Some collection classes overload the method for faster calculation.

 -- Generic function: lazy-size-of coll
     Returns either the size of the collection, or a promise to
     calculate it.  The intent of this method is to avoid size
     calculation if it is expensive.  In some cases, the caller wants
     to have size just for optimization, and it is not desirable to
     spend time to calculate the size.  Such caller uses this method
     and just discards the information if it is a promise.

 -- Generic function: coerce-to class coll
     Convert a collection COLL to another collection which is an
     instance of CLASS.  If COLL is a sequence and CLASS is a sequence
     class, the order is preserved.

          (coerce-to <vector> '(1 2 3 4))
            => #(1 2 3 4)

          (coerce-to <string> '#(#\a #\b #\c))
            => "abc"


File: gauche-refe.info,  Node: Fundamental iterator creators,  Next: Implementing collections,  Prev: Miscellaneous operations on collection,  Up: Collection framework

9.3.4 Fundamental iterator creators
-----------------------------------

These are fundamental methods on which all the rest of iterative method
are built.  The method interface is not intended to be called from
general code, but suitable for building other iterator construct.   The
reason why I chose this interface as fundamental methods are explained
at the bottom of this subsection.

 -- Generic function: call-with-iterator collection proc &keyword start
     A fundamental iterator creator.   This creates two procedures from
     COLLECTION, both take no argument, and then call PROC with those
     two procedures.   The first procedure is terminate predicate,
     which returns `#t' if the iteration is exhausted, or `#f' if there
     are still elements to be visited.  The second procedure is an
     incrementer, which returns one element from the collection and
     sets the internal pointer to the next element.  The behavior is
     undefined if you call the incrementer after the terminate
     predicate returns `#t'.

     If the collection is actually a sequence, the incrementer is
     guaranteed to return elements in order, from 0-th element to the
     last element.  If a keyword argument START is given, however, the
     iteration begins from START-th element and ends at the last
     element.  If the collection is not a sequence, the iteration order
     is arbtrary, and START argument has no effect.

     An implementation of CALL-WITH-ITERATOR method may limit the
     extent of the iterator inside the dynamic scope of the method.
     For example, it allocates some resource (e.g. connect to a
     database) before calling PROC, and deallocates it (e.g. disconnect
     from a database) after PROC returns.

     This method returns the value(s) PROC returns.

          (call-with-iterator '(1 2 3 4 5)
            (lambda (end? next)
              (do ((odd-nums 0))
                  ((end?) odd-nums)
                (when (odd? (next)) (inc! odd-nums)))))
           => 3

     See also `with-iterator' macro below, for it is easier to use.

 -- Macro: with-iterator (collection end? next args ...) body ...
     A convenience macro to call `call-with-iterator'.
          (with-iterator (coll end? next args ...) body ...)
           ==
          (call-with-iterator coll
            (lambda (end? next) body ...)
             args ...)

 -- Function: call-with-iterators collections proc
     A helper function to write n-ary iterator method.  This function
     applies `call-with-iterator' for each COLLECTIONs, and makes two
     lists, the first consists of terminate predicates and the second
     of incrementers.  Then PROC is called with those two lists.
     Returns whatever PROC returns.

 -- Generic function: call-with-builder collection-class proc &keyword
          size
     A fundamental builder creator.  Builder is a way to construct a
     collection incrementally.  Not all collection classes provide this
     method.

     COLLECTION-CLASS is a class of the collection to be built.  This
     method creates two procedures, adder and getter, then calls PROC
     with those procedures.  Adder procedure takes one argument and
     adds it to the collection being built.  Getter takes no argument
     and returns a built collection object.  The effect is undefined if
     adder is called after getter is called.

     A keyword argument SIZE may be specified if the size of the result
     collection is known.  Certain collections may be built much more
     efficiently if the size is known; other collections may just
     ignore it.   The behavior is undefined if more than SIZE elements
     are added, or the collection is retrieved before SIZE elements are
     accumulated.

     If the collection class is actually a sequence class, adder is
     guaranteed to add elements in order.  Otherwise, the order of
     elements are insignificant.

     Some collection class may take more keyword arguments to
     initialize the collection.

     This method returns the value(s) PROC returned.

          (call-with-builder <list>
            (lambda (add! get)
              (add! 'a) (add! 'b) (add! 'c) (get)))
           => (a b c)

          (call-with-builder <vector>
            (lambda (add! get)
              (add! 'a) (add! 'b) (add! 'c) (get)))
           => #(a b c)

     See also `with-builder' macro below, for it is much easier to use.

 -- Macro: with-builder (collection add! get args ...) body ...
     A convenience macro to call `call-with-builder'.
          (with-builder (coll add! get args ...) body ...)
           ==
          (call-with-builder coll
            (lambda (add! get) body ...)
            args ...)

   _Discussion_: Other iterator methods are built on top of
call-with-iterator and call-with-builder.  By implementing those
methods, you can easily adapt your own collection class to all of those
iterative operations.   Optionally you can overload some of higher-level
methods for efficiency.

   It is debatable that which set of operations should be primitives.
I chose call-with-iterator style for efficiency of the applications I
see most.   The following is a discussion of other possible primitive
iterators.

`fold'
     It is possible to make `fold' a primitive method, and build other
     iterator method on top of it.  Collection-specific iterating
     states can be kept in the stack of `fold', thus it runs
     efficiently.  The method to optimize a procedure that uses `fold'
     as a basic iterator construct.  However, it is rather cumbersome
     to derive generator-style interface from it.   It is also tricky
     to iterate irregularly over more than one collections.

CPS
     Passes iteratee the continuation procedure that continues the
     iteration.   The iteratee just returns when it want to terminate
     the iteration.  It has resource management problem described in
     Oleg Kiselyov's article (*note OLEG2: oleg2.).

Iterator object
     Like C++ iterator or Common Lisp generator.  Easy to write loop.
     The problem is that every call of checking termination or getting
     next element must be dispatched.

Series
     Common Lisp's series can be very efficient if the compiler can
     statically analyze the usage of series.  Unfortunately it is not
     the case in Gauche.  Even if it could, the extension mechanism
     doesn't blend well with Gauche's object system.

Macros
     Iterator can be implemented as macros, and that will be very
     efficient; e.g. Scheme48's iterator macro.  It uses macros to
     extend, however, and that doesn't blend well with Gauche's object
     system.

   The current implementation is close to the iterator object approach,
but using closures instead of iterator objects so that avoiding
dispatching in the inner loop.  Also it allows the iterator
implementator to take care of the resource problem.


File: gauche-refe.info,  Node: Implementing collections,  Prev: Fundamental iterator creators,  Up: Collection framework

9.3.5 Implementing collections
------------------------------

The minimum requirements of the collection class implementation is as
follow:
   * The class inherits `<collection>' abstract class.

   * A method `call-with-iterator' is implemented.

   This makes iterator methods such as `map', `for-each', `find' and
`filter' to work.

   In order to make the constructive methods (e.g. `map-to' to create
your collection), you have to implement `call-with-builder' method as
well.  Note that `call-with-builder' method must work a sort of class
method, dispatched by class, rather than normal method dispatched by
instance.   In Gauche, you can implement it by using a metaclass.
Then the minimal code will look like this:

     (define-class <your-collection-meta> (<class>) ())

     (define-class <your-collection> (<collection>)
      (...) ;; slots
      :metaclass <your-collection-meta>)

     (define-method call-with-iterator
         ((coll <your-collection>) proc . options)
       ...
       )

     (define-method call-with-builder
          ((coll <your-collection-meta>) proc . options)
       ...
       )

   Optionally, you can overload other generic functions to optimize
performance.


File: gauche-refe.info,  Node: Configuration parameters,  Next: Dictionary framework,  Prev: Collection framework,  Up: Library modules - Gauche extensions

9.4 `gauche.config' - Configuration parameters
==============================================

 -- Module: gauche.config
     This module allows the Scheme program to access the configuration
     information the same as you can get from the `gauche-config'
     program.

 -- Function: gauche-config option
     Returns the configured value of the OPTION.

     See the manpage of `gauche-config', or run `gauche-config' without
     any argument from the shell, to find out the valid options.
          (gauche-config "--cc")
            => "gcc"
          (gauche-config "-L")
            => "-L/usr/lib/gauche/0.6.5/i686-pc-linux-gnu"
          (gauche-config "-l")
            => "-ldl -lcrypt -lm -lpthread"


File: gauche-refe.info,  Node: Dictionary framework,  Next: Low-level file operations,  Prev: Configuration parameters,  Up: Library modules - Gauche extensions

9.5 `gauche.dictionary' - Dictionary framework
==============================================

 -- Module: gauche.dictionary
     A dictionary is an abstract class for objects that can map a key
     to a value.  This module provides some useful generic functions
     for dictionaries, plus generic dictionary classes built on top of
     other dictionary classes.

* Menu:

* Generic functions for dictionaries::
* Generic dictionaries::


File: gauche-refe.info,  Node: Generic functions for dictionaries,  Next: Generic dictionaries,  Prev: Dictionary framework,  Up: Dictionary framework

9.5.1 Generic functions for dictionaries
----------------------------------------

These generic functions are useful to implement algorithms common to
any dictionary-like objects.  Among built-in classes, `<hash-table>'
and `<tree-map>' implement the dictionary interface.  All the `<dbm>'
classes provided by `dbm' module also implement it.

   To make your own class implement the dictionary interface, you have
to provide at least `dict-get', `dict-put!', `dict-exists?',
`dict-delete!' and `dict-fold'.   Other generic functions have default
behavior built on top of these.  Of course your can implement other
methods as well, potentially to gain better performance.

 -- Generic function: dict-get (dict `<dictionary>') key &optional
          default
     Returns the value corresponding to the KEY.  If the dictionary
     doesn't have an entry with KEY, returns DEFAULT when it is
     provided, or raises an error if not.

 -- Generic function: dict-put! (dict `<dictionary>') key value
     Puts the mapping from KEY to VALUE into the dictionary.

 -- Generic function: (setter dict-get) (dict `<dictionary>') key value
     This works the same as `dict-put!'.

 -- Generic function: dict-exists? (dict `<dictionary>') key
     Returns `#t' if the dictionary has an entry with KEY, `#f' if not.

 -- Generic function: dict-delete! (dict `<dictionary>') key
     Removes an entry with KEY form the dictionary.  If the dictionary
     doesn't have such an entry, this function is noop.

 -- Generic function: dict-fold (dict `<dictionary>') proc seed
     Calls a procedure PROC over each entry in a dictionary DICT,
     passing a seed value.  Three arguments are given to PROC; an
     entry's key, an entry's value, and a seed value.  Initial seed
     value is SEED.  The value returned from PROC is used for the seed
     value of the next call of PROC.  The result of the last call of
     PROC is returned from DICT-FOLD.

     If DICT is `<ordered-dictionary>', PROC is called in the way to
     keep the following associative order, where the key is ordered
     from K0 (minimum) to KN (maximum), and the corresponding values is
     from V0 to VN:
          (proc Kn Vn (proc Kn-1 Vn-1 ... (proc K0 V0 seed)))

 -- Generic function: dict-fold-right (dict `<ordered-dictionary>')
          proc seed
     Like `dict-fold', but the associative order of applying PROC is
     reversed as follows:
          (proc K0 V0 (proc K1 V1 ... (proc Kn Vn seed)))

     This generic function is only defined on `<ordered-dictionary>'.

 -- Generic function: dict-for-each (dict `<dictionary>') proc
     Calls PROC with a key and a value of every entry in the dictionary
     DICT.  For ordered dictionaries, PROC is guaranteed to be called
     in the increasing order of keys.

 -- Generic function: dict-map (dict `<dictionary>') proc
     Calls PROC with a key and a value of every entry in the dictionary
     DICT, and gathers the result into a list and returns it.  For
     ordered dictionaries, the result is in the increasing order of
     keys (it doesn't necessarily mean PROC is called in that order).

 -- Generic function: dict-keys (dict `<dictionary>')
 -- Generic function: dict-values (dict `<dictionary>')
     Returns a list of all keys or values of a dictionary DICT,
     respectively.  For ordered dictionaries, the returned list is in
     the increasing order of keys.


File: gauche-refe.info,  Node: Generic dictionaries,  Prev: Generic functions for dictionaries,  Up: Dictionary framework

9.5.2 Generic dictionaries
--------------------------

 -- Class: <bimap>
     Provides a bidirectional map (_bimap_), a relation between two set
     of values, of which you can lookup both ways.

     Internally, a bimap consists of two dictionaries, _left_ map and
     _right_ map.  Think a bimap as a relation between Xs and Ys.  The
     left map takes an X as a key and returns corresponding Y as its
     value.  The right map takes an Y as a key and returns
     corresponding X as its value.

     Currently, `<bimap>' only supports strict one-to-one mapping.
     Mutating interface (`bimap-*-put!', `bimap-*-delete!' etc)
     modifies both left and right maps to maintain this one-to-one
     mapping.  (In future, we may provide an option to make many-to-one
     and many-to-many mappings).

     A bimap can be used as a dictionary, with the generic dictionary
     functions such as `dict-get'.  In such cases, the left map takes
     precedence; that is, the key given to `dict-get' etc. is regarded
     as the key to the left map.

 -- Function: make-bimap left-map right-map
     Creates a new bimap consists of two dictionaries, LEFT-MAP and
     RIGHT-MAP.   It is the caller's responsibility to choose
     appropriate type of dictionaries; for example, if you want to
     create a relation between a string and a number, you man want to
     create it like this:

          (make-bimap (make-hash-table 'string=?)  ; string -> number
                      (make-hash-table 'eqv?))     ; number -> string

 -- Function: bimap-left bimap
 -- Function: bimap-right bimap
     Returns the left or right map of BIMAP, respectively.

 -- Function: bimap-left-get bimap key &optional default
 -- Function: bimap-right-get bimap key &optional default
     Lookup the value corresponding to the KEY in the left or right map
     of BIMAP.   If no entry is found for KEY, DEFAULT is returned if
     provided, otherwise an error is raised.

 -- Function: bimap-left-exists? bimap key
 -- Function: bimap-right-exists? bimap key
     Returns `#f' if the left or right map of BIMAP has an entry of the
     key, `#t' otherwise.

 -- Function: bimap-put! bimap x y &key (on-conflict :supersede)
     Put a relation (X, Y) into the bimap.  After this,
     `(bimap-left-get X)' will return Y, and `(bimap-left-get Y)' will
     return X.

     If there's already a relation (X, _) and/or (_, Y), the behavior
     depends on the value of the keyword argument ON-CONFLIT.

    `:supersede'
          This is the default behavior.  Duplicate relations are
          silently removed in order to maintain one-to-one mapping.
          For example, suppose a bimap between strings and numbers has
          had `("foo", 1)' and `("bar", 2)'.  When you try to put
          `("bar", 2)' with this option, the first two entries are
          removed.  Returns `#t'.

    `:error'
          Raises an error when duplicate relations are found.

    `#f'
          When duplicate relations are found, does nothing and returns
          `#f'.


 -- Function: bimap-left-delete! bimap key
 -- Function: bimap-right-delete! bimap key
     Deletes an relation with the given left key or right key from
     BIMAP.  Both left and right maps are modified so that the
     consistency is maintained.  If there's no relations with given
     key, these are noop.

