This is gauche-refe.info, produced by makeinfo version 4.13 from
gauche-refe.texi.

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* Gauche: (gauche-refe.info).	        An R5RS Scheme implementation.
END-INFO-DIR-ENTRY


File: gauche-refe.info,  Node: Low-level file operations,  Next: Hooks,  Prev: Dictionary framework,  Up: Library modules - Gauche extensions

9.6 `gauche.fcntl' - Low-level file operations
==============================================

 -- Module: gauche.fcntl
     Provides an interface to `fcntl(2)', including advisory file
     locking.

 -- Function: sys-fcntl port-or-fd operation &optional arg
     Performs certain operation on the file specified by PORT-OR-FD,
     which should be a port object or an integer that specifies a
     system file descriptor.  If it is a port, it must be associated to
     the opened file (i.e. `port-type' returns `file', see *note Common
     port operations::).

     The operation is specified by an integer OPERATION.  Several
     variables are defined for valid OPERATION.

    `F_GETFD'
          Returns flags associated to the file descriptor of PORT-OR-FD.
          The optional argument ARG is not used.   The return value is
          an integer whose definition is system specific, except one
          flag, `FD_CLOEXEC', which indicates the file descriptor
          should be closed on `exec'.  See the manual entry of
          `fcntl(2)' of your system for the details.

    `F_SETFD'
          Sets the file descriptor flags given as ARG to PORT-OR-FD.
          For example, the portable way of setting `FL_CLOEXEC' flag is
          as follows:
               (sys-fcntl port F_SETFD
                         (logior FD_CLOEXEC
                                 (sys-fcntl port F_GETFD)))

    `F_GETFL'
          Returns flags associated to the open files specified by
          PORT-OR-FD.  The flags includes the following information:

             * File access mode.  When masked by `O_ACCMODE', it's
               either one of `O_RDONLY', `O_WRONLY' or `O_RDWR'.

             * File creation options.  `O_CREAT', `O_EXCL' and/or
               `O_TRUNC'.

             * Whether appending is allowed or not, by `O_APPEND'

             * Whether I/O is blocking or non-blocking, by `O_NONBLOCK'.

             * Whether it grabs terminal control, by `O_NOCTTY'.

          The system may define system-specific flags.

    `F_SETFL'
          Sets flags to the open files specified by PORT-OR-FD.  Among
          the flags listed above, only `O_NONBLOCK' and `O_APPEND' can
          be changed.

          Note that `F_GETFD'/`F_SETFD' concern flags associated to the
          file descriptor itself, while `F_GETFL'/`F_SETFL' concern
          flags associated to the opened file itself.  This makes
          difference when more than one file descriptor points to the
          same opened file.

    `F_DUPFD'
          Creates new file descriptor that points to the same file
          referred by PORT-OR-FD.  An integer must be provided as ARG,
          and that specifies the minimum value of file descriptor to be
          assigned.

    `F_GETLK'
          The third argument must be provided and be an instance of
          `<sys-flock>' object described below.  It searches the lock
          information specified by ARG, and modifies ARG accordingly.

    `F_SETLK'
    `F_SETLKW'
          The third argument must be provided and be an instance of
          `<sys-flock>' object described below.  Sets the advisory file
          lock according to ARG.   If the lock is successfully
          obtained, `#t' is returned.  If the other process has the
          lock conflicting the request, `F_SETLK' returns `#f', while
          `F_SETLKW' waits until the lock is available.

    `F_GETOWN'
          Returns the process id or process group that will receive
          SIGIO and SIGURG signals for events on the file descriptor.
          Process group is indicated by a negative value.  This flag is
          only available on the systems that has this feature (BSD and
          Linux have this).

    `F_SETOWN'
          Sets the process id or process group that will receive SIGIO
          and SIGURG signals for events on the file descriptor.
          Process group is indicated by a negative value.  This flag is
          only available on the systems that has this feature (BSD and
          Linux have this).  Check out fcntl(2) manpage of your system
          for the details.


     Other value for OPERATION causes an error.

 -- Builtin Class: <sys-flock>
     A structure represents POSIX advisory record locking.  Advisory
     record locking means the system may not prevents the process from
     operating on files that it doesn't have an appropriate lock.  All
     the processes are expected to use `fcntl' to check locks before it
     operates on the files that may be shared.

     The following slots are defined.

      -- Instance Variable of <sys-flock>: type
          An integer represents lock type.  Following variables are
          predefined for the valid values:

         `F_RDLCK'
               Read locking

         `F_WRLCK'
               Write locking

         `F_UNLCK'
               To remove a lock by `F_SETLK', or to indicate the record
               is not locked by `F_GETLK'.

      -- Instance Variable of <sys-flock>: whence
          Indicates from where `start' is measured.

      -- Instance Variable of <sys-flock>: start
          The offset of beginning of the locked region.

      -- Instance Variable of <sys-flock>: len
          The number of bytes to lock.  Zero means "until EOF".

      -- Instance Variable of <sys-flock>: pid
          An integer process id that holding the lock; used only by
          `F_GETLK'.


File: gauche-refe.info,  Node: Hooks,  Next: Interactive session,  Prev: Low-level file operations,  Up: Library modules - Gauche extensions

9.7 `gauche.hook' - Hooks
=========================

 -- Module: gauche.hook
     Provides a hook object, which manages a list of closures to be
     called at certain time.

     This API of hooks are upper-compatible of Guile's, with the
     following extensions.
        * Based on Gauche's object system.  Most APIs are methods so
          you can extend the hook features.

        * Hook object itself is applicable.  You don't need to use
          `run-hook'.

        * The method to remove a procedure from a hook is called
          `delete-hook!', for consistency with SRFI-1 and others.
          `remove-hook!' is defined as an alias of `delete-hook!' for
          compatibility with Guile.

 -- Class: <hook>
     A hook class, which keeps a list of procedures to be called at
     once.

     The `object-apply' method is defined on `<hook>' class, so you can
     "apply" a hook object as if it were a procedure--which causes all
     the registered procedure to be invoked.

 -- Function: make-hook &optional (arity 0)
     Creates a new hook object with given arity, which should be a
     non-negative integer.

 -- Function: hook? obj
     Returns true if OBJ is a hook object.

 -- Function: hook-empty? hook
     Returns true if HOOK's procedure list is empty.

 -- Method: add-hook! (hook <hook>) proc &optional (append? #f)
     Adds a procedure PROC to HOOK.  If APPEND?  is given and true,
     PROC is added at the end of the list.  Otherwise, PROC is added at
     the front of the list.  The PROC has to be called with the arity
     given at the `make-hook'.

 -- Method: delete-hook! (hook <hook>) proc
 -- Method: remove-hook! (hook <hook>) proc
     Removes PROC from the procedure list of HOOK.  `Remove-hook!' is
     an alias of `delete-hook!' just for compatibility with Guile.

 -- Method: reset-hook! (hook <hook>)
     Empties HOOK's procedure list.

 -- Method: hook->list (hook <hook>)
     Returns a copy of HOOK's procedure list.

 -- Method: run-hook (hook <hook>) arg ...
     Calls HOOK's procedures in order, with arguments ARG ....  The
     number of arguments must match the arity given at `make-hook'.


File: gauche-refe.info,  Node: Interactive session,  Next: Listener,  Prev: Hooks,  Up: Library modules - Gauche extensions

9.8 `gauche.interactive' - Utilities for interactive session
============================================================

 -- Module: gauche.interactive
     Provides useful utilities for the interactive session.

     This module is automatically loaded when you run `gosh'
     interactively.

     This module also sets autoloads for functions defined in
     `gauche.reload' module (see *note Reloading modules::), so that
     those functions can be used by default in interactive development.

 -- Macro: apropos pattern &optional module
     Show a list of defined variables whose name matches PATTERN.  If
     you give a module or a module name MODULE, only the variables
     defined in that module are listed.  Without MODULE, the variables
     "visible" from the current module are listed.

     PATTERN may be a symbol or a regexp object.  If it is a symbol,
     the variables whose name contains the substring that matches the
     symbol's name are listed.  If it is a regexp object, the variables
     whose name matches the regexp are listed.

     Some examples:
          ;; List variables that contains "string" in their name
          (apropos 'string)

          ;; Search in srfi-14 module
          (apropos 'char 'srfi-14)

 -- Generic Function: describe obj
 -- Generic Function: d obj
     Prints the detail information about a Scheme object OBJ.  The
     default method shows OBJ's class, and if it has any slots, the
     list of slot names and their values.  You can specialize this
     method for customized display.

 -- Function: info symbol
     Displays a page of Gauche's info file that contains definition of
     the function or syntax specified by SYMBOL.  If an environment
     variable `INFOPATH' is defined, this function searches for the
     info file from the directories in it.  Otherwise, this function
     guesses info file location from the `gosh''s library directory.
     If the info file can't be found, an error is signalled.   If the
     info file is found, but SYMBOL is not in its index, an error is
     signalled as well.  So this function doesn't work if you haven't
     installed info file.

     If the current output port is a tty, the info page is displayed by
     a paging software.  If an environment variable `PAGER' is defined,
     it is used as a paging software.  Otherwise, this function looks
     for `less' and `more' in this order from the directories in
     `PATH'.  If none of them is found, or the output port is not a
     tty, this function just displays the page.

     The first invocation of this function in a session takes some time
     to parse the info file.


File: gauche-refe.info,  Node: Listener,  Next: User-level logging,  Prev: Interactive session,  Up: Library modules - Gauche extensions

9.9 `gauche.listener' - Listener
================================

 -- Module: gauche.listener
     This module provides a convenient way to enable multiple
     read-eval-print loop (repl) concurrently.

     An obvious way to run multiple repls is to use threads; creating
     as many threads as sessions and calling `read-eval-print-loop'
     (*Note Eval and repl::) from each thread.  Nevertheless, sometimes
     single threaded implementation is preferred.  For instance, you're
     using a library which is not MT-safe, or your application already
     uses select/poll-based dispatching mechanism.

     To implement repl in the single-threaded selection-base
     application, usually you register a handler that is called when
     data is available in the listening port.  The handler reads the
     data and add them into a buffer.  Then it examines if the data in
     the buffer consists a complete expression, and if so, it reads the
     expression from the buffer, evaluates it, then prints the result
     to the reporting port.  The `<listener>' class in this module
     provides this handler mechanism, so all you need to do is to
     register the handler to your dispatching mechanism.

     Note: it may also be desirable to buffer the output sometimes, but
     the current version doesn't implement it.

Listener API
------------

 -- Class: <listener>
     An object that maintains the state of a repl session.  It has many
     external slots to customize its behavior.  Those slot values can
     be set at construction time by using the keyword of the same name
     as the slot, or can be set by `slot-set!' afterwards.  However,
     most of them should be set before calling `listener-read-hander'.

      -- Instance Variable of <listener>: input-port
          Specifies the input port from which the listener get the
          input.  The default value is the current input port when the
          object is constructed.

      -- Instance Variable of <listener>: output-port
          Specifies the output port to which the listener output will
          go.  The default value is the current output port when the
          object is constructed.

      -- Instance Variable of <listener>: error-port
          Specifies the output port to which the listener's error
          messages will go.  The default value is the current error
          port when the object is constructed.

      -- Instance Variable of <listener>: reader
          A procedure with no arguments.  It should read a Scheme
          expression from the current input port when called.  The
          default value is system's `read' procedure.

      -- Instance Variable of <listener>: evaluator
          A procedure that takes two arguments, a Scheme expression and
          an environment specifier.  It should evaluate the expression
          in the given environment and returns zero or more value(s).
          The default value is system's `eval' procedure.

      -- Instance Variable of <listener>: printer
          A procedure that takes zero or more argument(s) and prints
          them out to the current output port.  The default value is a
          procedure that prints each value by `write', followed by a
          newline.

      -- Instance Variable of <listener>: prompter
          A procedure with no arguments.  It should prints a prompt to
          the current output port.  The output is flushed by the
          listener object so this procedure doesn't need to care about
          it.  The default procedure prints `"listener> "'.

      -- Instance Variable of <listener>: environment
          An environment specifier where the expressions will be
          evaluated.  The default value is the value returned by
          `(interaction-environment)'.

      -- Instance Variable of <listener>: finalizer
          A thunk that will be called when EOF is read from
          `input-port'.  During the execution of FINALIZER, the current
          input, output and error ports are restored to the ones when
          `listener-read-handler' is called.

          It can be `#f' if no such procedure is needed.  The default
          value is `#f'.

      -- Instance Variable of <listener>: error-handler
          A procedure that takes one argument, an error exception.  It
          is called when an error occurs during read-eval-print stage,
          with the same dynamic environment as the error is signalled.
          The default value is a procedure that simply prints the error
          exception by `report-error'.

      -- Instance Variable of <listener>: fatal-handler
          A procedure that takes one argument, an error exception.  It
          is called when a _fatal_ error occurred (see below for the
          precise definition).  If this handler is called, you should
          assume you can no longer continue the listener session
          safely, even write messages to the client.  This handler is
          to log such condition or to clean up the listener.  During
          the execution of FATAL-HANDLER, the current input, output and
          error ports are restored to the ones when
          `listener-read-handler' is called.

          If FATAL-HANDLER returns `#f', FINALIZER is called
          afterwards.  With this, you can implement a common cleanup
          work in FINALIZER.  If FATAL-HANDLER returns a true value,
          FINALIZER will not be called.



 -- Method: listener-read-handler (listener <listener>)
     Returns a thunk that is to be called when a data is available from
     `input-port' of the listener.

     The returned thunk (read handler) does the following steps.  Note
     that the first prompt is _not_ printed by this procedure.  See
     `listener-show-prompt' below.
       1. Reads available data from `input-port' and appends it to the
          listener's internal buffer.

       2. Scans the buffer to see if it has a complete S-expression.
          If not, returns.

       3. Reads the S-expression from the buffer.  The read data is
          removed from the buffer.

       4. Evaluates the S-expression, then prints the result to
          `output-port'.

       5. Prints the prompt by prompter procedure to `output-port',
          then flush `output-port'.

       6. Repeats from 2.

 -- Method: listener-show-prompt (listener <listener>)
     Shows a prompt to the listener's output port, by using listener's
     prompter procedure.  Usually you want to use this procedure to
     print the first prompt, for instance, when the client is connected
     to the listener socket.

 -- Function: complete-sexp? str
     Returns `#t' if STR contains a complete S-expression.  This
     utility procedure is exported as well, since it might be useful
     for other purposes.

     Note that this procedure only checks syntax of the expressions,
     and doesn't rule out erroneous expressions (such as containing
     invalid character name, unregistered SRFI-10 tag, etc.).  This
     procedure may raise an error if the input contains '`#<''
     character sequence.

Error handling
--------------

There are a few error situations the listener handles diffetently.

   * _Fatal error_ - An error situation that the listener session can
     no longer go on safely.  You cannot even tell so to the listener
     client, since the connection to the client may be broken.  All you
     can do is to clean up the listener session (e.g. removes the
     handler).   This case happens in (1) a low-level system error
     occurrs during reading from INPUT-PORT. (A syntax error of the
     input isn't count as fatal, and handled as REPL error described
     below.), (2) a `SIGPIPE' signal is raised during writing to
     OUTPUT-PORT, or (3) an unhandled error occurred during executing
     ERROR-HANDLER.

     When this situation happens, the FATAL-HANDLER is called if it is
     given.  If FATAL-HANDLER returns `#f', or FATAL-HANDLER isn't
     given, FINALIZER is also called.

   * _Leaked error_ - If an error occurrs during executing
     FATAL-HANDLER or FINALIZER, we don't have no more safety net.  The
     error is 'leaked' outside the listener handler, and should be
     handled by the user of `gauche.listener'.

     Generally this situation should be considered as a bug of the
     program; you should make sure to catch foreseeable errors within
     FATAL-HANDLER and FINALIZER.

   * _REPL error_ - Other errors are handled by ERROR-HANDLER.

Listener example
----------------

The following code snippet opens a server socket, and opens a Scheme
interactive session when a client is connected.  (Note: this code is
just for demonstration.  Do not run this program on the machine
accessible from outside network!)

     (use gauche.net)
     (use gauche.selector)
     (use gauche.listener)

     (define (scheme-server port)
       (let ((selector (make <selector>))
             (server   (make-server-socket 'inet port :reuse-addr? #t))
             (cid      0))

         (define (accept-handler sock flag)
           (let* ((client (socket-accept server))
                  (id     cid)
                  (input  (socket-input-port client :buffering :none))
                  (output (socket-output-port client))
                  (finalize (lambda ()
                              (selector-delete! selector input #f #f)
                              (socket-close client)
                              (format #t "client #~a disconnected\n" id)))
                  (listener (make <listener>
                              :input-port input
                              :output-port output
                              :error-port output
                              :prompter (lambda () (format #t "client[~a]> " id))
                              :finalizer finalize))
                  (handler (listener-read-handler listener))
                  )
             (format #t "client #~a from ~a\n" cid (socket-address client))
             (inc! cid)
             (listener-show-prompt listener)
             (selector-add! selector input (lambda _ (handler)) '(r))))

         (selector-add! selector
                        (socket-fd server)
                        accept-handler
                        '(r))
         (format #t "scheme server started on port ~s\n" port)
         (do () (#f) (selector-select selector))))


File: gauche-refe.info,  Node: User-level logging,  Next: Singleton,  Prev: Listener,  Up: Library modules - Gauche extensions

9.10 `gauche.logger' - User-level logging
=========================================

 -- Module: gauche.logger
     Provides a simple interface to log the program's activity.  The
     information can be written to the specified file, or to the system
     logger using `syslog(3)'.  When a file is used, syslog-like prefix
     string is added to each message, which is configurable.  It can
     also takes care of locking of the file (see the description of
     `lock-policy' below).

 -- Class: <log-drain>
     Represents the destination of log messages.  There's one implicit
     global `<log-drain>' instance, which is used by default.  However,
     you can create as many instances by `make' method as you want, in
     case if you want to log to more than one destination.

      -- Instance Variable of <log-drain>: path
          Path of the log file.  It can be also `#t', which means the
          current error port, or `#f', which makes `log-format' to
          return the formatted message but not write to any log files,
          or a symbol `syslog', which means the messages are sent to
          the system logger.

          By default, this slot is `#f'.

      -- Instance Variable of <log-drain>: prefix
          Specifies the prefix string that is attached to the beginning
          of every message.  If the message spans to several lines, the
          prefix is attached to each line.   The value of this slot can
          also be a procedure that takes `<log-drain>' object and
          returns a string to be used as the prefix.  The procedure is
          called every time prefix is needed.

          When the `path' slot is a symbol `syslog', the value of this
          slot is ignored.  System logger will attach an appropriate
          prefix.

          When the value of the prefix slot is a string, the following
          character sequences have special meanings and replaced by
          `log-format' for appropriate information when written out.

         `~T'
               Current time, in the format of "Mmm DD hh:mm:ss" where
               "Mmm" is an abbreviated month, "DD" is the day of month,
               "hh", "mm" and "ss" are hours (in 24 hour basis),
               minutes and seconds, respectively.  This format is
               compatible with system logs.

         `~Y'
               Current 4-digit year.

         `~P'
               The program name.  The default value is the basename of
               `*program-name*' (*Note Writing Scheme scripts::), but
               you can change it by the `program-name' slot described
               below.

         `~$'
               The process id of this program.

         `~U'
               The name of the effective user of the process.

         `~H'
               The hostname the process is running.

          The default value of this slot is "`~T ~P[~$]: '".  For
          example, if a string "this is a log message.\nline 2\nline 3"
          is given as the message, it produces something like the
          following log entry.

               Sep  1 17:30:23 myprogram[441]: this is a log message
               Sep  1 17:30:23 myprogram[441]: line 2
               Sep  1 17:30:23 myprogram[441]: line 3


      -- Instance Variable of <log-drain>: program-name
          Specifies the program name written by `~P' directive of the
          prefix slot.

      -- Instance Variable of <log-drain>: lock-policy
          Specifies the way the log file should be locked.  If the
          value of this slot is a symbol `fcntl', the log file is
          locked using fcntl() (*Note Low-level file operations::).  If
          the value is a symbol `file', the log file is locked by
          creating auxiliary lock file, whose name is generated by
          appending ".lock" after the log file path.  The logging
          process needs a write permission to the log file directory.
          Note that if the process is killed forcibly during writing the
          log file, a stale lock file may remain.  `Log-format'
          silently removes the lock file if it is unusually old
          (currently 10 minutes).  If the value is `#f', no locking is
          performed.

          The default value is `fcntl', except MacOSX which doesn't
          support fcntl()-style locking and thus `file' is default.

          The locking isn't performed if the destination is not a file.

      -- Instance Variable of <log-drain>: syslog-option
      -- Instance Variable of <log-drain>: syslog-facility
      -- Instance Variable of <log-drain>: syslog-priority
          The value of these slots are used when the destination of the
          drain is the system logger.   *Note Syslog::, for the
          detailed information about these values.  The default values
          of these slots are `LOG_PID', `LOG_USER' and `LOG_INFO',
          respectively.

 -- Function: log-open path &keyword prefix program-name
     Sets the destination of the default log message to the path PATH.
     It can be a string or a boolean, as described above.  You can also
     set prefix and program name by corresponding keyword arguments.

     Despite its name, this function doesn't open the specified file
     immediately.  The file is opened and closed every time `log-format'
     is called.

 -- Parameter: log-default-drain
     When called with no argument, returns the current default log-drain
     `log-format' uses when the explicit drain is omitted.  It may
     return `#f' if the default log drain hasn't been opened by
     `log-open'.

     Calling with new `<log-drain>' object or `#f' alters the default
     log-drain.  You can also use `parameterize' (*note Parameters::)
     to change the log drain temporary.

 -- Method: log-format (format <string>) arg ...
 -- Method: log-format (drain <log-drain>) (format <string>) arg ...
     Formats a log message by FORMAT and ARG ..., by using `format'
     (*Note Output::).    In the first form, the output goes to the
     default destination.  In the second form, the output goes to the
     specfied drain.

     The file is opened and closed every time.  You can safely move the
     log file while your program that touches the log file is running.
     Also `log-format' acquires a write lock of the log file by
     `sys-fcntl' (*Note Low-level file operations::).

     If the first form of `log-format' is called before `log-open' is
     called, `log-format' does nothing.  It is useful to embed debug
     stubs in your code; once your code is past the debugging stage,
     you just comment out `log-open' and the code runs without logging.


File: gauche-refe.info,  Node: Singleton,  Next: Slot with validator,  Prev: User-level logging,  Up: Library modules - Gauche extensions

9.11 `gauche.mop.singleton' - Singleton
=======================================

 -- Module: gauche.mop.singleton
     Provides a metaclass to define a singleton class.

 -- Class: <singleton-meta>
     Creates a singleton class.  A singleton class is a class that is
     guaranteed to create only one instance.  The first invocation of
     `make' creates the single instance, and further attempt of
     creation returns the same instance.
          (define-class single () () :metaclass <singleton-meta>)

          (define a (make single))
          (define b (make single))

          (eq? a b) => #t

     The slots of the instance are initialized at the first invocation
     of `make'.  Initargs of `make' are effective only in the fist
     invocation, and ignored in the subsequent invocation.

 -- Method: instance-of (class <singleton-meta>) &rest initargs
     This method just calls `make' with the passed arguments.  It is
     more obvious in the program that you're dealing with singleton.

 -- Class: <singleton-mixin>
     An instance of `<singleton-meta>'.  Instead of specifying
     `<singleton-meta>' as the `:metaclass' argument of `define-class',
     you can inherit this class to give your class the property of
     singleton.


File: gauche-refe.info,  Node: Slot with validator,  Next: Networking,  Prev: Singleton,  Up: Library modules - Gauche extensions

9.12 `gauche.mop.validator' - Slot with validator
=================================================

 -- Module: gauche.mop.validator
     Provides a metaclass that adds `:validator' and `:observer' slot
     options.

 -- Class: <validator-meta>
     This metaclass adds a feature that you can specify callbacks that
     are called before and after the slot value is set.  For example,
     if you want to guarantee that a certain slot always holds a string
     value, you can make a procedure be called before the slot is
     modified, either by `slot-ref' or by a setter method.  In the
     procedure you can either rejects a value except string, or coerce
     the value to a string.

     A _validator_ procedure is a callback procedure that is called
     before the slot value is set.   It can be specified by `:validator'
     slot option.  The procedure takes two values, the instance and the
     value to be set.  Whatever the procedure returns is set to the
     actual slot value.

     A _observer_ procedure is a callback procedure that is called
     after the slot value is set.  It can be specified by `:observer'
     slot option.  The procedure also takes two values, the instance
     and the new value.  Result of the observer procedure is discarded.

     See the following example:

          (define-class <v> ()
            ((a :accessor a-of
                :validator (lambda (obj value) (x->string value)))
             (b :accessor b-of
                :validator (lambda (obj value)
                             (if (integer? value)
                                 value
                                 (error "integer required for slot b")))))
            :metaclass <validator-meta>)

          (define v (make <v>))
          (slot-set! v 'a 'foo)
          (slot-ref v 'a) => "foo"

          (set! (a-of v) 1234)
          (a-of v) => "1234"

          (slot-set! v 'b 55)
          (slot-ref v 'b) => 55

          (slot-set! v 'b 3.4) => error
          (set! (b-of v) 3.4)  => error

     You can specify default slot value (`:init-value' etc.) with
     `:validator'.  In that case, the initialization method of the
     instance calls the validator with the specified default value, if
     :init-keyword is not given.

          (define-class <v> ()
            ((a :initform 'foo :init-keyword :a
                :validator (lambda (obj value) (x->string value)))))

          (slot-ref (make <v>) 'a)        => "foo"
          (slot-ref (make <v> :a 555) 'a) => "555"

     It looks similar to the virtual slot, but note that a slot with
     validator has an actual storage in the instance, while a virtual
     slot doesn't.

     It is also a good example of customizing how the slots are accessed
     using the metaobject protocol.  This feature is implemented by
     only a couple of dozen lines of code.


File: gauche-refe.info,  Node: Networking,  Next: Parameters,  Prev: Slot with validator,  Up: Library modules - Gauche extensions

9.13 `gauche.net' - Networking
==============================

 -- Module: gauche.net
     Provides a set of functions necessary for network communications
     based on BSD socket interface.

     The API is provided in two different levels.  Lower level routines
     reflect traditional BSD socket interface, such as `bind(2)'.
     Higher level routines provides more convenient way to create
     typical connection-oriented server/client sockets.

     This module also provides APIs to obtain various information about
     hostnames, service ports, and protocols.

     Gauche can handle IPv6 if it is compiled with the `--enable-ipv6'
     configuration option.  To check whether IPv6 is enabled or not,
     you can use `cond-expand' with `gauche.net.ipv6' feature identifier
     after loading `gauche.net', as shown below.

          (use gauche.net)
          (cond-expand
            (gauche.net.ipv6
              ... code to use ipv6 ...)
            (else
              ... ipv4 only code ...))

     See *note Feature conditional:: for the details of `cond-expand'.


* Menu:

* Socket address::
* High-level network functions::
* Low-level socket interface::
* Netdb interface::


File: gauche-refe.info,  Node: Socket address,  Next: High-level network functions,  Prev: Networking,  Up: Networking

9.13.1 Socket address
---------------------

Socket address objects
......................

 -- Builtin Class: <sockaddr>
     An abstract base class of socket addresses.  Each socket address
     family is implemented as a subclass of this class.

     Although socket addresses are built-in classes, you can use `make'
     method to create an instance of a specific socket address family.

 -- Generic Function: sockaddr-family addr
     Returns a symbol that indicates the family of the socket address
     ADDR.

 -- Generic Function: sockaddr-name addr
     Returns a string which represents the content of the socket address
     ADDR.

 -- Builtin Class: <sockaddr-in>
     AF_INET family socket address.  To create an instance of this
     class, use `make' method as follows:
          (make <sockaddr-in> :host HOST :port PORT)
     HOST can be a string, an integer IP address, a `u8vector' IP
     address, or one of the keywords `:any', `:broadcast', `:none' or
     `:loopback'.  If it is a string, it is either a host name or a
     dotted IP notation.  Gauche uses `gethostbyname(3)' to obtain the
     actual IP address from HOST parameter.  If it is a keyword `:any',
     or `:broadcast', the address uses `INADDR_ANY', or
     `INADDR_BROADCAST' respectively.  The keyword `:loopback' is a
     synonym to the IPv4 loopback address "127.0.0.1".

     PORT must be a positive integer indicating the port number.  See
     also `make-sockaddrs' below, to create multiple socket addresses
     on the machine which may have more than one protocol stack.

 -- Method: sockaddr-family (addr <sockaddr-in>)
     Returns a symbol `inet'.

 -- Method: sockaddr-name (addr <sockaddr-in>)
     Returns a string in the form "A.B.C.D:PORT",  where "A.B.C.D" is
     dotted decimal notion of the IP address and PORT is the port
     number.

 -- Method: sockaddr-addr (addr <sockaddr-in>)
 -- Method: sockaddr-port (addr <sockaddr-in>)
     Returns the IP address and the port number as an integer,
     respectively.

 -- Builtin Class: <sockaddr-un>
     AF_UNIX family socket address.  To create an instance of this
     class, use `make' method as follows:
          (make <sockaddr-un> :path PATH)
     PATH must be a string specifying pathname of the socket.

 -- Method: sockaddr-family (addr <sockaddr-un>)
     Returns a symbol `unix'.

 -- Method: sockaddr-name (addr <sockaddr-un>)
     Returns a pathname of the socket address.

 -- Builtin Class: <sockaddr-in6>
     AF_INET6 family socket address.  This is only available if gauche
     is configured with -enable-ipv6 configure option.  The constructor
     and the slots are the same as `<sockaddr-in>'.  See also
     `make-sockaddrs' below, to create multiple socket addresses on the
     machine which may have more than one protocol stack.

 -- Function: make-sockaddrs host port &optional proto
     This is a higher-level utility procedure to create all possible
     inet domain socket addresses that point to `HOST:PORT' of protocol
     PROTO.  Particularly, if the specified host has both IPv4 and IPv6
     addresses, and the running system supports both, then both IPv4
     and IPv6 socket addresses are returned.   If HOST has multiple IP
     addresses, socket addresses are created for each of these IP
     address.   You can make your network application much more portable
     among different network stack configurations.

     Passing `#f' to HOST creates the local (server) address.  You can
     also pass a service name (e.g. `"http"') instead of an integer, to
     the PORT argument.  The value of PROTO can be either a symbol
     `tcp' or `udp', and the default is `tcp'.

     It always returns a list of socket addresses.  If the lookup of
     HOST is failed, null list is returned.

Address and string conversion
.............................

 -- Function: inet-string->address address
     Converts string representating of the internet address ADDRESS to
     an integer address.  If ADDRESS is parsed successfully, returns
     two values: the integer address value and the recognized protocol
     (the constant value `2' (= `AF_INET') for IPv4 addresses, and `10'
     (= `AF_INET6') for IPv6 addresses).  If ADDRESS can't be parsed,
     `#f' and `#f' are returned.

          (inet-string->address "192.168.1.1")
           => 3232235777 and 2
          (inet-string->address "::1")
           => 1 and 10
          (inet-string->address "::192.168.1.1")
           => 3232235777 and 10
          (inet-string->address "ffe0::1")
           => 340116213421465348979261631549233168385 and 10
          (inet-string->address "::192.168.1.1")
           => 3232235777 and 10

 -- Function: inet-string->address! address buf
     Like `inet-string->address', but fills the given u8vector BUF by
     the parsed address instead of returning it as an integer value.
     The integer representation of inet addresses is likely to be a
     bignum, and you can avoid creating bignums with this function.
     The given u8vector BUF must be mutable.  Returns the protocol on
     success, or `#f' on failure.

     The caller must provide big enough buffer.  If BUF is larger than
     required, the result is filled from the top of the u8vector and
     the rest of the vector remains intact.

          (let* ((buf (make-u8vector 16 0))
                 (proto (inet-string->address! "192.168.1.1" buf)))
            (list proto buf))
           => (2 #u8(192 168 1 1 0 0 0 0 0 0 0 0 0 0 0 0))

 -- Function: inet-address->string address protocol
     Converts the given ADDRESS to its string representation of the
     protocol PROTOCOL, which can be either `2' (the constant
     `AF_INET') or `10' (the constant `AF_INET6').  An integer or a
     u8vector can be used as ADDRESS.  If it is a u8vector, only the
     necessary portion of the vector is read; i.e.  the vector can be
     longer than the required length.

          (inet-address->string 3232235777 AF_INET)
            => "192.168.1.1"

          (inet-address->string '#u8(192 168 1 1) AF_INET)
            => "192.168.1.1"

          (inet-address->string 3232235777 AF_INET6)
            => "::c0a8:101"


File: gauche-refe.info,  Node: High-level network functions,  Next: Low-level socket interface,  Prev: Socket address,  Up: Networking

9.13.2 High-level network functions
-----------------------------------

 -- Builtin Class: <socket>
     Abstracts a socket, a communication endpoint.

     For a connection-oriented socket, you can access the communication
     channel by two ports associated to the socket, one for input and
     another for output.  `socket-input-port' and `socket-output-port'
     returns those ports, respectively.

   The following three functions are convenient ways to create a
connection-oriented socket.  Those functions are to provide an easy
methods for typical cases, but have less control.  If you need more
than these functions provide, use low-level interface.

 -- Function: make-client-socket &optional address-spec ...
     Creates and returns a client socket, connected to the address
     specified by ADDRESS-SPEC ....

    `(make-client-socket 'unix PATH)'
          The client socket is connected to the unix domain server
          socket of address PATH.

    `(make-client-socket 'inet HOST PORT)'
          The client socket is connected to the inet domain server
          socket with hostname HOST and port PORT.   TCP protocol is
          assumed.   HOST can be either a hostname, or a dotted decimal
          notation of IPv4 address.  If gauche is compiled with
          -enable-ipv6, IPv6 address notation can also be used.  PORT
          must be an exact integer specifying a port number, or a
          string service name (e.g. `"http"').

          If gauche is compiled with -enable-ipv6, and the hostname is
          given, and the hostname has both IPv6 and IPv4 addresses, then
          IPv6 connection is tried first, and IPv4 is used when IPv6
          fails.

    `(make-client-socket HOST PORT)'
          This works the same as above.  This form is for compatibility
          with STk.

    `(make-client-socket SOCKADDR)'
          If an instance of `<sockaddr>' is passed, a socket suitable
          for SOCKADDR is opened and then connected to the given
          address.

     This function raises an error if it cannot create a socket, or
     cannot connect to the specified address.

          (make-client-socket 'inet "www.w3.com" 80)
            => ;a socket connected to www.w3.com, port 80
          (make-client-socket "127.0.0.1" 23)
            => ;a socket connected to localhost, port 23
          (make-client-socket 'unix "/tmp/.sock"
            => ;a socket connected to a unix domain socket "/tmp/.sock"

 -- Function: make-server-socket &optional address-spec ...
     Creates and returns a server socket, listening the address
     specified by ADDRESS-SPEC.

    `(make-server-socket 'unix PATH [:backlog NUM])'
          The socket is bound to a unix domain socket with a name PATH.
          The keyword argument BACKLOG is passed to `socket-listen' to
          specify the maximum number of connection request the server
          can keep befor accepting them.  The default is 5.  If your
          server is very busy and you see "connection refused" often,
          you might want to increase it.

    `(make-server-socket 'inet PORT [:reuse-addr? FLAG] [:sock-init PROC] [:backlog NUM])'
          The socket is bound to an inet domain TCP socket, listening
          port PORT, which must be a non-negative exact integer or a
          string service name (e.g. `"http"').  If PORT is zero, the
          system assigns one of available port numbers.  If a keyword
          argument REUSE-ADDR? is given and true, `SO_REUSEADDR' option
          is set to the socket before bound to the port.  This allows
          the process to bind the server socket immediately after other
          process releases the port.

          If keyword argument `sock-init' is given, it should be a
          procedure that takes two arguments, a created socket and the
          socket address.  The procedure is called just after the
          socket is created.  It is useful to set some special socket
          options.  The keyword argument BACKLOG is the same as in unix
          sockets; see the description above.

    `(make-server-socket PORT [:reuse-addr? FLAG] [:sock-init PROC][:backlog NUM])'
          This is a synonym to the above form (except PORT must be an
          integer).  This form is backward-compatible with STk's
          `make-server-socket'.

    `(make-server-socket SOCKADDR [:reuse-addr? FLAG][:sock-init PROC][:backlog NUM])'
          This form explicitly specifies the socket address to listen
          by an instance of `<sockaddr>'.

          (make-server-socket 'inet 8080)
            => #<socket (listen "0.0.0.0:8080")>
          (make-server-socket 8080)
            => #<socket (listen "0.0.0.0:8080")>
          (make-server-socket 'inet 0)
            => #<socket (listen "0.0.0.0:35628")>
          (make-server-socket 'unix "/tmp/.sock")
            => #<socket (listen "/tmp/.sock")>

 -- Function: make-server-sockets host port &keyword reuse-addr?
          sock-init
     Creates one or more sockets that listen at PORT on all available
     network interfaces of HOST.  You can specify a service name (such
     as "`http'") to PORT, as well as an integer port number.  Returns
     a list of opened, bound and listened sockets.

     This procedure is particularly useful when the host has multiple
     protocol stacks, such as IPv4 and IPv6.

     The meaning of keyword arguments are the same as of
     `make-server-socket'.

   Several accessors are available on the returned socket object.

 -- Function: socket-address socket
     Returns a socket address associated with SOCKET.  If no address
     has been associated to the socket, `#f' is returned.

 -- Function: socket-input-port socket &keyword (buffering `:modest')
 -- Function: socket-output-port socket &keyword (buffering `:line')
     Returns an input and output port associated with SOCKET,
     respectively.

     The keyword argument BUFFERING specifies the buffering mode of the
     port.  *Note File ports::, for explanation of the buffering mode.

 -- Function: socket-close socket
     Closes SOCKET.  All the ports associated to SOCKET are closed as
     well.  Note: as of release 0.7.2, this procedure does not shutdown
     the connection.  It is because SOCKET may be referenced by forked
     process(es) and you might want to close it without interfering the
     existing connection.   You can call `socket-shutdown' to shutdown
     the connection explicitly.

 -- Function: call-with-client-socket socket proc
     SOCKET must be a connected client socket.  PROC is called with two
     arguments, an input port that reads from the socket and an output
     port that writes to the socket.  The socket is closed after PROC
     returns or PROC raises an error.

   This is an example of usage of high-level socket functions, a very
simple http client.

     #!/usr/bin/env gosh
     (use gauche.net)

     (define (usage)
       (display "Usage: swget url\n" (current-error-port))
       (exit 1))

     ;; Returns three values: host, port, and path.
     (define (parse-url url)
       (rxmatch-let (rxmatch #/^http:\/\/([-A-Za-z\d.]+)(:(\d+))?(\/.*)?/ url)
           (#f host #f port path)
         (values host port path)))

     (define (get url)
       (receive (host port path) (parse-url url)
         (call-with-client-socket
             (make-client-socket 'inet host (string->number (or port "80")))
           (lambda (in out)
             (format out "GET ~a HTTP/1.0\r\n" path)
             (format out "host: ~a\r\n\r\n" host)
             (flush out)
             (copy-port in (current-output-port))))))

     (define (main args)
       (if (= (length args) 2)
           (get (cadr args))
           (usage))
       0)


File: gauche-refe.info,  Node: Low-level socket interface,  Next: Netdb interface,  Prev: High-level network functions,  Up: Networking

9.13.3 Low-level socket interface
---------------------------------

These functions provide APIs similar to the system calls.  Those who
are familiar to programming with socket APIs will find these functions
useful since you can have more detailed control over the sockets.

 -- Function: make-socket domain type &optional protocol
     Returns a socket with specified parameters.

 -- Constant: PF_UNIX
 -- Constant: PF_INET
 -- Constant: PF_INET6
     These constants are bound to the system's constants `PF_UNIX',
     `PF_INET' and `PF_INET6'.  You can use those values for DOMAIN
     argument of `make-socket'.

     (`PF_INET6' is defined only if the underlying operating system
     supports IPv6.)

 -- Constant: AF_UNIX
 -- Constant: AF_INET
 -- Constant: AF_INET6
     These constants are bound to `AF_UNIX', `AF_INET' and `AF_INET6'.

     (`AF_INET6' is defined only if the underlying operating system
     supports IPv6.)

 -- Constant: SOCK_STREAM
 -- Constant: SOCK_DGRAM
 -- Constant: SOCK_RAW
     These constants are bound to `SOCK_STREAM', `SOCK_DGRAM' and
     `SOCK_RAW', and suitable to pass to the TYPE argument of
     `make-socket'.

 -- Function: socket-fd socket
     Returns an integer system file descriptor of the underlying socket.

 -- Function: socket-status socket
     Returns a internal status of SOCKET, by one of the following
     symbols.
     none                The socket is just created.
     bound               The socket is bound to an address by
                         `socket-bind'
     listening           The socket is listening a connection by
                         `socket-listen'
     connected           The socket is connected by `socket-connect' or
                         `socket-accept'.
     shutdown            The socket is shutdown by `socket-shutdown'
     closed              The socket is closed by `socket-close'.

 -- Function: socket-bind socket address
     Binds SOCKET to the local network address ADDRESS.  It is usually
     used to associate specific address to the server port.  If binding
     failed, an error is signalled (most likely the address is already
     in use).

     For the inet domain address, you can pass ADDRESS with port=0; the
     system assigns the port number and sets the actual address to the
     `address' slot of SOCKET.

 -- Function: socket-listen socket backlog
     Listens SOCKET.  The socket must be already bound to some address.
     BACKLOG specifies maximum number of connection requests to be
     queued.

 -- Function: socket-accept socket
     Accepts a connection request coming to SOCKET.  Returns a new
     socket that is connected to the remote entity.  The original
     SOCKET keeps waiting for further connections.  If there's no
     connection requests, this call waits for one to come.

     You can use `sys-select' to check if there's a pending connection
     request.

 -- Function: socket-connect socket address
     Connects SOCKET to the remote address ADDRESS.  This is the way
     for a client socket to connect to the remote entity.

 -- Function: socket-shutdown socket how
     Shuts down connection of SOCKET.  If HOW is `SHUT_RD' (or 0), the
     receive channel of SOCKET is disallowed.  If HOW is `SHUT_WR' (or
     1), the send channel of SOCKET is disallowed.  If HOW is
     `SHUT_RDWR' (or 2), both receive and send channels are disallowed.
     It is an error to call this function on a non-connected socket.

     If you shut down the send channel of the socket, the remote peer
     sees EOF from its receive channel.  This is useful if the remote
     peer expects EOF before sending something back to you.

 -- Function: socket-getsockname socket
     Returns a `<sockaddr>' instance that is the local address of
     SOCKET.

 -- Function: socket-getpeername socket
     Returns a `<sockaddr>' instance that is the peer address of SOCKET.

 -- Function: socket-send socket msg &optional flags
 -- Function: socket-sendto socket msg to-address &optional flags.
     Interfaces to `send(2)' and `sendto(2)', respectively.  Transmits
     the content of MSG through SOCKET.  MSG can be either a string or
     a uniform vector; if you send binary packets, uniform vectors are
     recommended.

     When `socket-send' is used, SOCKET must already be connected.  On
     the other hand, `socket-setdto' can be used for non-connected
     socket, and the destination address is specified by a `<sockaddr>'
     instance TO-ADDRESS.

     The optional FLAGS can be a bitwise OR of the integer constants
     `MSG_*'.  See the system's manpage of `send(2)' and `sendto(2)'
     for the details.

 -- Function: socket-sendmsg socket msghdr &optional flags
     Sends a packet described by MSGHDR through SOCKET using
     `sendmsg(3)'.  The MSGHDR argument must be a string or u8vector,
     and it must be prepared as a binary representation of `struct
     msghdr'.  A reliable way to build a MSGHDR is to use
     `socket-buildmsg' described below.

     The FLAGS argument is the same as `socket-send' and
     `socket-sendto'.

     Returns number of octets sent.

 -- Function: socket-buildmsg addr iov control flags &optional buf
     Builds a binary representation of `struct msghdr' which is
     suitable to be given to `socket-sendmsg'.  You have to be familiar
     with `sendmsg(3)' system call to understand this procedure.

     The ADDR argument must be an instance of `<sockaddr>' or `#f'.  If
     it is a sockaddr, the `msg_name' field of the msghdr is filled
     with the address.

     The IOV argument must be a vector or `#f'.  If it is a vector,
     each element must be either a string or a u8vector.  They are used
     to fill `msg_iov' field of the msghdr.  Their contents will be
     concatenated in the kernel to make a payload.

     The CONTROL argument represents ancillary data, a.k.a. cmsg.  It
     can be `#f' if you don't need ancillary data.  Otherwise, it must
     be a list in the following form:
          ((LEVEL TYPE DATA) ...)
     Where LEVEL and TYPE are exact integers, and DATA is either a
     string or a u8vector.  The former two are used to fill cmsg's
     `cmsg_level' and `cmsg_type' fields.  The DATA is for cmsg's data
     (`cmsg_len' is calculated from DATA).

     The FLAGS argument is used to fill `msg_flags'.

     If the BUF argument is `#f' or omitted, new memories are allocated
     to construct the msghdr.  If a mutable u8vector is given to BUF,
     `socket-buildmsg' tries to use it to construct the msghdr as much
     as possible; it allocates memory only if BUF is used up.

     Returns the constructed msghdr as a u8vector.

 -- Function: socket-recv! socket buf &optional flags
     Interface to `recv(2)'.  Receives a message from SOCKET, and
     stores it into BUF, which must be a mutable uniform vector.
     Returns the number of bytes actually written.   SOCKET must be
     already connected.  If the size of BUF isn't enough to store the
     entire message, the rest may be discarded depending on the type of
     SOCKET.

     The optional FLAGS can be a bitwise OR of the integer constants
     `MSG_*'.  See the system's manpage of `recv(2)' for the details.

 -- Function: socket-recvfrom! socket buf addrs &optional flags
     Interface to `recvfrom(2)'.  Receives a message from SOCKET, which
     may be unconnected, and stores it to a mutable uniform vector BUF.
     Like SOCKET-RECV, if the size of BUF isn't enough to store the
     entire message, the rest may be discarded depending on the type of
     SOCKET.

     Returns two values; the number of bytes actually written into BUF,
     and an instance of a subclass of `<sys-sockaddr>' which shows the
     sender's address.

     The ADDRS argument must be a list of instances of socket
     addresses, optionally its last cdr being `#t' (as a special case,
     if there's zero addresses to pass, just `#t' may be given).  The
     content of each address doesn't matter; if the protocol family of
     one of them matches the sender's address, the sender's address is
     written into the passed sockaddr object.  By listing sockaddrs of
     possible families, you can count on `socket-recvfrom!' to allocate
     no memory on successful operation.  It is useful if you call
     `socket-recvfrom!' in a speed-sensitive inner loop.

     If the sender's address family doesn't match any of the addresses
     given to ADDRS, the behavior depends on whether the list is
     terminated by `()' or `#t'.  If it is terminated by `()', (i.e.
     ADDRS is a proper list), the sender's address is simply discarded
     and `socket-recvfrom!' returns `#f' as the second value.  If the
     list is terminated by `#t', `socket-recvfrom!' allocates a fresh
     sockaddr object and returns it as the second value.

     Two simple cases: If you pass `()' to ADDRS, the sender's address
     is always discarded, which is useful if SOCKET is connected (that
     is, you already know your sender's address).  If you pass `#t' to
     ADDRS, a new socket address object is always allocated for the
     sender's address, which is convenient if you don't mind memory
     allocation.

     The optional FLAGS can be a bitwise OR of the integer constants
     `MSG_*'.  See the system's manpage of `recvfrom(2)' for the
     details.

 -- Function: socket-recv socket bytes &optional flags
 -- Function: socket-recvfrom socket bytes &optional flags
     Like `socket-recv!' and `socket-recvfrom!', but these returns the
     received message as a (possibly incomplete) string, up to BYTES
     size.  Additionally, `socket-recvfrom' always allocates a socket
     address object for the sender's address.

     The use of these procedures are discouraged, since they often
     returns incomplete strings for binary messages.  Using strings for
     binary data creates many pitfalls.  Uniform vectors (especially
     `u8vector's) are for binary data.  (The reason these procedures
     return strings is merely historical.)

 -- Variable: MSG_CTRUNC
 -- Variable: MSG_DONTROUTE
 -- Variable: MSG_EOR
 -- Variable: MSG_OOB
 -- Variable: MSG_PEEK
 -- Variable: MSG_TRUNC
 -- Variable: MSG_WAITALL
     Pre-defined integer constants to be used as FLAGS values for
     `socket-send', `socket-sendto', `socket-recv' and
     `socket-recvfrom'.   Some of these constants may not be defined if
     the underlying operating system doesn't provide them.

   Further control over sockets and protocol layers is possible by
getsockopt/setsockopt interface, as described below.

 -- Function: socket-setsockopt socket level option value
 -- Function: socket-getsockopt socket level option rsize
     These are the interface to setsockopt() and getsockopt() calls.
     The interface is a bit clumsy, in order to allow full access to
     those low-level calls.

     SOCKET must be a non-closed socket object.  LEVEL and OPTION is an
     exact integer to specify the level of protocol stack and the
     option you want to deal with.  There are several variables
     pre-bound to system constants listed below.

     To set the socket option, you can pass either an exact integer or
     a string to VALUE.  If it is an integer, the value is passed to
     setsockopt(2) as C `int' value.  If it is a string, the byte
     sequence is passed as is.  The required type of value depends on
     the option, and Gauche can't know if the value you passed is
     expected by setsockopt(2); it is your responsibility to pass the
     correct values.

     To get the socket option, you need to tell the maximum length of
     expected result by RSIZE parameter, for Gauche doesn't know the
     amount of data each option returns.  `socket-getsockopt' returns
     the option value as a byte string.  If you know the option value
     is an integer, you can pass 0 to RSIZE; in that case
     `socket-getsockopt' returns the value as an exact integer.

     Note about the name: I tempted to name these function
     socket-{set|get}opt or socket-{set|get}-option, but I rather took
     the naming consistency.  Hence duplicated "sock"s.


   The following predefined variables are provided.  Note that some of
them are not available on all platforms.  See manpages `socket(7)',
`tcp(7)' or `ip(7)' of your system to find out exact specification of
those values.

   For "level" argument:

 -- Variable: SOL_SOCKET
 -- Variable: SOL_TCP
 -- Variable: SOL_IP
     These variables are bound to `SOL_SOCKET', `SOL_TCP' and `SOL_IP',
     respectively.

   For "option" argument:

 -- Variable: SO_KEEPALIVE
     Expects integer value.  If it is not zero, enables sending  of
     keep-alive messages on connection-oriented sockets.

 -- Variable: SO_OOBINLINE
     Expects integer value.  If it is not zero, out-of-band data is
     directly placed into the receive data stream.  Otherwise
     out-of-band  data  is  only passed when the MSG_OOB flag is set
     during receiving.

 -- Variable: SO_REUSEADDR
     Expects integer value.  If it is not zero, `socket-bind' allows to
     reuse local addresses, unless an active listening socket bound to
     the address.

 -- Variable: SO_TYPE
     Gets the socket type as an integer (like `sock_stream').  Can be
     only used with `socket-getsockopt'.

 -- Variable: SO_BROADCAST
     Expects integer value.  If it is not zero, datagram sockets are
     allowed to send/receive broadcast packets.

 -- Variable: SO_PRIORITY
     Expects integer value, specifying the protocol-defined priority
     for all packets to be sent on this socket.

 -- Variable: SO_ERROR
     Gets and clears the pending socket error as an integer.  Can be
     only used with `socket-getsockopt'.

 -- Function: inet-checksum packet size
     Calculates one's complement of Internet Checksum (RFC1071) of the
     PACKET, which must be given as a uniform vector.  First SIZE bytes
     of PACKET are used for calculation.  Returned value is in network
     byte order (big-endian).  It is an error if SIZE is greater than
     the size of PACKET.

     Note: The used algorithm assumes PACKET is not too big (< 64K).


File: gauche-refe.info,  Node: Netdb interface,  Prev: Low-level socket interface,  Up: Networking

9.13.4 Netdb interface
----------------------

 -- Builtin Class: <sys-hostent>
     A class of objects for network hosts.  Corresponding to `struct
     hostent' in C.  The following slots are available read-only.

      -- Instance Variable of <sys-hostent>: name
          The formal name of the host (string).

      -- Instance Variable of <sys-hostent>: aliases
          A list of alias names of the host (list of strings).

      -- Instance Variable of <sys-hostent>: addresses
          A list of addresses (list of strings).  Only ipv4 address is
          supported currently.  Each address is represented by dotted
          decimal notation.

 -- Function: sys-gethostbyname name
     Looks up a host named NAME.  If found, returns a `<sys-hostent>'
     object.  Otherwise, returns `#f'.
          (let ((host (sys-gethostbyname "www.w3c.org")))
            (list (slot-ref host 'name)
                  (slot-ref host 'aliases)
                  (slot-ref host 'addresses)))
            => ("www.w3.org" ("www.w3c.org") ("18.29.1.34" "18.29.1.35"))

 -- Function: sys-gethostbyaddr addr proto
     Looks up a host that has an address ADDR of protocol PROTO.  ADDR
     is a natural string representation of the address; for ipv4, it is
     a dotted decimal notation.  PROTO is a protocol number; only
     `AF_INET' is supported currently.  If the host is found, returns a
     `<sys-hostent>' object.  Otherwise, returns `#f'.
          (let ((host (sys-gethostbyaddr "127.0.0.1" AF_INET)))
            (list (slot-ref host 'name)
                  (slot-ref host 'aliases)
                  (slot-ref host 'addresses))
            => ("localhost" ("localhost.localdomain") ("127.0.0.1"))

 -- Builtin Class: <sys-servent>
     An entry of the network service database.  Corresponding to
     `struct servent' in C.  The following slots are available
     read-only.

      -- Instance Variable of <sys-servent>: name
          The formal name of the service (string).

      -- Instance Variable of <sys-servent>: aliases
          A list of alias names of the service (list of strings).

      -- Instance Variable of <sys-servent>: port
          A port number registered for this service (exact integer).

      -- Instance Variable of <sys-servent>: proto
          A protocol name for this service (string).

 -- Function: sys-getservbyname name proto
     Looks up the network service database with a service name NAME and
     a protocol PROTO.  Both NAME and PROTO must be a string.  If a
     service is found, an instance of `<sys-servent>' is returned.
     Otherwise, `#f' is returned.
          (let ((serv (sys-getservbyname "http" "tcp")))
            (list (slot-ref serv 'name)
                  (slot-ref serv 'aliases)
                  (slot-ref serv 'port)
                  (slot-ref serv 'proto)))
            => ("http" () 80 "tcp")

 -- Function: sys-getservbyport port proto
     Looks up the network service database with a service port PORT and
     a protocol PROTO.  PORT must be an exact integer, and PROTO must
     be a string.  If a service is found, an instance of
     `<sys-servent>' is returned.  Otherwise, `#f' is returned.
          (let ((serv (sys-getservbyport 6000 "tcp")))
            (list (slot-ref serv 'name)
                  (slot-ref serv 'aliases)
                  (slot-ref serv 'port)
                  (slot-ref serv 'proto)))
            => ("x-server" () 6000 "tcp")

 -- Builtin Class: <sys-protoent>
     An entry of the protocol database.   Corresponds to `struct
     protoent' in C.   The following slots are available read-only.

      -- Instance Variable of <sys-servent>: name
          The formal name of the protocol (string).

      -- Instance Variable of <sys-servent>: aliases
          A list of alias names of the protocol (list of strings).

      -- Instance Variable of <sys-servent>: proto
          A protocol number (exact integer).

 -- Function: sys-getprotobyname name
     Looks up the network protocol database with a name NAME, which
     must be a string.  If a protocol is found, an instance of
     `<sys-protoent>' is returned.  Otherwise, `#f' is returned.
          (let ((proto (sys-getprotobyname "icmp")))
            (list (slot-ref proto 'name)
                  (slot-ref proto 'aliases)
                  (slot-ref proto 'proto)))
            => ("icmp" ("ICMP") 1)

 -- Function: sys-getprotobynumber number
     Looks up the network protocol database with a protocol number
     NUMBER, which must be an exact integer.  If a protocol is found,
     an instance of `<sys-protoent>' is returned.  Otherwise, `#f' is
     returned.
          (let ((proto (sys-getprotobynumber 17)))
            (list (slot-ref proto 'name)
                  (slot-ref proto 'aliases)
                  (slot-ref proto 'proto)))
            => ("udp" ("UDP") 17)

 -- Builtin Class: <sys-addrinfo>
     The new interface to keep address information.  Corresponds to
     `struct addrinfo' in C.  This is only available if gauche is
     configured with -enable-ipv6 option.  The following slots are
     provided.

      -- Instance Variable of <sys-addrinfo>: flags

      -- Instance Variable of <sys-addrinfo>: family

      -- Instance Variable of <sys-addrinfo>: socktype

      -- Instance Variable of <sys-addrinfo>: protocol

      -- Instance Variable of <sys-addrinfo>: addrlen

      -- Instance Variable of <sys-addrinfo>: addr

 -- Function: sys-getaddrinfo nodename servname hints
     Returns `<sys-addrinfo>' instance from the given NODENAME,
     SERVNAME and HINTS.  This is only available if gauche is compiled
     with -enable-ipv6 option.

 -- Function: sys-ntohs integer
 -- Function: sys-ntohl integer
 -- Function: sys-htons integer
 -- Function: sys-htonl integer
     Utility functions to convert 16bit (`s') or 32bit (`l') integers
     between _network_ byte order (`n') and _host_ byte order (`h').

     Scheme API to the netdb interface calls those byte order conversion
     functions internally, so you don't usually need them so much as in
     C programs.  However, it may be useful when you're constructing or
     analyzing binary packets.  See also *note Packing Binary Data:: to
     handle binary data.


File: gauche-refe.info,  Node: Parameters,  Next: Parsing command-line options,  Prev: Networking,  Up: Library modules - Gauche extensions

9.14 `gauche.parameter' - Parameters
====================================

 -- Module: gauche.parameter
     A _parameter_ is something like a stateful procedure that takes
     zero or one argument.  If no argument is given, the parameter
     returns the current value it is keeping.  If single argument is
     given, it will be the current value of the parameter.  A parameter
     has several advantages over global variables to store states.

     Value of parameters are kept for each thread, so you can use a
     parameter as a thread-local storage.  When a new thread is
     created, it inherits a copy of parameters from its creator thread.

     You can give a "filter procedure" that checks the new value before
     setting it as the parameter value, so that you can guarantee the
     value of the parameter is always sane.

     With the macro `parameterize', you can change the parameter's
     value within certain dynamic scope.   It can effectively replace
     dynamically scoped variables.

     You can also register callback procedures to be called whenever
     the value of the parameter is changed.   It can effectively
     replace so-called "traced variables"

     The basic parameter object feature is defined in SRFI-39.  It also
     can be found in other Scheme implementations, including
     ChezScheme, Chicken and MzScheme.  Gauche's one is upper
     compatible to SRFI-39.

 -- Class: <parameter>
     A parameter class.  A `object-apply' method is defined so that a
     parameter can be used as if it were a procedure.

 -- Function: make-parameter value &optional filter
     [SRFI-39] Creates a parameter whose initial value is VALUE.  If an
     optional argument FILTER is given, it must be a procedure that
     takes one argument and returns one value; whenever the parameter's
     value is about to change, the procedure is called with the given
     value, and the value the procedure returns will be the parameter's
     value.  The filter procedure can raise an error or reject to
     change the parameter's value.

 -- Macro: parameterize ((param value) ...) body ...
     [SRFI-39] Evaluages BODY ..., with change parameter PARAM's value
     to the given VALUE within the dynamic scope of BODY ....  Returns
     the value(s) of the result of the last BODY.

   Some examples:
     (define a (make-parameter 1))
     (a) => 1
     (a 2) => 1
     (a) => 2
     (parameterize ((a 3))
       (a)) => 3
     (a) => 2

 -- Method: parameter-observer-add! (p <parameter>) proc &optional when
          where
     Adds PROC to "observer" procedures of a parameter P.  Observer
     procedures are called either (1) just before a new value is set to
     the parameter, or (2) just after the new value is set to the
     parameter.   In case of (1), a filter procedure is already applied
     before a callback is called.  In either case, observer procedures
     are called with two arguments, the old value and the new value.
     The return value(s) of observer procedures are discarded.

     The optional WHEN argument must be either a symbol `before' or
     `after', to specify whether PROC should be called before or after
     the value is changed.   If omitted, `after' is assumed.

     The optional WHERE argument must be either a symbol `append' or
     `prepend', to specify whether PROC should be prepended or appended
     to the existing observer procedure list.  If omitted, `append' is
     assumed.

     _Note_: Although the parameter value itself is thread-local, the
     observer list is shared by all threads.

 -- Method: parameter-observer-delete! (p <parameter>) proc &optional
          when
     Deletes PROC from observer procedure list of a parameter P.  If
     PROC is not in the list, nothing happens.  You can give either a
     symbol `before' or `after' to WHEN argument to specify from which
     list PROC should be deleted.  If WHEN argument is omitted, PROC is
     deleted from both lists.

 -- Method: parameter-pre-observers (p <parameter>)
 -- Method: parameter-post-observers (p <parameter>)
     Returns a hook object (*Note Hooks::) that keeps "before" or
     "after" observers, respectively.

     _Note_: Although the parameter value itself is thread-local, these
     hook objects are shared by all threads.


File: gauche-refe.info,  Node: Parsing command-line options,  Next: High Level Process Interface,  Prev: Parameters,  Up: Library modules - Gauche extensions

9.15 `gauche.parseopt' - Parsing command-line options
=====================================================

 -- Module: gauche.parseopt
     This module defines a convenient way to parse command-line options.
     The interface is hinted by Perl, and conveniently handles
     long-format options with multiple option arguments.

     Actually, you have a few choices to parse command-line options in
     Gauche.  SRFI-37 (*Note A program argument processor::) provides
     functional interface to parse POSIX/GNU compatible argument syntax.
     SLIB has `getopt'-compatible utility.  Required features may
     differ from application to application, so choose whichever fits
     your requirement.

High-level API
--------------

 -- Macro: let-args args (bind-spec ... [. rest]) body ...
     This macro captures the most common pattern of argument processing.
     It takes a list of arguments, ARGS, and scans it to find
     Unix-style command-line options and binds their values to local
     variables according to BIND-SPEC, then executes BODY ....

     Let's look at a simple example first, which gives you a good idea
     of what this form does. (See the "Examples" section below for more
     examples).

          (define (main args)
            (let-args (cdr args)
                ((verbose     "v|verbose")
                 (outfile     "o|outfile=s")
                 (debug-level "d|debug-level=i" 0)
                 (help        "h|help" => (cut show-help (car args)))
                 . restargs
                )
              ....))

          (define (show-help progname)
            ...)

     The local variable VERBOSE will be bound to `#t' if a command-line
     argument `-v' or `--verbose' is given, and to `#f' otherwise.  The
     variable OUTPUT is specified to take one option argument; if the
     command-line arguments are given like `-o out.txt', OUTFILE
     receives `"out.txt"'.  The DEBUG-LEVEL one is similar, but the
     option argument is coerced to an integer, and also it has default
     value 0 when the option isn't given.  The HELP clause invokes an
     action rather than merely binding the value.

     (Note: Currently `let-args' does not distinguish so-called short
     and long options, e.g. `-v' and `--v' have the same effect, so as
     `-verbose' and `--verbose'.  In future we may add an option to
     make it compatible with `getopt_long(3)'.)

     The final RESTARGS variable after the dot receives a list of
     non-optional command-line arguments.

     Let's look at BIND-SPEC in detail.  It must be one of the
     following forms.

          1. (VAR OPTION-SPEC)
          2. (VAR OPTION-SPEC DEFAULT)
          3. (VAR OPTION-SPEC => CALLBACK)
          4. (VAR OPTION-SPEC DEFAULT => CALLBACK)

          5. (else => HANDLER)
          6. (else FORMALS BODY ...)

     A list of command-line arguments passed to ARGS are parsed
     according to OPTION-SPECs.  If the corresponding option is given,
     a variable VAR is bound to a value as follows:

          (a) If the BIND-SPEC is 1. or 2., then
            (a1) If OPTION-SPEC doesn't require an argument, then `#t':
            (a2) If OPTION-SPEC requires one argument, then the value of
                 the argument:
            (a3) If OPTION-SPEC requires more than one argument,
                 the list of the values of the arguments.
          (b) If the BIND-SPEC is 3. or 4., then CALLBACK is called with
            the value(s) of arguments, and its return value.

     We'll explain the details of OPTION-SPEC later.

     As a special case, VAR can be `#f', in which case the value is
     ignored.  It is only useful for side effects in CALLBACK.

     If the corresponding option is not given in ARGS, VAR is bound to
     DEFAULT if it is given, or `#f' otherwise.

     The last BIND-SPEC may be the form 5 or 6. in which case the
     clause is selected when no other OPTION-SPEC matches a given
     command-line option.  In the form 5, HANDLER will be called with
     three arguments; the given option, a list of remaining
     command-line arguments, and a continuation procedure.  The HANDLER
     is supposed to handle the given option, and it may call the
     continuation procedure with the remaining arguments to continue
     processing, or it may return a list of arguments which will be
     treated as non-optional command-line arguments.  The form 6 is a
     shorthand notion of `(else => (lambda FORMALS BODY ...))'.

     The BIND-SPEC list can be an improper list, whose last cdr is a
     symbol.  In which case, a list of the rest of the command-line
     arguments is bound to the variable named by the symbol.

     Note that the DEFAULT, CALLBACK, and forms in `else' clause is
     evaluated outside of the scope of binding of VARs (as the name
     `let-args' implies).

     Unlike typical `getopt' or `getopt_long' implementation in C,
     `let-args' does not permute the given command-line arguments.  It
     stops parsing when it encounters a non-option argument (argument
     without starting with a minus sign).

     If the parser encounters an argument with only two minus signs
     ``--'', it stops argument parsing and returns a list of arguments
     after ``--''.

     After all the bindings is done, BODY ... are evaluated.  BODY may
     began with internal define forms.

Option spec
-----------

OPTION-SPEC is a string that specifies the name of the option and how
the option takes the arguments.  An alphanumeric characters, underscore,
plus and minus sign is allowed for option's names, except that minus
sign can't be the first character, i.e. the valid option name matches a
regexp `#/[\w+][-\w+]*/'.

   If the option takes argument(s), it can be specified by attaching
equal character and a character (or characters) that represents the
type of the argument(s) after the name.  The option can take more than
one arguments.  The following characters are recognized as a type
specifier of the option's argument.

`s'
     String.

`n'
     Number.

`f'
     Real number (coerced to flonum).

`i'
     Exact integer.

`e'
     S-expression.

`y'
     Symbol (argument is converted by `string->symbol').

   Let's see some examples of OPTION-SPEC:

`"NAME"'
     Specifies option NAME, that doesn't take any argument.

`"NAME=s"'
     Option NAME takes one argument, and it is passed as a string.

`"NAME=i"'
     Option NAME takes one argument, and it is passed as an exact
     integer.

`"NAME=ss"'
     Option NAME takes two arguments, both string.

`"NAME=iii"'
     Option NAME takes three integer arguments.

`"NAME=sf"'
     Option NAME takes two arguments, the first is a string and the
     second is a number.

   If the option has alternative names, they can be concatenated by "|".
For example, an option spec `"h|help"' will match both "h" and "help".

   In the command line, the option may appear with preceding single or
double minus signs.  The option's argument may be combined by the
option itself with an equal sign.  For example, all the following
command line arguments match an option spec `"prefix=s"'.
     -prefix /home/shiro
     -prefix=/home/shiro
     --prefix /home/shiro
     --prefix=/home/shiro

Examples
--------

This example is taken from `gauche-install' script.  The MODE option
takes numbers in octal, so it uses the callback procedure to convert it.
See also the `else' clause how to handle unrecognized option.

       (let-args (cdr args)
           ((#f      "c")        ;; ignore for historical reason
            (mkdir   "d|directory")
            (mode    "m|mode=s" #o755 => (cut string->number <> 8))
            (owner   "o|owner=s")
            (group   "g|group=s")
            (srcdir  "S|srcdir=s")
            (target  "T|target=s")
            (utarget "U|uninstall=s")
            (shebang "shebang=s")
            (verb    "v")
            (dry     "n|dry-run")
            (#f      "h|help" => usage)
            (else (opt . _) (print "Unknown option : " opt) (usage))
            . args)
         ...)

   The next example is a small test program to show the usage of `else'
clause.  It gathers all options into the variable R, except that when
it sees `-c' it stops argument processing and binds the rest of the
arguments to RESTARGS.

     (use gauche.parseopt)

     (define (main args)
       (let1 r '()
         (let-args (cdr args)
           ((else (opt rest cont)
              (cond [(equal? opt "c") rest]
                    [else (push! r opt) (cont rest)]))
            . restargs)
          (print "options: " (reverse r))
          (print "restargs: " restargs)
          0)))

   Sample session of the above script (suppose it is saved as
`example').

     $ ./example -a -b -c -d -e foo
     options: (a b)
     restargs: (-d -e foo)
     $ ./example -a -b -d -e foo
     options: (a b d e)
     restargs: (foo)

Low-level API
-------------

The followings are lower-level API used to build `let-args' macro.

 -- Macro: parse-options args (option-clause ...)
     ARGS is an expression that contains a list of command-line
     arguments.  This macro scans the command-line options (an argument
     that begins with ``-'') and processes it as specified in
     OPTION-CLAUSEs, then returns the remaining arguments.

     Each OPTION-CLAUSE is consisted by a pair of OPTION-SPEC and its
     action.

     If a given command-line option matches one of OPTION-SPEC, then
     the associated action is evaluated.  An action can be one of the
     following forms.

    `BIND-SPEC BODY ...'
          BIND-SPEC is a proper or dotted list of variables like
          lambda-list.  The option's arguments are bound to BIND-SPEC,
          then then BODY ... is evaluated.

    `=> PROC'
          If a command-line option matches OPTION-SPEC, calls a
          procedure PROC with a list of the option's arguments.

     If a symbol `else' is at the position of OPTION-SPEC, the clause
     is selected when no other option clause matches a given
     command-line option.  Three "arguments" are associated to the
     clause; the unmatched option, the rest of arguments, and a
     procedure that represents the option parser.


 -- Macro: make-option-parser (option-clause ...)
     This is a lower-level interface.  OPTION-CLAUSEs are the same as
     `parse-options'.  This macro returns a procedure that can be used
     later to parse the command line options.

     The returned procedure takes one required argument and one
     optional argument.  The required argument is a list of strings,
     for given command-line arguments.  The optional argument may be a
     procedure that takes more than three arguments, and if given, the
     procedure is used as if it is the body of `else' option clause.


File: gauche-refe.info,  Node: High Level Process Interface,  Next: Reloading modules,  Prev: Parsing command-line options,  Up: Library modules - Gauche extensions

9.16 `gauche.process' - High Level Process Interface
====================================================

 -- Module: gauche.process
     This module provides a higher-level API of Unix process control,
     implemented on top of low-level system calls such as `sys-fork'
     and `sys-exec'.   This module also provides "process ports", a
     convenient way to send/receive information to/from subprocesses.

* Menu:

* Process object::
* Process ports::


File: gauche-refe.info,  Node: Process object,  Next: Process ports,  Prev: High Level Process Interface,  Up: High Level Process Interface

9.16.1 Process object
---------------------

 -- Class: <process>
     An object to keep the status of a child process.  You can create
     the process object by `run-process' procedure described below.
     The process ports explained in the next section also use process
     objects.

     The `<process>' class keeps track of the child processes spawned
     by high-level APIs such as `run-process' or `open-input-process'.
     The exit status of such children must be collected by
     `process-wait' or `process-wait-any' calls, which also do some
     bookkeeping.   Using the low-level process calls such as
     `sys-wait' or `sys-waitpid' directly will cause inconsistent state.

 -- Class: <process-abnormal-exit>
     A condition type mainly used by the process port utility
     procedures.  Inherits `<error>'.  This type of condition is thrown
     when the high-level process port utilities detect the child proces
     exitted with non-zero status code.

      -- Instance Variable of <process-abnormal-exit>: process
          A process object.

     Note: In Unix terms, exitting a process by calling `exit(2)' or
     returning from `main()' is a normal exit, regardless of the exit
     status.  Some commands do use non-zero exit status to tell one of
     the normal results of execution (such as `grep(1)').  However,
     large number of commands uses non-zero exit status to indicate
     that they couldn't carry out the required operation, so we treat
     them as exceptional situations.

 -- Function: run-process cmd/args &keyword input output error fork
          wait directory host sigmask
     Runs a command with arguments given to CMD/ARGS in a subprocess
     and returns a `<process>' object.  The CMD/ARGS argument must be a
     list, whose car specifies the command name and whose cdr is the
     command-line arguments.

     If the command name contains a slash, it is taken as the pathname
     of the executable.  Otherwise the named command is searched from
     the directories in the `PATH' environment variable.

     Each element in CMD/ARGS are converted to a string by `x->string',
     for the convenience.

     The following keyword arguments are recognized:
    `:input FILE'
    `:output FILE'
    `:error FILE'
          These arguments controls the subprocess' standard i/o.  FILE
          may be either a string or a keyword `:pipe'.  If it is a
          string, the process' standard input, output, or error goes to
          the named file.   If it is `:pipe', the process'
          corresponding standard i/o is connected to a pipe, and the
          other side of the pipe is available for the calling process.

    `:wait FLAG'
          If FLAG is true, `run-process' waits until the subprocess
          terminates.  Othewise the subprocess runs asynchronously and
          `run-process' returns immediately, which is the default
          behavior.  Note that if the subprocess is running
          asynchronously, it is the caller's responsibility to call
          `process-wait' at certain timing to collect its exit status.

    `:fork FLAG'
          If FLAG is true, `run-process' forks to run the subprocess,
          which is the default behavior.  If FLAG is false,
          `run-process' directly calls `sys-exec', so it never returns.

    `:host HOSTSPEC'
          This argument is used to execute COMMAND on the remote host.
          The full syntax of HOSTSPEC is `protocol:user@hostname:port',
          where PROTOCOL:, USER@, or :PORT part can be omitted.  The
          PROTOCOL part specifies the protocol to commnucate with the
          remote host; currently only `ssh' is supported, and it is
          also the default when PROTOCOL is omitted.  The USER part
          specifies the login name of the remote host.  The HOSTNAME
          specifies the remote host name, and the PORT part specifies
          the alternative port number which PROTOCOL connects to.

    `:directory DIRECTORY'
          If a string is given to DIRECTORY, the process is started
          with DIRECTORY as its working directory.  If DIRECTORY is
          `#f', this argument is ignored.  An error is signalled if
          DIRECTORY is other type of objects, or it is a string but is
          not a name of a existing directory.

          When HOST keyword argunmet is also given, this argument
          specifies the working directory of the _remote_ process.

          Note: `run-process' checks the validity of DIRECTORY, but
          actual `chdir(2)' is done just before `exec(2)', and it is
          possible that `chdir' fails in spite of previous checks.  At
          the moment when `chdir' fails, there's no reliable way to
          raise an exception to the caller of `run-process', so it
          writes out an error message to standard error port and exits.
          A robust program may take this case into account.

    `:sigmask MASK'
          MASK must be either an instance of `<sys-sigset>', a list of
          integers, or `#f'.  If an instance of `<sys-sigset>' is
          given, the signal mask of executed process is set to it.   A
          list of integers are treated as a list of signals to mask.
          It is important to set an appropriate mask if you call
          `run-process' from multithreaded application.  See the
          description of `sys-exec' (*note Unix process management::)
          for the details.

          If the HOST keyword argument is specified, this argument
          merely sets the signal mask of the local process (`ssh').

     The following example runs `ls -al' synchronously.

          (run-process '(ls -al) :wait #t)

     Note that `-i' is read as an imaginary number, so be careful to
     pass `-i' as a command-line argument; you should use a string, or
     write `|-i|' to make it a symbol.

          (run-process '(ls "-i") :wait #t)

     Note: Old version of this procedure took arguments differently,
     like `(run-process "ls" "-al" :wait #t)', which was compatible to
     STk.  This is still supported but deprecated.

 -- Function: process? obj
     == `(is-a? OBJ <process>)'

 -- Method: process-pid (process <process>)
     Returns the process ID of the subprocess PROCESS.

 -- Method: process-command (process <process>)
     Returns the command invoked in the subprocess PROCESS.

 -- Method: process-input (process <process>)
 -- Method: process-output (process <process>)
 -- Method: process-error (process <process>)
     If the process' standard input, output or error is connected to a
     pipe, returns another end of the pipe, i.e. `process-input'
     returns an output port that can feed data to PROCESS' stdin,
     `process-output' returns an input port that can read data from
     PROCESS' stdout, and `process-error' returns an input port that
     can read data from `process'' stderr.  If the corresponding i/o is
     not connected to the pipe, the function returns `#f'.

          (let* ((process (run-process '("date") :output :pipe))
                 (line (read-line (process-output process))))
            (process-wait process)
            line)
           => "Fri Jun 22 22:22:22 HST 2001"

 -- Function: process-alive? process
     Returns true if PROCESS is alive.  Note that Gauche can't know the
     subprocess' status until it is explicitly checked by
     `process-wait'.

 -- Function: process-list
     Returns a list of active processes.  The process remains active
     until its exit status is explicitly collected by `process-wait'.
     Once the process's exit status is collected and its state changed
     to inactive, it is removed from the list `process-list' returns.

 -- Function: process-wait process &optional nohang
          error-on-nonzero-status
     Obtains the exit status of the subprocess PROCESS, and stores it
     to PROCESS's status slot.  The status can be obtained by
     `process-exit-status'.

     This suspends execution until PROCESS exits by default.  However,
     if a true value is given to the optional argument NOHANG, it
     returns immediately if PROCESS hasn't exit.

     If a true value is given to the optional argument
     ERROR-ON-NONZERO-STATUS, and the obtained status code is not zero,
     this procedure raises `<process-abnormal-exit>' error.

     Returns `#t' if this call actually obtains the exit status, or
     `#f' otherwise.

 -- Function: process-wait-any &optional nohang
     Obtains the exit status of any of the subprocesses created by
     `run-process'.  Returns a process object whose exit status is
     collected.

     If a true value is given to the optional argument NOHANG, this
     procedure returns `#f 'immediately even if no child process has
     exit.  If NOHANG is omitted or `#f', this procedure waits for any
     of children exits.

     If there's no child processes, this procedure immediately returns
     `#f'.

 -- Function: process-exit-status process
     Returns exit status of PROCESS retrieved by `process-wait'.  If
     this is called before `process-wait' is called on PROCESS, the
     result is undefined.

 -- Function: process-send-signal process signal
     Sends a signal SIGNAL to the subprocess PROCESS.  SIGNAL must be
     an exact integer for signal number.  *Note Signal::, for
     predefined variables of signals.

 -- Function: process-kill process
 -- Function: process-stop process
 -- Function: process-continue process
     Sends SIGKILL, SIGSTOP and SIGCONT to PROCESS, respectively.


File: gauche-refe.info,  Node: Process ports,  Prev: Process object,  Up: High Level Process Interface

9.16.2 Process ports
--------------------

 -- Function: open-input-process-port command &keyword input error
          encoding conversion-buffer-size
     Runs COMMAND asynchronously in a subprocess.  Returns two values,
     an input port which is connected to the stdout of the running
     subprocess, and a process object.

     COMMAND can be a string or a list.

     If it is a string, it is passed to `/bin/sh'.  You can use shell
     metacharacters in this form, such as environment variable
     interpolation, globbing, and redirections.  If you create the
     command line by concatenating strings, it's your responsibility to
     ensure escaping special characters if you don't want the shell to
     interpret them.  The `shell-escape-string' function described
     below might be a help.

     If COMMAND is a list, each element is converted to a string by
     `x->string' and then passed directly to `sys-exec' (the `car' of
     the list is used as both the command path and the first element of
     argv, i.e. `argv[0]').  Use this form if you want to avoid the
     shell from interfering; i.e. you don't need to escape special
     characters.

     The subprocess's stdin is redirected from `/dev/null', and its
     stderr shares the calling process's stderr by default.  You can
     change these by giving file pathnames to INPUT and ERROR keyword
     arguments, respectively.

     You can also give the ENCODING keyword argument to specify
     character encoding of the process output.  If it differs from the
     Gauche's internal encoding format, `open-input-process-port'
     inserts a character encoding conversion port.  If ENCODING is
     given, the CONVERSION-BUFFER-SIZE keyword argument can control the
     conversion buffer size.  See *note Character code conversion::, for
     the details of character encoding conversions.
          (receive (port process) (open-input-process-port "ls -l Makefile")
            (begin0 (read-line port)
                    (process-wait process)))
           => "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

          (receive (port process) (open-input-process-port '(ls -l "Makefile"))
            (begin0 (read-line port)
                    (process-wait process)))
           => "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

          (open-input-process-port "command 2>&1")
           => ;the port reads both stdout and stderr

          (open-input-process-port "command 2>&1 1>/dev/null")
           => ;the port reads stderr
     The exit status of subprocess is not automatically collected.  It
     is the caller's responsibility to issue `process-wait', or the
     subprocess remains in a zombie state.  If it bothers you, you can
     use one of the following functions.

 -- Function: call-with-input-process command proc &keyword input error
          encoding conversion-buffer-size on-abnormal-exit
     Runs COMMAND in a subprocess and pipes its stdout to an input
     port, then call PROC with the port as an argument.  When PROC
     returns, it collects its exit status, then returns the result PROC
     returned.  The cleanup is done even if PROC raises an error.

     The keyword argument ON-ABNORMAL-EXIT specifies what happens when
     the child process exits with non-zero status code.  It can be
     either `:error' (default), `:ignore', or a procedure that takes
     one argument.  If it is `:error', a `<process-abnormal-exit>'
     error condition is thrown by non-zero exit status; the `process'
     slot of the condition holds the process object.  If it is
     `:ignore', nothing is done for non-zero exit status.  If it is a
     procedure, it is called with a process object; when the procedure
     returns, `call-with-input-process' returns normally.

     The semantics of COMMAND and other keyword arguments are the same
     as `open-input-process-port' above.
          (call-with-input-process "ls -l *"
            (lambda (p) (read-line p)))

 -- Function: with-input-from-process command thunk &keyword input
          error encoding conversion-buffer-size on-abnormal-exit
     Runs COMMAND in a subprocess, and calls THUNK with its current
     input port connected to the command's stdout.  The command is
     terminated and its exit status is collected, after THUNK returns
     or raises an error.

     The semantics of COMMAND and keyword arguments are the same as
     `call-with-input-process' above.
          (with-input-from-process "ls -l *" read-line)

 -- Function: open-output-process-port command &keyword output error
          encoding conversion-buffer-size
     Runs `command' in a subprocess asynchronously.  Returns two values,
     an output port which is connected to the stdin of the subprocess.
     and the process object.

     The semantics of COMMAND is the same as `open-input-process-port'.
     The semantics of ENCODING and CONVERSION-BUFFER-SIZE are also the
     same.

     The subprocess's stdout is redirected to `/dev/null' by default,
     and its stderr shares the calling process's stderr.  You can
     change these by giving file pathnames to OUTPUT and ERROR keyword
     arguments, respectively.

     The exit status of the subprocess is not automatically collected.
     The caller should call `process-wait' on the subprocess at
     appropriate time.

 -- Function: call-with-output-process command proc &keyword output
          error encoding conversion-buffer-size on-abnormal-exit
     Runs `command' in a subprocess, and calls PROC with an output port
     which is connected to the stdin of the command.  The exit status
     of the command is collected after either PROC returns or raises an
     error.

     The semantics of keyword arguments are the same as
     `open-output-process-port', except ON-ABNORMAL-EXIT, which is the
     same as described in `call-with-input-process'.
          (call-with-output-process "/usr/sbin/sendmail"
            (lambda (out) (display mail-body out)))

 -- Function: with-output-to-process command thunk &keyword output
          error encoding conversion-buffer-size on-abnormal-exit
     Same as `call-with-output-process', except that the output port
     which is connected to the stdin of the command is set to the
     current output port while executing THUNK.

 -- Function: call-with-process-io command proc &keyword error encoding
          conversion-buffer-size on-abnormal-exit
     Runs COMMAND in a subprocess, and calls PROC with two arguments;
     the first argument is an input port which is connected to the
     command's stdout, and the second is an output port connected to
     the command's stdin.  The error output from the command is shared
     by the calling process's, unless an alternative pathname is given
     to the ERROR keyword argument.

     The exit status of the command is collected when PROC returns or
     raises an error.

 -- Function: process-output->string command &keyword error encoding
          conversion-buffer-size on-abnormal-exit
 -- Function: process-output->string-list command &keyword error
          encoding conversion-buffer-size on-abnormal-exit
     Runs COMMAND and collects its output (to stdout) and returns them.
     `process-output->string' concatenates all the output from COMMAND
     to one string, replacing any sequence of whitespace characters to
     single space.   The action is similar to "command substitution" in
     shell scripts.  `process-output->string-list' collects the output
     from COMMAND line-by-line and returns the list of them.  Newline
     characters are stripped.

     Internally, COMMAND is run by `call-with-input-process', to which
     keyword arguments are passed.
          (process-output->string '(uname -smp))
            => "Linux i686 unknown"

          (process-output->string '(ls))
            => "a.out foo.c foo.c~ foo.o"

          (process-output->string-list '(ls))
            => ("a.out" "foo.c" "foo.c~" "foo.o")


 -- Function: shell-escape-string arg
     If ARG contains characters that affects shell's command-line
     argument parsing, escape ARG to avoid shell's interpretation.
     Otherwise, returns ARG itself.

     Use this procedure when you need to build a command-line string by
     yourself.  (If you pass a command-line argument list, instead of a
     single command-line string, you don't need to escape them since we
     bypass the shell.)

     On Windows native build, this procedure is compatible to the
     argument parsing convention of Windows standard C runtime.


File: gauche-refe.info,  Node: Reloading modules,  Next: Simple dispatcher,  Prev: High Level Process Interface,  Up: Library modules - Gauche extensions

9.17 `gauche.reload' - Reloading modules
========================================

 -- Module: gauche.reload
     In the development cycle, you often have to reload modules
     frequently.  This module supports it.

     Note that some part of semantics of the program depends on the
     order of loading modules, so reloading arbitrary modules may
     change the program behavior unexpectedly.  This module is for
     developers who knows what they are doing.

     *Redefinition rules*: Reloading a module resets all the binding in
     the module by default.  Sometimes it is not desirable, however.
     For example, you might want to keep an intermediate results in
     some variable.  You can specify rules for the reloading procedure
     to determine which binding to keep.

     The rule is described in the following syntax.
            <module-rules> : (<module-rule> ...)
            <module-rule>  : (<module-pattern> <rule> ...)
            <module-pattern> : a symbol module name, or a symbol containing glob pattern
            <rule>         : procedure | symbol | regexp
                           | (and <rule> ...)
                           | (or  <rule> ...)
                           | (not <rule>)

     `<module-rules>' is the global rule to determine per-module rules.
     `<module-pattern>' is either a symbol module name or a symbol that
     contains glob pattern (e.g. `mylib.*').  If `<rule>' is a
     procedure, it is used as a predicate and the bindings whose value
     satisfies the predicate are kept from redefinition.   If `<rule>'
     is a symbol, the binding of the variable whose name is the symbol
     is kept.  If `<rule>' is a regexp, the bindings of the variable
     whose name matches the regexp are kept.

     Note that the mechanism to prevent redefinition is kind of ad-hoc
     hack and semantically unclean.  Especially, the right-hand
     expressions of `define's are still evaluated, so any side effects
     they have will be in effect (e.g. `define-class' would still
     redefine a class).  It's just for your convenience.  Take a look
     at the code if you want to know the exact behavior.

 -- Function: reload module-name &optional rule ...
     Reloads the specified module.   You can optionally specify
     redefinition rules by RULE ..., where each RULE is the term
     `<rule>' defined above.

 -- Function: reload-modified-modules &optional module-rules
     Reloads module(s) that have been modified since they are loaded
     last time.  If optional MODULE-RULES is given, it is used to
     determine the redefinition rules for reloaded modules.  If
     MODULE-RULES is omitted, the current rules are used.  The default
     of current rules is empty.   You can set the current rules by
     `module-reload-rules'.

 -- Function: module-reload-rules &optional module-rules
     This is a parameter (*Note Parameters::) that keeps the default
     module rules for `reload-modified-modules'.  If called without
     arguments, returns the current module rules.  If called with
     MODULE-RULES, sets the argument to the current module rules.

 -- Function: reload-verbose &optional flag
     This is a parameter to control verbosity of the reloading
     procedures.  If called without arguments, returns the current
     verbosity flag.  If called with FLAG, it is set to the current
     verbosity flag.


File: gauche-refe.info,  Node: Simple dispatcher,  Next: Sequence framework,  Prev: Reloading modules,  Up: Library modules - Gauche extensions

9.18 `gauche.selector' - Simple dispatcher
==========================================

 -- Module: gauche.selector
     This module provides a simple interface to dispatch I/O events to
     registered handlers, based on `sys-select' (*Note I/O
     multiplexing::).

 -- Class: <selector>
     A dispatcher instance that keeps watching I/O ports with associated
     handlers.  A new instance can be created by `make' method.

 -- Method: selector-add! (self <selector>) port-or-fd proc flags
     Add a handler PROC to the selector.  PROC is called when
     PORT-OR-FD, which should be a port object or an integer that
     specifies a system file descriptor,  meets a certain condition
     specified by FLAGS.  FLAGS must be a list of one or more of the
     following symbols.
    `r'
          Calls PROC when data is available at PORT-OR-FD to read.

    `w'
          Calls PROC when PORT-OR-FD is ready to be written.

    `x'
          Calls PROC when an exceptional condition occurs on PORT-OR-FD.

     PROC is called with two arguments.  The first one is PORT-OR-FD
     itself, and the second one is a symbol `r', `w' or `x', indicating
     the condition.

     If a handler is already associated with PORT-OR-FD under the same
     condition, the previous handler is replaced by PROC.

 -- Method: selector-delete! (self <selector>) port-or-fd proc flags
     Deletes the handler entries that matches PORT-OR-FD, PROC and
     FLAGS.   One or more of the arguments may be `#f', meaning "don't
     care".  For example,
          (selector-delete! selector the-port #f #f)
     deletes all the handlers associated to THE-PORT, and
          (selector-delete! selector #f #f '(w))
     deletes all the handlers waiting for writable condition.

 -- Method: selector-select (self <selector>) &optional (timeout #f)
     Dispatcher body.  Waits for the conditions registered in SELF, and
     when it occurs, calls the associated handler.  If the TIMEOUT
     argument is omitted or false, this method waits indefinitely.
     Alternatively you can give a timeout value, that can be a real
     number in microseconds, or a list of two integers that represents
     seconds and microseconds.

     Returns the number of handlers called.  Zero means the selector
     has been timed out.

     It is safe to modify SELF inside handler.  The change will be
     effective from the next call of `selector-select'

   This is a simple example of "echo" server:

     (use gauche.net)
     (use gauche.selector)

     (define (echo-server port)
       (let ((selector (make <selector>))
             (server   (make-server-socket 'inet port :reuse-addr? #t)))

         (define (accept-handler sock flag)
           (let* ((client (socket-accept server))
                  (output (socket-output-port client)))
             (selector-add! selector
                            (socket-input-port client :buffering #f)
                            (lambda (input flag)
                              (echo client input output))
                            '(r))))

         (define (echo client input output)
           (let ((str (read-block 4096 input)))
             (if (eof-object? str)
                 (begin (selector-delete! selector input #f #f)
                        (socket-close client))
                 (begin (display str output)
                        (flush output)))))

         (selector-add! selector
                        (socket-fd server)
                        accept-handler
                        '(r))
         (do () (#f) (selector-select selector))))


File: gauche-refe.info,  Node: Sequence framework,  Next: Syslog,  Prev: Simple dispatcher,  Up: Library modules - Gauche extensions

9.19 `gauche.sequence' - Sequence framework
===========================================

 -- Module: gauche.sequence
     Provides a generic operations on _sequences_.  A sequence is a
     collection with ordered elements.  Besides all the operations
     applicable on collections, you can associate integer index to each
     element, and apply order-aware operations on the elements.

     This module inherits `gauche.collection' (*Note Collection
     framework::).  All the collection generic operations can be
     applied to a sequence as well.

     Among Gauche builtin class, lists, vectors and strings are
     sequences and the specialized methods are defined for them.
     Other extension types, such as SRFI-4 uniform vector, have the
     methods as well.

* Menu:

* Fundamental sequence accessors::
* Slicing sequence::
* Mapping over sequences::
* Other operations over sequences::
* Implementing sequence::


File: gauche-refe.info,  Node: Fundamental sequence accessors,  Next: Slicing sequence,  Prev: Sequence framework,  Up: Sequence framework

9.19.1 Fundamental sequence accessors
-------------------------------------

 -- Method: ref (seq <sequence>) index &optional fallback
     Returns INDEX-th element of the sequence SEQ.  This method enables
     uniform access for any sequence types.

     When INDEX is less than zero, or greater than or equal to the size
     of the sequence, FALLBACK is returned if provided, or an error is
     signalled if not.

          (ref '(a b c) 1)  => b
          (ref '#(a b c) 1) => b
          (ref "abc" 1)     => #\b

 -- Method: (setter ref) (seq <sequence>) index value
     Sets VALUE to the INDEX-th element of the sequence SEQ.  This is
     the uniform sequence modifier.

     Note: Some sequences may not support arbitrary modification by
     index.  For example, if you have a sequence representing a set of
     sorted integers, you cannot modify I-th element with arbitrary
     value.  Yet such sequence may provide other means of modification,
     such as inserting or deleting elements.

          (let ((x (list 'a 'b 'c)))
            (set! (ref x 1) 'z)
            x) => (a z c)

          (let ((x (vector 'a 'b 'c)))
            (set! (ref x 1) 'z)
            x) => #(a z c)

          (let ((x (string #\a #\b #\c)))
            (set! (ref x 1) #\z)
            x) => "azc"

 -- Method: referencer (seq <sequence>)

 -- Method: modifier (seq <sequence>)


File: gauche-refe.info,  Node: Slicing sequence,  Next: Mapping over sequences,  Prev: Fundamental sequence accessors,  Up: Sequence framework

9.19.2 Slicing sequence
-----------------------

 -- Method: subseq (seq <sequence>) &optional start end
     Retrieve a subsequence of the sequence SEQ, from START-th element
     (inclusive) to END-th element (exclusive).  If END is omitted, up
     to the end of sequence is taken.  The type of the returned
     sequence is the same as SEQ.

          (subseq '(a b c d e) 1 4)   => (b c d)
          (subseq '#(a b c d e) 1 4)  => #(b c d)
          (subseq "abcde" 1 4)        => "bcd"

          (subseq '(a b c d e) 3)     => (d e)

 -- Method: (setter subseq) (seq <sequence>) start end value-seq
 -- Method: (setter subseq) (seq <sequence>) start value-seq
     Sets the elements of VALUE-SEQ from the START-th element
     (inclusive) to the END-th element (exclusive) of the sequence SEQ.
     VALUE-SEQ can be any sequence, but its size must be larger than
     (END - START).

     In the second form, END is figured out by the length of VALUE-SEQ.

          (define s (vector 'a 'b 'c 'd 'e))
          (set! (subseq s 1 4) '(4 5 6))
          s => #(a 4 5 6 e)
          (set! (subseq s 0)   "ab")
          s => #(#\a #\b 5 6 e)


File: gauche-refe.info,  Node: Mapping over sequences,  Next: Other operations over sequences,  Prev: Slicing sequence,  Up: Sequence framework

9.19.3 Mapping over sequences
-----------------------------

You can use extended `fold', `map', `for-each' and other generic
functions on sequences, since a sequence is also a collection.
However, sometimes you want to have index as well as the element itself
during iteration.   There are several generic functions for it.

 -- Method: fold-with-index kons knil (seq <sequence>) ...
     Like generic `fold', except KONS is given the index within SEQ, as
     the first argument, as well as each element from SEQs and the
     accrued value.

          (fold-with-index acons '() '(a b c))
            => ((2 . c) (1 . b) (0 . a))

 -- Method: map-with-index proc (seq <sequence>) ...
 -- Method: map-to-with-index class proc (seq <sequence>) ...
 -- Method: for-each-with-index proc (seq <sequence>) ...
     Like `map', `map-to' and `for-each', except PROC receives the
     index as the first argument.

          (map-with-index list '(a b c d) '(e f g h))
            => ((0 a e) (1 b f) (2 c g) (3 d h))

          (map-to-with-index <vector> cons '(a b c d))
            => #((0 . a) (1 . b) (2 . c) (3 . d))

 -- Method: find-with-index pred (seq <sequence>)
     Finds the first element in SEQ that satisfies PRED like `find',
     but returns two values, the index of the element and the element
     itself.   If no element satisfies PRED, two `#f''s are returned.

          (find-with-index char-upper-case? "abraCadabra")
            => 4 and #\C

          (find-with-index char-numeric? "abraCadabra")
            => #f and #f

 -- Method: find-index pred (seq <sequence>)
     Like `find', but returns the index of the first element that
     satisfies PRED in SEQ, instead of the element itself.  If no
     element in SEQ satisfies PRED, `#f' is returned.

          (find-index char-upper-case? "abraCadabra")
            => 4

          (find-index char-numeric? "abraCadabra")
            => #f

     See also `list-index' in SRFI-1 (*Note SRFI-1 Searching::).

 -- Method: fold-right kons knil (seq <sequence>) ...
     Generalization of `fold-right' on lists.  Like `fold', this method
     applies a higher-order function KONS over given sequence(s),
     passing the "seed" value whose default is KNIL.  The difference
     between `fold' and `fold-right' is the associative order of
     elements on which KONS is applied.

     When we have one sequence, `[E0, E1, ..., En]', `fold' and
     `fold-right' work as follows, respectively.

          fold:
            (kons En (kons En-1 (kons ... (kons E1 (kons E1 knil)) ...)))

          fold-right
            (kons E0 (kons E1 (kons ... (kons En-1 (kons En knil)) ...)))

     This method isn't defined on `<collection>', since collections
     don't care the order of elements.


File: gauche-refe.info,  Node: Other operations over sequences,  Next: Implementing sequence,  Prev: Mapping over sequences,  Up: Sequence framework

9.19.4 Other operations over sequences
--------------------------------------

Selection and searching
.......................

Note that selection and searching methods for collections can also be
applied to sequences.  See *note Selection and searching in
collection::.

Grouping
........

 -- Generic function: group-sequence seq &keyword key test
     Groups consecutive elements in a sequence SEQ which have the
     common key value.  A key value of an element is obtained by
     applying the procedure KEY to the element; the default procedure
     is `identity'.  For each element in SEQ, KEY is applied exactly
     once.  The equal-ness of keys are compared by TEST procedure,
     whose default is `eqv?'.

          (group-sequence '(1 1 1 2 3 4 4 2 2 3 1 1 3))
            => ((1 1 1) (2) (3) (4 4) (2 2) (3) (1 1) (3))

          (group-sequence '(1 1 1 2 3 4 4 2 2 3 1 1 3)
                          :key (cut modulo <> 2)))
            => ((1 1 1) (2) (3) (4 4 2 2) (3 1 1 3))

          (group-sequence '#("a" "a" "b" "b" "c" "d" "d")
                          :test string=?)
            => (("a" "a") ("b" "b") ("c") ("d" "d"))

          (group-sequence "aabbcdd"
                          :test char=?)
            => ((#\a #\a) (#\b #\b) (#\c) (#\d #\d))

     This method is similar to Haskell's `group'.  If you want to group
     elements that are not adjacent, use `group-collection' (*Note
     Selection and searching in collection::).

Permutation and shuffling
.........................

 -- Generic function: permute (src <sequence>) (permuter <sequence>)
          &optional fallback
     Returns a newly created sequence of the same type as SRC, in which
     the elements are permuted from SRC according to PERMUTER.

     PERMUTER is a sequence of exact integers.  When the K-th element
     of PERMUTER is I, the K-th element of the result is `(ref SRC I)'.
      Therefore, the size of the result sequence is the same as the
     size of PERMUTER.  PERMUTER can be any kind of sequence, unrelated
     to the type of SRC.

     It is allowed that the same index I can appear more than once in
     PERMUTER.

          (permute '(a b c d) '(3 2 0 1))     => (d c a b)
          (permute '(a b c d) '(0 2))         => (a c)
          (permute '(a b c d) '(0 0 1 1 2 2)) => (a a b b c c)

     If an integer in PERMUTER is out of the valid range as the index
     of SRC, then an error is signalled unless FALLBACK is given.  If
     FALLBACK is given, what value is used depends on the result of
     `(ref SRC I FALLBACK)'--which usually returns FALLBACK for the
     out-of-range index I.

          (permute '#(a b c) '(3 2 1 0) 'foo) => #(foo c b a)

          (permute "!,HWdelor" #(2 5 6 6 7 1 -1 3 7 8 6 4 0) #\space)
            => "Hello, World!"

 -- Generic function: permute-to (class <class>) (src <sequence>)
          (permuter <sequence>) &optional fallback
     Like `permute', but the result will be an instance of the given
     CLASS instead of the class of SRC.

          (permute-to <string> '(#\a #\b #\c #\d #\r)
                      '(0 1 4 0 2 0 3 0 1 4 0))
            => "abracadabra"

 -- Generic function: permute! (src <sequence>) (permuter <sequence>)
          &optional fallback
     Also like `permute', but the result is stored back to SRC.  SRC
     must be a mutable sequence, and the length of SRC and PERMUTER
     must be the same.

 -- Generic function: shuffle (src <sequence>) &optional random-source
     Returns a new sequence of the same type and size as SRC, in which
     elements are randomly permuted.

          (shuffle '(a b c d e))  => (e b d c a)
          (shuffle "abcde")       => "bacde"

     This generic function uses `srfi-27' (*Note Sources of random
     bits::).  By default it uses `default-random-source', but you can
     pass an alternative random source by the optional argument.

 -- Generic function: shuffle-to (class <class>) (src <sequence>)
          &optional random-source
     Like `shuffle', except that the result will be an instance of
     CLASS instead of the class of SRC.

 -- Generic function: shuffle! (src <sequence>) &optional random-source
     Like `shuffle', but the result is stored back to SRC.  SRC must be
     a mutable sequence.


File: gauche-refe.info,  Node: Implementing sequence,  Prev: Other operations over sequences,  Up: Sequence framework

9.19.5 Implementing sequence
----------------------------


File: gauche-refe.info,  Node: Syslog,  Next: Termios,  Prev: Sequence framework,  Up: Library modules - Gauche extensions

9.20 `gauche.syslog' - Syslog
=============================

 -- Module: gauche.syslog
     This module provides syslog(3) system logger interface.

     For the common applications, you might find `gauche.logger' module
     easier to use (*Note User-level logging::).  This module is for
     those who need direct access to the syslog API.

     The procedures are only defined if the undelying system supports
     them.

 -- Function: sys-openlog ident option facility
     [POSIX] Opens a connection to the system logger.  A string argument
     IDENT is used for the prefix of the log, and usually is the
     program name.  OPTION is an integer flag to control the behavior
     of logging, and FACILITY is an integer that specify the type of
     the program.

     The flag for OPTION can be composed by `logior'-ing one or more of
     the following integer constants: `LOG_CONS', `LOG_NDELAY',
     `LOG_NOWAIT', `LOG_ODELAY', `LOG_PERROR' and `LOG_PID'.  (Some of
     the constants may not be defined if the underlying system doesn't
     support them).

     The FACILITY argument can be one of the following integer
     constants: `LOG_AUTH', `LOG_AUTHPRIV', `LOG_CRON', `LOG_DAEMON',
     `LOG_FTP', `LOG_KERN', `LOG_LOCAL0' through `LOG_LOCAL7',
     `LOG_LPR', `LOG_MAIL', `LOG_NEWS', `LOG_SYSLOG', `LOG_USER' and
     `LOG_UUCP'.  (Some of the constants may not be defined if the
     underlying system doesn't support them).

     See your system's manpage of openlog(3) for detail description
     about these constants.  Log the string MESSAGE.  Unlike syslog(3),
     this procedure doesn't do formatting--you can use `format' (*Note
     Output::) to create a formatted message, or use higher-level
     routine `log-format' (*Note User-level logging::).

     An integer argument PRIORITY can be composed by `logior'-ing one
     of the FACILITY constants described above and the LEVEL constants:
     `LOG_EMERG', `LOG_ALERT', `LOG_CRIT', `LOG_ERR', `LOG_WARNING',
     `LOG_NOTICE', `LOG_INFO', `LOG_DEBUG'.


 -- Function: sys-closelog
     [POSIX] Closes the connection to the logging system.

 -- Function: sys-setlogmask mask
     [POSIX] Sets the process's log priority mask that determines which
     calls to `sys-syslog' may be logged.  An priority MASK can be
     composed by `logior'-ing bitmasks corresponding to the LEVEL
     argument of `sys-syslog'.  You can use `sys-logmask' below to
     obtain a bitmask from the level.

 -- Function: sys-logmask level
     [POSIX] Returns an integer bitmask for `sys-setlogmask' from the
     log level LEVEL.


File: gauche-refe.info,  Node: Termios,  Next: Unit testing,  Prev: Syslog,  Up: Library modules - Gauche extensions

9.21 `gauche.termios' - Termios
===============================

 -- Module: gauche.termios
     This module defines POSIX termios interface, which controls
     terminal attributes.  This module also provides pseudo tty
     interface, if the system provides it.

 -- Builtin Class: <sys-termios>
     POSIX termios(7) structure.

      -- Instance Variable of <sys-termios>: iflag

      -- Instance Variable of <sys-termios>: oflag

      -- Instance Variable of <sys-termios>: cflag

      -- Instance Variable of <sys-termios>: lflag

      -- Instance Variable of <sys-termios>: cc

     The slots `iflag', `oflag', `cflag' and `lflag' contains
     non-negative integers representing bitmasks.

     The slot `cc' contains a _copy_ of `c_cc' array of `struct
     termios', as an u8vector (see *note Uniform vectors:: for the
     details about u8vector).  Since `cc' slot is a copy of the
     internal structure, you have to `set!' an u8vector to the slot
     explicitly to make changes to the `c_cc' array.


   Throughout this section, argument PORT-OR-FD refers to either a port
object or a small integer representing system's file descriptor.  If
PORT is not associated to the system terminal, an error is signalled.
(You can check if PORT has an associated terminal by `sys-isatty?'.
*Note Other file operations::).

 -- Function: sys-tcgetattr port-or-fd
     Returns terminal parameters in a `<sys-termios>' object,
     associated to PORT-OR-FD.

 -- Function: sys-tcsetattr port-or-fd when termios
     Sets terminal parameters associated to PORT-OR-FD by TERMIOS,
     which must be an instance of `<sys-termios>'.

     An integer argument WHEN specifies when the changes take effect.
     Three variables are pre-defined for the argument:
    `TCSANOW'
          The change is reflected immediately.

    `TCSADRAIN'
          The change is reflected after all pending output is flushed.

    `TCSAFLUSH'
          The change is reflected after all pending output is flushed,
          and all pending input is discarded.

 -- Function: sys-tcsendbreak port-or-fd duration
     Transmits a zero stream for the specified duration to the terminal
     associated to PORT-OR-FD.  The unit of duration depends on the
     system; see man tcsendbreak(3) of your system for details.

 -- Function: sys-tcdrain port-or-fd
     Waits until all output written to PORT-OR-FD is transmitted.

 -- Function: sys-tcflush port-or-fd queue
     Discards data in the buffer of PORT-OR-FD, specified by QUEUE,
     which may be one of the following values.
    `TCIFLUSH'
          Discards data received but not read.

    `TCOFLUSH'
          Discards data written but not transmitted.

    `TCIOFLUSH'
          Do both `TCIFLUSH' and `TCOFLUSH' action.

 -- Function: sys-tcflow port-or-fd action
     Controls data flow of PORT-OR-FD by ACTION, which may be one of
     the following values:
    `TCOOFF'
          Suspends output transmission.

    `TCOON'
          Restarts output transmission.

    `TCIOFF'
          Transmits a STOP character to make the terminal device stop
          transmitting data to the system.

    `TCION'
          Transmits a START character to make the terminal device
          resume transmitting data to the system.

 -- Function: sys-tcgetpgrp port-or-fd
     Returns process group ID of the terminal associated to PORT-OR-FD.

 -- Function: sys-tcsetpgrp port-or-fd pgrp
     Sets process group ID of the terminal associated to PORT-OR-FD to
     PGRP.

 -- Function: sys-cfgetispeed termios
 -- Function: sys-cfsetispeed termios speed
 -- Function: sys-cfgetospeed termios
 -- Function: sys-cfsetospeed termios speed
     Gets/sets input/output speed (baud rate) parameter stored in
     TERMIOS object.   Speed is represented by the following predefined
     numbers: `B0', `B50', `B75', `B110', `B134', `B150', `B200',
     `B300', `B600', `B1200', `B1800', `B2400', `B4800', `B9600',
     `B19200', `B38400'.

     Some system may support higher baud rate, such as `B57600',
     `B115200' or `B230400'.  You can use `symbol-bound?' to check
     these options are defined.  `B0' is used to terminate the
     connection.

 -- Function: sys-openpty &optional term
     Opens a pair of pseudo ttys, one for master and the other for
     slave, then returns two integers which are their file descriptors.
     An optional argument TERM must be, if passed, a `<sys-termios>'
     object; it sets the slave pty's parameters.

     You can use `open-input-fd-port' and/or `open-output-fd-port' to
     create a port around the returned file descriptor (*Note File
     ports::).  To obtain pseudo tty's name, use `sys-ttyname' (*Note
     Other file operations::).

     This function is available only if the system supports
     `openpty(3)'.

 -- Function: sys-forkpty &optional term
     Opens a pair of pseudo ttys, one for master and the other for
     slave, sets the slave pty suitable for login terminal, then
     fork(2).

     Returns two integers; the first value is a child pid for the
     parent process, and 0 for the child process.  The second value is
     a file descriptor of the master pty.

     An optional argument TERM must be, if passed, a `<sys-termios>'
     object; it sets the slave pty's parameters.

     This function is available only if the system supports
     `forkpty(3)'.

     Note: `sys-forkpty' has the same MT hazard as `sys-fork' (see
     *note Unix process management::, for details).  If you're running
     multiple threads, use `sys-forkpty-and-exec' below.

 -- Function: sys-forkpty-and-exec command args &keyword iomap term
          sigmask
     Does `sys-forkpty', and lets the child process immediately `exec's
     the specified COMMAND with arguments ARGS.   This function doesn't
     have the hazard in multi-thread environment.

     The meanings of arguments COMMAND, ARGS, IOMAP and SIGMASK are the
     same as `sys-exec' (see *note Unix process management::).  If the
     keyword argument TERM is given, it is used to initialize the slave
     pty.

   The following example shows how to get a password from the user
without echoing:

     (use gauche.termios)

     (define (get-password prompt)
       (let* ((port (current-input-port))
              (attr (sys-tcgetattr port))
              (lflag (slot-ref attr 'lflag)))
         ;; Show prompt
         (display prompt)
         (flush)
         ;; Turn off echo during reading.
         (dynamic-wind
          (lambda ()
            (slot-set! attr 'lflag (logand lflag (lognot ECHO)))
            (sys-tcsetattr port TCSAFLUSH attr))
          (lambda ()
            (read-line port))
          (lambda ()
            (slot-set! attr 'lflag lflag)
            (sys-tcsetattr port TCSANOW attr)))))


File: gauche-refe.info,  Node: Unit testing,  Next: Threads,  Prev: Termios,  Up: Library modules - Gauche extensions

9.22 `gauche.test' - Unit Testing
=================================

 -- Module: gauche.test
     Defines a set of functions to write test scripts.  A test script
     will look like this:
          (use gauche.test)
          (test-start "my feature")
          (load "my-feature")  ; load your program
          (import my-feature)  ; if your program defines a module.

          (test-module 'my-feature) ; tests consistency in your module.

          (test-section "feature group 1")
          (test "feature 1-1" EXPECT (lambda () TEST-BODY))
          (test "feature 1-2" EXPECT (lambda () TEST-BODY))
           ...

          (test-section "feature group 2")
          (define test-data ...)
          (test "feature 2-1" EXPECT (lambda () TEST-BODY))
          (test "feature 2-2" *test-error* (lambda () TEST-THAT-SIGNALS-ERROR))
           ...

          (test-end)

     With this convention, you can run test both interactively or in
     batch.   To run a test interactively, just load the file and it
     reports a result of each test, as well as the summary of failed
     test at the end.  To run a test in batch, it is convenient to
     redirect the stdout to some file If stdout is redirected to other
     than tty, all the verbose logs will go there, and only a small
     amount of messages go to stderr.

     It is recommended to have a "test" target always in Makefile of
     your module/program, so that the user of your program can run a
     test easily.  The rule may look like this:

          test :
                  gosh my-feature-test.scm > test.log


 -- Function: test name expected thunk &optional compare
     Calls THUNK, and compares its result with EXPECTED.  The
     comparison predicate is `equal?' by default, but you can specify
     your own predicate by the argument COMPARE.  NAME is a name of the
     test, for logging purpose.

     If THUNK signals an uncaptured error, it is catched and yields a
     special error object.  A global variable `*test-error*' is bound
     to the error object, so that you can test an expected error.

     The procedure COMPARE is called as follows:
          (COMPARE EXPECTED RESULT-OF-THUNK)
     It should return `#t' if the given result agrees the expected
     value, or `#f' otherwise.  One typical usage of the custom
     comparison method is to compare inexact numbers tolerating small
     error.

          (test "test 1" (/ 3.141592653589 4)
                (lambda () (atan 1))
                (lambda (expected result)
                  (< (abs (- expected result)) 1.0e-10)))

 -- Variable: *test-error*
     Bound to a special error object, which can be used as an expected
     value if the test thunk is supposed to signal an error.

          (test "test if car signals an error" *test-error*
                (lambda () (car 5)))

 -- Variable: *test-report-error*
     If this variable is true, the `test' routine prints stack trace to
     the current error port when it captures an error.  It is useful
     when you got an unexpected test-error object and want to check out
     where the error is occurring.

     This variable is initialized by the environment variable
     `GAUCHE_TEST_REPORT_ERROR' when the `gauche.test' module is
     loaded.  For example, you can use the environment variable to
     check out an unexpected error from your test script as follows
     (the value of the environment variable doesn't matter).

          env GAUCHE_TEST_REPORT_ERROR=1 gosh mytest.scm

 -- Macro: test* name expected expr &optional compare
     A convenience macro that wraps EXPR by lambda.

          (test* name expected expr)
            == (test name expected (lambda () expr))

 -- Function: test-module module &keyword allow-undefined
     MODULE must be a symbol module name or a module.  This procedure
     performs some heuristic consistency check of the given module: (1)
     whether symbols set as autoload in MODULE can actually be loaded,
     (2) whether the symbols declared in export list is actually defined
     in the module, and (3) whether the global variable referenced
     within functions are all defined.   Although not perfect, this
     test can catch some careless typo in symbol names.

     Sometimes you have a global vaiable that may not be defined
     depending on compiler options or platforms, and you check its
     existence at runtime before using it.  The undefined variable
     reference check by `test-module' doesn't follow such logic, and
     reports an error whenever it finds your code referring to
     undefined variable.  In such case, you can give a list of symbols
     to the ALLOW-UNDEFINED keyword argument; the test will excludes
     them from the check.

 -- Function: test-start module-name
     Initializes internal state and prints a log header.  This should
     be called before any tests.  MODULE-NAME is used only for logging
     purpose.

 -- Function: test-section section-name
     Marks beginning of the group of tests.  This is just for logging.

 -- Function: test-end
     Prints out list of failed tests, and returns the number of failed
     tests.


File: gauche-refe.info,  Node: Threads,  Next: Measure timings,  Prev: Unit testing,  Up: Library modules - Gauche extensions

9.23 `gauche.threads' - Threads
===============================

If enabled at compilation time, Gauche can use threads built on top of
POSIX threads (pthreads).

 -- Module: gauche.threads
     Provides thread API.   You can 'use' this module regardless
     whether the thread support is compiled in or not; if threads are
     not supported, many thread-related procedures simply signals a
     "not supported" error.

   To check if threads are available in the running Gauche program, use
the following procedure.

 -- Function: gauche-thread-type
     Returns a symbol that indicates the supported thread type.  In the
     current version, the return value may be `pthread' when threads on
     top of POSIX threads are available, or `none' when threads are not
     available.

   Scheme-level thread API conforms SRFI-18, "Multithreading support"
(*note [SRFI-18]: srfi-18.), wrapped around Gauche's object interface.

* Menu:

* Thread programming tips::
* Thread procedures::
* Synchronization primitives::
* Thread exceptions::


File: gauche-refe.info,  Node: Thread programming tips,  Next: Thread procedures,  Prev: Threads,  Up: Threads

9.23.1 Thread programming tips
------------------------------

Although the surface API of threads looks simple and portable, you need
to know how the threads are implemented in order to utilize the
feature's potential.   Some languages support threads as language's
built-in construct and encourage programmers to express the calculation
in terms of threads.  However, it should be noted that in many cases
there are alternative ways than threads to implement the desired
algorithm, and you need to compare advantages and disadvantages of
using threads depending on how the threads are realized in the
underlying system.

   In Gauche, the primary purpose of threads is to write programs that
_require_ preemptive scheduling, therefore are difficult to express in
other ways.  Preemptive threads may be required, for example, when you
have to call a module that does blocking I/O which you can't intercept,
or may spend nondeterministic amount of calculation time that you want
to interrupt.

   For each Gauche's thread, an individual VM is allocated and it is
run by the dedicated POSIX thread.  Thus there is not much overhead in
context switch than the native thread, but the creation of threads
costs much higher than, say, lightweight threads built on top of
call/cc.  So Gauche's preemptive threads are _not_ designed for
applications that want to create thousands of threads for fine-grained
calculation.

   The recommended usage is the technique so called "thread pool", that
you create a set of threads and keep them around for long time and
dispatch jobs to them as needed.

   Preemptive threads have other difficulties (e.g. see *note
[FairThreads]: fairthreads.), and sometimes the alternatives may be a
better fit than the native preemptive threads.

   * If what you need is just a concurrent calculation, you might be
     able to use cooperative thread technique built on top of
     `call/cc'.   Creating call/cc-based threads is much faster than
     creating native threads.

   * If what you need is to deal with blocking I/O, and you have all
     your code at hand, it is sometimes easier to use good old
     `select'-based dispatching (*Note Simple dispatcher::, for
     example).

   * If what you need is to control the resource consumption in the
     subsystem, and the subsystem works fairly independently from the
     main system, you may be able to use Unix processes instead of
     threads.  It may sound to go backward, but Unix process does
     provide higher "shield" between the subsystem and the main system
     (e.g. the main system can keep running even if subsystem
     segfaults).


   Of course, these technique are not mutually exclusive with native
threads.  You can use dispatcher with "thread pool" technique, for
example.   Just keep it in your mind that the native threads are not
only but one of the ways to realize those features.


File: gauche-refe.info,  Node: Thread procedures,  Next: Synchronization primitives,  Prev: Thread programming tips,  Up: Threads

9.23.2 Thread procedures
------------------------

 -- Builtin Class: <thread>
     A thread.  Each thread has an associated thunk which is evaluated
     by a POSIX thread.  When thunk returns normally, the result is
     stored in the internal 'result' slot, and can be retrieved by
     `thread-join!'.  When thunk terminates abnormally, either by
     raising an exception or terminated by `thread-terminate!', the
     exception condition is stored in their internal 'result exception'
     slot, and will be passed to the thread calling `thread-join!' on
     the terminated thread.

     Each thread has its own dynamic environment and dynamic handler
     stack.  When a thread is created, its dynamic environment is
     initialized by the creator's dynamic environment.  The thread's
     dynamic handler stack is initially empty.

     Access to the resouces shared by multiple threads must be protected
     explicitly by synchronization primitives.  *Note Synchronization
     primitives::.

     Access to ports are serialized by Gauche. If multiple threads
     attempt to write to a port, their output may be interleaved but no
     output will be lost, and the state of the port is kept consistent.
     If multiple threads attempt to read from a port, a single read
     primitive (e.g. `read', `read-char' or `read-line') works
     atomically.

     Signal handlers are shared by all threads, but each thread has its
     own signal mask.  *Note Signals and threads::, for details.

     A thread object has the following external slots.

      -- Instance Variable of <thread>: name
          A name can be associated to a thread.  This is just for the
          convenience of the application.  The primordial thread has
          the name "`root'".

      -- Instance Variable of <thread>: specific
          A thread-local slot for use of the application.

 -- Function: current-thread
     [SRFI-18], [SRFI-21] Returns the current thread.

 -- Function: thread? obj
     [SRFI-18], [SRFI-21] Returns `#t' if OBJ is a thread, `#f'
     otherwise.

 -- Function: make-thread thunk &optional name
     [SRFI-18], [SRFI-21] Creates and returns a new thread.  To run the
     thread, you need to call `thread-start!'.

     You can provide the name of the thread by the optional argument
     NAME.

     Internally, this procedure just allocates and initializes a Scheme
     thread object; the POSIX thread is not created until
     `thread-start!'  is called.

 -- Function: thread-name thread
     [SRFI-18], [SRFI-21] Returns the value of NAME slot of THREAD.

 -- Function: thread-specific thread
 -- Function: thread-specific-set! thread value
     [SRFI-18], [SRFI-21] Gets/sets the value of the THREAD's specific
     slot.

 -- Function: thread-start! thread
     [SRFI-18], [SRFI-21] Starts the THREAD.  It is an error if THREAD
     is already started.  Returns THREAD.

 -- Function: thread-yield!
     [SRFI-18], [SRFI-21] Suspends the execution of the calling thread
     and yields CPU to other waiting runnable threads, if any.

 -- Function: thread-sleep! timeout
     [SRFI-18], [SRFI-21] Suspends the calling thread for the period
     specified by TIMEOUT, which must be either a `<time>' object
     (*Note Time::) that specifies absolute point of time, or a real
     number that specifies relative point of time from the time this
     procedure is called in number of seconds.

     After the specified time passes, `thread-sleep!' returns with
     unspecified value.

     If TIMEOUT points a past time, `thread-sleep!' returns immediately.

 -- Function: thread-terminate! thread
     [SRFI-18], [SRFI-21] Terminates the specified thread THREAD.  The
     THREAD is terminated and an instance of
     `<terminated-thread-exception>' is stored in the result exception
     field of THREAD.

     If THREAD is the same as the calling thread, this procedure won't
     return.  Otherwise, this procedure returns unspecified value.

     This procedure should be used with care, since THREAD won't have a
     chance to call cleanup procedures (such as 'after' thunks of
     `dynamic-wind') If THREAD is in the critical section, it leaves
     some state inconsistent.  However, once a thread is terminated,
     any mutex that the thread has kept becomes 'abandoned' state, and
     an attempt to lock such a mutex by other thread raises an
     'abandoned mutex exception', so that you will know the situation.
     *Note Synchronization primitives::.

 -- Function: thread-join! thread &optional timeout timeout-val
     [SRFI-18], [SRFI-21] Waits termination of THREAD, or until the
     timeout is reached if TIMEOUT is given.

     TIMEOUT must be either a `<time>' object (*Note Time::) that
     specifies absolute point of time, or a real number that specifies
     relative point of time from the time this procedure is called in
     number of seconds, or `#f' that indicates no timeout (default).

     If THREAD terminates normally, `thread-join!' returns a value
     which is stored in the result field of THREAD.  If THREAD
     terminates abnormally, `thread-join!' raises an exception which is
     stored in the result exception field of THREAD.

     If the timeout is reached, THREAD-JOIN! returns TIMEOUT-VAL if
     given, or raises `<join-timeout-exception>'.


File: gauche-refe.info,  Node: Synchronization primitives,  Next: Thread exceptions,  Prev: Thread procedures,  Up: Threads

9.23.3 Synchronization primitives
---------------------------------

 -- Builtin Class: <mutex>
     A primitive synchronization device.  It can take one of four
     states: locked/owned, locked/not-owned, unlocked/abandoned and
     unlocked/not-abandoned.  A mutex can be locked (by `mutex-lock!')
     only if it is in unlocked state.  An 'owned' mutex keeps a thread
     that owns it.  Typically an owner thread is the one that locked
     the mutex, but you can make a thread other than the locking thread
     own a mutex.  A mutex becomes unlocked either by `mutex-unlock!'
     or the owner thread terminates.  In the former case, a mutex
     becomes unlocked/not-abandoned state.  In the latter case, a mutex
     becomes unlocked/abandoned state.

     A mutex has the following external slots.

      -- Instance Variable of <mutex>: name
          The name of the mutex.

      -- Instance Variable of <mutex>: state
          The state of the mutex.  This is a read-only slot.  See the
          description of `mutex-state' below.

      -- Instance Variable of <mutex>: specific
          A slot an application can keep arbitrary data.  For example,
          an application can implement a 'recursive' mutex using the
          specific field.

 -- Function: mutex? obj
     [SRFI-18], [SRFI-21] Returns `#t' if OBJ is a mutex, `#f'
     otherwise.

 -- Function: make-mutex &optional name
     [SRFI-18], [SRFI-21] Creates and returns a new mutex object.  When
     created, the mutex is in unlocked/not-abandoned state.
     Optionally, you can give a name to the mutex.

 -- Function: mutex-name mutex
     [SRFI-18], [SRFI-21] Returns the name of the mutex.

 -- Function: mutex-specific mutex
 -- Function: mutex-specific-set! mutex value
     [SRFI-18], [SRFI-21] Gets/sets the specific value of the mutex.

 -- Function: mutex-state mutex
     [SRFI-18], [SRFI-21] Returns the state of MUTEX, which may be one
     of the followings:

    a thread
          The mutex is locked/owned, and the owner is the returned
          thread.

    symbol `not-owned'
          The mutex is locked/not-owned.

    symbol `abandoned'
          The mutex is unlocked/abandoned.

    symbol `not-abandoned'
          The mutex is unlocked/not-abandoned.

 -- Function: mutex-lock! mutex &optional timeout thread
     [SRFI-18], [SRFI-21] Locks MUTEX.  If MUTEX is in
     unlocked/not-abandoned state, this procedure changes its state to
     locked state exclusively.  By default, MUTEX becomes locked/owned
     state, owned by the calling thread.  You can give other owner
     thread as THREAD argument.  If THREAD argument is given and `#f',
     the mutex becomes locked/not-owned state.

     If MUTEX is in unlocked/abandoned state, that is, some other
     thread has been terminated without unlocking it, this procedure
     signals 'abandoned mutex exception' (*Note Thread exceptions::)
     after changing the state of MUTEX.

     If MUTEX is in locked state and TIMEOUT is omitted or `#f', this
     procedure blocks until MUTEX becomes unlocked.   If TIMEOUT is
     specified, `mutex-lock!' returns when the specified time reaches in
     case it couldn't obtain a lock.  You can give TIMEOUT an absolute
     point of time (by `<time>' object, *Note Time::), or a relative
     time (by a real number).

     `Mutex-lock!' returns `#t' if MUTEX is successfully locked, or
     `#f' if timeout reached.

     Note that MUTEX itself doesn't implements a 'recursive lock'
     feature; that is, if a thread that has locked MUTEX tries to lock
     MUTEX again, the thread blocks.  It is not difficult, however, to
     implement a recursive lock semantics on top of this mutex.  The
     following example is taken from SRFI-18 document:

          (define (mutex-lock-recursively! mutex)
            (if (eq? (mutex-state mutex) (current-thread))
                (let ((n (mutex-specific mutex)))
                  (mutex-specific-set! mutex (+ n 1)))
                (begin
                  (mutex-lock! mutex)
                  (mutex-specific-set! mutex 0))))

          (define (mutex-unlock-recursively! mutex)
            (let ((n (mutex-specific mutex)))
              (if (= n 0)
                  (mutex-unlock! mutex)
                  (mutex-specific-set! mutex (- n 1)))))

 -- Function: mutex-unlock! mutex &optional condition-variable timeout
     [SRFI-18], [SRFI-21] Unlocks MUTEX.  The state of MUTEX becomes
     unlocked/not-abandoned.  It is allowed to unlock a mutex that is
     not owned by the calling thread.

     If optional CONDITION-VARIABLE is given, `mutex-unlock!' serves
     the "condition variable wait" operation (e.g. `pthread_cond_wait'
     in POSIX threads).   The current thread atomically wait on
     CONDITION-VARIABLE and unlocks MUTEX.  The thread will be
     unblocked when other thread signals on CONDITION-VARIABLE (see
     `condition-variable-signal!' and `condition-variable-broadcast!'
     below), or TIMEOUT reaches if it is supplied.  The TIMEOUT
     argument can be either a `<time>' object to represent an absolute
     time point (*Note Time::), a real number to represent a relative
     time in seconds, or `#f' which means never.  The calling thread
     may be unblocked prematurely, so it should reacquire the lock of
     MUTEX and checks the condition, as in the following example (it is
     taken from SRFI-18 document):

          (let loop ()
            (mutex-lock! m)
            (if (condition-is-true?)
                (begin
                  (do-something-when-condition-is-true)
                  (mutex-unlock! m))
                (begin
                  (mutex-unlock! m cv)
                  (loop))))

     The return value of `mutex-unlock!' is `#f' when it returns
     because of timeout, and `#t' otherwise.

 -- Function: with-locking-mutex mutex thunk
     Calls THUNK with locking a mutex MUTEX.  This is defined as
     follows.
          (define (with-locking-mutex mutex thunk)
            (dynamic-wind
             (lambda () (mutex-lock! mutex))
             thunk
             (lambda () (mutex-unlock! mutex))))

 -- Builtin Class: <condition-variable>
     A condition variable keeps a set of threads that are waiting for a
     certain condition to be true.  When a thread modifies the state of
     the concerned condition, it can call `condition-variable-signal!'
     or `condition-variable-broadcast!', which unblock one or more
     waiting threads so that they can check if the condition is
     satisfied.

     A condition variable object has the following slots.

      -- Instance Variable of <condition-variable>: name
          The name of the condition variable.

      -- Instance Variable of <condition-variable>: specific
          A slot an application can keep arbitrary data.

     Note that SRFI-18 doesn't have a routine equivalent to pthreads'
     `pthread_cont_wait'.  If you want to wait on condition variable,
     you can pass a condition variable to `mutex-unlock!' as an
     optional argument (see above), then acquire mutex again by
     `mutex-lock!'.  This design is for flexibility; see SRFI-18
     document for the details.

     This is the common usage of pthreads' condition variable:
          while (some_condition != TRUE) {
            pthread_cond_wait(condition_variable, mutex);
          }
     And it can be translated to SRFI-18 as follows:
          (let loop ()
            (unless some-condition
              (mutex-unlock! mutex condition-variable)
              (mutex-lock! mutex)
              (loop)))

 -- Function: condition-variable? obj
     [SRFI-18], [SRFI-21] Returns `#t' if OBJ is a condition variable,
     `#f' otherwise.

 -- Function: make-condition-variable &optional name
     [SRFI-18], [SRFI-21] Returns a new condition variable.  You can
     give its name by optional NAME argument.

 -- Function: condition-variable-name cv
     [SRFI-18], [SRFI-21] Returns the name of the condition variable.

 -- Function: condition-variable-specific cv
 -- Function: condition-variable-specific-set! cv value
     [SRFI-18], [SRFI-21] Gets/sets the specific value of the condition
     variable.

 -- Function: condition-variable-signal! cv
     [SRFI-18], [SRFI-21] If there are threads waiting on CV, causes
     the scheduler to select one of them and to make it runnable.

 -- Function: condition-variable-broadcast! cv
     [SRFI-18], [SRFI-21] Unblocks all the threads waiting on CV.


File: gauche-refe.info,  Node: Thread exceptions,  Prev: Synchronization primitives,  Up: Threads

9.23.4 Thread exceptions
------------------------

Some types of exceptions may be thrown from thread-related procedures.
These exceptions can be handled by Gauche's exception mechanism (*Note
Exceptions::).

 -- Builtin Class: <thread-exception>
     A base class of thread-related exceptions.  Inherits `<exception>'
     class.  It has one slot.

      -- Instance Variable of <thread-exception>: thread
          A thread that threw this exception.

 -- Builtin Class: <join-timeout-exception>
     An exception thrown by `thread-join!' when a timeout reaches
     before the waited thread returns.  Inherits `<thread-exception>'.

 -- Builtin Class: <abandoned-mutex-exception>
     An exception thrown by `mutex-lock!' when a MUTEX to be locked is
     in unlocked/abandoned state.  Inherits `<thread-exception>'.  It
     has one additional slot.

      -- Instance Variable of <abandoned-mutex-exception>: mutex
          A mutex that caused this exception.

 -- Builtin Class: <terminated-thread-exception>
     An exception thrown by `thread-join!' when the waited thread is
     terminated abnormally (by `thread-terminate!').  Inherits
     `<thread-exception>'.  It has one additional slot.

      -- Instance Variable of <terminated-thread-exception>: terminator
          A thread that terminated the thread that causes this
          exception.

 -- Builtin Class: <uncaught-exception>
     An exception thrown by `thread-join!' when the waited thread is
     terminated by an uncaught exception.  Inherits
     `<thread-exception>'.  It has one additional slot.

      -- Instance Variable of <uncaught-exception>: reason
          An exception that caused the termination of the thread.

 -- Function: join-timeout-exception? obj
 -- Function: abandoned-mutex-exception? obj
 -- Function: terminated-thread-exception? obj
 -- Function: uncaught-exception? obj
     [SRFI-18], [SRFI-21] These procedures checks if OBJ is a certain
     type of exception.  Provided for the compatibility to SRFI-18.

 -- Function: uncaught-exception-reason exc
     [SRFI-18], [SRFI-21] Returns the value of `reason' slot of
     `<uncaught-exception>' object.  Provided for the compatibility to
     SRFI-18.


File: gauche-refe.info,  Node: Measure timings,  Next: Uniform vectors,  Prev: Threads,  Up: Library modules - Gauche extensions

9.24 `gauche.time' - Measure timings
====================================

 -- Module: gauche.time
     Provides two simple ways to measure execution time of Scheme code.
     A macro `time', which is convenient for interactive use, and
     `<time-counter>' objects which are useful to be embedded in the
     program.

 -- Macro: time expr expr2 ...
     Evaluates EXPR EXPR2 ... sequentially, as `begin', and returns the
     result(s) of the last expression.  Before returning the value(s),
     the macro reports the elapsed (real) time and CPU times in the
     user space and the kernel space to the current error port, much
     like the bourne shell's time command.

     The current version uses `sys-gettimeofday' (*Note Time::) to
     calculate the elapsed time, and `sys-times' (*Note System
     inquiry::) to calculate user and system CPU times.  So the
     resolution of these numbers depends on these underlying system
     calls.  Usually the CPU time has 10ms resolution, while the
     elapsed time might have higher resolution.  On the systems that
     doesn't have gettimeofday(2) support, however, the elapsed time
     resolution can be as bad as a second.

          gosh> (time (length (sort (call-with-input-file "/usr/share/dict/words" port->string-list))))
          ;(time (length (sort (call-with-input-file "/usr/share/dict/words" port- ...
          ; real   0.357
          ; user   0.350
          ; sys    0.000
          45427

 -- Class: <time-counter>
     An abstract class of time counters.  Time counter is a kind of
     timer whose value is incremented as the time passes.  The counting
     can be started and stopped any number of times.  The value of the
     counter can be read when the timer is stopping.  You can have
     multiple time counters.  It is useful, for example, to measure the
     time in two parts inside a loop independently.

     The concrete subclass determines which time it is counting.  You
     have to instantiate one of those subclasses described below to use
     the time counter.

 -- Class: <real-time-counter>
 -- Class: <user-time-counter>
 -- Class: <system-time-counter>
 -- Class: <process-time-counter>
     Classes for time counters that count real (elapsed) time,
     user-space CPU time, kernel-space CPU time, and total CPU time
     (user + system), respectively.

 -- Method: time-counter-start! (counter <time-counter>)
 -- Method: time-counter-stop! (counter <time-counter>)
     Starts and stops the COUNTER.  The time during the counter is
     running is accumulated to the counter value when the counter is
     stopped.

     Start/stop pairs can be nested, but only the outermost pair takes
     the effect.  That is, if you call `time-counter-start!' on the
     counter that is already started, it doesn't have any effect except
     that to stop such a counter you have to call `time-counter-stop!'
     one more time.  It is useful when you want to measure the time
     spent in the larger block that may already contain timer
     start/stop pairs.

     Calling `time-counter-stop!' on the already stopped counter has no
     effect.

 -- Method: time-counter-reset! (counter <time-counter>)
     Resets the value of COUNTER.  If COUNTER is already running, it is
     forced to stop before being reset.

 -- Method: time-counter-value (counter <time-counter>)
     Returns the current value of the counter as the number of seconds,
     in a real number.  The resolution depends on the source of the
     counter.

 -- Macro: with-time-counter counter expr ...
     A convenience macro to run the COUNTER while EXPR ...  are
     evaluated.  Returns the result(s) of the last expression.  It is
     defined as follows.
          (define-syntax with-time-counter
            (syntax-rules ()
              ((_ counter . exprs)
               (dynamic-wind
                (lambda () (time-counter-start! counter))
                (lambda () . exprs)
                (lambda () (time-counter-stop! counter))))
              ))

   The following example measures approximate times spend in process-A
and process-B inside a loop.

     (let ((ta (make <real-time-counter>))
           (tb (make <real-time-counter>)))
       (dotimes (i 100000)
         (with-time-counter ta
           (process-A))
         (with-time-counter tb
           (process-B)))
       (format #t "Time spent in process-A: ~s\n" (time-counter-value ta))
       (format #t "Time spent in process-B: ~s\n" (time-counter-value tb))
       )


File: gauche-refe.info,  Node: Uniform vectors,  Next: Comparing version numbers,  Prev: Measure timings,  Up: Library modules - Gauche extensions

9.25 `gauche.uvector' - Uniform vectors
=======================================

 -- Module: gauche.uvector
     Provides vectors whose elements are of the same numeric type, as
     defined in SRFI-4 (*note SRFI-4: srfi-4.).

     Gauche's implementation is a superset of SRFI-4 in a few ways:
        * Some routines takes optional parameters: `TAGvector->list'
          takes optional start and end indices, and `TAGvector-ref'
          takes optional fallback value.

        * Additional functions: copy procedures (`TAGvector-copy' and
          `TAGvector-copy!'), conversion procedures
          (`TAGvector->vector' and `vector->TAGvector'), and some
          arithmetic functions (`TAGvector-add', etc.)

        * Implements the collection framework (*Note Collection
          framework::) and the sequence framework (*Note Sequence
          framework::).  So the methods like `map', `for-each', `ref'
          or `subseq' can be used on the SRFI-4 vector types.

        * Support of `f16vector', a vector of 16-bit floating point
          number as used in high-dynamic range image format (1 sign
          bit, 5 exponent bits, and 10 mantissa bits).

     There are some advantages of using SRFI-4 vectors over normal
     (heterogeneous) vectors.  It may be more compact than the normal
     vectors.  Some operations (especially Gauche's extension of vector
     arithmetic operations) can bypass type check and conversion of
     individual elements, thus be more efficient.  And it is much easier
     and efficient to communicate with external libraries that require
     homogeneous array of numbers; for example, OpenGL binding of Gauche
     uses SRFI-4 vectors extensively.
The following ten types of vectors are defined.
_s8vector_
     Elements are exact integers in the range between -2^7 and 2^7-1

_u8vector_
     Elements are exact integers in the range between 0 and 2^8-1

_s16vector_
     Elements are exact integers in the range between -2^15 and 2^15-1

_u16vector_
     Elements are exact integers in the range between 0 and 2^16-1

_s32vector_
     Elements are exact integers in the range between -2^31 and 2^31-1

_u32vector_
     Elements are exact integers in the range between 0 and 2^32-1

_s64vector_
     Elements are exact integers in the range between -2^63 and 2^63-1

_u64vector_
     Elements are exact integers in the range between 0 and 2^64-1

_f16vector_
     Elements are inexact real numbers representable in 16bits float
     (a.k.a half float)

_f32vector_
     Elements are inexact real numbers representable in the `float' of
     C compiler that compiles Gauche.  Usually it is a single precision
     IEEE floating point number.

_f64vector_
     Elements are inexact real numbers representable in the `double' of
     C compiler that compiles Gauche.  Usually it is a double precision
     IEEE floating point number.

   When you try to store a number out of the range of the vector type,
an error is signalled by default.  However, some procedures take an
optional argument CLAMP that specifies alternative behavior in such a
case.  CLAMP argument may take one of the following values.
`#f'
     Default behavior (signals an error).

`high'
     Clamps high bound; i.e. if the value to be stored is beyond the
     higher bound of the range, the maximum value is stored instead.

`low'
     Clamps low bound; i.e. if the value to be stored is below the
     lower bound of the range, the minimum value is stored instead.

`both'
     Clamps both sides; does both `high' and `low'.

     (list->u8vector '(-1))         => error
     (list->u8vector '(-1) 'low)    => #u8(0)
     (list->u8vector '(-1) 'high)   => error
     (list->u8vector '(3000) 'high) => #u8(255)
     (list->u8vector '(-100 20 300) 'both) => #u8(0 20 255)

   In the following description, `TAG' can be replaced for any of `s8',
`u8', `s16', `u16', `s32', `u32', `s64', `u64', `f16', `f32', `f64'.

* Menu:

* Uvector basic operations::
* Uvector conversion operations::
* Uvector numeric operations::
* Uvector block I/O::


File: gauche-refe.info,  Node: Uvector basic operations,  Next: Uvector conversion operations,  Prev: Uniform vectors,  Up: Uniform vectors

9.25.1 Uvector basic operations
-------------------------------

 -- Builtin Class: <TAGvector>
     A class for TAGvector.  It inherits `<sequence>'.

 -- Reader Syntax: `#TAG(N ...)'
     Denotes a literal homogeneous vector.
          #s8(3 -2 4)
          #u32(4154 88357 2 323)
          #f32(3.14 0.554525 -3.342)

 -- Function: TAGvector? OBJ
     [SRFI-4] Returns `#t' if OBJ is a TAGvector, `#f' otherwise.

 -- Function: TAGvector X ...
     [SRFI-4] Constructs TAGvector whose elements are numbers X ....
     The numbers must be exact integer for exact integer vectors, and
     in the valid range of the vector.
          (s8vector 1 2 3) => #s8(1 2 3)

 -- Function: make-TAGvector LEN &OPTIONAL FILL
     [SRFI-4] Constructs a TAGvector of length LEN.  The elements are
     initialized by a number FILL.   For exact integer vectors, FILL
     must be an exact integer and in the valid range.  If FILL is
     omitted, the content of the vector is undefined.
          (make-u8vector 4 0) => #u8(0 0 0 0)

 -- Function: TAGvector-length VEC
     [SRFI-4] Returns the length of the TAGvector VEC.

     Note that the generic function `size-of' can be used to obtain the
     length of VEC as well, if you import `gauche.collection' (*Note
     Collection framework::).
          (s16vector-length '#s16(111 222 333)) => 3

          (use gauche.collection)
          (size-of '#s16(111 222 333)) => 3

 -- Function: TAGvector-ref VEC K &optional FALLBACK
     [SRFI-4+] Returns the K-th element of TAGvector VEC.

     If the index K is out of the valid range, an error is signalled
     unless an optional argument FALLBACK is given; in that case,
     FALLBACK is returned.

     Note that the generic function `ref' can be used as well, if you
     import `gauche.collection'.

          (u16vector-ref '#u16(111 222 333) 1) => 222

          (use gauche.collection)
          (ref '#u16(111 222 333) 1) => 222

 -- Function: TAGvector-set! VEC K N &optional CLAMP
     [SRFI-4+] Sets a number N to the K-th element of TAGvector VEC.
     Optional CLAMP argument specifies the behavior when N is out of
     valid range.   Default is to signal an error.

     Note that the setter of the generic function `ref' can be used as
     well, if you import `gauche.collection'.
          (let ((v (s32vector -439 852 8933)))
            (s32vector-set! v 1 4)
            v)
           => #s32vector(-439 4 8933)

          (use gauche.collection)
          (let ((v (s32vector -439 852 8933)))
            (set! (ref v 1) 4)
            v)
           => #s32vector(-439 4 8933)

 -- Function: TAGvector-fill! VEC FILL &optional START END
     Stores FILL in every element of VEC, ranging from START to END of
     VEC, if they are given.

 -- Function: TAGvector-copy VEC &optional START END
     Copies the srfi-4 vector VEC.  If START and/or END are given, they
     limit the range of VEC to be copied.

          (u8vector-copy '#u8(1 2 3 4))     => #u8(1 2 3 4)
          (u8vector-copy '#u8(1 2 3 4) 2)   => #u8(3 4)
          (u8vector-copy '#u8(1 2 3 4) 1 3) => #u8(2 3)

 -- Function: TAGvector-copy! TARGET TSTART SOURCE &optional SSTART SEND
     Both TARGET and SOURCE must be TAGvectors, and TARGET must be
     mutable.  This procedure copies the elements of START, beginning
     from index SSTART (inclusive) and up to SEND, into TARGET,
     beginning from index TSTART.  SSTART and TSTART may be omitted,
     and in that case 0 and the length of SOURCE are assumed,
     respectively.

          (let ((target (u8vector 0 1 2 3 4 5 6)))
            (u8vector-copy! target 2 '#u8(10 11 12 13 14) 1 4)
            target)
           => #u8(0 1 11 12 13 6)

     If the number of elements in the source vector between SSTART and
     SEND is larger than the target vector beginning from TSTART, the
     excess elements are silently discarded.

     _Note:_ This procedure used to take just two uniform vectors,
     TARGET and SOURCE, and just copies contents of SOURCE to TARGET.
     Both vectors had to be the same type and same length.  The API is
     revised to the current form to make it parallel with
     `string-copy!' (SRFI-13) and `vector-copy!' (SRFI-43).  The old
     interface is still supported for the backward compatibility, but
     it is deprecated and will be gone in the future releases.

   Using collection and sequence framework, you can perform various
operations on the homogeneous vectors.

     (use gauche.collection)
     (use gauche.sequence)

     (fold + 0 '#s32(1 2 3 4)) => 10

     (map-to <f32vector> * '#f32(3.2 1.1 4.3) '#f32(-4.3 2.2 9.4))
       => #f32(-13.760001 2.420000 40.420002)

     (subseq #u32(1 4 3 4 5) 2 4) => #u32(3 4)


File: gauche-refe.info,  Node: Uvector conversion operations,  Next: Uvector numeric operations,  Prev: Uvector basic operations,  Up: Uniform vectors

9.25.2 Uvector conversion operations
------------------------------------

 -- Function: TAGvector->list VEC &optional START END
     [SRFI-4+] Converts TAGvector VEC to a list.  If START and/or END
     are given, they limit the range of VEC to be extracted.

     Note that the generic function `coerce-to' can be used as well, if
     you import `gauche.collection'.
          (u32vector->list '#u32(9 2 5)) => (9 2 5)

          (use gauche.collection)
          (coerce-to <list> '#u32(9 2 5)) => (9 2 5)

 -- Function: TAGvector->vector VEC &optional START END
     Converts TAGvector VEC to a vector.  If START and/or END are
     given, they limit the range of VEC to be copied.

     Note that the generic function `coerce-to' can be used as well, if
     you import `gauche.collection'.
          (f32vector->vector '#f32(9.3 2.2 5.5))   => #(9.3 2.2 5.5)
          (f32vector->vector '#f32(9.3 2.2 5.5) 2) => #(5.5)

          (use gauche.collection)
          (coerce-to <vector> '#f32(9.3 2.2 5.5)) => #(9.3 2.2 5.5)

 -- Function: list->TAGvector LIST &optional CLAMP
     [SRFI-4+] Converts a list LIST to a TAGvector.  Optional argument
     CLAMP specifies the behavior when the element of LIST is out of
     the valid range.

     Note that the generic function `coerce-to' can be used as well, if
     you import `gauche.collection'.
          (list->s64vector '(9 2 5)) => #s64(9 2 5)

          (use gauche.collection)
          (coerce-to <s64vector> '(9 2 5)) => #s64(9 2 5)

 -- Function: vector->TAGvector VEC &optional START END CLAMP
     Converts a vector VEC to a TAGvector.  If START and/or END are
     given, they limit the range of VEC to be copied.  Optional
     argument CLAMP specifies the behavior when the element of VEC is
     out of the valid range.

     Note that the generic function `coerce-to' can be used as well, if
     you import `gauche.collection'.
          (vector->f64vector '#(3.1 5.4 3.2)) => #f64(3.1 5.4 3.2)

          (use gauche.collection)
          (coerce-to <f64vector> '#(3.1 5.4 3.2)) => #f64(3.1 5.4 3.2)

 -- Function: string->s8vector string &optional start end
 -- Function: string->u8vector string &optional start end
     Returns an s8vector or u8vector whose byte sequence is the same as
     the internal representation of the given string.  Optional range
     arguments START and END specifies the _character position_ inside
     STRING to be converted.

     These procedures are useful when you want to access byte sequence
     of the string randomly.

          (string->u8vector "abc") => #u8(97 98 99)

 -- Function: string->s8vector! target tstart string &optional start end
 -- Function: string->u8vector! target tstart string &optional start end
     TARGET must be an s8vector or a u8vector, respectively.  TARGET
     must be mutable.  Like copies the raw byte representation of STRING
     into TARGET beginning from index TSTART.

     Returns TARGET.

          (let ((target (make-u8vector 10 0)))
            (string->u8vector! target 3 "abcde"))
           => #u8(0 0 0 97 98 99 100 101 0 0)


 -- Function: s8vector->string vec &optional start end
 -- Function: u8vector->string vec &optional start end
     Converts a byte sequence in s8vector or u8vector to a string that
     has the same byte sequence.  Optional range arguments START and
     END specifies the byte position in VEC to be converted.

     Note that these procedure may result an incomplete string if VEC
     contains a byte sequence invalid as the internal encoding of the
     string.

 -- Function: string->s32vector string &optional start end
 -- Function: string->u32vector string &optional start end
     Returns an s32vector or u32vector whose elements are the internal
     codes of the characters in the string.  Optional range arguments
     START and END specifies the _character position_ inside STRING to
     be converted.

     These procedures are useful when you want to access the characters
     in the string randomly.

 -- Function: s32vector->string vec &optional start end
 -- Function: u32vector->string vec &optional start end
     Without START and END, these procedures work like this:
          (lambda (vec) (map-to <string> integer->char vec)))
     Optional range arguments START and END limits the range of
     conversion between them.

 -- Function: uvector-alias uvector-class vec &optional start end
     This procedure creates an uvector of class UVECTOR-CLASS that
     shares the storage of the given uniform vector VEC.  If optional
     START and END arguments are given, only the specified range of VEC
     is used for the new vector.  Since the storage is shared,
     modification of the original vector can be seen from the new
     vector, or vice versa.

     The class UVECTOR-CLASS must be either one of the uniform vector
     class, but is not necessary match the class of the source vector
     VEC.   In such case, the new vector looks at the same region of
     VEC's memory, but interprets it differently.  For example, the
     following code determines whether Gauche is running on big-endian
     or little-endian machine:

          (let ((u8v (uvector-alias <u8vector> #u32(1))))
            (if (zero? (u8vector-ref u8v 0))
                'big-endian
                'little-endian))

     If the UVECTOR-CLASS is other than s8vector or u8vector, the
     region the new vector points has to meet the alignment
     requirement.  You can assume the beginning of the source vector is
     aligned suitable for any uniform vectors.  So, for example, if
     you're creating u32vector from u8vector, the START and END must be
     multiple of 4 (or, if they're omitted, the length of the original
     u8vector must be multiple of 4).  An error is signalled when the
     given parameters doesn't satisfy alignment constraint.


File: gauche-refe.info,  Node: Uvector numeric operations,  Next: Uvector block I/O,  Prev: Uvector conversion operations,  Up: Uniform vectors

9.25.3 Uvector numeric operations
---------------------------------

 -- Function: TAGvector-add VEC VAL &optional CLAMP
 -- Function: TAGvector-add! VEC VAL &optional CLAMP
 -- Function: TAGvector-sub VEC VAL &optional CLAMP
 -- Function: TAGvector-sub! VEC VAL &optional CLAMP
 -- Function: TAGvector-mul VEC VAL &optional CLAMP
 -- Function: TAGvector-mul! VEC VAL &optional CLAMP
     Element-wise arithmetic.  VEC must be a TAGvector, and VAL must be
     either a TAGvector, a vector, or a list of the same length as VEC,
     or a number (an exact integer for integer vectors, and a real
     number for f32- and f64-vectors).

     If VAL is a TAGvector, its elements are added to, subtracted from,
     or multiplied by the corresponding elements of VEC, respectively,
     and the results are gathered to a TAGvector and returned.  The
     destructive version (those have bang `!' in the name) reuses VEC
     to store the result.  If the result of calculation goes out of the
     range of TAGvector's element, the behavior is specified by CLAMP
     optional argument.  (For f32vector and f64vector, CLAMP argument
     is ignored and the result may contain infinity).

     If VAL is a number, it is added to, subtracted from, or multiplied
     by each element of VEC, respectively.

          (s8vector-add '#s8(1 2 3 4) '#s8(5 6 7 8)) => #s8(6 8 10 12)
          (u8vector-sub '#u8(1 2 3 4) '#u8(2 2 2 2)) => error
          (u8vector-sub '#u8(1 2 3 4) '#u8(2 2 2 2) 'both) => #u8(0 0 1 2)

          (f32vector-mul '#f32(3.0 2.0 1.0) 1.5) => #f32(4.5 3.0 1.5)

 -- Function: TAGvector-div VEC VAL
 -- Function: TAGvector-div! VEC VAL
     Element-wise division of flonum vectors.   These are only defined
     for f16, f32 and f64vector.  VAL must be a TAGvector, a vector or
     a list of the same length as VEC, or a real number.

          (f32vector-div '#f32(1.0 2.0 3.0) 2.0) => #f32(0.5 1.0 1.5)

 -- Function: TAGvector-and VEC VAL
 -- Function: TAGvector-and! VEC VAL
 -- Function: TAGvector-ior VEC VAL
 -- Function: TAGvector-ior! VEC VAL
 -- Function: TAGvector-xor VEC VAL
 -- Function: TAGvector-xor! VEC VAL
     Element-wise logical (bitwise) operation.  These procedures are
     only defined for integral vectors.  VAL must be a TAGvector, a
     vector or a list of the same length as VEC, or an exact integer.
     Bitwise and, inclusive or or exclusive or is calculated between
     each element in VEC and the corresponding element of VAL (when VAL
     is a non-scalar value), or VAL itself (when VAL is an integer).
     The result is returned in a TAGvector.  The destructive version
     reuses VEC to store the result.

 -- Function: TAGvector-dot VEC0 VEC1
     Calculates the dot product of two TAGvectors.  The length of VEC0
     and VEC1 must be the same.

 -- Function: TAGvector-range-check VEC MIN MAX
     VEC must be a TAGvector, and each of MIN and MAX must be either a
     TAGvector, a vector or a list of the same length as VEC, or a
     number, or `#f'.

     For each element in VEC, this procedure checks if the value is
     between MINVAL and MAXVAL inclusive, where MINVAL and MAXVAL are
     the corresponding values of MIN and MAX (when MIN and/or MAX is/are
     non-scalar value) or MIN and MAX themselves (when MIN and/or MAX
     is/are a number).  When MIN is `#f', negative infinity is assumed.
     When MAX is `#f', positive infinity is assumed.

     If all the elements in VEC are within the range, `#f' is returned.
     Otherwise, the index of the leftmost element of VEC that is out of
     range is returned.

          (u8vector-range-check '#u8(3 1 0 2) 0 3)  => #f
          (u8vector-range-check '#u8(3 1 0 2) 1 3)  => 2

          (u8vector-range-check '#u8(4 32 64 98) 0 '#u8(10 40 70 90))
            => 3

          ;; Range check in a program
          (cond
           ((u8vector-range-check u8v 1 31)
            => (lambda (i)
                (errorf "~sth vector element is out of range: ~s"
                        i (u8vector-ref u8v i))))
           (else (do-something u8v)))

 -- Function: TAGvector-clamp VEC MIN MAX
 -- Function: TAGvector-clamp! VEC MIN MAX
     VEC must be a TAGvector, and each of MIN and MAX must be either a
     TAGvector, a vector or a list of the same length as VEC, or a
     number, or `#f'.

     Like TAGvector-range-check, these procedures check if each element
     of VEC are within the range between MINVAL and MAXVAL inclusive,
     which are derived from MIN and MAX.  If the value is less than
     MINVAL, it is replaced by MINVAL.  If the value is grater than
     MAXVAL, it is replaced by MAXVAL.

     TAGvector-clamp creates a copy of VEC and do clamp operation on
     it, while TAGvector-clamp! modifies VEC.  Both return the clamped
     vector.

          (s8vector-clamp '#s8(8 14 -3 -22 0) -10 10) => #s8(8 10 -3 -10 0)


File: gauche-refe.info,  Node: Uvector block I/O,  Prev: Uvector numeric operations,  Up: Uniform vectors

9.25.4 Uvector block I/O
------------------------

A uniform vector can be seen as an abstraction of a chunk of memory.
So you might want to use it for binary I/O.  Yes, you can do it.

 -- Function: read-block! vec &optional iport start end endian
     Reads a chunk of data from the given input port IPORT, and stores
     it to the uniform vector VEC.  You can give any uniform vector.
     If optional START and END arguments are given, they specify the
     index range in VEC that is to be filled, and the rest of the
     vector remains untouched.  Otherwise, entire vector is used.  A
     special value -1 for END indicates the end of VEC.  If IPORT is
     omitted, the current input port is used.

     If the input reached EOF before the required region of VEC is
     filled, the rest of the vector is untouched.

     If IPORT is already reached EOF when `read-block!' is called, an
     EOF object is returned.  Otherwise, the procedure returns the
     number of _elements_ read (not bytes).

     If the IPORT is a buffered port with `modest' or `none' buffering
     mode (*Note File ports::), `read-block!' may return before all the
     elements in VEC is filled, even if IPORT hasn't reached EOF.  The
     ports connected to a pipe or a network socket behave so by
     default.  If you know there will be enough data arriving and want
     to make sure VEC is filled, change the buffering mode of IPORT to
     `full'.

     The data is read as a byte stream, so if you give uniform vectors
     other than s8vector or u8vector, your result may affected by the
     endian.    Suppose the input stream has a byte sequence `#x01,
     #x02, #x03, #x04'.  If you read it into u32vector, the first
     element you'll get may be `#x01020304' if you're using big-endian,
     or `#x04030201' if you're using little-endian.  By default
     `read-block!' uses the platform's native endian.  You can specify
     the endian by passing either symbol `big-endian' or
     `little-endian' to the optional argument ENDIAN.

   (Technically there are more variations than a simple big/little
endians.  See the discussion in *note Binary I/O::.)

 -- Function: write-block vec &optional oport start end endian
     Writes out the content of the uniform vector VEC 'as is' to the
     output port OPORT.   If OPORT is omitted, the current output port
     is used.  If optional START and END arguments are given, they
     specify the index range in VEC to be written out.  A special value
     -1 for END indicates the end of VEC.  This procedure returns an
     unspecified value.

     If you write out a uniform vector except s8vector and u8vector, the
     care should be taken about the endianness, as in `read-block!'.
     The number `#x01020304' in your u32vector may be written out as
     the byte sequence `#x01, #x02, #x03, #x04' or `#x04, #x03, #x02,
     #x01', depends on the ENDIAN argument, whose default is
     platform-dependent.


File: gauche-refe.info,  Node: Comparing version numbers,  Next: Virtual ports,  Prev: Uniform vectors,  Up: Library modules - Gauche extensions

9.26 `gauche.version' - Comparing version numbers
=================================================

 -- Module: gauche.version
     This module provides a convenient procedure to compare _version
     numbers_ or _revision numbers_, such as "`0.5.1'", "`3.2-3'" or
     "`8.2pl1'".  Usually each release of software component has a
     version number, and you can define order between them.  For
     example, version "1.2.3" is newer than "1.2" and older than "2.1".
      You can compare those version numbers like this:

          (version<? "2.2.3" "2.2.11")     => #t
          (version<? "2.3.1" "2.3")        => #f
          (version<? "2.3.1-1" "2.3.1-10") => #t
          (version<? "13a" "5b")           => #f

     There are no standard way to name versions, so I chose one
     convention.   This won't work for all possible variations, but I
     think it covers typical cases.

     Strictly speaking, you can only define partial order between
     version numbers, for there can be branches.   This module uses
     simple measure and just assumes the version numbers can be fully
     ordered.

     The version number here is defined by the following syntax.
           <version> : <principal-release>
                     | <version> <post-subrelease>
                     | <version> <pre-subrelease>
           <principal-release> : <relnum>
           <post-subrelease>   : [.-] <relnum>
           <pre-subrelease>    : _ <relnum>
           <relnum>            : [0-9A-Za-z]+

     Typically `<relnum>' is composed by numeric part and extension
     part.  For example, "23a" is composed by an integer 23 and
     extension "a".  If `<relnum>' doesn't begins with digits, we
     assume its numeric part is -1.

     Then, the order of `<relnum>' is defined as follows:
       1. If relnum A and relnum B have different numeric part, we
          ignore the extension and order them numerically, e.g.  "`3b'"
          < "`4a'".

       2. If relnum A and relnum B have the same numeric part, we
          compare extension by alphabetically, e.g.  "`4c'" < "`4d'"
          and "`5'" < "`5a'".

     Given the order of `<relnum>', the order of version numbers are
     defined as follows:
       1. Decompose each version number into a list of
          `<principal-release>' and subsequence subrelease components.
          We call each element of the list "release components".

       2. If the first release component of both lists are the same,
          remove it from both.  Repeat this until the head of the lists
          differ.

       3. Now we have the following cases.
            1. Both lists are empty: versions are the same.

            2. One list (A) is empty and the other list (B) has
               post-subrelease at head: A is prior to B

            3. One list (A) is empty and the other list (B) has
               pre-subrelease at head: B is prior to A

            4. List A's head is post-subrelease and list B's head is
               pre-subrelease: B is prior to A

            5. Both lists have post-subrelease or pre-subrelease at
               head: compare their relnums.
          Here are some examples:
          "1" < "1.0" < "1.1" < "1.1.1" < "1.1.2" < "1.2" < "1.11"
          "1.2.3" < "1.2.3-1" < "1.2.4"
          "1.2.3" < "1.2.3a" < "1.2.3b"
          "1.2_rc0" < "1.2_rc1" < "1.2" < "1.2-pl1" < "1.2-pl2"
          "1.1-patch112" < "1.2_alpha"

     The reason of having `<pre-subrelease>' is to allow "release
     candidate" or "pre-release" version.

 -- Function: version=? ver1 ver2
 -- Function: version<? ver1 ver2
 -- Function: version<=? ver1 ver2
 -- Function: version>? ver1 ver2
 -- Function: version>=? ver1 ver2
     Returns a boolean value depending on the order of two version
     number string VER1 and VER2.  If the arguments contain invalid
     strings as the defined version number, an error is signalled.

 -- Function: version-compare ver1 ver2
     Compares two version number strings VER1 and VER2, and returns
     either -1, 0, or 1, depending whether VER1 is prior to VER2, VER1
     is the same as VER2, or VER1 is after VER2, respectively.

 -- Function: relnum-compare rel1 rel2
     This is lower-level procedure of `version-compare'.  Compares two
     release numbers (relnums) REL1 and REL2, and returns either -1, 0,
     or 1 depending whether  REL1 is prior to REL2, REL1 is the same as
     REL2, or REL1 is after REL2, respectively.


File: gauche-refe.info,  Node: Virtual ports,  Prev: Comparing version numbers,  Up: Library modules - Gauche extensions

9.27 `gauche.vport' - Virtual ports
===================================

 -- Module: gauche.vport
     _Virtual ports_, or procedural ports, are the ports whose behavior
     can be programmed in Scheme.

     This module provides two kinds of virtual ports: Fully virtual
     ports, in which every I/O operation invokes user-provided
     procedures, and virtual buffered ports, in which I/O operations
     are done on an internal buffer and user-provided procedures are
     called only when the buffer needs to be filled or flushed.

     This module also provides virtual buffered ports backed up by a
     uniform vector, as an example of the feature.

Fully virtual ports
...................

This type of virtual ports are realized by classes
`<virtual-input-port>' and `<virtual-output-port>'.  You can customize
the port behavior by setting appropriate slots with procedures.

 -- Class: <virtual-input-port>
     An instance of this class can be used as an input port.  The
     behavior of the port depends on the settings of the instance slot
     values.

     To work as a meaningful input port, at least either one of `getb'
     or `getc' slot must be set.  Otherwise, the port returns EOF for
     all input requests.

      -- Instance Variable of <virtual-input-port>: getb
          If set, the value must be a procedure that takes no arguments.
          Every time binary input is required, the procedure is called.

          The procedure must return an exact integer between 0 and 255
          inclusive, or `#f' or an EOF object.  If it returns an
          integer, it becomes the value read from the port.  If it
          returns other values, the port returns EOF.

          If the port is requested a character input and it doesn't have
          the `getc' procedure, the port calls this procedure, possibly
          multiple times, to construct a whole character.

      -- Instance Variable of <virtual-input-port>: getc
          If set, the value must be a procedure that takes no arguments.
          Every time character input is required, the procedure is
          called.

          The procedure must return a character, `#f' or an EOF object.
          If it returns a character, it becomes the value read from the
          port.  If it returns other values, the port returns EOF.

          If the port is requested a binary input and it doesn't have
          the `getb' procedure, the port calls this procedure, then
          converts a character into a byte sequence, and use it as the
          binary value(s) read from the port.

      -- Instance Variable of <virtual-input-port>: gets
          If set, the value must be a procedure that takes one argument,
          a positive exact integer.  It is called when the block binary
          input, such as `read-block', is requested.  It must return a
          (maybe incomplete) string up to the specified size, or `#f'
          or EOF object.  If it returns a null string, `#f' or EOF
          object, the port thinks it reached EOF.  If it returns other
          string, it is used as the result of block read.  It shouldn't
          return a string larger than the given size (Note: you must
          count size (bytes), not the number of characters).  The
          reason of this procedure is efficiency; if this procedure is
          not provided, the port calls `getb' procedure repeatedly to
          prepare the block of data.  In some cases, providing block
          input can be much more efficient (e.g. suppose you're reading
          from a block of memory chunk).

          You can leave this slot unset if you don't need to take such
          advantage.

      -- Instance Variable of <virtual-input-port>: ready
          If set, the value must be a procedure that takes one boolean
          argument.  It is called when `char-ready?' or `byte-ready?' is
          called on the port.   The value returned from your procedure
          will be the result of these procedures.

          The boolean argument is `#t' if `char-ready?' is called, or
          `#f' if `byte-ready?' is called.

          If unset, `char-ready?' and `byte-ready?' always return `#t'
          on the port

      -- Instance Variable of <virtual-input-port>: close
          If set, the value must be a procedure that takes no arguments.
          It is called when the port is closed.  Return value is
          discarded.  You can leave this unset if you don't need to
          take an action when the port is closed.

          This procedure may be called from a finalizer, so you have to
          be careful to write it.   See the note on finalization below.

      -- Instance Variable of <virtual-input-port>: seek
          If set, the value must be a procedure that takes two
          arguments, offset and whence.  The meaning of them is the
          same as the arguments to `port-seek' (*Note Common port
          operations::).  The procedure must adjust the port's internal
          read pointer so that the next read begins from the new
          pointer.  It should return the updated pointer (the byte
          offset from the beginning of the port).

          If unset, call of `port-seek' and `port-tell' on this port
          will return `#f'.

          Note that this procedure may be called for the purpose of
          merely querying the current position, with 0 as `offset' and
          `SEEK_CUR' as `whence'.  If your port knows the read pointer
          but cannot move it, you can still provide this procedure,
          which returns the current pointer position for such queries
          and returns `#f' for other arguments.


 -- Class: <virtual-output-port>
     An instance of this class can be used as an output port.  The
     behavior of the port depends on the settings of the instance slot
     values.

     To work as an output port, at least either one of `putb' or `putc'
     slot has to be set.

      -- Instance Variable of <virtual-output-port>: putb
          If set, the value must be a procedure that takes one argument,
          a byte value (exact integer between 0 and 255, inclusive).
          Every time binary output is required, the procedure is called.
          The return value of the procedure is ignored.

          If this slot is not set and binary output is requested, the
          port may signal an `<io-unit-error>' error.

      -- Instance Variable of <virtual-output-port>: putc
          If set, the value must be a procedure that takes one argument,
          a character.  Every time character output is required, the
          procedure is called.  The return value of the procedure is
          ignored.

          If this slot is not set but `putb' slot is set, the virtual
          port decomposes the character into a sequence of bytes then
          calls `putb' procedures.

      -- Instance Variable of <virtual-output-port>: puts
          If set, the value must be a procedure that takes a (possibly
          incomplete) string.  The return value of the procedure is
          ignored.

          This is for efficiency.  If this slot is not set, the virtual
          port calls `putb' or `putc' repeatedly to output a chunk of
          data.  But if your code can perform chunked output
          efficiently, you can provide this procedure.

      -- Instance Variable of <virtual-output-port>: flush
          If set, the value must be a procedure that takes no arguments.
          It is called when flushing a port is required (e.g. `flush'
          is called on the port, or the port is being closed).

          This procedure is useful that your port does some sort of
          buffering, or needs to keep some state.  If your port doesn't
          do stateful operation, you can leave this unset.

          This procedure may be called from a finalizer, and needs a
          special care.  See notes on finalizers below.


      -- Instance Variable of <virtual-output-port>: close
          The same as `<virtual-input-port>''s `close' slot.

      -- Instance Variable of <virtual-output-port>: seek
          The same as `<virtual-input-port>''s `seek' slot.


Virtual buffered ports
......................

This type of virtual ports are realized by classes
`<buffered-input-port>' and `<buffered-output-port>'.  You can
customize the port behavior by setting appropriate slots with
procedures.

   Those ports have internal buffer and only calls Scheme procedures
when the buffer needs to be filled or flushed.  Generally it is far
more efficient than calling Scheme procedures for every I/O operation.
Actually, the internal buffering mechanism is the same as Gauche's file
I/O ports.

   These ports uses `u8vector' as a buffer.  See *note Uniform vectors::
for the details.

 -- Class: <buffered-input-port>
     An instance of this class behaves as an input port.  It has the
     following instance slots.  For a meaningful input port, you have
     to set at least `fill' slot.

      -- Instance Variable of <buffered-input-port>: fill
          If set, it must be a procedure that takes one argument, a
          `u8vector'.  It must fill the data from the beginning of the
          vector.  It doesn't need to fill the entire vector if there's
          not so many data.  However, if there are remaining data, it
          must fill at least one byte; if the data isn't readily
          available, it has to wait until some data becomes available.

          The procedure must return a number of bytes it actually
          filled.  It may return 0 or an EOF object to indicate the
          port has reached EOF.

      -- Instance Variable of <buffered-input-port>: ready
          If set, it must be a procedure that takes no arguments.  The
          procedure must return a true value if there are some data
          readily available to read, or `#f' otherwise.  Unlike fully
          virtual ports, you don't need to distinguish binary and
          character I/O.

          If this slot is not set, the port is regarded as it always
          has data ready.

      -- Instance Variable of <buffered-input-port>: close
          If set, it must be a procedure that takes no arguments.  The
          procedure is called when the virtual buffered port is closed.
          You don't need to set this slot unless you need some cleaning
          up when the port is closed.

          This procedure may be called from a finalizer, and needs
          special care.  See the note on finalization below.

      -- Instance Variable of <buffered-input-port>: filenum
          If set, it must be a procedure that returns underlying file
          descriptor number (exact nonnegative integer).  The procedure
          is called when `port-file-number' is called on the port.

          If there's no such underlying file descriptor, you can return
          `#f', or you can leave this slot unset.

      -- Instance Variable of <buffered-input-port>: seek
          If set, it must be a procedure that takes two arguments,
          OFFSET and WHENCE.  It works the same way as
          `<virtual-input-port>''s seek procedure; see above.

          This procedure may be called from a finalizer, and needs
          special care.  See the note on finalization below.

     Besides those slot values, you can pass an exact nonnegative
     integer as the `:buffer-size' keyword argument to the MAKE method
     to set the size of the port's internal buffer.  If `:buffer-size'
     is omitted, or zero is passed, the system's default buffer size
     (something like 8K) is used.  `:buffer-size' is not an instance
     slot and you cannot set it after the instance of the buffered port
     is created.   The following example specifies the buffered port to
     use a buffer of size 64K:

          (make <buffered-input-port> :buffer-size 65536 :fill my-filler)

 -- Class: <buffered-output-port>
     An instance of this class behaves as an output port.  It has the
     following instance slots.  You have to set at least `flush' slot.

      -- Instance Variable of <buffered-output-port>: flush
          If set, it must be a procedure that takes two arguments, an
          `u8vector' buffer and a flag.  The procedure must output data
          in the buffer to somewhere, and returns the number of bytes
          actually output.

          If the flag is false, the procedure may output less than
          entire buffer (but at least one byte).  If the flag is true,
          the procedure must output entire buffer.

      -- Instance Variable of <buffered-output-port>: close
          Same as `<buffered-input-port>''s `close' slot.

      -- Instance Variable of <buffered-output-port>: filenum
          Same as `<buffered-input-port>''s `filenum' slot.

      -- Instance Variable of <buffered-output-port>: seek
          Same as `<buffered-input-port>''s `seek' slot.

     Besides those slot values, you can pass an exact nonnegative
     integer as the `:buffer-size' keyword argument to the MAKE method
     to set the size of the port's internal buffer.  See the description
     of `<buffered-input-port>' above for the details.


Uniform vector ports
....................

The following two procedures returns a buffered input/output port
backed up by a uniform vector.    The source or destination vector can
be any type of uniform vector, but they are aliased to `u8vector' (see
`uvector-alias' in *note Uvector conversion operations::).

   If used together with `pack'/`unpack' (see *note Packing Binary
Data::), it is useful to parse or construct binary data structure.  It
is also an example of using virtual ports; read `gauche/vport.scm' (or
`ext/vport/vport.scm' in the source tree) if you're curious about the
implementation.

 -- Function: open-input-uvector uvector
     Returns an input port that reads the content of the given uniform
     vector UVECTOR from its beginning.  If reading operation reaches
     the end of UVECTOR, EOF is returned.  Seek operation is also
     implemented.

 -- Function: open-output-uvector uvector
     Returns an output port that fills the given uvector by the data
     output to the port.  If UVECTOR is completely filled, more data
     are silently discarded.  Seek operation is also implemented.

Note on finalization
....................

If an unclosed virtual port is garbage collected, its close procedure
is called (in case of virtual buffered ports, its flush procedure may
also be called before close procedure).  It is done by a finalizer of
the port.  Since it is a part of garbage-collection process (although
the Scheme procedure itself is called outside of the garbage collector
main part), it requires special care.

   * It is possible that the object the virtual port has a reference
     may already be finalized.  For example, if a virtual port X holds
     the only reference to a _sink_ port Y, to which the output goes.
     X's `flush' procedure sends its output to Y.  However, if `flush'
     procedure can be called from a finalizer, it may be possible that
     Y's finalizer has already been called and Y is closed.   So X's
     `flush' procedure has to check if Y has not been closed.

   * You cannot know when and in which thread the finalizer runs.  So
     if the procedure like `close' or `flush' of virtual ports need to
     lock or access the global resource, it needs to take extra care of
     avoiding dead lock or conflict of access.

     Even in single thread programs, the finalizer can run anywhere in
     Scheme programs, so effectively it should be considered as running
     in a different thread.


File: gauche-refe.info,  Node: Library modules - SRFIs,  Next: Library modules - Utilities,  Prev: Library modules - Gauche extensions,  Up: Top

10 Library modules - SRFIs
**************************

This chapter lists modules that provides SRFI functionalities.  Note
that some of SRFI features are built in Gauche core and not listed
here.  *Note Standard conformance::, for entire list of supported SRFIs.

* Menu:

* Feature conditional::         srfi-0
* List library::                srfi-1
* Homogeneous vectors::         srfi-4
* A compatible let form with signatures and rest arguments::  srfi-5
* Feature-based program configuration language::  srfi-7
* Record types::                srfi-9
* Let-values::                  srfi-11
* String library::              srfi-13
* Character-set library::       srfi-14
* Time data types and procedures::  srfi-19
* Sources of random bits::      srfi-27
* Localization::                srfi-29
* A program argument processor::  srfi-37
* Eager comprehensions::        srfi-42
* Vector library::              srfi-43
* Requiring extensions::        srfi-55


File: gauche-refe.info,  Node: Feature conditional,  Next: List library,  Prev: Library modules - SRFIs,  Up: Library modules - SRFIs

10.1 `srfi-0' - Feature conditional
===================================

 -- Module: srfi-0
     Provides SRFI-0 `cond-expand' macro form.  Now this module is
     autoloaded when `cond-expand' is used, so you don't need to say
     `(use srfi-0)' explicitly.  Portable programs can't use 'use' form
     anyway.

 -- Macro: cond-expand (feature-requirement command-or-definition ...)
          ...
     [SRFI-0] This macro expands to COMMAND-OR-DEFINITION ... if Gauche
     supports FEATURE-REQUIREMENT.  In a way, it can be used to absorb
     the different feature sets supported by different Scheme
     implementations.

     FEATURE-REQUIREMENT must be in the following syntax:
          FEATURE-REQUIREMENT
            : FEATURE-IDENTIFIER
            | (and FEATURE-REQUIREMENT ...)
            | (or  FEATURE-REQUIREMENT ...)
            | (not FEATURE-REQUIREMENT)

     FEATURE-IDENTIFIER is a symbol that indicates a feature.  If such
     a feature is supported in Gauche, it satisfies the
     FEATURE-REQUIREMENT.  You can do boolean combination of
     FEATURE-REQUIREMENTs to compose more complex conditions.

     The macro tests each FEATURE-REQUIREMENT in order, and if one is
     satisfied, the macro itself expands to the corresponding
     COMMAND-OR-DEFINITION ....

     The last clause may begin with a symbol `else' instead of
     FEATURE-REQUIREMENT.  If no condition is fulfilled before it, then
     the macro expands to the COMMAND-OR-DEFINITIONs of the else
     clause.  If there's no else clause and no condition is fulfilled,
     an error is signalled.

     Currently, Gauche recognizes srfi names (e.g. `srfi-1') that it
     supports (*Note Standard conformance::, for the list of supported
     SRFIs), and a symbol `gauche' as FEATURE-IDENTIFIER.

     Suppose you are writing a program that requires srfi-13 (string
     library).  In Gauche, the standard way to use srfi-13 is like this:

          (use srfi-13)

          ;; ... your program ...

     However, the 'use' macro is Gauche specific and won't work on
     other Scheme implementations.  You can write instead:

          (cond-expand
            (srfi-13
              ;; ... your program ...
            ))

     If the implementation supports `srfi-13', the form expands to your
     program.  Note that Gauche issues `(use srfi-13)' for you in this
     case.

     The above form signals an error if the implementation doesn't
     support srfi-13.  However, you might want to run your program on
     such implementations as well, by providing alternative library
     definitions.

          (cond-expand
           (srfi-13
             ;; ... your program ...
           )
           (else
             (load "my-srfi-13-implementation")
             ;; ... your program ...
           ))


File: gauche-refe.info,  Node: List library,  Next: Homogeneous vectors,  Prev: Feature conditional,  Up: Library modules - SRFIs

10.2 `srfi-1' - List library
============================

 -- Module: srfi-1
     SRFI-1 is a rich collection of list manipulation library (*note
     [SRFI-1]: srfi-1.).  It is available by saying `(use srfi-1)'.
     The implementation is based on Olin Shivers's reference
     implementation.

* Menu:

* SRFI-1 List constructors::
* SRFI-1 List predicates::
* SRFI-1 List selectors::
* SRFI-1 List miscellaneous routines::
* SRFI-1 Fold::
* SRFI-1 Filtering & Partitioning::
* SRFI-1 Searching::
* SRFI-1 Deletion::
* SRFI-1 Association lists::
* SRFI-1 Set operations::


File: gauche-refe.info,  Node: SRFI-1 List constructors,  Next: SRFI-1 List predicates,  Prev: List library,  Up: List library

10.2.1 List constructors
------------------------

 -- Function: xcons cd ca
     [SRFI-1] Equivalent to `(cons ca cd)'.  Useful to pass to
     higher-order procedures.

 -- Function: cons* elt1 elt2 ...
     [SRFI-1] Like `list', but the last argument provides the tail of
     the constructed list.  This is just a synonym of Gauche built-in
     procedure `list*'.
          (cons* 1 2 3 4) => (1 2 3 . 4)
          (cons* 1) => 1

 -- Function: list-tabulate n init-proc
     [SRFI-1] Constructs an N-element list, in which each element is
     generated by `(INIT-PROC i)'.
          (list-tabulate 4 values) => (0 1 2 3)

 -- Function: circular-list elt1 elt2 ...
     [SRFI-1] Constructs a circular list of the elements.
          (circular-list 'z 'q) => (z q z q z q ...)

 -- Function: iota count &optional (start 0) (step 1)
     [SRFI-1] Returns a list of numbers, starting from START,
     increasing by STEP.
          (iota 5) => (0 1 2 3 4)
          (iota 5 0 -0.1) => (0 -0.1 -0.2 -0.3 -0.4)


File: gauche-refe.info,  Node: SRFI-1 List predicates,  Next: SRFI-1 List selectors,  Prev: SRFI-1 List constructors,  Up: List library

10.2.2 List predicates
----------------------

 -- Function: proper-list? x
     [SRFI-1] Returns `#t' if x is a proper list.

 -- Function: circular-list? x
     [SRFI-1] Returns `#t' if x is a circular list.

 -- Function: dotted-list? x
     [SRFI-1] Returns `#t' if x is a finite, non-nil-terminated list.
     This includes non-pair, non-() values (e.g. symbols, numbers),
     which are considered to be dotted lists of length 0.

 -- Function: null-list? list
     [SRFI-1] Returns `#t' if LIST is the empty list `()', and #F
     otherwise.

 -- Function: not-pair? x
     [SRFI-1] `(lambda (x) (not (pair? x)))'.

     SRFI-1 says: Provided as a procedure as it can be useful as the
     termination condition for list-processing procedures that wish to
     handle all finite lists, both proper and dotted.

 -- Function: list= elt= list ...
     [SRFI-1] Determines list equality by comparing every n-th element
     of given lists by the procedure ELT=.

     It is an error to apply `list=' to anything except proper lists.

     The equality procedure must be consistent with `eq?', i.e.
          (eq? x y) => (elt= x y).


File: gauche-refe.info,  Node: SRFI-1 List selectors,  Next: SRFI-1 List miscellaneous routines,  Prev: SRFI-1 List predicates,  Up: List library

10.2.3 List selectors
---------------------

 -- Function: first pair
 -- Function: second pair
 -- Function: third pair
 -- Function: fourth pair
 -- Function: fifth pair
 -- Function: sixth pair
 -- Function: seventh pair
 -- Function: eighth pair
 -- Function: ninth pair
 -- Function: tenth pair
     [SRFI-1] Returns n-th element of the (maybe improper) list.

 -- Function: car+cdr pair
     [SRFI-1] Returns two values, `(car pair)' and `(cdr pair)'.

 -- Function: take x i
 -- Function: drop x i
     [SRFI-1] `take' returns the first i elements of list x.  `drop'
     returns all but the first i elements of list x.
          (take '(a b c d e)  2) => (a b)
          (drop '(a b c d e)  2) => (c d e)
     X may be any value:
          (take '(1 2 3 . d) 2) => (1 2)
          (drop '(1 2 3 . d) 2) => (3 . d)
          (drop '(1 2 3 . d) 3) => d
     `drop' is exactly equivalent to performing I cdr operations on X.
     The returned value shares a common tail with X.  On the other
     hand, take always allocates a new list for result if the argument
     is a list of non-zero length.

     An error is signalled if I is past the end of list X.  *Note
     Additional list library::, for more tolerant version of `take' and
     `drop'.

     For generic subsequence extraction from any sequence, see `subseq'
     in *note Slicing sequence::.

 -- Function: take-right flist i
 -- Function: drop-right flist i
     [SRFI-1] `take-right' returns the last I elements of FLIST.
     `drop-right' returns all but the last I elements of FLIST.
          (take-right '(a b c d e) 2) => (d e)
          (drop-right '(a b c d e) 2) => (a b c)
     FLIST may be any finite list.
          (take-right '(1 2 3 . d) 2) => (2 3 . d)
          (drop-right '(1 2 3 . d) 2) => (1)
          (take-right '(1 2 3 . d) 0) => d
          (drop-right '(1 2 3 . d) 0) => (1 2 3)
     `take-right''s return value always shares a common tail with FLIST.
     `drop-right' always allocates a new list if the argument is a list
     of non-zero length.

     An error is signalled if I is larger than the length of FLIST.
     *Note Additional list library::, for more tolerant version of
     `take-right' and `drop-right'.

 -- Function: take! x i
 -- Function: drop-right! x i
     [SRFI-1]  Linear update variants of TAKE and DROP-RIGHT.  Those
     procedures may destructively modifies X.

     If X is circular, `take!' may return a list shorter than expected.

 -- Function: split-at x i
 -- Function: split-at! x i
     [SRFI-1] `split-at' splits the list X at index I, returning a list
     of the first I elements, and the remaining tail.
          (split-at '(a b c d e) 2) => (a b) (c d e)
     `split-at!' is the linear-update variant. It may destructively
     modifies X to produce the result.

 -- Function: last pair
     [SRFI-1] Returns the last element of the non-empty, finite list
     PAIR.  It is equivalent to `(car (last-pair pair))'.  Note that
     `last-pair' is Gauche built-in procedure.


File: gauche-refe.info,  Node: SRFI-1 List miscellaneous routines,  Next: SRFI-1 Fold,  Prev: SRFI-1 List selectors,  Up: List library

10.2.4 List miscellaneous routines
----------------------------------

 -- Function: length+ x
     EN [SRFI-1] If X is a proper list, returns its length.  Otherwise,
     returns `#f'.

 -- Function: concatenate list-of-lists
 -- Function: concatenate! list-of-lists!
     [SRFI-1] Equivalent to `(apply append LIST-OF-LISTS)' and `(apply
     append! LIST-OF-LISTS)', respectively.

 -- Function: append-reverse rev-head tail
 -- Function: append-reverse! rev-head tail
     [SRFI-1] `append-reverse' returns `(append (reverse rev-head)
     tail)'.  `append-reverse!' is the linear-update variant.

 -- Function: zip clist1 clist2 ...
     [SRFI-1] Equivalent to `(map list clist1 clist2 ...)'.  If `zip'
     is passed N lists, it returns a list as long as the shortest of
     these lists, each element of which is an N-element list comprised
     of the corresponding elements from the parameter lists.
          (zip '(one two three)
               '(1 2 3)
               '(odd even odd even odd even odd even))
               => ((one 1 odd) (two 2 even) (three 3 odd))

          (zip '(1 2 3)) => ((1) (2) (3))
     At least one of the argument lists must be finite:
          (zip '(3 1 4 1) (circular-list #f #t))
               => ((3 #f) (1 #t) (4 #f) (1 #t))

 -- Function: unzip1 list
 -- Function: unzip2 list
 -- Function: unzip3 list
 -- Function: unzip4 list
 -- Function: unzip5 list
     [SRFI-1] `unzip1' takes a list of lists, where every list must
     contain at least one element, and returns a list containing the
     initial element of each such list.  `unzip2' takes a list of
     lists, where every list must contain at least two elements, and
     returns two values: a list of the first elements, and a list of
     the second elements. `unzip3' does the same for the first three
     elements of the lists, and so on.
          (unzip2 '((1 one) (2 two) (3 three))) =>
             (1 2 3) and
             (one two three)

 -- Function: count pred clist1 clist2 ...
     [SRFI-1] A procedure PRED is applied to the N-th element of given
     lists, from N is zero to the length of the the shortest finite
     list in the given lists, and the count of times PRED returned true
     is returned.
          (count even? '(3 1 4 1 5 9 2 5 6)) => 3
          (count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) => 3
     At least one of the argument lists must be finite:
          (count < '(3 1 4 1) (circular-list 1 10)) => 2


File: gauche-refe.info,  Node: SRFI-1 Fold,  Next: SRFI-1 Filtering & Partitioning,  Prev: SRFI-1 List miscellaneous routines,  Up: List library

10.2.5 List fold, unfold & map
------------------------------

 -- Function: fold kons knil clist1 clist2 ...
     [SRFI-1] The fundamental list iterator.  When it is given a single
     list CLIST1 = (E1 E2 ... EN), then this procedure returns
          (KONS EN ... (KONS E2 (KONS E1 KNIL)) ... )

     If N list arguments are provided, then the KONS function must take
     N+1 parameters: one element from each list, and the "seed" or fold
     state, which is initially KNIL.  The fold operation terminates
     when the shortest list runs out of values.  At least one of the
     list arguments must be finite.

     Examples:
          (fold + 0 '(3 1 4 1 5 9)) => 23 ;sum up the elements
          (fold cons '() '(a b c d e)) => (e d c b a) ;reverse
          (fold cons* '() '(a b c) '(1 2 3 4 5))
              => (c 3 b 2 a 1) ;n-ary case

 -- Function: fold-right kons knil clist1 clist2 ...
     [SRFI-1] The fundamental list recursion operator.  When it is
     given a single list CLIST1 = (E1 E2 ... EN), then this procedure
     returns
          (KONS E1 (KONS E2 ... (KONS EN KNIL)))

     If N list arguments are provided, then the KONS function must take
     N+1 parameters: one element from each list, and the "seed" or fold
     state, which is initially KNIL.  The fold operation terminates
     when the shortest list runs out of values.  At least one of the
     list arguments must be finite.

     Examples:
          (fold-right cons '() '(a b c d e))
             => (a b c d e) ;copy list
          (fold-right cons* '() '(a b c) '(1 2 3 4 5))
             => (a 1 b 2 c 3) ;n-ary case

 -- Function: pair-fold kons knil clist1 clist2 ...
 -- Function: pair-fold-right kons knil clist1 clist2 ...
     [SRFI-1] Like `fold' and `fold-right', but the procedure KONS gets
     each `cdr' of the given CLISTs, instead of `car'.

 -- Function: reduce f ridentity list
 -- Function: reduce-right f ridentity list
     [SRFI-1] Variant of `fold' and `fold-right'.   F must be a binary
     operator, and RIDENTITY is the value such that for any value X
     that is valid as F's input,
           (f x ridentity) == x

     These functions effectively do the same thing as `fold' or
     `fold-right', respectively, but omit the first application of F to
     RIDENTITY, using the above nature.  So RIDENTITY is used only when
     LIST is empty.

 -- Function: unfold p f g seed &optional tail-gen
     [SRFI-1] Fundamental recursive list constructor.  Defined by the
     following recursion.

          (unfold p f g seed tail-gen) ==
             (if (p seed)
                 (tail-gen seed)
                 (cons (f seed)
                       (unfold p f g (g seed))))
     That is, P determines where to stop, G is used to generate
     successive seed value from the current seed value, and F is used
     to map each seed value to a list element.

 -- Function: unfold-right p f g seed &optional tail
     [SRFI-1] Fundamental iterative list constructor.  Defined by the
     following recursion.

          (unfold-right p f g seed tail) ==
            (let lp ((seed seed) (lis tail))
              (if (p seed)
                  lis
                  (lp (g seed) (cons (f seed) lis))))

 -- Function: append-map f clist1 clist2 ...
 -- Function: append-map! f clist1 clist2 ...
     [SRFI-1] Equivalent to

            (apply append (map F CLIST1 CLIST2 ...))
            (apply append! (map F CLIST1 CLIST2 ...))
     At least one of the list arguments must be finite.

 -- Function: map! f clist1 clist2 ...
     [SRFI-1] The procedure F is applied to each element of CLIST1 and
     corresponding elements of CLIST2s, and the result is collected to
     a list.  Cells in CLIST1 is reused to construct the result list.

 -- Function: map-in-order f clist1 clist2 ...
     [SRFI-1] A variant of `map', but it guarantees to apply F on each
     elements of arguments in a left-to-right order.  Since Gauche's
     `map' implementation follows the same order, this function is just
     a synonym of `map'.

 -- Function: pair-for-each f clist1 clist2 ...
     [SRFI-1] Like `for-each', but the procedure F is applied on each
     `cdr' of CLISTs.

 -- Function: filter-map f clist1 clist2 ...
     [SRFI-1] Like `map', but only true values are saved.  At least one
     of the list arguments must be finite.
          (filter-map (lambda (x) (and (number? x) (* x x)))
                      '(a 1 b 3 c 7))
            => (1 9 49)


File: gauche-refe.info,  Node: SRFI-1 Filtering & Partitioning,  Next: SRFI-1 Searching,  Prev: SRFI-1 Fold,  Up: List library

10.2.6 List filtering & partitioning
------------------------------------

 -- Function: filter pred list
 -- Function: filter! pred list
     [SRFI-1] A procedure PRED is applied on each element of LIST, and
     a list of elements that PRED returned true on it is returned.
          (filter odd? '(3 1 4 5 9 2 6)) => (3 1 5 9)
     `filter!' is the linear-update variant.  It may destructively
     modifies LIST to produce the result.

 -- Function: remove pred list
 -- Function: remove! pred list
     [SRFI-1] A procedure PRED is applied on each element of LIST, and
     a list of elements that PRED returned false on it is returned.
          (remove odd? '(3 1 4 5 9 2 6)) => (4 2 6)
     `remove!' is the linear-update variant.  It may destructively
     modifies LIST to produce the result.

 -- Function: partition pred list
 -- Function: partition! pred list
     [SRFI-1] `filter' and `remove' simultaneously, i.e.  returns two
     lists, the first is the result of filtering elements of LIST by
     PRED, and the second is the result of removing elements of LIST by
     PRED.
          (partition odd? '(3 1 4 5 9 2 6))
            => (3 1 5 9) (4 2 6)
     `partition!' is the linear-update variant.  It may destructively
     modifies LIST to produce the result.


File: gauche-refe.info,  Node: SRFI-1 Searching,  Next: SRFI-1 Deletion,  Prev: SRFI-1 Filtering & Partitioning,  Up: List library

10.2.7 List searching
---------------------

 -- Function: find pred clist
     [SRFI-1] Applies PRED for each element of CLIST, from left to
     right, and returns the first element that PRED returns true on.
     If no element satisfies PRED, `#f' is returned.

 -- Function: find-tail pred clist
     [SRFI-1] Applies PRED for each element of CLIST, from left to
     right, and when PRED returns a true value, returns the pair whose
     car is the element.  If no element satisfies PRED, `#f' is
     returned.

 -- Function: take-while pred clist
 -- Function: take-while! pred list
     [SRFI-1] Returns the longest initial prefix of CLIST whose
     elements all satisfy PRED.

 -- Function: drop-while pred clist
     [SRFI-1] Drops the longest initial prefix of CLIST whose elements
     all satisfy PRED, and returns the rest.

 -- Function: span pred clist
 -- Function: span! pred list
 -- Function: break pred clist
 -- Function: break! pred list
     [SRFI-1] `span' is equivalent to `(values (take-while pred clist)
     (drop-while pred clist))'.  `break' inverts the sense of PRED.

 -- Function: any pred clist1 clist2 ...
     [SRFI-1] Applies PRED across each element of CLISTs, and returns
     as soon as PRED returns a non-false value.  The return value of
     `any' is the non-false value PRED returned.  If CLISTs are
     exhausted before PRED returns a non-false value, `#f' is returned.

 -- Function: every pred clist1 clist2 ...
     [SRFI-1] Applies PRED across each element of CLISTs, and returns
     `#f' as soon as PRED returns `#f'.  If all application of PRED
     return a non-false value, `every' returns the last result of the
     applications.

 -- Function: list-index pred clist1 clist2 ...
     [SRFI-1] Returns the index of the leftmost element that satisfies
     PRED.  If no element satisfies PRED, `#f' is returned.


File: gauche-refe.info,  Node: SRFI-1 Deletion,  Next: SRFI-1 Association lists,  Prev: SRFI-1 Searching,  Up: List library

10.2.8 List deletion
--------------------

 -- Function: delete x list &optional elt=
 -- Function: delete! x list &optional elt=
     [SRFI-1] Equivalent to
            (remove (lambda (y) (elt= x y)) list)
            (remove! (lambda (y) (elt= x y)) list)
     The comparison procedure, ELT=, defaults to `equal?'.

 -- Function: delete-duplicates list &optional elt=
 -- Function: delete-duplicates! list &optional elt=
     [SRFI-1] Removes duplicate elements from LIST.  If there are
     multiple equal elements in LIST, the result list only contains the
     first or leftmost of these elements in the result. The order of
     these surviving elements is the same as in the original list.  The
     comparison procedure, ELT=, defaults to `equal?'.


File: gauche-refe.info,  Node: SRFI-1 Association lists,  Next: SRFI-1 Set operations,  Prev: SRFI-1 Deletion,  Up: List library

10.2.9 Association lists
------------------------

 -- Function: alist-cons key datum alist
     [SRFI-1] Returns `(cons (cons KEY DATUM) ALIST)'.  This is an
     alias of the Gauche builtin procedure `acons'.

 -- Function: alist-copy alist
     [SRFI-1] Returns a fresh copy of ALIST.  The spine of ALIST and
     each cell that points a key and a value is copied.
          (define a (list (cons 'a 'b) (cons 'c 'd)))
          a => ((a . b) (c . d))

          (define b (alist-copy a))
          b => ((a . b) (c . d))

          (set-cdr! (car a) 'z)
          a => ((a . z) (c . d))
          b => ((a . b) (c . d))

 -- Function: alist-delete key alist &optional =
 -- Function: alist-delete! key alist &optional =
     [SRFI-1] Deletes all cells in ALIST whose key is the same as KEY.
     Comparison is done by a procedure =.  The default is `eqv?'.

     The linear-update version `alist-delete!' may or may not modify
     ALIST.


File: gauche-refe.info,  Node: SRFI-1 Set operations,  Prev: SRFI-1 Association lists,  Up: List library

10.2.10 Lists as sets
---------------------

These procedures use a list as a set, that is, the elements in a list
matter, but their order doesn't.

   All procedures in this category takes a comparison procedure ELT=,
as the first argument, which is used to determine two elements in the
given sets are the same.

   See also *note Combination library::, which concerns combinations of
elements in the set.

 -- Function: lset<= elt= list1 ...
     [SRFI-1] Returns `#t' iff all elements in LIST1 are also included
     in LIST2, and so on.  If no lists are given, or a single list is
     given, `#t' is returned.

 -- Function: lset= elt= list1 list2 ...
     [SRFI-1] Returns `#t' if all elements in LIST1 are in LIST2, and
     all elements in LIST2 are in LIST1, and so on.

          (lset= eq? '(b e a) '(a e b) '(e e b a)) => #t

 -- Function: lset-adjoin elt= list elt ...
     [SRFI-1] Adds ELT ... to the set LIST, if each one is not already
     a member of LIST.  (The order doesn't matter).

          (lset-adjoin eq? '(a b c) 'a 'e) => '(e a b c)

 -- Function: lset-union elt= list1 ...
     [SRFI-1] Returns the union of the sets LIST1 ....

 -- Function: lset-intersection elt= list1 list2 ...
     [SRFI-1] Returns a set of elements that are in every LISTs.

 -- Function: lset-difference elt= list1 list2 ...
     [SRFI-1] Returns a set of elements that are in LIST1 but not in
     LIST2.  In n-ary case, binary differece operation is simply folded.

 -- Function: lset-xor elt= list1 ...
     [SRFI-1] Returns the exclusive-or of given sets; that is, the
     returned set consists of the elements that are in either LIST1 or
     LIST2, but not in both.   In n-ary case, binary xor operation is
     simply folded.

 -- Function: lset-diff+intersection elt= list1 list2 ...
     [SRFI-1] Returns two sets, a difference and an intersection of
     given sets.

 -- Function: lset-union! elt= list ...
 -- Function: lset-intersection! elt= list1 list2 ...
 -- Function: lset-difference! elt= list1 list2 ...
 -- Function: lset-xor! elt= list1 ...
 -- Function: lset-diff+intersection! elt= list1 list2 ...
     [SRFI-1] Linear update variant of the corresponding procedures.
     The cells in the first list argument may be reused to construct
     the result.


File: gauche-refe.info,  Node: Homogeneous vectors,  Next: A compatible let form with signatures and rest arguments,  Prev: List library,  Up: Library modules - SRFIs

10.3 `srfi-4' - Homogeneous vectors
===================================

 -- Module: srfi-4
     SRFI-4 is now implemented in `gauche.uvector' module *Note Uniform
     vectors::.  This module simply inherits `gauche.uvector' for
     backward-compatibility.


File: gauche-refe.info,  Node: A compatible let form with signatures and rest arguments,  Next: Feature-based program configuration language,  Prev: Homogeneous vectors,  Up: Library modules - SRFIs

10.4 `srfi-5' - A compatible let form with signatures and rest arguments
========================================================================

 -- Module: srfi-5
     This module provides srfi-5's extended `let' syntax.

 -- Macro: let ((var val) ... [. (rest val ...)]) body ...
 -- Macro: let name ((var val) ... [. (rest val ...)]) body ...
 -- Macro: let (name (var val) ... [. (rest val ...)]) body ...
     [SRFI-5] The `let' syntax is extended in two ways.

        * The extended `let' syntax accepts the NAME identifier (for
          named let syntax) within the list of bindings (as in the third
          syntax above).

        * The extended `let' syntax accepts the rest parameter binding
          which works like the rest paremter in the `lambda' syntax.

     See SRFI-5 document for rationale of this extension.


File: gauche-refe.info,  Node: Feature-based program configuration language,  Next: Record types,  Prev: A compatible let form with signatures and rest arguments,  Up: Library modules - SRFIs

10.5 `srfi-7' - Feature-based program configuration language
============================================================

 -- Module: srfi-7
     This module provides a program configuration metalanguage
     (`program' form) defined in srfi-7.  Gauche autoloads srfi-7
     module, so you don't need to say `(use srfi-7)' explicitly.  Note
     that the `program' form isn't necessary to be a Scheme expression.
     Srfi-7 allows an implementation to preprocess the `program' form
     to produce a Scheme program, then executes it with different means.
     Gauche implements `program' form as a macro, so it can evaluates
     the form directly.  Nonetheless, it doesn't make sense to mix
     `program' form and other forms in one file, or expecting a return
     value of `program' form.  A typical usage of `program' form is to
     prepare a single file which just contains `program' form.  (It can
     load other files using `files' clause (see below) within the
     `program' form.)   To execute such a program file in Gauche, you
     can just load it.

 -- Configuration Language: program program-clause program-clause2 ...
     [SRFI-7] This is a configuration language to structure a Scheme
     program, based on availability of the features.

     A Scheme program is constructed from the `program' form.  Gauche
     evaluates the constructed Scheme program on-the-fly.

     Each PROGRAM-CLAUSE needs to be one of the "Program Clauses" below.

 -- Program Clause: requires feature-id feature-id2 ...
     [SRFI-7] The FEATURE-ID's are the same as `srfi-0''s (*Note
     Feature conditional::).  It tells that the following code requires
     these FEATURE-ID's.

     If a feature-id which is not supported in Gauche is given, an
     error is signaled.

 -- Program Clause: files filename ...
     [SRFI-7] Inserts the content of the FILENAMEs into a program.  In
     Gauche, this clause just causes FILENAMEs to be loaded into the
     current module.

 -- Program Clause: code scheme-expression ...
     [SRFI-7] The SCHEME-EXPRESSIONs are inserted into a program.

 -- Program Clause: feature-cond clause clause2 ...
     [SRFI-7] CLAUSE is a following form:
          (REQUIREMENT PROGRAM-CLAUSE PROGRAM-CLAUSE2 ...)

     Where REQUIREMENT should be one of the following:
        * FEATURE-ID

        * `(and REQUIREMENT ...)'

        * `(or REQUIREMENT ...)'

        * `(not REQUIREMENT)'

     The REQUIREMENT of the last CLAUSE may be `else'.

     Gauche checks each REQUIREMENT one by one, and if it finds a
     fulfilled REQUIREMENT, inserts the PROGRAM-CLAUSEs in that CLAUSE
     into the program.


File: gauche-refe.info,  Node: Record types,  Next: Let-values,  Prev: Feature-based program configuration language,  Up: Library modules - SRFIs

10.6 `srfi-9' - Record types
============================

 -- Module: srfi-9
     Contains a macro to use record types.  A record type is
     implemented on top of Gauche's object system.

     The SRFI-9 record type is not as powerful as the object system, but
     it will be useful if you want your program to be portable.

     See also *note SLIB-compatible record type::, which provides an
     SCM-compatible procedural interface of record types.

 -- Macro: define-record-type name (constructor init-tag ...) predicate
          (field accessor [modifier]) ...
     Creates a record type and binds it to NAME.  In Gauche, a record
     type is just a subclass of `<record>'.

     CONSTRUCTOR is bound to a procedure that creates an instance of
     the record type, which takes as many arguments as INIT-TAG ....
     Each INIT-TAG corresponds to one of the field name, and the fields
     of the created record instance is initialized accordingly.  Not all
     of fields need to appear in INIT-TAG; uninitialized fields remain
     unbound.

     PREDICATE is bound to a procedure that takes one argument, and
     returns #t if the argument is an instance of the defined record
     type, #f otherwise.

     Followings are field specifications.  The record has fields FIELD
     ..., and each field can be accessed by a method ACCESSOR.  If
     MODIFIER is given to the field, it is bound to a method that sets
     the value to the field.

     Example:
          (define-record-type pare
            (kons x y) pare?
            (x kar set-kar!)
            (y kdr))
           => #<class pare>

          (pare? (kons 2 3)) => #t
          (pare? (cons 2 3)) => #f

          (kar (kons 2 3)) => 2
          (kdr (kons 2 3)) => 3

          (let ((x (kons 2 3)))
            (set-kar! x -1)
            (kar x)) => -1

     Conceptually, the above example is expanded into the following
     sequence of forms.
          (define-class pare (<record>) (x y))
          (define (kons x y)
            (let ((obj (make pare)))
              (slot-set! obj 'x x)
              (slot-set! obj 'y y)
              obj))
          (define (pare? obj) (is-a? obj pare))
          (define-method kar ((obj pare))
            (slot-ref obj 'x))
          (define-method set-kar! ((obj pare) value)
            (slot-set! obj 'x value))
          (define-method kdr ((obj pare))
            (slot-ref obj 'y))



File: gauche-refe.info,  Node: Let-values,  Next: String library,  Prev: Record types,  Up: Library modules - SRFIs

10.7 `srfi-11' - Let-values
===========================

 -- Module: srfi-11
     Defines two macros, `let-values' and `let*-values'.  They are
     convenient to use with multiple values (*note [SRFI-11]: srfi-11.).


 -- Macro: let-values ((vars expr) ...) body ...
     [SRFI-11] VARS are a list of variables. EXPR is evaluated, and its
     first return value is bound to the first variable in VARS, its
     second return value to the second variable, and so on, then BODY
     is evaluated.  The scope of EXPRs are the outside of `let-values'
     form, like `let'.

          (let-values (((a b) (values 1 2))
                       ((c d) (values 3 4)))
            (list a b c d)) => (1 2 3 4)

          (let ((a 1) (b 2) (c 3) (d 4))
            (let-values (((a b) (values c d))
                         ((c d) (values a b)))
              (list a b c d))) => (3 4 1 2)

     VARS can be a dotted list or a single symbol, like the lambda
     parameters.

          (let-values (((x . y) (values 1 2 3 4)))
            y) => (2 3 4)

          (let-values ((x (values 1 2 3 4)))
            x) => (1 2 3 4)

     If the number of values returned by EXPR doesn't match what VARS
     expects, an error is signalled.

 -- Macro: let*-values ((vars expr) ...) body ...
     [SRFI-11] Same as `let-values', but each EXPR's scope includes the
     preceding VARS.

          (let ((a 1) (b 2) (c 3) (d 4))
            (let*-values (((a b) (values c d))
                          ((c d) (values a b)))
              (list a b c d))) => (3 4 3 4)


File: gauche-refe.info,  Node: String library,  Next: Character-set library,  Prev: Let-values,  Up: Library modules - SRFIs

10.8 `srfi-13' - String library
===============================

 -- Module: srfi-13
     Defines a large set of string-related functions.  In Gauche, those
     functions are splitted to number of files and the form `(use
     srfi-13)' merely sets up autoloading of those files.  So it is not
     likely to slow down the script startup.  See SRFI-13 (*note
     [SRFI-13]: srfi-13.)  for the detailed specification and
     discussion of design issues.  This manual serves as a reference of
     function API.  Some SRFI-13 functions are Gauche built-in and not
     listed here.  Note: SRFI-13 documents suggests the name of the
     module that implements these functions to be "string-lib" and
     "string-lib-internals".  Gauche uses the name "srfi-13" for
     consistency.

* Menu:

* SRFI-13 General conventions::
* SRFI-13 String predicates::
* SRFI-13 String Constructors::
* SRFI-13 String Selection::
* SRFI-13 String Comparison::
* SRFI-13 String Prefixes & Suffixes::
* SRFI-13 String searching::
* SRFI-13 String case mapping::
* SRFI-13 String reverse & append::
* SRFI-13 String mapping::
* SRFI-13 String rotation::
* SRFI-13 other string operations::
* SRFI-13 String filtering::
* SRFI-13 Low-level string procedures::


File: gauche-refe.info,  Node: SRFI-13 General conventions,  Next: SRFI-13 String predicates,  Prev: String library,  Up: String library

10.8.1 General conventions
--------------------------

There are a few common factors in string library API, which I don't
repeat in each function description

_argument convention_
     The following argument names imply their types.
    S, S1, S2
          Those arguments must be strings.

    CHAR/CHAR-SET/PRED
          This argument can be a character, a character-set object, or
          a predicate that takes a single character and returns a
          boolean value.  "Applying CHAR/CHAR-SET/PRED to a character"
          means, if CHAR/CHAR-SET/PRED is a character, it is compared
          to the given character; if CHAR/CHAR-SET/PRED is a character
          set, it is checked if the character set contains the given
          character; if CHAR/CHAR-SET/PRED is a procedure, it is applied
          to the given character.  "A character satisfies
          CHAR/CHAR-SET/PRED" means such application to the character
          yields true value.

    START, END
          Lots of SRFI-13 functions takes these two optional arguments,
          which limit the area of input string from START-th character
          (inclusive) to END-th character (exclusive), where the
          operation is performed.  When specified, the condition 0 <=
          START <= END <= LENGTH OF THE STRING must be satisfied.
          Default value of START and END is 0 and the length of the
          string, respectively.

_`shared' variant_
     Some functions have variants with "/shared" attached to its name.
     SRFI-13 defines those functions to allow to share the part of input
     string, for better performance.  Gauche doesn't have a concept of
     shared string, and these functions are mere synonyms of their
     non-shared variants.  However, Gauche _internally_ shares the
     storage of strings, so generally you don't need to worry about the
     overhead of copying substrings.

_`right' variant_
     Most functions works from left to right of the input string.  Some
     functions have variants with "-right" to its name, that works from
     right to left.



File: gauche-refe.info,  Node: SRFI-13 String predicates,  Next: SRFI-13 String Constructors,  Prev: SRFI-13 General conventions,  Up: String library

10.8.2 String predicates
------------------------

 -- Function: string-null? s
     [SRFI-13] Returns `#t' if S is an empty string, `""'.

 -- Function: string-every char/char-set/pred s &optional start end
     [SRFI-13] Sees if every character in S satisfies
     CHAR/CHAR-SET/PRED.  If so, `string-every' returns the value that
     is returned at the last application of CHAR/CHAR-SET/PRED.  If any
     of the application returns `#f', `string-every' returns `#f'
     immediately.

 -- Function: string-any char/char-set/pred s &optional start end
     [SRFI-13] Sees if any character in S satisfies CHAR/CHAR-SET/PRED.
     If so, `string-any' returns the value that is returned by the
     application.   If no character satisfies CHAR/CHAR-SET/PRED, `#f'
     is returned.


File: gauche-refe.info,  Node: SRFI-13 String Constructors,  Next: SRFI-13 String Selection,  Prev: SRFI-13 String predicates,  Up: String library

10.8.3 String Constructors
--------------------------

 -- Function: string-tabulate proc len
     [SRFI-13] PROC must be a procedure that takes an integer argument
     and returns a character.  `string-tabulate' creates a string,
     whose I-th character is calculated by `(proc i)'.
          (string-tabulate
            (lambda (i) (integer->char (+ i #x30))) 10)
           => "0123456789"


 -- Function: reverse-list->string char-list
     [SRFI-13] == `(list->string (reverse char-list))'.


File: gauche-refe.info,  Node: SRFI-13 String Selection,  Next: SRFI-13 String Comparison,  Prev: SRFI-13 String Constructors,  Up: String library

10.8.4 String selection
-----------------------

 -- Function: substring/shared s start &optional end
     [SRFI-13] In Gauche, this is the same as `substring', except that
     the END argument is optional.
          (substring/shared "abcde" 2) => "cde"

 -- Function: string-copy! target tstart s &optional start end
     [SRFI-13] Copies a string S into a string TARGET from the position
     TSTART.  Optional START and END arguments limits the range of S.
     If the copied string run over the end of TARGET, an error is
     signalled.
          (define s (string-copy "abcde"))
          (string-copy! s 2 "ZZ")
          s => "abZZe"

 -- Function: string-take s nchars
 -- Function: string-drop s nchars
 -- Function: string-take-right s nchars
 -- Function: string-drop-right s nchars
     [SRFI-13] Returns the first NCHARS-character string of S
     (`string-take') or the string without first NCHARS
     (`string-drop').  The `*-right' variation counts from the end of
     string.  It is guaranteed that the returned string is always a
     copy of S, even no character is dropped.
          (string-take "abcde" 2) => "ab"
          (string-drop "abcde" 2) => "cde"

          (string-take-right "abcde" 2) => "de"
          (string-drop-right "abcde" 2) => "abc"

 -- Function: string-pad s len &optional char start end
 -- Function: string-pad-right s len &optional char start end
     [SRFI-13] If a string S is shorter than LEN, returns a string of
     LEN where CHAR is padded to the left or right, respectively.  If S
     is longer than LEN, the rightmost or leftmost LEN chars are taken.
     CHAR defaults to `#\space'.  If START and END are provided, the
     substring of S is used as the source.

          (string-pad "abc" 10)    => "       abc"
          (string-pad "abcdefg" 3) => "efg"

          (string-pad-right "abc" 10) => "abc       "

          (string-pad "abcdefg" 10 #\+ 2 5)
            => "+++++++cde"

 -- Function: string-trim s &optional char/char-set/pred start end
 -- Function: string-trim-right s &optional char/char-set/pred start end
 -- Function: string-trim-both s &optional char/char-set/pred start end
     [SRFI-13] Removes characters that match CHAR/CHAR-SET/PRED from S.
     `String-trim' removes the characters from left of S,
     `string-trim-right' does from right, and `string-trim-both' does
     from both sides.  CHAR/CHAR-SET/PRED defaults to `#[\s]', i.e. a
     char-set of whitespaces.  If START and END are provided, the
     substring of S is used as the source.

          (string-trim "   abc  ")       => "abc  "
          (string-trim-right "   abc  ") => "   abc"
          (string-trim-both "   abc  ")  => "abc"


File: gauche-refe.info,  Node: SRFI-13 String Comparison,  Next: SRFI-13 String Prefixes & Suffixes,  Prev: SRFI-13 String Selection,  Up: String library

10.8.5 String comparison
------------------------

 -- Function: string-compare s1 s2 proc< proc= proc> &optional start1
          end1 start2 end2
 -- Function: string-compare-ci s1 s2 proc< proc= proc> &optional
          start1 end1 start2 end2
     [SRFI-13]

 -- Function: string= s1 s2 &optional start1 end1 start2 end2
 -- Function: string`<>' s1 s2 &optional start1 end1 start2 end2
 -- Function: string`<' s1 s2 &optional start1 end1 start2 end2
 -- Function: string`<=' s1 s2 &optional start1 end1 start2 end2
 -- Function: string`>' s1 s2 &optional start1 end1 start2 end2
 -- Function: string`>=' s1 s2 &optional start1 end1 start2 end2
     [SRFI-13]

 -- Function: string-ci`=' s1 s2 &optional start1 end1 start2 end2
 -- Function: string-ci`<>' s1 s2 &optional start1 end1 start2 end2
 -- Function: string-ci`<' s1 s2 &optional start1 end1 start2 end2
 -- Function: string-ci`<=' s1 s2 &optional start1 end1 start2 end2
 -- Function: string-ci`>' s1 s2 &optional start1 end1 start2 end2
 -- Function: string-ci`>=' s1 s2 &optional start1 end1 start2 end2
     [SRFI-13]

 -- Function: string-hash s &optional bound start end
 -- Function: string-hash-ci s &optional bound start end
     [SRFI-13]


File: gauche-refe.info,  Node: SRFI-13 String Prefixes & Suffixes,  Next: SRFI-13 String searching,  Prev: SRFI-13 String Comparison,  Up: String library

10.8.6 String Prefixes & Suffixes
---------------------------------

 -- Function: string-prefix-length s1 s2 &optional start1 end1 start2
          end2
 -- Function: string-suffix-length s1 s2 &optional start1 end1 start2
          end2
 -- Function: string-prefix-length-ci s1 s2 &optional start1 end1
          start2 end2
 -- Function: string-suffix-length-ci s1 s2 &optional start1 end1
          start2 end2
     [SRFI-13]

 -- Function: string-prefix? s1 s2 &optional start1 end1 start2 end2
 -- Function: string-suffix? s1 s2 &optional start1 end1 start2 end2
 -- Function: string-prefix-ci? s1 s2 &optional start1 end1 start2 end2
 -- Function: string-suffix-ci? s1 s2 &optional start1 end1 start2 end2
     [SRFI-13]


File: gauche-refe.info,  Node: SRFI-13 String searching,  Next: SRFI-13 String case mapping,  Prev: SRFI-13 String Prefixes & Suffixes,  Up: String library

10.8.7 String searching
-----------------------

 -- Function: string-index s char/char-set/pred &optional start end
 -- Function: string-index-right s char/char-set/pred &optional start
          end
     [SRFI-13] Looks for the first element in a string S that matches
     CHAR/CHAR-SET/PRED, and returns its index.  If CHAR/CHAR-SET/PRED
     is not found in S, returns `#f'.  Optional START and END limit the
     range of S to search.
          (string-index "Aloha oe" #\a) => 4
          (string-index "Aloha oe" #[Aa]) => 0
          (string-index "Aloha oe" #[\s]) => 5
          (string-index "Aloha oe" char-lower-case?) => 1
          (string-index "Aloha oe" #\o 3) => 6

     See also the Gauche built-in procedure `string-scan' (*note String
     utilities::), if you need speed over portability.

 -- Function: string-skip s char/char-set/pred &optional start end
 -- Function: string-skip-right s char/char-set/pred &optional start end
     [SRFI-13] Looks for the first element that does not match
     CHAR/CHAR-SET/PRED and returns its index.  If such element is not
     found, returns `#f'.  Optional START and END limit the range of S
     to search.

 -- Function: string-count s char/char-set/pred &optional start end
     [SRFI-13] Counts the number of elements in S that matches
     CHAR/CHAR-SET/PRED.  Optional START and END limit the range of S
     to search.

 -- Function: string-contains s1 s2 &optional start1 end1 start2 end2
 -- Function: string-contains-ci s1 s2 &optional start1 end1 start2 end2
     [SRFI-13] Looks for a string S2 inside another string S1.  If
     found, returns an index in S1 from where the matching string
     begins.  Returns `#f' otherwise.  Optional START1, END1, START2
     and END2 limits the range of S1 and S2.

     See also the Gauche built-in procedure `string-scan' (*note String
     utilities::), if you need speed over portability.


File: gauche-refe.info,  Node: SRFI-13 String case mapping,  Next: SRFI-13 String reverse & append,  Prev: SRFI-13 String searching,  Up: String library

10.8.8 String case mapping
--------------------------

 -- Function: string-titlecase s &optional start end
 -- Function: string-titlecase! s &optional start end
     [SRFI-13]

 -- Function: string-upcase s &optional start end
 -- Function: string-upcase! s &optional start end
     [SRFI-13]

 -- Function: string-downcase s &optional start end
 -- Function: string-downcase! s &optional start end
     [SRFI-13]


File: gauche-refe.info,  Node: SRFI-13 String reverse & append,  Next: SRFI-13 String mapping,  Prev: SRFI-13 String case mapping,  Up: String library

10.8.9 String reverse & append
------------------------------

 -- Function: string-reverse s &optional start end
 -- Function: string-reverse! s &optional start end
     [SRFI-13] Returns a string in which the character positions are
     reversed from S.  `string-reverse!' modifies S.
          (string-reverse "mahalo") => "olaham"
          (string-reverse "mahalo" 3) => "ola"
          (string-reverse "mahalo" 1 4) => "aha"

          (let ((s (string-copy "mahalo")))
            (string-reverse! s 1 5)
            s)
            => "mlahao"

 -- Function: string-concatenate string-list
     [SRFI-13] Concatenates list of strings.
          (string-concatenate '("humuhumu" "nukunuku" "apua" "`a"))
            => "humuhumunukunukuapua`a"

 -- Function: string-concatenate/shared string-list
 -- Function: string-append/shared s ...
     [SRFI-13] "Shared" version of `string-concatenate' and
     `string-append'.  In Gauche, these are just synonyms of them.

 -- Function: string-concatenate-reverse string-list
 -- Function: string-concatenate-reverse/shared string-list
     [SRFI-13] Reverses STRING-LIST before concatenation.  "Shared"
     version works the same in Gauche.


File: gauche-refe.info,  Node: SRFI-13 String mapping,  Next: SRFI-13 String rotation,  Prev: SRFI-13 String reverse & append,  Up: String library

10.8.10 String mapping
----------------------

 -- Function: string-map proc s &optional start end
 -- Function: string-map! proc s &optional start end
     [SRFI-13] `string-map' applies PROC on every character of S, and
     collects the results into a string and returns it.  On the other
     hand, `string-map!' modifies S.
          (string-map char-upcase "wikiwiki") => "WIKIWIKI"
          (string-map char-upcase "wikiwiki" 4) => "WIKI"

          (let ((s (string-copy "wikiwiki")))
            (string-map! char-upcase s 4)
            s)
            => "wikiWIKI"

 -- Function: string-fold kons knil s &optional start end
 -- Function: string-fold-right kons knil s &optional start end
     [SRFI-13]

 -- Function: string-unfold p f g seed &optional base make-final
     [SRFI-13]

 -- Function: string-unfold-right p f g seed &optional base make-final
     [SRFI-13]

 -- Function: string-for-each proc s &optional start end
     [SRFI-13]

 -- Function: string-for-each-index proc s &optional start end
     [SRFI-13]


File: gauche-refe.info,  Node: SRFI-13 String rotation,  Next: SRFI-13 other string operations,  Prev: SRFI-13 String mapping,  Up: String library

10.8.11 String rotation
-----------------------

 -- Function: xsubstring s from &optional to start end
     [SRFI-13]

 -- Function: string-xcopy! target tstart s sfrom &optional sto start
          end
     [SRFI-13]


File: gauche-refe.info,  Node: SRFI-13 other string operations,  Next: SRFI-13 String filtering,  Prev: SRFI-13 String rotation,  Up: String library

10.8.12 Other string operations
-------------------------------

 -- Function: string-replace s1 s2 start1 end1 &optional start2 end2
     [SRFI-13] Returns a new string whose content is a copy of a string
     S1, except the part beginning from the index START1 (inclusive)
     and ending at the index END1 (exclusive) are replaced by a string
     S2.   When optional START2 and END2 arguments are given, S2 is
     trimmed first according to them.  The size of the _gap_, `(- END1
     START1)', doesn't need to be the same as the size of the inserted
     string.  Effectively, this is the same as the following code.

          (string-append (substring s1 0 start1)
                         (substring s2 start2 end2)
                         (substring s1 end1 (string-length s1)))


 -- Function: string-tokenize s &optional token-set start end
     [SRFI-13] Splits the string S into a list of substrings, where
     each substring is a maximal non-empty contiguous sequence of
     characters from the character set TOKEN-SET.  The default of
     TOKEN-SET is `char-set:graphic' (*Note SRFI-14 Predefined
     character-set::).

     See also Gauche's built-in `string-split' (*Note String
     utilities::), which provides similar features but different
     criteria.


File: gauche-refe.info,  Node: SRFI-13 String filtering,  Next: SRFI-13 Low-level string procedures,  Prev: SRFI-13 other string operations,  Up: String library

10.8.13 String filtering
------------------------

 -- Function: string-filter s char/char-set/pred &optional start end
 -- Function: string-delete s char/char-set/pred &optional start end
     [SRFI-13]


File: gauche-refe.info,  Node: SRFI-13 Low-level string procedures,  Prev: SRFI-13 String filtering,  Up: String library

10.8.14 Low-level string procedures
-----------------------------------

 -- Function: string-parse-start+end proc s args
 -- Function: string-parse-final-start+end proc s args
     [SRFI-13]

 -- Macro: let-string-start+end (start end [rest]) proc-exp s-exp
          args-exp body ...
     [SRFI-13]

 -- Function: check-substring-spec proc s start end
 -- Function: substring-spec-ok? s start end
     [SRFI-13]

 -- Function: make-kmp-restart-vector s &optional c= start end
     [SRFI-13]

 -- Function: kmp-step pat rv c i c= p-start
     [SRFI-13]

 -- Function: string-kmp-partial-search pat rv s i &optional c= p-start
          s-start s-end
     [SRFI-13]


File: gauche-refe.info,  Node: Character-set library,  Next: Time data types and procedures,  Prev: String library,  Up: Library modules - SRFIs

10.9 `srfi-14' - Character-set library
======================================

 -- Module: srfi-14
     Implements the character set library defined in SRFI-14 (*note
     SRFI-14: srfi-14.).  Note that several basic character-set
     operations are Gauche's build-in functions.  *Note Character set::.

* Menu:

* SRFI-14 Character-set constructors::
* SRFI-14 Character-set Comparison::
* SRFI-14 Character-set iteration::
* SRFI-14 Character-set query::
* SRFI-14 Character-set algebra::
* SRFI-14 Predefined character-set::


File: gauche-refe.info,  Node: SRFI-14 Character-set constructors,  Next: SRFI-14 Character-set Comparison,  Prev: Character-set library,  Up: Character-set library

10.9.1 Character-set constructors
---------------------------------

 -- Function: list->char-set char-list &optional base-cs
 -- Function: list->char-set! char-list base-cs
     [SRFI-14] Constructs a character set from a list of characters
     CHAR-LIST.  If BASE-CS is given, it must be a character set, and
     the characters in it are added to the result character set.
     `List->char-set!' is allowed, but not required, to reuse BASE-CS
     to store the result.

 -- Function: string->char-set s &optional base-cs
 -- Function: string->char-set! s base-cs
     [SRFI-14] Like `list->char-set' and `list->char-set!', but take a
     list of characters from a string S.

 -- Function: char-set-filter pred char-set &optional base-cs
 -- Function: char-set-filter! pred char-set base-cs
     [SRFI-14] Returns a character set containing every character C in
     CHAR-SET such that `(PRED C)' returns true.  If a character set
     BASE-CS is given, its content is added to the result.  The linear
     update version `char-set-filter!' is allowed, but not required, to
     modify BASE-CS to store the result.

 -- Function: ucs-range->char-set lower upper &optional error? base-cs
 -- Function: ucs-range->char-set! lower upper error? base-cs
     [SRFI-14]


 -- Function: integer-range->char-set lower upper &optional error?
          base-cs
 -- Function: integer-range->char-set! lower upper error? base-cs

 -- Function: ->char-set x
     [SRFI-14]


File: gauche-refe.info,  Node: SRFI-14 Character-set Comparison,  Next: SRFI-14 Character-set iteration,  Prev: SRFI-14 Character-set constructors,  Up: Character-set library

10.9.2 Character-set comparison
-------------------------------

 -- Function: char-set= char-set1 ...
     [SRFI-14]

 -- Function: char-set`<=' char-set1 ...
     [SRFI-14]

 -- Function: char-set-hash char-set &optional bound
     [SRFI-14]


File: gauche-refe.info,  Node: SRFI-14 Character-set iteration,  Next: SRFI-14 Character-set query,  Prev: SRFI-14 Character-set Comparison,  Up: Character-set library

10.9.3 Character-set iteration
------------------------------

 -- Function: char-set-cursor char-set
     [SRFI-14]

 -- Function: char-set-ref char-set cursor
     [SRFI-14]

 -- Function: char-set-cursor-next char-set cursor
     [SRFI-14]

 -- Function: end-of-char-set? ccursor
     [SRFI-14]

 -- Function: char-set-fold kons knil char-set
     [SRFI-14]

 -- Function: char-set-unfold pred fun gen seed &optional base-char-set
 -- Function: char-set-unfold! pred fun gen seed base-char-set
     [SRFI-14]

 -- Function: char-set-for-each proc char-set
     [SRFI-14]

 -- Function: char-set-map proc char-set
     [SRFI-14]


File: gauche-refe.info,  Node: SRFI-14 Character-set query,  Next: SRFI-14 Character-set algebra,  Prev: SRFI-14 Character-set iteration,  Up: Character-set library

10.9.4 Character-set query
--------------------------

 -- Function: char-set-size char-set
     [SRFI-14]

 -- Function: char-set-count pred char-set
     [SRFI-14]

 -- Function: char-set->list char-set
     [SRFI-14]

 -- Function: char-set->string char-set
     [SRFI-14]

 -- Function: char-set-every pred char-set
     [SRFI-14]

 -- Function: char-set-any pred char-set
     [SRFI-14]


File: gauche-refe.info,  Node: SRFI-14 Character-set algebra,  Next: SRFI-14 Predefined character-set,  Prev: SRFI-14 Character-set query,  Up: Character-set library

10.9.5 Character-set algebra
----------------------------

 -- Function: char-set-adjoin char-set char1 ...
 -- Function: char-set-adjoin! char-set char1 ...
     [SRFI-14] Returns a character set that adds CHAR1 ... to CHAR-SET.

 -- Function: char-set-delete char-set char1 ...
 -- Function: char-set-delete! char-set char1 ...
     [SRFI-14]

 -- Function: char-set-complement char-set
 -- Function: char-set-complement! char-set
     [SRFI-14]

 -- Function: char-set-union char-set ...
 -- Function: char-set-union! char-set1 char-set2 ...
     [SRFI-14]

 -- Function: char-set-intersection char-set ...
 -- Function: char-set-intersection! char-set1 char-set2 ...
     [SRFI-14]

 -- Function: char-set-difference char-set1 char-set2 ...
 -- Function: char-set-difference! char-set1 char-set2 ...
     [SRFI-14]

 -- Function: char-set-xor char-set ...
 -- Function: char-set-xor! char-set1 char-set2 ...
     [SRFI-14]

 -- Function: char-set-diff+intersection char-set1 char-set2 ...
 -- Function: char-set-diff+intersection! char-set1 char-set2 char-set3
          ...
     [SRFI-14]


File: gauche-refe.info,  Node: SRFI-14 Predefined character-set,  Prev: SRFI-14 Character-set algebra,  Up: Character-set library

10.9.6 Predefined character-set
-------------------------------

 -- Variable: char-set:letter
     [SRFI-14]

 -- Variable: char-set:blank
     [SRFI-14]

 -- Variable: char-set:iso-control
     [SRFI-14]

 -- Variable: char-set:digit
 -- Variable: char-set:hex-digit
     [SRFI-14]

 -- Variable: char-set:graphic
     [SRFI-14]

 -- Variable: char-set:lower-case
 -- Variable: char-set:upper-case
 -- Variable: char-set:title-case
     [SRFI-14]

 -- Variable: char-set:printing
     [SRFI-14]

 -- Variable: char-set:punctuation
     [SRFI-14]

 -- Variable: char-set:whitespace
     [SRFI-14]

 -- Variable: char-set:symbol
     [SRFI-14]

 -- Variable: char-set:ascii
     [SRFI-14]

 -- Variable: char-set:empty
     [SRFI-14]

 -- Variable: char-set:full
     [SRFI-14]


File: gauche-refe.info,  Node: Time data types and procedures,  Next: Sources of random bits,  Prev: Character-set library,  Up: Library modules - SRFIs

10.10 `srfi-19' - Time data types and procedures
================================================

 -- Module: srfi-19
     This SRFI defines various representations of time and date, and
     conversion methods among them.

     On Gauche, time object is supported natively by `<time>' class
     (*Note Time::).  Date object is supported by `<date>' class
     described below.

* Menu:

* SRFI-19 Time types::
* SRFI-19 Time queries::
* SRFI-19 Time procedures::
* SRFI-19 Date::
* SRFI-19 Date reader and writer::


File: gauche-refe.info,  Node: SRFI-19 Time types,  Next: SRFI-19 Time queries,  Prev: Time data types and procedures,  Up: Time data types and procedures

10.10.1 Time types
------------------

Time type is represented by a symbol.  This module defines the
following constant variables that is bound to its name, for convenience.

 -- Constant: time-utc
     [SRFI-19] UTC time.  Gauche's built-in `current-time' always
     returns this type (*Note Time::).

 -- Constant: time-tai
     [SRFI-19] International Atomic Time.  This time is a bit larger
     than UTC, due to the leap seconds.

 -- Constant: time-monotonic
     [SRFI-19] Implementation-dependent monotonically increasing time.
     In Gauche, this is the same as `time-tai'.

 -- Constant: time-duration
     [SRFI-19] Duration between two absolute time points.

 -- Constant: time-process
     [SRFI-19] CPU time in current process.  Gauche calculates this
     from user time and system time returned by POSIX times(3).

 -- Constant: time-thread
     [SRFI-19] CPU time in current thread.  In the current
     implementation, this is the same as `time-process'.


File: gauche-refe.info,  Node: SRFI-19 Time queries,  Next: SRFI-19 Time procedures,  Prev: SRFI-19 Time types,  Up: Time data types and procedures

10.10.2 Time queries
--------------------

 -- Function: current-time &optional time-type
     [SRFI-19] Extends Gauche built-in `current-time' (*Note Time::) to
     take optional TIME-TYPE argument to specify the desired time type.
     TIME-TYPE must be one of the types described in *note SRFI-19 Time
     types::.

 -- Function: current-date &optional tz-offset
     [SRFI-19] Returns the current date as an instance of `<date>' class
     (*Note SRFI-19 Date::).  If TZ-OFFSET is given, it must be an
     offset from UTC in number of seconds.  If TZ-OFFSET is not given,
     returns the date in local time zone.

 -- Function: current-julian-day
     [SRFI-19] Returns the current julian day, a point in time as a
     real number of days since -4714-11-24T12:00:00Z (November 24,
     -4714 at noon, UTC).

 -- Function: current-modified-julian-day
     [SRFI-19] Returns the current modified julian day, a point in time
     as a real number of days since 1858-11-17T00:00:00Z (November 17,
     1858 at midnight, UTC).

 -- Function: time-resolution
     [SRFI-19]


File: gauche-refe.info,  Node: SRFI-19 Time procedures,  Next: SRFI-19 Date,  Prev: SRFI-19 Time queries,  Up: Time data types and procedures

10.10.3 Time procedures
-----------------------

 -- Function: make-time type nanoseconds seconds
     [SRFI-19] Returns an instance of `<time>' class with specified
     initial values.  Equivalent to `(make <time> :type type :second
     seconds :nanosecond nanoseconds)'.

     (This function had been defined incorrectly before release 0.6.8;
     the arguments SECONDS and NANOSECONDS were switched.  Please check
     your code if it uses `make-time').

 -- Function: time-type time
 -- Function: time-second time
 -- Function: time-nanosecond time
 -- Function: set-time-type! time type
 -- Function: set-time-second! time second
 -- Function: set-time-nanosecond! time nanosecond
     [SRFI-19] Getter and setter of `<time>' object slots.

 -- Function: copy-time time
     [SRFI-19] Returns a new instance of `<time>' whose content is the
     same as given TIME

 -- Function: time=? time0 time1
 -- Function: time<? time0 time1
 -- Function: time<=? time0 time1
 -- Function: time>? time0 time1
 -- Function: time>=? time0 time1
     [SRFI-19] Compares two times.  Types of both times must match.

 -- Function: time-difference time0 time1
 -- Function: time-difference! time0 time1
     [SRFI-19] Returns the difference of two times, in `time-duration'
     time.  Types of both times must match.  `Time-difference!'
     modifies TIME0 to store the result.

 -- Function: add-duration time0 time-duration
 -- Function: add-duration! time0 time-duration
 -- Function: subtract-duration time0 time-duration
 -- Function: subtract-duration! time0 time-duration
     [SRFI-19] Adds or subtracts TIME-DURATION to or from TIME0.  Type
     of returned time is the same as TIME0.  Type of TIME-DURATION must
     be `time-duration'.  `add-duration!' and `subtract-duration!' reuse
     TIME0 to store the result.


File: gauche-refe.info,  Node: SRFI-19 Date,  Next: SRFI-19 Date reader and writer,  Prev: SRFI-19 Time procedures,  Up: Time data types and procedures

10.10.4 Date
------------

 -- Class: <date>
     Represents a date.

      -- Instance Variable of <date>: nanosecond
          Nanosecond portion of the date by an integer between 0 and
          999,999,999, inclusive.

      -- Instance Variable of <date>: second
          Second portion of the date by an integer between 0 and 60,
          inclusive.  (60 for leap second).

      -- Instance Variable of <date>: minute
          Minute portion of the date by an integer between 0 and 59,
          inclusive.

      -- Instance Variable of <date>: hour
          Hour portion of the date by an integer between 0 and 23,
          inclusive.

      -- Instance Variable of <date>: day
          Day portion of the date by an integer between 0 and 31,
          inclusive.  The actual upper bound of the day is determined
          by the year and the month.  (Note: 1 is for the first day; 0
          is allowed by the specification, but I don't see why).

      -- Instance Variable of <date>: month
          Month portion of the date by an integer between 1 and 12,
          inclusive.  1 for January, 2 for February, and so on.  (Note:
          this is different from POSIX's `<sys-tm>' convention).

      -- Instance Variable of <date>: year
          Year portion of the date.

      -- Instance Variable of <date>: zone-offset
          The number of seconds east of GMT for this timezone, by an
          integer.

 -- Function: make-date nanosecond second minute hour day month year
          zone-offset
     [SRFI-19] Makes a `<date>' object from the given values.  Note:
     this procedure does not check if the values are in the valid range.

 -- Function: date? obj
     [SRFI-19] Returns true iff OBJ is a `<date>' object.

 -- Function: date-nanosecond date
 -- Function: date-second date
 -- Function: date-minute date
 -- Function: date-hour date
 -- Function: date-day date
 -- Function: date-month date
 -- Function: date-year date
 -- Function: date-zone-offset date
     [SRFI-19] Accessors.

 -- Function: date-year-day date
 -- Function: date-week-day date
 -- Function: date-week-number date day-of-week-starting-week
     [SRFI-19] Calculates the day number in the year (1 for January
     1st), the day number in the week (0 for Sunday, 1 for Monday, ...),
     and the ordinal week of the year which holds this date, ignoring a
     first partial week, respectively.

     DAY-OF-WEEK-STARTING-WEEK is the integer corresponding to the day
     of the week which is to be considered the first day of the week
     (Sunday=0, Monday=1, etc.).

 -- Function: date->julian-day date
 -- Function: date->modified-julian-day date
 -- Function: date->time-monotonic date
 -- Function: date->time-tai date
 -- Function: date->time-utc date
     [SRFI-19] Conversions from date to various date/time types.

 -- Function: julian-day->date jd &optional tz-offset
 -- Function: julian-day->time-monotonic jd
 -- Function: julian-day->time-tai jd
 -- Function: julian-day->time-utc jd
     [SRFI-19] Conversions from julian-day to various date/time types.

 -- Function: modified-julian-day->date jd &optional tz-offset
 -- Function: modified-julian-day->time-monotonic jd
 -- Function: modified-julian-day->time-tai jd
 -- Function: modified-julian-day->time-utc jd
     [SRFI-19] Conversions from modified julian-day to various
     date/time types.

 -- Function: time-monotonic->date time &optional tz-offset
 -- Function: time-monotonic->julian-day time
 -- Function: time-monotonic->modified-julian-day time
 -- Function: time-monotonic->time-tai time
 -- Function: time-monotonic->time-tai! time
 -- Function: time-monotonic->time-utc time
 -- Function: time-monotonic->time-utc! time
     [SRFI-19] Conversions from time-monotonic to various date/time
     types.

 -- Function: time-tai->date time &optional tz-offset
 -- Function: time-tai->julian-day time
 -- Function: time-tai->modified-julian-day time
 -- Function: time-tai->time-monotonic time
 -- Function: time-tai->time-monotonic! time
 -- Function: time-tai->time-utc time
 -- Function: time-tai->time-utc! time
     [SRFI-19] Conversions from time-tai to various date/time types.

 -- Function: time-utc->date time &optional tz-offset
 -- Function: time-utc->julian-day time
 -- Function: time-utc->modified-julian-day time
 -- Function: time-utc->time-monotonic time
 -- Function: time-utc->time-monotonic! time
 -- Function: time-utc->time-tai time
 -- Function: time-utc->time-tai! time
     [SRFI-19] Conversions from time-utc to various date/time types.


File: gauche-refe.info,  Node: SRFI-19 Date reader and writer,  Prev: SRFI-19 Date,  Up: Time data types and procedures

10.10.5 Date reader and writer
------------------------------

 -- Function: date->string date &optional format-string
     [SRFI-19+] Converts a `<date>' object to a string, according to
     the format specified by FORMAT-STRING.  If FORMAT-STRING is
     omitted, `"~c"' is assumed.

     A format string is copied to output, except a sequence begins with
     `~' which is replaced with the following rules:

    `~~'
          A literal `~'.

    `~a'
          Locale's abbreviated weekday name (Sun...Sat).

    `~A'
          Locale's full weekday name (Sunday...Saturday).

    `~b'
          Locale's abbreviate month name (Jan...Dec).

    `~B'
          Locale's full month name (January...December).

    `~c'
          Locale's date and time (e.g., "Fri Jul 14 20:28:42-0400
          2000").

    `~d'
          Day of month, zero padded (01...31).

    `~D'
          Date (mm/dd/yy).

    `~e'
          Day of month, blank padded ( 1...31).

    `~f'
          Seconds+fractional seconds, using locale's decimal separator
          (e.g. 5.2).

    `~h'
          Same as ~b.

    `~H'
          Hour, zero padded, 24-hour clock (00...23).

    `~I'
          Hour, zero padded, 12-hour clock (01...12).

    `~j'
          Day of year, zero padded.

    `~k'
          Hour, blank padded, 24-hour clock ( 0...23).

    `~l'
          Hour, blank padded, 12-hour clock ( 1...12).

    `~m'
          Month, zero padded (01...12).

    `~M'
          Minute, zero padded (00...59).

    `~n'
          New line.

    `~N'
          Nanosecond, zero padded.

    `~p'
          Locale's AM or PM.

    `~r'
          Time, 12 hour clock, same as "~I:~M:~S ~p".

    `~s'
          Number of full seconds since "the epoch" (in UTC).

    `~S'
          Second, zero padded (00...60).

    `~t'
          Horizontal tab.

    `~T'
          Time, 24 hour clock, same as "~H:~M:~S".

    `~U'
          Week number of year with Sunday as first day of week
          (01...53).

    `~V'
          Week number of year with Monday as first day of week
          (00...52).

    `~w'
          Day of week (0...6).

    `~W'
          Week number of year with Monday as first day of week
          (00...52).

    `~x'
          Locale's date representation, for example: "07/31/00".

    `~X'
          Locale's time representation, for example: "06:51:44".

    `~y'
          Last two digits of year (00...99).

    `~Y'
          Year.

    `~z'
          Time zone in RFC-822 style.

    `~1'
          ISO-8601 year-month-day format.

    `~2'
          ISO-8601 hour-minute-second-timezone format.

    `~3'
          ISO-8601 hour-minute-second format.

    `~4'
          ISO-8601 year-month-day-hour-minute-second-timezone format.

    `~5'
          ISO-8601 year-month-day-hour-minute-second format.

     Note: currently Gauche doesn't honor process's locale setting, and
     it always formats the date as if the locale is "C".  It may be
     changed in future, so you shouldn't rely on, for example, `~a'
     always formatted as "Sun".."Sat".

     There's no portable way to ensure you'll get "C" locale formats
     since there's no standard way to set process's locale yet.
     However, Gauche provides a way to ensure the locale to be "C", as
     an extension to srfi-19.  Insert `@' between `~' and the directive
     character, such as `~@a'.

 -- Function: string->date string template-string
     [SRFI-19]



File: gauche-refe.info,  Node: Sources of random bits,  Next: Localization,  Prev: Time data types and procedures,  Up: Library modules - SRFIs

10.11 `srfi-27' - Sources of Random Bits
========================================

 -- Module: srfi-27
     This module provides SRFI-27 pseudo random generator interface,
     using Mersenne Twister algorithm (*Note Mersenne-Twister random
     number generator::) as the backbone.

 -- Function: random-integer n
     [SRFI-27] Returns a random exact integer between [0, N-1],
     inclusive, using the default random source.  To set a random seed
     for this procedure, use `random-source-randomize!' or
     `random-source-pseudo-randomize!' on `default-random-source'.

 -- Function: random-real
     [SRFI-27] Returns a random real number between (0, 1), exclusive,
     using the default random source.  To set a random seed for this
     procedure, use `random-source-randomize!' or
     `random-source-pseudo-randomize!' on `default-random-source'.

 -- Variable: default-random-source
     [SRFI-27] Keeps the default random source that is used by
     `random-integer' and `random-real'.

 -- Function: make-random-source
     [SRFI-27] Creates and returns a new random source.  In the current
     Gauche implementation, it is just a `<mersenne-twister>' object.
     It may be changed in the future implementation.

 -- Function: random-source? obj
     [SRFI-27] Returns `#t' if OBJ is a random source object.

 -- Function: random-source-state-ref s
 -- Function: random-source-state-set! s state
     [SRFI-27] Gets and sets the "snapshot" of the state of the random
     source S.  STATE is an opaque object whose content depends on the
     backbone generator.

 -- Function: random-source-randomize! s
     [SRFI-27] Makes an effort to set the state of the random source S
     to a truly random state.  The current implementation uses the
     current time and the process ID to set the random seed.

 -- Function: random-source-pseudo-randomize! s i j
     [SRFI-27] Changes the state of the random source S into the
     initial state of the (I, J)-th independent random source, where I
     and J are non-negative integers.  This procedure can be used to
     reuse a random source S as large number of independent random
     source, indexed by two non-negative integers.  Note that this
     procedure is entirely deterministic.

 -- Function: random-source-make-integers s
     [SRFI-27] Returns a procedure, that takes one integer argument N
     and returns a random integer between 0 and N-1 inclusive for every
     invocation, from the random source S.

 -- Function: random-source-make-reals s &optional unit
     [SRFI-27] Returns a procedure, that takes no argument and returns
     a random real between 0 and 1 exclusive for every invocation, from
     the random source S.  If UNIT is given, the random real the
     returned procedure generates will be quantized by the given UNIT,
     where 0 < UNIT < 1.


File: gauche-refe.info,  Node: Localization,  Next: A program argument processor,  Prev: Sources of random bits,  Up: Library modules - SRFIs

10.12 `srfi-29' - Localization
==============================

 -- Module: srfi-29
     This module implements the message localization mechanism defined
     in SRFI-29.

     In fact, this module consists of two submodules, `srfi-29.bundle'
     and `srfi-29.format'.  The module `srfi-29' extends both
     submodules.  It is because srfi-29's definition of the `format'
     procedure is incompatible to Gauche's native `format' (thus Common
     Lisp's `format') in the handling of `~@*' directive.

     So I splitted the module into two, `srfi-29.format' which contains
     srfi-29's `format', and `srfi-29.bundle' which contains the rest
     ("bundle" API).  If a program wishes a complete compatibility of
     srfi-29, use `srfi-29' module, which overrides Gauche's native
     `format'.   If a program just wants srfi-29's "bundle" API, but
     wants to keep Gauche's `format', use `srfi-29.bundle'.

     A localization feature is also provided by `text.gettext' module
     (*Note Localized messages::), which is a preferable way of message
     localization in Gauche.  This module is provided mainly for
     porting code that uses srfi-29 features.

Bundle specifier
----------------

A _bundle specifier_ is an arbitrary list of symbols, but typically it
takes the form like:
     `(PACKAGE LANGUAGE COUNTRY DETAILS ...)'
   Where PACKAGE specifies the software package, LANGUAGE and COUNTRY
specifies language and country code, and DETAILS gives other
informations like encoding.

   The values for the default bundle specifier can be obtained by the
following parameters.

 -- Parameter: current-language
 -- Parameter: current-country
 -- Parameter: current-locale-details
     [SRFI-29] The `current-language' and `current-country' parameters
     keep the ISO 639-1 language code and ISO 3166-1 country code
     respectively, both as symbols.  The `current-locale-details' keeps
     a list of auxiliary local informations, such as encodings.

     These parameters are initialized if `LANG' environment variable is
     set in the form of `lang_country.encoding' format.  For example,
     if the `LANG' setting is `ja_JP.eucJP', those parameters are `ja',
     `jp', and `(eucjp)', respectively.   If `LANG' is `C' or undefined,
     the default values are `en', `us', and `()', respectively.

Bundle preparation
------------------

 -- Function: declare-bundle! bundle-specifier association-list
     [SRFI-29] Put the association list of template key (symbol) and
     the locale-specific message (string) into the bundle database,
     with BUNDLE-SPECIFIER as the key.

   Gauche currently supports only in-memory bundle database.  That is,
you have to call `declare-bundle!' within the application in order to
lookup the localized messages.

 -- Function: save-bundle! bundle-specifier
 -- Function: load-bundle! bundle-specifier
     [SRFI-29] Since Gauche doesn't support persistent bundle database
     yet, these procedures does nothing and returns `#f'.  (It is still
     conforming behavior of srfi-29).

Retrieving localized message
----------------------------

 -- Function: localized-template package-name message-template-name
     [SRFI-29] Retrieves localized message, associated with a symbol
     MESSAGE-TEMPLATE-NAME in the package PACKAGE-NAME.

Extended format procedure
-------------------------

 -- Function: format format-string args
     [SRFI-29] SRFI-29 extends SRFI-28's `format' procedure spec (which
     supports `~a', `~s', `~%' and `~~' directives), in order to
     support argument repositioning.

     A directive `~N@*', where N is an integer or can be omitted,
     causes the next directive to retrieve a value from N-th optional
     argument.  The referenced value isn't consumed, and won't affect
     the processing of subsequent directives.

     Although SRFI-28 spec is compatible to Gauche's native `format'
     (*Note Output::), this SRFI-29 extention isn't.  Specifically, the
     `~N@*' directive of Gauche's `format' changes the argument pointer
     to points N-th optional argument, thus it affects all the
     subsequent arguments.

     Because of this incompatibility, this function is defined in a
     separate module, `srfi-29.format'.  If you use `srfi-29', which
     extends `srfi-29.bundle' and `srfi-29.format', the `format'
     procedure will be overridden by srfi-29's `format' in your module.
     If you want to keep Gauche's native `format', use `srfi-29.bundle'
     only.


File: gauche-refe.info,  Node: A program argument processor,  Next: Eager comprehensions,  Prev: Localization,  Up: Library modules - SRFIs

10.13 `srfi-37' - args-fold: a program argument processor
=========================================================

 -- Module: srfi-37
     This module implements `args-fold', yet another procedure to
     process command-line arguments, defined in SRFI-37 (*note
     [SRFI-37]: srfi-37.).

     Unlike `gauche.parseopt' (*Note Parsing command-line options::),
     `args-fold' provides functional interface, i.e.  the user's states
     are explicitly passed via parser's argument and return values, and
     also follows POSIX and GNU getopt guidelines, including long
     options.

 -- Function: args-fold args options unrecognized-proc operand-proc
          &rest seeds
     Processes program options ARGS from left to right, according to
     given option specification OPTIONS, and two procedures
     UNRECOGNIZED-PROC and OPERAND-PROC.

     OPTIONS is a list of option objects, explained below.  Each option
     object keeps the name(s) of the option, a flag to specify whether
     the option takes an argument or not, and a procedure to process
     that option (we'll call it _option procedure_).

     `Args-fold' recognizes both single-character options (short
     options) and long options.  A short option must begin with single
     hyphen (e.g. `-a'), while long option must begin with double
     hyphens (e.g. `--help').   Short options can be concatenated, e.g.
     `-abc' or `-a -b -c'.  Both a short option and a long option can
     take required or optional arguments.   Required short-option
     argument can appear with or without space after the option, e.g.
     `-afoo' or `-a foo'.  Long-option argument can appear after
     character '`='' or space, e.g. `--long=foo' or `--long foo'.

     When `args-fold' encounters a command-line argument that cannot be
     an option argument, and doesn't begin with hyphen, the argument is
     treated as an _operand_.   `Args-fold' allows operands and options
     to be interleaved.  However, if `args-fold' encounters '`--'', the
     rest of arguments are treated as operands, regardless of beginning
     with hyphen or not.

     When the given option matches one of option object in OPTIONS, the
     option procedure is called as follows:

          (OPTION-PROC OPTION NAME ARG SEED ...)

     where OPTION is the matched option object, NAME is the string
     actually used to specify the option, ARG is the option argument
     (or `#f' if there's none), and SEED ... is the user's state
     information.  OPTION-PROC must return as many arguments as SEEDs.

     When `args-fold' encounters an option that doesn't match any of
     the option objects, it creates a new option object for the option
     and calls UNRECOGNIZED-PROC with the same arguments as OPTION-PROC.

     When `args-fold' finds an operand, OPERAND-PROC is called as
     follows:

          (OPERAND-PROC OPERAND SEED ...)

     OPERAND-PROC must return as many arguments as SEEDs.

     The caller's state should be explicitly passed around seed
     arguments and return values.  The initial seed values are SEEDs
     given to `args-fold'.  The values returned from option procedure,
     UNRECOGNIZED-PROC and OPERAND-PROC are used as the seed arguments
     of next invocation of those procedures.  The values returned from
     the last call to the procedures are returned from `args-fold'.

 -- Function: option names require-arg? optional-arg? processor
     Creates an option object with the passed properties.

     NAMES is a list of characters and/or strings.  A character is used
     for a short option, and a string is used for a long option.

     Two flags, REQUIRE-ARG? and OPTIONAL-ARG?  indicates whether the
     option should take an option argument, or may take an option
     argument.

     PROCESSOR is the option processor procedure.

     Note that, if an option argument is passed using '`='' character,
     it is passed to the option procedure even if the option has `#f'
     in both REQUIRE-ARG?  and OPTIONAL-ARG?.  It is up to the option
     procedure to deal with the argument.

     It should also be noted that the optional option argument for a
     short option is only recognized if it is given without whitespace
     after the short option.  That is, if a short option '`d'' is
     marked to take optional option argument, then '`-dfoo'' is
     interpreted as '`-d'' with argument '`foo'', but '`-d foo'' is
     interpreted as '`-d'' without argument and an operand `foo'.  If
     '`d'' is marked to take required option argument, however, both
     are interpreted as '`-d'' with argument '`foo''.

 -- Function: option? obj
     Returns `#t' if OBJ is an option object, `#f' otherwise.

 -- Function: option-names option
 -- Function: option-required-arg? option
 -- Function: option-optional-arg? option
 -- Function: option-processor
     Returns the properties of an option object OPTION.

   A simple example:

     (use srfi-37)

     (define options
      (list (option '(#\d "debug") #f #t
                    (lambda (option name arg debug batch paths files)
                      (values (or arg "2") batch paths files)))
            (option '(#\b "batch") #f #f
                    (lambda (option name arg debug batch paths files)
                      (values debug #t paths files)))
            (option '(#\I "include") #t #f
                    (lambda (option name arg debug batch paths files)
                      (values debug batch (cons arg paths) files)))))

     (define (main args)
       (receive (debug-level batch-mode include-paths files)
         (args-fold (cdr args)
                    options
                    (lambda (option name arg . seeds)         ; unrecognized
                      (error "Unrecognized option:" name))
                    (lambda (operand debug batch paths files) ; operand
                      (values debug batch paths (cons operand files)))
                    0      ; default value of debug level
                    #f     ; default value of batch mode
                    '()    ; initial value of include paths
                    '()    ; initial value of files
                    )
          (print "debug level = " debug-level)
          (print "batch mode = " batch-mode)
          (print "include paths = " (reverse include-paths))
          (print "files = " (reverse files))
          0))

