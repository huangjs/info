This is gauche-refe.info, produced by makeinfo version 4.13 from
gauche-refe.texi.

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* Gauche: (gauche-refe.info).	        An R5RS Scheme implementation.
END-INFO-DIR-ENTRY


File: gauche-refe.info,  Node: Eager comprehensions,  Next: Vector library,  Prev: A program argument processor,  Up: Library modules - SRFIs

10.14 `srfi-42' - Eager comprehensions
======================================

 -- Module: srfi-42
     This module provides a generic comprehension mechanism, which some
     other languages (e.g. Haskell and Python) provides as a built-in
     mechanism.  It provides rich set of operators so it can be used as
     not only a list generator but a generic loop construct (actually,
     some may say it is as powerful/evil as Common Lisp's _loop_ macro).

     It also runs eagerly, that is, if it generates a list, it creates
     the entire list when evaluated, instead of generate the elements
     _on demand_.  Thus it can't represent an infinite sequence, which
     Haskell's comprehension naturally does.  In Scheme, you can use
     streams built on top of delayed evaluation for such purpose (*Note
     Stream library::).

Eager comprehension examples
----------------------------

Let's begin with some examples.

   Generate a list of squares for the first five integers:
     (list-ec (: i 5) (* i i)) => (0 1 4 9 16)

   `list-ec' is a comprehension macro that generates a list.  The first
form `(: i 5)' is called a QUALIFIER, which specifies a set of values
to repeat over (here it is each integer from 0 below 5).  The last form
`(* i i)' is called a BODY, which is ordinary Scheme expression
evaluated for each values specified by the QUALIFIER.

   A comprehension can have more than one qualifiers.  Next example
generate set of pair of numbers `(x y)', where `x' is between 2
(inclusive) and 5 (exclusive), and `y' is between 1 (inclusive) and x
(exclusive).

     (list-ec (: x 2 5) (: y 1 x) (list x y))
       => ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3))

   The qualifiers works as _nested_; that is, `(: x 2 5)' specifies to
repeat the rest of the clauses--`(: y 1 x)' and `(list x y)'.

   The above two examples can be written in Haskell as the followings:

     [ i*i   | i <- [0..4] ]
     [ (x,y) | x <- [2..4], y <- [1..x-1] ]

   Note the differences: (1) In Haskell, the body expression to yield
the elements comes first, followed by qualifiers (selectors).  In
srfi-42, the body expression comes last.  (2) In srfi-42, range
operator's lower bound is inclusive but its upper bound is exclusive.

   List a set of numbers `(a b c d)', where `a^3+b^3 = c^3+d^3':
     (define (taxi-number n)
       (list-ec (: a 1 n)
                (: b (+ a 1) n)
                (: c (+ a 1) b)
                (: d (+ c 1) b)
                (if (= (+ (expt a 3) (expt b 3))
                       (+ (expt c 3) (expt d 3))))
                (list a b c d)))

   If you want to change values of more than one variable
simultaneously, instead of nesting, you can bundle the qualifiers like
this:

     (list-ec (:parallel (: x '(a b c d)) (: y '(1 2 3 4)))
              (list x y))
       => ((a 1) (b 2) (c 3) (d 4))

   You can generate not only a list, but other sequences:
     (vector-ec (: i 5) i) => #(0 1 2 3 4)
     (string-ec (: i 5) (integer->char (+ i 65))) => "ABCDE"

   Or apply folding operations:
     (sum-ec (: i 1 100) i)
       => 4950    ;; sum of integers from 1 below 100.
     (product-ec (: i 1 10) i)
       => 362880 ;; ... and product of them.

Comprehension macros
--------------------

Each comprehension takes the following form.
     (COMPREHENSION-MACRO QUALIFIER ... BODY)

   It evaluates BODY repeatedly as specified by QUALIFIER ....
Depending on the type of comprehension, the results of BODY may be
either collected to create an aggregate (list, vector, string, ...),
folded by some operator (sum, product, min, max, ...), or simply
discarded.

   Each QUALIFIER specifies how to repeat the following QUALIFIERS and
BODY.  A QUALIFIER can be a generational qualifier that yields a set of
values to loop over, or a control qualifier that specify a condition to
exclude some values.  See the Qualifiers heading below.

   A few comprehensions takes extra values before QUALIFIERS or after
BODY.

 -- Macro: do-ec qualifier ... body
     [SRFI-42] Repeats BODY.  The results of BODY is discarded.  This
     is for side-effecting operations.

 -- Macro: list-ec qualifier ... body
     [SRFI-42] Repeats `body' and collects the results into a list.

 -- Macro: append-ec qualifier ... body
     [SRFI-42] Repeats `body', which must yield a list.  Returns a list
     which is the concatenation of all lists retured by BODY.

 -- Macro: string-ec qualifier ... body
 -- Macro: string-append-ec qualifier ... body
     [SRFI-42] Repeats BODY, which must yield a character (in
     `string-ec') or a string (in `string-append-ec').  Returns a
     string that consists of the results of BODY.

 -- Macro: vector-ec qualifier ... body
     [SRFI-42] Repeats BODY and collects the results into a vector.

 -- Macro: vector-of-length-ec k qualifier ... body
     [SRFI-42] This is like `vector-ec', except that the length of the
     result vector is known to be K.  It can be more efficient than
     `vector-ec'.  Unless the comprehension repeats exactly `k' times,
     an error is signaled.

 -- Macro: sum-ec qualifier ... body
 -- Macro: product-ec qualifier ... body
     [SRFI-42] BODY must yield a numeric value.  Returns sum of and
     product of the results, respectively.

 -- Macro: min-ec qualifier ... body
 -- Macro: max-ec qualifier ... body
     [SRFI-42] BODY must yield a numeric value.  Returns maximum and
     minimum value of the results, respectively.  BODY must be
     evaluated at least once, or an error is signalled.

 -- Macro: any?-ec qualifier ... test
 -- Macro: every?-ec qualifier ... test
     [SRFI-42] Evaluates TEST for each iteration, and returns `#t' as
     soon as it yields non-`#f' (for `any-ec?'), or returns `#f' as
     soon as it yields `#f' (for `every?-ec').  Unlink the
     comprehensions introduced above, these stop evaluating TEST as
     soon as the condition meets.  If the qualifiers makes no
     iteration, `#f' and `#t' are returned, respectively.

 -- Macro: first-ec default qualifier ... body
 -- Macro: last-ec default qualifier ... body
     [SRFI-42] First initializes the result by the value of the
     expression DEFAULT, then start iteration, and returns the value of
     the first and last evaluation of BODY, respectively.  In fact,
     `first-ec' only evaluates BODY at most once.

     These procedures are most useful when used with control qualifiers.
     For example, the following `first-ec' returns the _first_ set of
     distinct integers (X, Y, Z), where X*X+Y*Y+Z*Z becomes a square of
     another integer W.

          (first-ec #f (:integers w) (: z 1 w) (: y 1 z) (: x 1 y)
                    (if (= (* w w) (+ (* x x) (* y y) (* z z))))
                    (list x y z w))

     Note that the first qualifier, `(:integers w)', generates infinite
     number of integers; if you use `list-ec' instead of `first-ec' it
     won't stop.

 -- Macro: fold-ec seed qualifier ... expr proc
 -- Macro: fold3-ec seed qualifier ... expr init proc
     [SRFI-42] Reduces the values produced by EXPR.

     Suppose EXPR produces a sequence of values X0, X1, ..., XN.
     `Fold-ec' calculates the following value:

          (PROC XN (...(PROC X1 (PROC X0 SEED))...))

     It's similar to `fold', except that PROC is evaluated within the
     scope of QUALIFIER ... so you can refer to the variables
     introduced by them.  On the other hand, SEED is outside of the
     scope of QUALIFIERs.

     `Fold-ec3' is almost the same but the initial value calculation.
     In `fold-ec3', SEED is only used when QUALIFIERs makes no
     iteration.  Otherwise it calculates the following value:

          (PROC XN (...(PROC X1 (INIT X0))...))


Qualifiers
----------

Generational qualifiers
.......................

This type of qualifiers generates (possibly infinite) values over which
the rest of clauses iterate.

   In the following descriptions, VARS refers to either a single
identifier, or a series of identifier and a form `(index IDENTIFIER2)'.
The single identifier in the former case and the first identifier in
the latter case name the variable to which each generated value is
bound.  The IDENTIFIER2 in the latter case names a variable to which a
series of integers, increasing with each generated element, is bound.
See the following example:

     (list-ec (: x '(a b c)) x)
       => (a b c)
     (list-ec (: x (index y) '(a b c)) (cons x y))
       => ((a . 0) (b . 1) (c . 2))

 -- EC Qualifier: : vars arg1 args ...
     A generic dispatcher of generational qualifiers.

 -- EC Qualifier: :list vars arg1 args ...
 -- EC Qualifier: :vector vars arg1 args ...
 -- EC Qualifier: :string vars arg1 args ...

 -- EC Qualifier: :integers vars

 -- EC Qualifier: :range vars stop
 -- EC Qualifier: :range vars start stop
 -- EC Qualifier: :range vars start stop step

 -- EC Qualifier: :real-range vars stop
 -- EC Qualifier: :real-range vars start stop
 -- EC Qualifier: :real-range vars start stop step

 -- EC Qualifier: :char-range vars min max

 -- EC Qualifier: :port vars port
 -- EC Qualifier: :port vars port read-proc

 -- EC Qualifier: :dispatched vars dispatch arg1 args ...

 -- EC Qualifier: :do (lb ...) ne1? (ls ...)
 -- EC Qualifier: :do (let (ob ...) oc ...) (lb ...) ne1? (let (ib ...)
          ic ...) ne2? (ls ...)

 -- EC Qualifier: :let vars expr

 -- EC Qualifier: :parallel generator ...

 -- EC Qualifier: :while generator expr

 -- EC Qualifier: :until generator expr

Control qualifiers
..................

 -- EC Qualifier: if test

 -- EC Qualifier: not test
 -- EC Qualifier: and test ...
 -- EC Qualifier: or test ...

 -- EC Qualifier: begin command ... expr

 -- EC Qualifier: nested qualifier ...


File: gauche-refe.info,  Node: Vector library,  Next: Requiring extensions,  Prev: Eager comprehensions,  Up: Library modules - SRFIs

10.15 `srfi-43' - Vector library
================================

 -- Module: srfi-43
     This module provides library functions for vectors.  Some of
     srfi-43 procedures are built-in; see *note Vectors::.

Vector constructors
-------------------

 -- Function: vector-unfold f length seed ...
     [SRFI-43]

 -- Function: vector-unfold-right f length seed ...
     [SRFI-43]

 -- Function: vector-reverse-copy vec &optional start end
     [SRFI-43]

 -- Function: vector-append vec ...
     [SRFI-43] Returns a newly allocated vector whose contents are
     concatenation of elements of VEC in order.

 -- Function: vector-concatenate list-of-vectors
     [SRFI-43] Acts like `(apply vector-append list-of-vectors)', though
     this may be more efficient.

Vector predicates
-----------------

 -- Function: vector-empty? vec
     [SRFI-43] Returns `#t' if VEC's length is zero, and `#f' if VEC's
     length is more than zero.  Signals an error if VEC is not a vector.

 -- Function: vector= elt= vec ...
     [SRFI-43] Compares VECs element-wise, using given predicate ELT=.
     Returns `#t' iff lengths of all the vectors are the same, and
     every corresponding elements are equal by ELT=.  ELT= is always
     called with two arguments and must return `#t' iff two are the
     same.

Iteration over vectors
----------------------

 -- Function: vector-fold kons knil vec1 vec2 ...
     [SRFI-43] KONS is iterated over each corresponding elements of the
     given vectors, with passing around the seed value, whose default
     is proided by KNIL.

 -- Function: vector-fold-right kons knil vec1 vec2 ...
     [SRFI-43]

 -- Function: vector-map f vec1 vec2 ...
     [SRFI-43]

 -- Function: vector-map! f vec1 vec2 ...
     [SRFI-43]

 -- Function: vector-for-each f vec1 vec2 ...
     [SRFI-43]

 -- Function: vector-count pred vec1 vec2 ...
     [SRFI-43]

Vector searching
----------------

 -- Function: vector-index pred vec1 vec2 ...
 -- Function: vector-index-right pred vec1 vec2 ...
     [SRFI-43] Returns the index of the first or the last elements in
     VEC1 VEC2 ... that satisfy PRED, respectively.  Returns `#f' if no
     elements satisfy PRED.  In `vector-index', comparison ends at the
     end of the shortest vector.  For `vector-index-right', all the
     vectors must have the same length.

 -- Function: vector-skip pred vec1 vec2 ...
 -- Function: vector-skip-right pred vec1 vec2 ...
     [SRFI-43] Like `vector-index' and `vector-index-right', except that
     the result of PRED is negated.  That is, returns the index of the
     first or the last elements that don't sastisfy PRED.

 -- Function: vector-binary-search vec value cmp &optional start end
     [SRFI-43+] Look for VALUE in a vector VEC, and returns its index
     if it is found, or `#f' if it is not found.  Comparison of VALUE
     and an element in VEC is done by a procedure CMP, which takes two
     arguments, and should return a negative integer if the first
     argument is less than the second, 0 if they are the same, and a
     positive integer if the first is greater than tne second.

     Elements in VEC must be ordered from smaller to greater w.r.t.
     CMP.  Using that fact, this procedure performs binary search
     instead of linear search.

     The optional arguments START and END are an extention to SRFI-43,
     and can be used to limit the range of the search in START-th
     element (inclusive) to END-th element (exclusive).

 -- Function: vector-any pred vec1 vec2 ...
     [SRFI-43] Applies PRED on each corresponding elements of VEC1 VEC2
     ... left to right, and as soon as PRED returns non-`#f' value, the
     procedure stops iteration and returns the value.

     If no elements that satisfy PRED are found, it returns `#f'.

     Vectors can have different lengths.  Iteration stops at the end of
     the shortest.

 -- Function: vector-every pred vec1 vec2 ...
     [SRFI-43] Applies PRED on each corresponding elements of VEC1 VEC2
     ... left to right.  If all the elements (when the lengths of
     vectors differ, the first N elements where N is the length of the
     shortest) satisfy PRED, returns the last result of PRED.
     Otherwise returns `#t'.

Vector mutators
---------------

 -- Function: vector-swap! vec i j
     [SRFI-43] Swaps vector VEC's `i'-th and `j'-th elements.

 -- Function: vector-reverse! vec &optional start end
     [SRFI-43]

 -- Function: vector-copy! target tstart source &optional sstart send
     [SRFI-43]

 -- Function: vector-reverse-copy! target tstart source &optional
          sstart send
     [SRFI-43]

Vector conversion
-----------------

 -- Function: reverse-vector->list vec &optional start end
     [SRFI-43]

 -- Function: reverse-list->vector list &optional start end
     [SRFI-43]


File: gauche-refe.info,  Node: Requiring extensions,  Prev: Vector library,  Up: Library modules - SRFIs

10.16 `srfi-55' - Requiring extensions
======================================

 -- Module: srfi-55
     This module defines `require-extension' macro, a yet another way
     to write portable scripts.  See *note Feature conditional:: and
     *note Feature-based program configuration language:: for other
     means of ensuring specific features.

     This module is autoloaded when you use `require-extension', so you
     don't need explicitly say `(use srfi-55)'; for portable scripts,
     you shouldn't.

 -- Macro: require-extension clause ...
     Make extension(s) specified by CLAUSEs available in the rest of
     the program.

     A CLAUSE takes the following form:
          (EXTENSION-ID EXTENSION-ARG ...)

     Currently, only `srfi' is supported as EXTENSION-ID, and its
     arguments are SRFI numbers.

     For example, the following form:
          (require-extension (srfi 1 13 14))

     Roughly correspons to Gauche's `use' forms:
          (use srfi-1)
          (use srfi-13)
          (use srfi-14)


File: gauche-refe.info,  Node: Library modules - Utilities,  Next: References,  Prev: Library modules - SRFIs,  Up: Top

11 Library modules - Utilities
******************************

* Menu:

* Binary I/O::                  binary.io
* Packing Binary Data::         binary.pack
* Rational-less arithmetic::    compat.norational
* Database independent access layer::  dbi
* Generic DBM interface::       dbm
* File-system dbm::             dbm.fsdbm
* GDBM interface::              dbm.gdbm
* NDBM interface::              dbm.ndbm
* Original DBM interface::      dbm.odbm
* Filtering file content::      file.filter
* Filesystem utilities::        file.util
* Mathematic constants::        math.const
* Mersenne-Twister random number generator::  math.mt-random
* RFC822 message parsing::      rfc.822
* Base64 encoding/decoding::    rfc.base64
* HTTP cookie handling::        rfc.cookie
* FTP::                         rfc.ftp
* HMAC keyed-hashing::          rfc.hmac
* HTTP::                        rfc.http
* IP packets::                  rfc.ip
* ICMP packets::                rfc.icmp
* MD5 message digest::          rfc.md5
* MIME message handling::       rfc.mime
* Quoted-printable encoding/decoding::  rfc.quoted-printable
* SHA message digest::          rfc.sha
* URI parsing and construction::  rfc.uri
* Zlib compression library::    rfc.zlib
* SLIB::                        slib
* Functional XML parser::       sxml.ssax
* SXML Query Language::         sxml.sxpath
* Manipulating SXML structure::  sxml.tools
* Serializing XML and HTML from SXML::  sxml.serializer
* CSV tables::                  text.csv
* Calculate difference of text streams::  text.diff
* Localized messages::          text.gettext
* Simple HTML document construction::  text.html-lite
* Parsing input stream::        text.parse
* Showing progress on text terminals::  text.progress
* SQL parsing and construction::  text.sql
* Transliterate characters::    text.tr
* Lazy text construction::      text.tree
* Combination library::         util.combinations
* Message digester framework::  util.digest
* Determine isomorphism::       util.isomorph
* The longest common subsequence::  util.lcs
* Additional list library::     util.list
* Pattern matching::            util.match
* Queue::                       util.queue
* Red black tree::              util.rbtree
* SLIB-compatible record type::  util.record
* Relation framework::          util.relation
* Sparse data containers::      util.sparse
* Stream library::              util.stream
* Trie::                        util.trie
* Topological sort::            util.toposort
* CGI Utility::                 www.cgi
* CGI testing::                 www.cgi.test


File: gauche-refe.info,  Node: Binary I/O,  Next: Packing Binary Data,  Prev: Library modules - Utilities,  Up: Library modules - Utilities

11.1 `binary.io' - Binary I/O
=============================

 -- Module: binary.io
     This module provides basic procedures to perform binary I/O of
     numeric data.  Each datum can be read from or written to a port,
     and got from or put to a uniform vector (see *note Uniform
     vectors::).  For structured binary data I/O, more convenient
     `pack' utility is implemented on top of this module (see *note
     Packing Binary Data::).  You might want to use this module
     directly if you need speed or want a flexible control of
     endianness.

     See also *note Uniform vectors::, which provides binary block I/O.

Endianness
----------

Most procedures of this module take an optional ENDIAN argument,
specifying the byte order of the binary input.  It must be either one
of symbols `big-endian', `little-endian', or `arm-little-endian'.  If
the endian argument is omitted, the current value of the builtin
parameter `default-endian' is used.  The default value of the
`default-endian' parameter is the machine's native endian.  (For 8-bit
I/O procedures like `read-u8' the endian argument has no effect, but is
accepted for consistency).

 -- Builtin Parameter: default-endian &optional value
     When called without VALUE, returns the current default endian.
     When called with VALUE, sets the current endian to the VALUE,
     which must be one of the following symbols:
    `big-endian'
          Big endian.  An integer `#x12345678' is written out as an
          octet sequence `#x12 #x34 #x56 #x78'.

    `little-endian'
          Little endian.  An integer `#x12345678' is written out as an
          octet sequence `#x78 #x56 #x34 #x12'.

    `arm-little-endian'
          This is a variation of `little-endian', and used in ARM
          processors in some specific modes.  It works just like
          `little-endian', except reading/writing double-precision
          floating point number (`f64'), which is written as two
          little-endian 32bit words ordered by big-endian (e.g. If
          machine register's representation is `#x0102030405060708', it
          is written as `#x04 #x03 #x02 #x01 #x08 #x07 #x06 #x05'.

     The default endian value is thread-local.  You can use
     `parameterize' (*Note Parameters::) to switch default endianness
     within certain dynamic scope.

I/O using port
--------------

 -- Function: read-u8 &optional port endian
 -- Function: read-u16 &optional port endian
 -- Function: read-u32 &optional port endian
 -- Function: read-u64 &optional port endian
     Reads 8, 16, 32 or 64 bit unsigned integer from PORT with
     specified endian, respectively.  If PORT is omitted, current input
     port is used.  If PORT reaches EOF before a complete integer is
     read, EOF is returned.

 -- Function: read-s8 &optional port endian
 -- Function: read-s16 &optional port endian
 -- Function: read-s32 &optional port endian
 -- Function: read-s64 &optional port endian
     Reads 8, 16, 32 or 64 bit 2's complement signed integer from PORT
     with specified endian, respectively.  If PORT is omitted, current
     input port is used.  If PORT reaches EOF before a complete integer
     is read, EOF is returned.

 -- Function: read-uint size &optional port endian
 -- Function: read-sint size &optional port endian
     More flexible version.  Reads SIZE-octet unsigned or signed
     integer from PORT with specified endian.  If PORT reaches EOF
     before a complete integer is read, EOF is returned.

 -- Function: read-ber-integer &optional port
     Reads BER compressed integer a la X.209.  A BER compressed integer
     is an unsigned integer in base 128, most  significant digit first,
     where the high bit is set on all but the final (least significant)
     byte.

 -- Function: write-u8 val &optional port endian
 -- Function: write-u16 val &optional port endian
 -- Function: write-u32 val &optional port endian
 -- Function: write-u64 val &optional port endian
     Writes a nonnegative integer VAL as 8, 16, 32 or 64 bit unsigned
     integer to PORT with specified endian, respectively.  VAL must be
     within the range of integers representable by the specified bits.
     When PORT is omitted, current output port is used.

 -- Function: write-s8 val &optional port endian
 -- Function: write-s16 val &optional port endian
 -- Function: write-s32 val &optional port endian
 -- Function: write-s64 val &optional port endian
     Writes an integer VAL as 8, 16, 32 or 64 bit as 2's complement
     signed integer to PORT with specified endian, respectively.  VAL
     must be within the range of integers representable by the
     specified bits.  When PORT is omitted, current output port is used.

 -- Function: write-uint size val &optional port endian
 -- Function: write-sint size val &optional port endian
     More flexible version.  Writes an integer VAL as unsigned or
     signed integer of SIZE bytes to PORT with specified endian.  When
     PORT is omitted, current output port is used.

 -- Function: write-ber-integer val &optional port
     Writes a nonnegative integer VAL in BER compressed integer to
     PORT.  See `read-ber-integer' above for BER format.

 -- Function: read-f16 &optional port endian
 -- Function: read-f32 &optional port endian
 -- Function: read-f64 &optional port endian
     Reads 16, 32, or 64-bit floating point numbers, respectively.
     32bit is IEEE754 single-precision, and 64bit is IEEE754
     double-precision numbers.  16-bit floating point number consists
     of 1-bit sign, 5-bit exponent and 10-bit mantissa, as used in some
     HDR image format.

     If PORT is omitted, current input port is used.  If PORT reaches
     EOF before a complete number is read, EOF is returned.

 -- Function: write-f16 val &optional port endian
 -- Function: write-f32 val &optional port endian
 -- Function: write-f64 val &optional port endian
     Writes a real number VAL to PORT in 16, 32, or 64-bit floating
     point number, respectively.  If PORT is omitted, current output
     port is used.

I/O using uniform vectors
-------------------------

In the following routines, the argument UV can be any type of uniform
vector; if it is not a `u8vector', it is treated as if `(uvector-alias
<u8vector> UV)' is called--that is, it reads directly from the memory
image that holds the uvector's content.  The POS argument specifies the
byte position from the beginning of the memory area (it is always byte
position, regardless of the uniform vector's element size).

 -- Function: get-u8 uv pos &optional endian
 -- Function: get-u16 uv pos &optional endian
 -- Function: get-u32 uv pos &optional endian
 -- Function: get-u64 uv pos &optional endian
 -- Function: get-s8 uv pos &optional endian
 -- Function: get-s16 uv pos &optional endian
 -- Function: get-s32 uv pos &optional endian
 -- Function: get-s64 uv pos &optional endian
 -- Function: get-f16 uv pos &optional endian
 -- Function: get-f32 uv pos &optional endian
 -- Function: get-f64 uv pos &optional endian
     Reads a number of a specific format from a uniform vector UV,
     starting at a byte position POS.  An error is signalled if the
     specified position makes reference outside of the uniform vector's
     content.  Returns the read number.

 -- Function: get-u16be uv pos
 -- Function: get-u16le uv pos
 -- Function: get-u32be uv pos
 -- Function: get-u32le uv pos
 -- Function: get-u64be uv pos
 -- Function: get-u64le uv pos
 -- Function: get-s16be uv pos
 -- Function: get-s16le uv pos
 -- Function: get-s32be uv pos
 -- Function: get-s32le uv pos
 -- Function: get-s64be uv pos
 -- Function: get-s64le uv pos
 -- Function: get-f16be uv pos
 -- Function: get-f16le uv pos
 -- Function: get-f32be uv pos
 -- Function: get-f32le uv pos
 -- Function: get-f64be uv pos
 -- Function: get-f64le uv pos
     These are big-endian (`be') or little-endian (`le') specific
     versions of `get-*' procedures.  In speed-sensitive code, you
     might want to use these to avoid the overhead of optional-argument
     handling.

 -- Function: put-u8! uv pos val &optional endian
 -- Function: put-u16! uv pos val &optional endian
 -- Function: put-u32! uv pos val &optional endian
 -- Function: put-u64! uv pos val &optional endian
 -- Function: put-s8! uv pos val &optional endian
 -- Function: put-s16! uv pos val &optional endian
 -- Function: put-s32! uv pos val &optional endian
 -- Function: put-s64! uv pos val &optional endian
 -- Function: put-f16! uv pos val &optional endian
 -- Function: put-f32! uv pos val &optional endian
 -- Function: put-f64! uv pos val &optional endian
     Writes a number VAL into a uniform vector UV in a specific format,
     starting at a byte position POS.  An error is signalled if the
     specified position makes reference outside of the uniform vector's
     content.

 -- Function: put-u16be! uv pos val
 -- Function: put-u16le! uv pos val
 -- Function: put-u32be! uv pos val
 -- Function: put-u32le! uv pos val
 -- Function: put-u64be! uv pos val
 -- Function: put-u64le! uv pos val
 -- Function: put-s16be! uv pos val
 -- Function: put-s16le! uv pos val
 -- Function: put-s32be! uv pos val
 -- Function: put-s32le! uv pos val
 -- Function: put-s64be! uv pos val
 -- Function: put-s64le! uv pos val
 -- Function: put-f16be! uv pos val
 -- Function: put-f16le! uv pos val
 -- Function: put-f32be! uv pos val
 -- Function: put-f32le! uv pos val
 -- Function: put-f64be! uv pos val
 -- Function: put-f64le! uv pos val
     These are big-endian (`be') or little-endian (`le') specific
     versions of `put-*' procedures.  In speed-sensitive code, you
     might want to use these to avoid the overhead of optional-argument
     handling.

Compatibility notes
-------------------

`read-u8' etc. were called `read-binary-uint8' etc., and `read-f32' and
`read-f64' were called `read-binary-float' and `read-binary-double',
respectively.  These old names are still supported for the backward
compatibility but their use is deprecated.  The reason of the changes is
for brevity and for consistency with the uniform vectors.


File: gauche-refe.info,  Node: Packing Binary Data,  Next: Rational-less arithmetic,  Prev: Binary I/O,  Up: Library modules - Utilities

11.2 `binary.pack' - Packing Binary Data
========================================

 -- Module: binary.pack
     This module provides an interface for packing and unpacking
     (writing and reading) binary data with templates.  The
     functionality was inspired largely by the Perl pack/unpack
     functions, with comparison of similar features from other
     languages, however an effort was made to make it more general and
     more efficient, to be usable for database-like processing.  To
     that end, the most notable differences are that any packable value
     is unpackable (and vice versa), and the default behavior is to
     pack and unpack using port I/O, so you can seek in a large file
     and unpack from it.  Also, templates may be stored as dispatch
     closures to pack, unpack or even skip over values without
     re-parsing the template.


 -- Function: pack template list &keyword :output :to-string?
     Writes the values in LIST to the current output port, according to
     the format specified by the string TEMPLATE.  The template string
     is a series of single character codes, optionally followed by a
     numeric count (which defaults to 1).  The format characters can
     generally be divided into string types, which interpret the count
     as a string byte size, and object types, which treat the count as
     a repetition indicator.  The count may be specified as the
     character `*', which means to use the full size of the string for
     string types, and use all remaining values for object types.
     Counts may also be specified as a template enclosed in brackets,
     which means the count is the byte size of the enclosed template.
     For example, `x[L]' skips a long.  The special format character
     `/' may be used to indicate a structure where the packed data
     contains a dynamic count followed by the value itself.  The
     template is written as `<count-item>/<value-item>', where
     `<count-item>' is any template character to be interpreted as a
     numeric count, and `<value-item>' is any other template character
     to use this count.  If a normal count is given after
     `<value-item>' it is ignored.  The format character `@' may be
     used with a count to pad to an absolute position since the start
     of the template.  Sub-templates may be grouped inside parentheses.
     If angle-brackets are used, then they also behave as group
     operators but recursively operate on nested lists.  The string
     types:
    `a'
          An arbitrary incomplete string, null padded.

    `A'
          A text string, space padded.

    `Z'
          A null terminated (ASCIZ) string, null padded.

    `b'
          A bit string (ascending bit order inside each byte).

    `B'
          A bit string (descending bit order inside each byte).

    `h'
          A hex string (low nybble first).

    `H'
          A hex string (high nybble first).

     The object types:

    `c'
          A signed 8bit integer.

    `C'
          An unsigned 8bit integer.

    `s'
          A signed short (16 bit) value.

    `S'
          An unsigned short (16 bit) value.

    `i'
          A signed integer (>= 32 bit) value.

    `I'
          An unsigned integer (>= 32 bit) value.

    `l'
          A signed long (32 bit) value.

    `L'
          An unsigned long (32 bit) value.

    `n, n!'
          An unsigned and signed short (16 bit) in "network"
          (big-endian) order.

    `N, N!'
          An unsigned and signed long (32 bit) in "network"
          (big-endian) order.

    `v, v!'
          An unsigned and signed short (16 bit) in "VAX"
          (little-endian) order.

    `V, V!'
          An unsigned and signed long (32 bit) in "VAX" (little-endian)
          order.

    `q'
          A signed quad (64 bit) value.

    `Q'
          An unsigned quad (64 bit) value.

    `f'
          A single-precision float in the native format.

    `d'
          A double-precision float in the native format.

    `w'
          A BER compressed integer.  An unsigned integer in base 128,
          most significant digit first, where the high bit is set on
          all but the final (least significant) byte.  Thus any size
          integer can be encoded, but the encoding is efficient and
          small integers don't take up any more space than they would
          in normal char/short/int encodings.

    `x'
          A null byte.

    `o'
          An sexp, handled with `read' and `write'.


     If the optional keyword :OUTPUT is given that port is used instead
     of the current output port.  If :TO-STRING? is given and true,
     then pack accumulates and returns the output as a string.

     Note that the returned string may be an incomplete string if the
     packed string contains a byte sequence invalid as a character
     sequence.

          (pack "CCCC" '(65 66 67 68) :to-string? #t)
           => "ABCD"

          (pack "C/a*" '("hello") :to-string? #t)
           => "\x05hello"

 -- Function: unpack template &keyword :input :from-string
     The complement of pack, unpack reads values from the current input
     port assuming they've been packed according to the string template
     and returns the values as a list.  unpack accepts the same format
     strings as pack.  Further, the following tautology holds:

          (equal? x (unpack fmt :from-string (pack fmt x :to-string? #t)))

     for any list X and format string FMT.  The only exceptions to this
     are when the template includes a `*' and when the `o' template is
     used, since Scheme numeric literals cannot be reliably delimited
     (though future versions of `pack' may circumvent this by
     registering a new read syntax).

     If the optional keyword :INPUT is given that port is used instead
     of the current input port.  If :FROM-STRING is given, then pack
     reads input from that string.

          (unpack "CCCC" :from-string "ABCD")
           => '(65 66 67 68)

          (unpack "C/a*" :from-string "\x05hello")
           => '("hello")

     _Note:_ in the current version, `@' in `unpack' template has a bug
     and does not work as supposed.  It will be fixed in the future
     version.

 -- Function: unpack-skip template &keyword :input
     unpack-skip is the same as unpack except it does not return the
     values.  In some cases, particularly with fixed-size templates,
     this can be much more efficient when you just want to skip over a
     value.

 -- Function: make-packer template
     The low-level interface.  This function returns a dispatch closure
     that can be used to pack, unpack and skip over the same cached
     template.  The dispatch closure accepts symbol methods as follows:

    `'pack list'
          pack the items in list to the current output port.

    `'unpack'
          unpack items from the current input port.

    `'skip'
          skip items from the current input port.

    `'packer'
          return the cached 'pack closure

    `'unpacker'
          return the cached 'unpack closure.

    `'skipper'
          return the cached 'skip closure.

    `'length'
          return the known fixed length of the template.

    `'variable-length?'
          return #t if the template has variable length elements.


File: gauche-refe.info,  Node: Rational-less arithmetic,  Next: Database independent access layer,  Prev: Packing Binary Data,  Up: Library modules - Utilities

11.3 `compat.norational' - Rational-less arithmetic
===================================================

 -- Module: compat.norational
     Until release 0.8.7, Gauche didn't have exact rational numbers.
     It was able to read the rational number literals such as `2/3',
     but they are immediately coerced to inexact real numbers (except
     when it represents a whole integer).  And if you divided an exact
     integer by another exact integer, the result could be coerced to
     an inexact real if the result wasn't a whole integer.

     As of 0.8.8, this is not the case anymore.  Exact division always
     yields exact result, except when the divisor is zero.
          (/ 2 3)  => 2/3
          (/ 5)    => 1/5
          (/ 4 2)  => 2

     This is more precise, but has one drawback: exact rational
     arithmetic is much slower than the integer and inexact real
     arithmetic.  If you inadvertently produce a rational number in the
     early stage of calculation, and continue to apply exact
     arithmetic, performance would be degraded miserably.

     The proper way to solve this is to insert `exact->inexact' to
     appropriate places.  However, to ease the transition, you can just
     import this module and the division `/' behaves in the way it used
     to.

          (use compat.norational)

          (/ 2 3)  => 0.6666666666666666
          (/ 5)    => 0.2
          (/ 4 2)  => 2

     The effect is not global, but only to the modules you explicitly
     import `compat.norational'.

     This module only redefines `/'.  So if your code has exact
     rational literals, they are treated as exact rationals rather than
     coerced to inexact reals.  You should prefix rational literals
     with `#i' to force Gauche to coerce them to inexact reals:
          gosh> 1/3
          1/3
          gosh> #i1/3
          0.3333333333333333


File: gauche-refe.info,  Node: Database independent access layer,  Next: Generic DBM interface,  Prev: Rational-less arithmetic,  Up: Library modules - Utilities

11.4 `dbi' - Database independent access layer
==============================================

 -- Module: dbi
     This module provides the unified interface to access various
     relational database systems (RDBMS).  The operations specific to
     individual database systems are packaged in database driver (DBD)
     modules, which is usually loaded implicitly by DBI layer.

     The module is strongly influenced by Perl's DBI/DBD architecture.
     If you have used Perl DBI, it would be easy to use this module.

   It's better to look at the example.  This is a simple outline of
accessing a database by `dbi' module:

     (guard (e ((<dbi-error> e)
                ;; handle error
                ))
       (let* ((conn   (dbi-connect "dbi:mysql:test;host=dbhost"))
              (query  (dbi-prepare conn
                        "SELECT id, name FROM users WHERE department = ?"))
              (result (dbi-execute query "R&D"))
              (getter (relation-accessor result)))
         (map (lambda (row)
                (list (getter row "id")
                      (getter row "name")))
              result)))

   There's nothing specific to the underlying database system except
the argument `"dbi:mysql:test;host=dbhost"' passed to `dbi-connect',
from which `dbi' module figures out that it is an access to `mysql'
database, loads `dbd.mysql' module, and let it handle the mysql-specific
stuff.  If you want to use whatever database system, you can just pass
`"dbi:WHATEVER:PARAMETER"' to `dbi-connect' instead, and everything
stays the same as far as you have `dbd.whatever' installed in your
system.

   A query to the database can be created by `dbi-prepare'.  You can
issue the query by `dbi-execute'.  This two-phase approach allows you
to create a prepared query, which is a kind of parameterized SQL
statement.  In the above example the query takes one parameter, denoted
as `'?'' in the SQL.  The actual value is given in `dbi-execute'.  When
you issue similar queries a lot, creating a prepared query and execute
it with different parameters may give you performance gain.  Also the
parameter is automatically quoted.

   When the query is a `SELECT' statement, its result is returned as a
collection that implements the relation protocol.  See *note Collection
framework:: and *note Relation framework:: for the details.

   The outermost `guard' is to catch errors.  The `dbi' related errors
are supposed to inherit `<dbi-error>' condition.  There are a few
specific errors defined in `dbi' module.  A specific `dbd' layer may
define more specific errors.

   In the next section we describe user-level API, that is, the
procedures you need to concern when you're using `dbi'.  The following
section is for the driver API, which you need to use to write a
specific `dbd' driver to make it work with `dbi' framework.

* Menu:

* DBI user API::
* Writing drivers for DBI::


File: gauche-refe.info,  Node: DBI user API,  Next: Writing drivers for DBI,  Prev: Database independent access layer,  Up: Database independent access layer

11.4.1 DBI user API
-------------------

DBI Conditions
..............

There are several predefined conditions `dbi' API may throw.  See *note
Exceptions:: for the details of conditions.

 -- Condition Type: <dbi-error>
     The base class of `dbi'-related conditions.  Inherits `<error>'.

 -- Condition Type: <dbi-nonexistent-driver-error>
     This condition is thrown by `dbi-connect' when it cannot find the
     specified driver.  Inherits `<dbi-error>'.

      -- Instance Variable of <dbi-nonexistent-driver-error>:
     driver-name
          Holds the requested driver name as a string.

 -- Condition Type: <dbi-unsupported-error>
     This condition is thrown when the called method isn't supported by
     the underlying driver.  Inherits `<dbi-error>'.

 -- Condition Type: <dbi-parameter-error>
     This condition is thrown when the number of parameters given to
     the prepared query doesn't match the ones in the prepared
     statement.

   Besides these errors, if a driver relies on `dbi' to parse the
prepared SQL statement, `<sql-parse-error>' may be thrown if an invalid
SQL statement is passed to `dbi-prepare'.  (*Note SQL parsing and
construction::).

Connecting to the database
..........................

 -- Function: dbi-connect dsn &keyword username password
     Connect to a database using a data source specified by DSN (data
     source name).  DSN is a string with the following syntax:
          dbi:DRIVER:OPTIONS

     DRIVER part names a specific driver.  You need to have the
     corresponding driver module, `dbd.DRIVER', installed in your
     system.  For example, if DSN begins with `"dbi:mysql:"',
     `dbi-connect' tries to load `dbd.mysql'.

     Interpretation of the OPTIONS part is up to the driver.  Usually
     it is in the form of `key1=value1;key2=value2;...', but some
     driver may interpret it differently.  For example, `mysql' driver
     allows you to specify a database name at the beginning of OPTIONS.
      You have to check out the document of each driver for the exact
     specification of OPTIONS.

     The keyword arguments gives extra information required for
     connection.  The USERNAME and PASSWORD are commonly supported
     arguments.  The driver may recognize more keyword arguments.

     If a connection to the database is successfully established, a
     connection object (an instance of a subclass of `<dbi-connection>')
     is returned.  Otherwise, an error is signalled.

 -- Class: <dbi-connection>
     The base class of a connection to a database system.  Each driver
     defines a subclass of this to keep information about
     database-specific connections.

 -- Method: dbi-open? (c <dbi-connection>)
     Queries whether a connection to the database is still open
     (active).

 -- Method: dbi-close (c <dbi-connection>)
     Closes a connection to the database.  This causes releasing
     resources related to this connection.   Once closed, C cannot be
     used for any dbi operations (except passing to `dbi-open?').
     Calling `dbi-close' on an already closed connection has no effect.

     Although a driver usually closes a connection when
     `<dbi-connection>' object is garbage-collected, it is not a good
     idea to rely on that, since the timing of GC is unpredictable.
     The user program must make sure that it calls `dbi-close' at a
     proper moment.

 -- Function: dbi-list-drivers
     Returns a list of module names of known drivers.

 -- Class: <dbi-driver>
     The base class of a driver.  You usually don't need to see this as
     far as you're using the high-level `dbi' API.

 -- Function: dbi-make-driver driver-name
     This is a low-level function called from `dbi-connect' method, and
     usually a user doesn't need to call it.

     Loads a driver module specified by DRIVER-NAME, and instantiate
     the driver class and returns it.

Preparing and issuing queries
.............................

 -- Method: dbi-prepare conn sql &keyword pass-through ...
     From a string representation of SQL statement SQL, creates and
     returns a query object (an instance of `<dbi-query>' or its
     subclass) for the database connection `conn'

     SQL may contain parameter slots, denoted by `?'.
          (dbi-prepare conn "insert into tab (col1, col2) values (?, ?)")

          (dbi-prepare conn "select * from tab where col1 = ?")

     They will be filled when you actually issue the query by
     `dbi-execute'.  There are some advantages of using parameter
     slots: (1) The necessary quoting is done automatically.  You don't
     need to concern about security holes caused by improper quoting,
     for example.  (2) Some drivers support a feature to send the
     template SQL statement to the server at the preparation stage, and
     send only the parameter values at the execution stage.  It would be
     more efficient if you issue similar queries lots of time.

     If the backend does't support prepared statements (SQL templates
     having `?' parameters), the driver may use `text.sql' module to
     parse SQL.  It may raise `<sql-parse-error>' condition if the
     given SQL is not well formed.

     You may pass a true value to the keyword argument PASS-THROUGH to
     suppress interpretation of SQL and pass SQL as-is to the back end
     database system.  It is useful if the back-end supports extension
     of SQL which `text.sql' doesn't understand.

     If the driver lets prepared statement handled in back-end, without
     using `text.sql', the `pass-through' argument may be ignored.  The
     driver may also take other keyword arguments.  Check out the
     documentation of individual drivers.

     _Note:_ Case folding of SQL statement is implementation dependent.
     Some DBMS may treat table names and column names in case
     insensitive way, while others do in case sensitive way.  To write
     a portable SQL statement, make them quoted identifiers, that is,
     always surround names by double quotes.

 -- Class: <dbi-query>
     Holds information about prepared query, created by `dbi-prepare'.
     The following slots are defined.

      -- Instance Variable of <dbi-query>: connection
          Contains the `<dbi-connection>' object.

      -- Instance Variable of <dbi-query>: prepared
          If the driver prepares query by itself, this slot may contain
          a prepared statement.  It is up to each driver how to use
          this slot, so the client shouldn't rely on its value.


 -- Method: dbi-open? (q <dbi-query>)
     Returns `#t' iff the query can still be passed to `dbi-execute'.

 -- Method: dbi-close (q <dbi-query>)
     Destroy the query and free resources associated to the query.
     After this operation, `dbi-open?' returns `#f' for Q, and the
     query can't be used in any other way.  Although the resource may
     be freed when Q is garbage-collected, it is strongly recommended
     that the application closes queries explicitly.

 -- Method: dbi-execute (q <dbi-query>) parameter ...
     Executes a query created by `dbi-prepare'.  You should pass the
     same number of PARAMETERs as the query expects.

     If the issued query is `select' statement, `dbi-execute' returns
     an object represents a _relation_.  A relation encapsulates the
     values in rows and columns, as well as meta information like
     column names.  See "Retrieving query results" below for how to
     access the result.

     If the query is other types, such as `create', `insert' or
     `delete', the return value of the query closure is unspecified.

 -- Method: dbi-do conn sql &optional options parameter-value ...
     This is a convenience procedure when you create a query and
     immediately execute it.   It is equivalent to the following
     expression, although the driver may overload this method to avoid
     creating intermediate query object to avoid the overhead.
          (dbi-execute (apply dbi-prepare conn sql options)
                       parameter-value ...)

 -- Method: dbi-escape-sql conn str
     Returns a string where special characters in STR are escaped.

     The official SQL standard only specify a single quote (`'') as
     such character.  However, it doesn't specify non-printable
     characters, and the database system may use other escaping
     characters.  So it is necessary to use this method rather than
     doing escaping by your own.

          ;; assumes c is a valid DBI connection
          (dbi-escape-sql c "don't know")
            => "don''t know"

Retrieving query results
........................

If the query is a `select' statement, it returns an object of both
`<collection>' and `<relation>'.  It is a collection of rows (that is,
it implements `<collection>' API), so you can use `map', `for-each' or
other generic functions to access rows.  You can also use the relation
API to retrieve column names and accessors from it.  See *note Relation
framework::, for the relation API, and *note Collection framework::,
for the collection API.

   The actual class of the object returned from a query depends on the
driver, but you may use the following method on it.

 -- Method: dbi-open? result
     Check whether the result of a query is still active.  The result
     may become inactive when it is explicitly closed by `dbi-close'
     and/or the connection to the database is closed.

 -- Method: dbi-close result
     Close the result of the query.  This may cause releasing resources
     related to the result.   You can no longer use RESULT once it is
     closed, except passing it to `dbi-open?'.

     Although a driver usually releases resources when the result is
     garbage-collected, the application shouldn't rely on that and is
     recommended call `dbi-close' explicitly when it is done with the
     result.


File: gauche-refe.info,  Node: Writing drivers for DBI,  Prev: DBI user API,  Up: Database independent access layer

11.4.2 Writing drivers for DBI
------------------------------

Writing a driver for a specific database system means implementing a
module `dbd.FOO', where FOO is the name of the driver.

   The module have to implement several classes and methods, as
explained below.

DBI classes to implement
........................

You have to define the following classes.

   * Subclass `<dbi-driver>'.  The class name _must_ be `<FOO-driver>',
     where FOO is the name of the driver.  Usually this class produces
     a singleton instance, and is only used to dispatch
     `dbi-make-connection' method below.

   * Subclass `<dbi-connection>'.  An instance of this class is created
     by `dbi-make-connection'.  It needs to keep the information about
     the actual connections.

   * Subclass `<relation>' and `<collection>' to represent query
     results suitable for the driver.  (In most cases, the order of the
     result of SELECT statement is significant, since it may be sorted
     by ORDER BY clause.  Thus it is more appropriate to inherit
     `<sequence>', rather than `<collection>').

   * Optionally, subclass `<dbi-query>' to keep driver-specific
     information of prepared queries.

DBI methods to implement
........................

The driver need to implement the following methods.

 -- Method: dbi-make-connection (d <foo-driver>) (options <string>)
          (option-alist <list>) &keyword username password ...
     This method is called from `dbi-connect', and responsible to
     connect to the database and to create a connection object.  It
     must return a connection object, or raise an `<dbi-error>' if it
     cannot establish a connection.

     OPTIONS is the option part of the data source name (DSN) given to
     `dbi-connect'.  OPTION-ALIST is an assoc list of the result of
     parsing OPTIONS.  Both are provided so that the driver may
     interpret OPTIONS string in nontrivial way.

     For example, given `"dbi:foo:myaddressbook;host=dbhost;port=8998"'
     as DSN, foo's `dbi-make-connection' will receive
     `"myaddressbook;host=dbhost;port=8998"' as OPTIONS, and
     `(("myaddressbook" . #t) ("host" . "dbhost") ("port" . "8998"))'
     as OPTONS-ALIST.

     After OPTIONS-ALIST, whatever keyword arguments given to
     `dbi-connect' are passed.  DBI protocol currently specifies only
     USERNAME and PASSWORD.  The driver may define other keyword
     arguments.  It is recommended to name the driver-specific keyword
     arguments prefixed by the driver name, e.g. for `dbd.foo', it may
     take a `:foo-whatever' keyword argument.

     It is up to the driver writer to define what options are available
     and the syntax of the options.  The basic idea is that the DSN
     identifies the source of the data; it's role is like URL in WWW.
     So, it may include the hostname and port number of the database,
     and/or the name of the database, etc.  However, it shouldn't
     include information related to authentication, such as username
     and password.  That's why those are passed via keyword arguments.

 -- Method: dbi-prepare (c <foo-connection>) (sql <string>) &keyword
          pass-through ...
     This method should create and return a prepared query object,
     which is an instance of `<dbi-query>' or its subclass.  The query
     specified by SQL is issued to the database system when the
     prepared query object is passed to `dbi-execute'.

     The method must set C to the `connection' slot of the returned
     query object.

     SQL is an SQL statement.  It may contain placeholders represented
     by `'?''.  The query closure should take the same number of
     arguments as of the placeholders.   It is up to the driver whether
     it parses SQL internally and construct a complete SQL statement
     when the query closure is called, or it passes SQL to the back-end
     server to prepare the statement and let the query closure just send
     parameters.

     If the driver parses SQL statement internally, it should recognize
     a keyword argument `pass-through'.  If a true value is given, the
     driver must treat `sql' opaque and pass it as is when the query
     closure is called.

     The driver may define other keyword arguments.  It is recommended
     to name the driver-specific keyword arguments prefixed by the
     driver name, e.g. for `dbd.foo', it may take a `:foo-whatever'
     keyword argument.

 -- Method: dbi-execute-using-connection (c <foo-connection>) (q
          <dbi-query>) (params <list>)
     This method is called from `dbi-execute'.  It must issue the query
     kept in Q.  If the query is parameterized, the actual parameters
     given to DBI-EXECUTE are passed to PARAMS argument.

     If Q is a `select'-type query, this method must return an
     appropriate relation object.

 -- Method: dbi-escape-sql (c <foo-connection>) str
     If the default escape method isn't enough, the driver may overload
     this method to implement a specific escaping.  For example, MySQL
     treats backslash characters specially as well as single quotes, so
     it has its `dbi-escape-sql' method.

 -- Method: dbi-open? (c <foo-connection>)
 -- Method: dbi-open? (q <foo-query>)
 -- Method: dbi-open? (r <foo-result>)
 -- Method: dbi-close (c <foo-connection>)
 -- Method: dbi-close (q <foo-query>)
 -- Method: dbi-close (r <foo-result>)
     Queries open/close status of a connection and a result, and closes
     a connection and a result.  The close methods should cause
     releasing resources used by connection/result.  The driver has to
     allow `dbi-close' to be called on a connection or a result which
     has already been closed.

 -- Method: dbi-do (c <foo-connection>) (sql <string>) &optional
          options parameter-value ...
     The default method uses `dbi-prepare' and `dbi-execute' to
     implement the function.  It just works, but the driver may
     overload this method in order to skip creating intermediate query
     object for efficiency.

DBI utility functions
.....................

The following functions are low-level utilities which you may use to
implement the above methods.

 -- Function: dbi-parse-dsn data-source-name
     Parse the data source name (DSN) string given to `dbi-connect',
     and returns tree values: (1) The driver name in a string. (2)
     'options' part of DSN as a string.  (3) parsed options in an assoc
     list.  This may raise `<dbi-error>' if the given string doesn't
     conform DSN syntax.

     You don't need to use this to write a typical driver, for the
     parsing is done before `dbi-make-connection' is called.  This
     method may be useful if you're writing a kind of meta-driver, such
     as a proxy.

 -- Function: dbi-prepare-sql connection sql
     Parses an SQL statement SQL which may contain placeholders, and
     returns a closure, which generates a complete SQL statement when
     called with actual values for the parameters.  If the back-end
     doesn't support prepared statements, you may use this function to
     prepare queries in the driver.

     CONNECTION is a DBI connection to the database.  It is required to
     escape values within SQL properly (see `dbi-escape-sql' above).

          ;; assume c contains a valid dbi connection
          ((dbi-prepare-sql c "select * from table where id=?") "foo'bar")
           => "select * from table where id='foo''bar'"


File: gauche-refe.info,  Node: Generic DBM interface,  Next: File-system dbm,  Prev: Database independent access layer,  Up: Library modules - Utilities

11.5 `dbm' - Generic DBM interface
==================================

 -- Module: dbm
     DBM-like libraries provides an easy way to store values to a file,
     indexed by keys.  You can think it as a persistent associative
     memory.

     This modules defines `<dbm>' abstract class, which has a common
     interface to use various DBM-type database packages.  As far as
     you operate on the already opened database, importing `dbm' module
     is enough.

     To create or open a database, you need a concrete implementation
     of the database.  Gauche currently has the following
     implementations.  Each module defines its own low-level accessing
     functions as well as the common interface.  Note that your system
     may not have one or more of those DBM libraries; Gauche defines
     only what the system provides.

    `dbm.fsdbm'
          file-system dbm (*Note File-system dbm::).

    `dbm.gdbm'
          GDBM library (*Note GDBM interface::).

    `dbm.ndbm'
          NDBM library (*Note NDBM interface::).

    `dbm.odbm'
          DBM library  (*Note Original DBM interface::).

The following code shows a typical usage of the database.

     (use dbm)         ; dbm abstract interface
     (use dbm.gdbm)    ; dbm concrete interface

     ; open the database
     (define *db* (dbm-open <gdbm> :path "mydb" :rw-mode :write))

     ; put the value to the database
     (dbm-put! *db* "key1" "value1")

     ; get the value from the database
     (define val (dbm-get *db* "key1"))

     ; iterate over the database
     (dbm-for-each *db* (lambda (key val) (foo key val)))

     ; close the database
     (dbm-close *db*)

* Menu:

* Opening and closing a dbm database::
* Accessing a dbm database::
* Iterating on a database::
* Managing dbm database instance::
* Writing a dbm implementation::


File: gauche-refe.info,  Node: Opening and closing a dbm database,  Next: Accessing a dbm database,  Prev: Generic DBM interface,  Up: Generic DBM interface

11.5.1 Opening and closing a dbm database
-----------------------------------------

 -- Class: <dbm>
     An abstract class for dbm-style database.  Defindes the common
     database operations.   This class has the following instance slots.
     They must be set before the database is actually opened by
     `dbm-open'.

     The concrete class may add more slots for finer control on the
     database, such as locking.

      -- Instance Variable of <dbm>: path
          Pathname of the dbm database.  Some dbm implementation may
          append suffixes to this.

      -- Instance Variable of <dbm>: rw-mode
          Specifies read/write mode.  Can be either one of the
          following keywords:
         `:read'
               The database will be opened in read-only mode.  The
               database file must exist when `dbm-open' is called.
               This is the default value.

         `:write'
               The database will be opened in Read-write mode.  If the
               database file does not exist, `dbm-open' creates one.

         `:create'
               The database will be created and opened in Read-write
               mode.  If the database file exists, `dbm-open' truncates
               it.

      -- Instance Variable of <dbm>: file-mode
          Specifies the file permissions (as `sys-chmod') to create the
          database.  The default value is `#o664'.

      -- Instance Variable of <dbm>: key-convert
      -- Instance Variable of <dbm>: value-convert
          By default, you can use only strings for both key and values.
          With this option, however, you can specify how to convert
          other Scheme values to/from string to be stored in the
          database.   The possible values are the followings:
         `#f'
               The default value.  Keys (values) are not converted.
               They must be a string.

         `#t'
               Keys (values) are converted to its string
               representation, using `write', to store in the database,
               and converted back to Scheme values, using `read', to
               retrieve from the database.  The data must have an
               external representation that can be read back.  (But it
               is not checked when the data is written; you'll get an
               error when you read the data).  The key comparison is
               done in the string level, so the external representation
               of the same key must match.

         a list of two procedures
               Both procedure must take a single argument.  The first
               procedure must receive a Scheme object and returns a
               string.  It is used to convert the keys (values) to
               store in the database.  The second procedure must
               receive a string and returns a Scheme object.  It is
               used to convert the stored data in the database to a
               Scheme object.  The key comparison is done in the string
               level, so the external representation of the same key
               must match.

 -- Metaclass: <dbm-meta>
     A metaclass of `<dbm>' and its subclasses.

 -- Method: dbm-open (dbm <dbm>)
     Opens a dbm database.  DBM must be an instance of one of the
     concrete classes that derived from the `<dbm>' class, and its
     slots must be set appropriately.   On success, it returns the DBM
     itself.  On failure, it signals an error.

 -- Method: dbm-open (dbm-class <dbm-meta>) options ...
     A convenient method that creates dbm instance and opens it.  It is
     defined as follows.
          (define-method dbm-open ((class <class>) . initargs)
            (dbm-open (apply make class initargs)))

   Database file is closed when it is garbage collected.  However, to
ensure the modification is properly synchronized, you should close the
database explicitly.

 -- Method: dbm-close (dbm `<dbm>')
     Closes a database DBM.  Once the database is closed, any operation
     to access the database content raises an error.

 -- Method: dbm-closed? (dbm `<dbm>')
     Returns true if a database DBM is already closed, false otherwise.


File: gauche-refe.info,  Node: Accessing a dbm database,  Next: Iterating on a database,  Prev: Opening and closing a dbm database,  Up: Generic DBM interface

11.5.2 Accessing a dbm database
-------------------------------

Once a database is opened, you can use the following methods to access
individual key/value pairs.

 -- Method: dbm-put! (dbm `<dbm>') key value
     Put a VALUE with KEY.

 -- Method: dbm-get (dbm `<dbm>') key &optional default
     Get a value associated with KEY.  If no value exists for KEY and
     DEFAULT is specified, it is returned.  If no value exists for KEY
     and DEFAULT is not specified, an error is signalled.

 -- Method: dbm-exists? (dbm `<dbm>') key
     Return true if a value exists for KEY, false otherwise.

 -- Method: dbm-delete! (dbm `<dbm>') key
     Delete a value associated with KEY.


File: gauche-refe.info,  Node: Iterating on a database,  Next: Managing dbm database instance,  Prev: Accessing a dbm database,  Up: Generic DBM interface

11.5.3 Iterating on a dbm database
----------------------------------

To walk over the entire database, following methods are provided.

 -- Method: dbm-fold (dbm `<dbm>') procedure knil
     The basic iterator.  For each key/value pair, PROCEDURE is called
     as `(PROCEDURE KEY VALUE R)', where R is KNIL for the fist call of
     PROCEDURE, and the return value of the previous call for
     subsequent calls.  Returns the result of the last call of
     PROCEDURE.  If no data is in the database, KNIL is returned.

     The following method returns the sum of all the integer values.
          (dbm-fold dbm (lambda (k v r) (if (integer? v) (+ v r) r)) 0)

 -- Method: dbm-for-each (dbm `<dbm>') procedure
     For each key/value pair in the database DBM, PROCEDURE is called.
     Two arguments are passed to PROCEDURE--a key and a value.   The
     result of PROCEDURE is discarded.

 -- Method: dbm-map (dbm `<dbm>') procedure
     For each key/value pair in the database DBM, PROCEDURE is called.
     Two arguments are passed to PROCEDURE--a key and a value.   The
     result of PROCEDURE is accumulated to a list which is returned as
     a result of `dbm-map'.


File: gauche-refe.info,  Node: Managing dbm database instance,  Next: Writing a dbm implementation,  Prev: Iterating on a database,  Up: Generic DBM interface

11.5.4 Managing dbm database instance
-------------------------------------

Each dbm implementation has its own way to store the database.  Legacy
dbm uses two files, whose names are generated by adding `.dir' and
`.pag' to the value of PATH slot.  `Fsdbm' creates a directory under
PATH.  If dbm database is backed up by some database server, PATH may
be used only as a key to the database in the server.  The following
methods hide such variations and provides a convenient way to manage a
database itself.   You have to pass a class that implements a concrete
dbm database to their first argument.

 -- Generic Function: dbm-db-exists? class name
     Returns `#t' if a database of class CLASS specified by NAME exists.

          ;; Returns #t if testdb.dir and testdb.pag exist
          (dbm-db-exists? <odbm> "testdb")

 -- Generic Function: dbm-db-remove class name
     Removes an entire database of class CLASS specified by NAME.

 -- Generic Function: dbm-db-copy class from to
     Copy a database of class CLASS specified by FROM to TO.  The
     integrity of FROM is guaranteed if the CLASS's dbm implementation
     supports locking (i.e. you won't get a corrupted database even if
     some other process is trying to write to FROM during copy).   If
     the destination database TO exists, its content is destroyed.  If
     this function is interrupted, whether TO is left in incomplete
     state or not depends on the dbm implementation.   The
     implementation usually tries its best to provide transactional
     behavior, that is, to recover original TO when the copy fails.
     However, for the robust operations the caller have to check the
     state of TO if `dbm-db-copy' fails.

          (dbm-db-copy <gdbm> "testdb.dbm" "backup.dbm")

 -- Generic Function: dbm-db-move class from to
     Moves or renames a database of class CLASS specified by FROM to
     TO.  Like `dbm-db-copy', the database integrity is guaranteed as
     far as CLASS's dbm implementation supports locking.  If the
     destination database TO exists, its content is destroyed.


File: gauche-refe.info,  Node: Writing a dbm implementation,  Prev: Managing dbm database instance,  Up: Generic DBM interface

11.5.5 Writing a dbm implementation
-----------------------------------

When you write an extension module that behaves like a persistent
hashtable, it is a good idea to adapt it to the dbm interface, so that
the application can use the module in a generic way.

   The minimum procedures to conform the dbm interface are as follow:

   * Define a metaclass `<FOO-meta>'.   It doesn't need to inherit
     anything except `<class>'.

   * Define a dbm class `<FOO>' that inherits `<dbm>' and whose
     metaclass is `<FOO-meta>'.

   * Define methods for `dbm-open', `dbm-close', `dbm-put!', `dbm-get',
     `dbm-exists', `dbm-delete!', `dbm-fold', `dbm-closed?',
     specialized for `<FOO>'.  (The case of `dbm-open' for `<FOO-meta>'
     is handled automatically, so you don't need to define it unless
     you want something special).  Also note that the specialized
     `dbm-open' must call `next-method' in it to set up dbm base class
     internals.

   * Define methods for `dbm-db-exists?' and `dbm-db-remove' on
     `<FOO-meta>'.

   Besides above, you may define the following methods.

   * Methods for `dbm-for-each' and `dbm-map'.  If you don't define
     them, a generic implementation by `dbm-fold' is used.  There may
     be an implementation specific way which is more efficient.

   * Methods for `dbm-db-copy' and `dbm-db-move'.  If you don't define
     them, a fallback method opens the specified databases and copies
     elements one by one, and removes the original if the method is
     `dbm-db-move'.  Note that the fallback method is not only
     inefficient, but also it may not copy any implementation-specific
     meta information.  It is highly recommended for the dbm
     implementation to provide these methods as well.

   It is generally recommended to name the implementation module as
`dbm.FOO', and the class of the implementation as `<FOO>'.  With this
convention it is easier to write an application that dynamically loads
and uses dbm implementation specified at runtime.


File: gauche-refe.info,  Node: File-system dbm,  Next: GDBM interface,  Prev: Generic DBM interface,  Up: Library modules - Utilities

11.6 `dbm.fsdbm' - File-system dbm
==================================

 -- Module: dbm.fsdbm
     Implements fsdbm.  Extends `dbm'.

 -- Class: <fsdbm>
     `Fsdbm' is a dbm implementation that directly uses the filesystem.
     Basically, it uses file names for keys, and file content for
     values.   Unlike other dbm implementations, this doesn't depend on
     external libraries--it is pure Scheme implementation--so it is
     always available, while other dbm implementations may not.
     Obviously, it is not suitable for the database that has lots of
     entries, or has entries deleted and added very frequently.  The
     advantage is when the number of entries are relatively small, and
     the values are relatively large while keys are small.  The
     database name given to `<fsdbm>' instance is used as a directory
     name that stores the data.  The data files are stored in
     subdirectories under PATH of `fsdbm' instance, hashed by the key.
     Non-alphanumeric characters in the key is encoded like `_3a' for
     '`:'', for example.  If a key is too long to be a file name, it is
     chopped to chunks, and each chunk but the last one is used as a
     directory name.  Note that a long key name may still cause a
     problem, for example, some of old 'tar' command can't deal with
     pathnames (not each pathname components, but the entire pathname)
     longer than 256 characters.

   Fsdbm implements all of the dbm protocol (see *note Generic DBM
interface::).  It doesn't have any fsdbm-specific procedures.


File: gauche-refe.info,  Node: GDBM interface,  Next: NDBM interface,  Prev: File-system dbm,  Up: Library modules - Utilities

11.7 `dbm.gdbm' - GDBM interface
================================

 -- Module: dbm.gdbm
     Provides interface to the gdbm library.  Extends `dbm'.

 -- Class: <gdbm>
     Inherits `<dbm>'.  Provides an implementation for GDBM library.
     This module is only installed when your system already has GDBM
     (1.8.0 is preferred, but works with older 1.7.x with some
     limitations).

      -- Instance Variable of <gdbm>: sync

      -- Instance Variable of <gdbm>: nolock

      -- Instance Variable of <gdbm>: bsize

   Besides the unified DBM interface (*Note Generic DBM interface::),
this module provides the following low-level functions that provides
direct access to the gdbm API.  See gdbm manual for details of these
APIs.

 -- Function: gdbm-open path &optional size rwmode fmode error-callback
      -- Variable: GDBM_READER

      -- Variable: GDBM_WRITER

      -- Variable: GDBM_WRCREAT

      -- Variable: GDBM_NEWDB

      -- Variable: GDBM_FAST

      -- Variable: GDBM_SYNC

      -- Variable: GDBM_NOLOCK

 -- Function: gdbm-close gdbm-object

 -- Function: gdbm-closed? gdbm-object

 -- Function: gdbm-store key value &optional flag
      -- Variable: GDBM_INSERT

      -- Variable: GDBM_REPLACE


 -- Function: gdbm-fetch gdbm-object key

 -- Function: gdbm-delete gdbm-object key

 -- Function: gdbm-firstkey gdbm-object

 -- Function: gdbm-nextkey gdbm-object key

 -- Function: gdbm-reorganize gdbm-object

 -- Function: gdbm-sync gdbm-object

 -- Function: gdbm-exists? gdbm-object key

 -- Function: gdbm-strerror errno

 -- Function: gdbm-setopt gdbm-object option value
      -- Variable: GDBM_CACHESIZE

      -- Variable: GDBM_FASTMODE

      -- Variable: GDBM_SYNCMODE

      -- Variable: GDBM_CENTFREE

      -- Variable: GDBM_COALESCEBLKS

 -- Function: gdbm-version

 -- Function: gdbm-errno


File: gauche-refe.info,  Node: NDBM interface,  Next: Original DBM interface,  Prev: GDBM interface,  Up: Library modules - Utilities

11.8 `dbm.ndbm' - NDBM interface
================================

 -- Module: dbm.ndbm
     Provides interface to the 'new' dbm library, a.k.a. ndbm.  Extends
     `dbm'.

 -- Class: <ndbm>
     Inherits `<dbm>'.  Provides an implementation for NDBM library.
     This module is only installed when your system already has NDBM.

   Besides the unified DBM interface (*Note Generic DBM interface::),
this module provides the following low-level functions that provides
direct access to the ndbm API.  See ndbm manual for details of these
APIs.

 -- Function: ndbm-open path flags mode

 -- Function: ndbm-close ndbm-object

 -- Function: ndbm-closed? ndbm-object

 -- Function: ndbm-store ndbm-object key content &optional flag

 -- Function: ndbm-fetch ndbm-object key

 -- Function: ndbm-delete ndbm-object key

 -- Function: ndbm-firstkey ndbm-object

 -- Function: ndbm-nextkey ndbm-object

 -- Function: ndbm-error ndbm-object

 -- Function: ndbm-clear-error ndbm-object


File: gauche-refe.info,  Node: Original DBM interface,  Next: Filtering file content,  Prev: NDBM interface,  Up: Library modules - Utilities

11.9 `dbm.odbm' - Original DBM interface
========================================

 -- Module: dbm.odbm
     Provides interface to the legacy dbm library.  Extends `dbm'.

 -- Class: <odbm>
     Inherits `<dbm>'.  Provides an implementation for legacy DBM
     library.  This module is only installed when your system already
     has DBM.

     The biggest limitation of the legacy DBM is that you can only open
     one database at a time.  You can create a multiple `<odbm>'
     instances, but you can open at most one of it at a time, or you'll
     get an error.

   Besides the unified DBM interface (*Note Generic DBM interface::),
this module provides the following low-level functions that provides
direct access to the dbm API.  See dbm manual for details of these APIs.

 -- Function: odbm-init path

 -- Function: odbm-close

 -- Function: odbm-store key value

 -- Function: odbm-fetch key

 -- Function: odbm-delete key

 -- Function: odbm-firstkey

 -- Function: odbm-nextkey key


File: gauche-refe.info,  Node: Filtering file content,  Next: Filesystem utilities,  Prev: Original DBM interface,  Up: Library modules - Utilities

11.10 `file.filter' - Filtering file content
============================================

 -- Module: file.filter
     This module provides utilities for a common pattern in filter-type
     commands, that is, to take an input, to process the content, and
     to write the result.   The common occurring pattern is:

        * Input may be a specified file, or an input port (the current
          input port by default).

        * Output may be a specified file, or an output port (the
          current output port by default).

        * Output may be a temporary file, which will be renamed upon
          completion of the processing.

        * Output file may be removed when an error occurs in the
          processing.

 -- Function: file-filter proc &keyword input output temporary-file
          keep-output?
     Calls PROC with two arguments, an input port and an output port.
     Returns the result(s) of PROC.  The input port and output port are
     chosen depending on the keyword arguments.

    `input'
          The argument must be either an input port or a string that
          specifies a file name.  If it's an input port, it is passed
          to PROC as is.  If it's a string, the named file is opened
          for input and the resulting port is passed to PROC, and the
          port is closed when PROC returns.  If this argument is
          omitted, the current input port is passed.

    `output'
          The argument must be either an output port or a string that
          specifies a file name.  If it's an output port, it is passed
          to PROC as is.  If it's a string, the named file is opened
          for output (unless TEMPORARY-FILE is given, in that case a
          temporary file is opened instead), and the resulting port is
          passed to PROC.  This port is closed when PROC returns.  If
          this argument is omitted, the current output port is passed.

    `temporary-file'
          If a string file name is given to this argument, the named
          file is opened for output during the processing, instead of
          the file name as OUTPUT.   The output port PROC receives is
          connected to this file.  When PROC returns normally, the file
          is renamed to the name given to OUTPUT keyword argument.

          If the given file name begins with characters except `"/"',
          `"./"' or `"../"', the directory of the file name given to
          OUTPUT argument is attached before it.  Furthermore, a unique
          name is attached to the temporary file name (the temporary
          file is opened by `sys-mkstemp'.)

          This argument is ignored when OUTPUT argument is not a string
          file name.

    `keep-output?'
          If a true value is given, the output is not deleted even when
          PROC signals an error.  By default, the output (or the
          temporary file when TEMPORARY-FILE is given) will be deleted
          on error.


File: gauche-refe.info,  Node: Filesystem utilities,  Next: Mathematic constants,  Prev: Filtering file content,  Up: Library modules - Utilities

11.11 `file.util' - Filesystem utilities
========================================

 -- Module: file.util
     Provides convenient utility functions handling files and
     directories.  Those functions are built on top of the primitive
     system procedures described in *note Filesystems::.

     Many procedures in this module takes a keyword argument
     FOLLOW-LINK?, which specifies the behavior when the procedure sees
     a symbolic link.  If true value is given to FOLLOW-LINK? (which is
     the default), the procedure operates on the file referenced by the
     link; if false is given, it operates on the link itself.

   Note on the naming convention: Some Scheme implementations "create"
new directories and files, while the others "make" them.  Some
implementations "delete" them, while the others "remove" them.  It
seems that both conventions are equally popular.  So Gauche provides
_both_.

* Menu:

* Directory utilities::
* Pathname utilities::
* File attribute utilities::
* File operations::


File: gauche-refe.info,  Node: Directory utilities,  Next: Pathname utilities,  Prev: Filesystem utilities,  Up: Filesystem utilities

11.11.1 Directory utilities
---------------------------

 -- Function: current-directory &optional new-directory
     When called with no argument, this returns the pathname of the
     current working directory.  When called with a string argument
     NEW-DIRECTORY, this sets the current working directory of the
     process to it.  If the process can't change directory to
     NEW-DIRECTORY, an error is signalled.

     This function is in ChezScheme, MzScheme and some other Scheme
     implementations.

 -- Function: home-directory &optional user
     Returns the home directory of the given USER, which may be a
     string user name or an integer user id.  If USER is omitted, the
     current user is assumed.  If the given user cannot be found, or
     the home directory of the user cannot be determined, `#f' is
     returned.

 -- Function: temporary-directory
     Returns the name of the directory that can be used to create a
     temporary files.   It returns the value of the environment
     variable `TMPDIR' if it is defined, or `/tmp' otherwise.

 -- Function: directory-list path &keyword children? add-path? filter
          filter-add-path?
     Returns a list of entries in the directory PATH.  The result is
     sorted by dictionary order.

     By default, only the basename (the last component) of the entries
     returned.   If ADD-PATH? is given and true, PATH is appended to
     each entry.  If CHILDREN? is given and true, `"."' and `".."' are
     excluded from the result.

     If FILTER is given, it must be a predicate that takes one argument.
     It is called on every element of the directory entry, and only the
     entries on which FILTER returns true are included in the result.
     The argument passed to FILTER is a basename of the directory entry
     by default, but when FILTER-ADD-PATH? is true, PATH is appended to
     the entry.

     If PATH is not a directory, an error is signalled.

          (directory-list "test")
           => ("." ".." "test.scm" "test.scm~")

          (directory-list "test" :add-path? #t)
           => ("test/." "test/.." "test/test.scm" "test/test.scm~")

          (directory-list "test" :children? #t)
           => ("test.scm" "test.scm~")

          (directory-list "test" :children? #t :add-path? #t
             :filter (lambda (e) (not (string-suffix? "~" e))))
           => ("test/test.scm")

 -- Function: directory-list2 path &keyword children? add-path? filter
          follow-link?
     Like `directory-list', but returns two values; the first one is a
     list of subdirectories, and the second one is a list of the rest.
     The keyword arguments CHILDREN?, `add-path?' and FILTER are the
     same as `directory-list'.

     Giving false value to FOLLOW-LINK? makes `directory-list2' not
     follow the symbolic links; if the PATH contains a symlink to a
     directory, it will be included in the first list if FOLLOW-LINK?
     is omitted or true, while it will be in the second list if
     FOLLOW-LINK? is false.

 -- Function: directory-fold path proc seed &keyword lister follow-link?
     A fundamental directory traverser.  Conceptually it works as
     follows, in recursive way.

        * If PATH is not a directory, calls `(PROC PATH SEED)' and
          returns the result.

        * If PATH is a directory, calls `(LISTER PATH SEED)'.  The
          procedure LISTER is expected to return two values: a list of
          pathnames, and the next seed value.   Then `directory-fold'
          is called on each returned pathname, passing the returned
          seed value to the SEED argument of the next call of
          `directory-fold'.  Returns the result of the last seed value.

     The default procedure of LISTER is just a call to `directory-list',
     as follows.
          (lambda (path seed)
            (values (directory-list path :add-path? #t :children? #t)
                    seed))

     Note that LISTER shouldn't return the given path itself (`"."')
     nor the parent directory (`".."'), or the recursion wouldn't
     terminate.  Also note LISTER is expected to return a path
     accessible from the current directory, i.e. if PATH is
     `"/usr/lib/foo"' and it contains `"libfoo.a"' and `"libfoo.so"',
     LISTER should return `'("/usr/lib/foo/libfoo.a"
     "/usr/lib/foo/libfoo.so")'.

     The keyword argument FOLLOW-LINK? is used to determine whether
     LISTER should be called on a symbolic link pointing to a directory.
     When FOLLOW-LINK? is true (default), LISTER is called with the
     symbolic link if it points to a directory.  When FOLLOW-LINK? is
     false, PROC is not called.

     The following example returns a list of pathnames of the emacs
     backup files (whose name ends with "~") under the given path.
          (use srfi-13) ;; for string-suffix?
          (directory-fold path
                          (lambda (entry result)
                            (if (string-suffix? "~" entry)
                                (cons entry result)
                                result))
                          '())

     The following example lists all the files and directories under the
     given pathname.   Note the use of LISTER argument to include the
     directory path itself in the result.
          (directory-fold path cons '()
            :lister (lambda (path seed)
                      (values (directory-list path :add-path? #t :children? #t)
                              (cons path seed))))


 -- Function: make-directory* name &optional perm
 -- Function: create-directory* name &optional perm
     Creates a directory NAME.  If the intermediate path to the
     directory doesn't exist, they are also created (like `mkdir -p'
     command on Unix).   If the directory NAME already exist, these
     procedure does nothing.  PERM specifies the integer flag for
     permission bits of the directory.

 -- Function: remove-directory* name
 -- Function: delete-directory* name
     Deletes directory NAME and its content recursively (like `rm -r'
     command on Unix).   Symbolic links are not followed.

 -- Function: copy-directory* src dst &keyword if-exists backup-suffix
          safe keep-timestamp keep-mode follow-link?
     If SRC is a regular file, copies its content to DST, just like
     `copy-file' does.  If SRC is a directory, recursively desends it
     and copy the file tree to DST.  Basically it mimics the behavior
     of `cp -r' command.

     If there's any symbolic links under SRC, the link itself is copied
     instead of the file pointed to by it, unless a true value is given
     to the FOLLOW-LINK? keyword argument, i.e. the default value of
     FOLLOW-LINK? is `#f'.  (Note that this is opposite to the
     `copy-file', in which FOLLOW-LINK? is true by default.)

     The meanings of the other keyword arguments are the same as
     `copy-file'.  See the entry of `copy-file' for the details.

 -- Function: create-directory-tree dir spec
     Creates a directory tree under DIR according to SPEC.  This
     procedure is useful to set up certain directory hierarchy at once.

     The SPEC argument is an S-expression with the following structure:

          <spec> : <name>                             ; empty file
                 | (<name> <option> ...)              ; empty file
                 | (<name> <option> ... <string>)     ; file with content
                 | (<name> <option> ... <procedure>)  ; file with generated content
                 | (<name> <option> ... (<spec> ...)) ; directory

          <name> : string or symbol

          <option> ... : keyword-value alternating list

     With the first and second form of SPEC, an empty file is created
     with the given name.  With the third form of SPEC, the string
     becomes the content of the file.

     With the fourth form of SPEC, the procedure is called with the
     pathname as an argument, and output to the current output port
     within the procedure is written to the created file.  The pathname
     is relative to the DIR argument.  At the time the procedure is
     called, its parent directory is already created.

     The last form of SPEC creates a named directory, then creates its
     children recursively according to the specs.

     With OPTIONs you can control attributes of created
     files/directories.  Currently the following options are recognized.

    `:mode MODE'
          Takes integer as permission mode bits.

    `:owner UID'
    `:group GID'
          Takes integer uid/gid of the owner/group of the
          file/directory.  Calling process may need special priviledge
          to change the owner and/or group.

    `:symlink PATH'
          This is only valid for file spec, and it causes
          `create-directory-tree' to create a named symbolic link whose
          content is PATH.

 -- Function: check-directory-tree dir spec
     Checks if a directory hierarchy according to SPEC exists under
     DIR.  Returns `#t' if it exists, or #F otherwise.

     The format of SPEC is the same as `create-directory-tree'
     described above.

     If SPEC contains options, the attributes of existing
     files/directories are also checked if they match the given options.


File: gauche-refe.info,  Node: Pathname utilities,  Next: File attribute utilities,  Prev: Directory utilities,  Up: Filesystem utilities

11.11.2 Pathname utilities
--------------------------

 -- Function: build-path base-path component ...
     Appends pathname components COMPONENT to the BASE-PATH.  COMPONENT
     can be a symbol `up' or `same'; in Unix, they are synonym to
     `".."' and `"."'.  This API is taken from MzScheme.

 -- Function: absolute-path? path
 -- Function: relative-path? path
     Returns `#t' if PATH is absolute or relative, respectively.

 -- Function: expand-path path
     Expands tilda-notation of PATH if it contains one.  Otherwise,
     PATH is returned.  This function does not check if PATH exists
     and/or readable.

 -- Function: resolve-path path
     Expands PATH like `expand-path', then resolve symbolic links for
     every components of the path.  If PATH does not exist, or contains
     dangling link, or contains unreadable directory, an error is
     signalled.

 -- Function: simplify-path path
     Remove 'up' (`".."') components and 'same' (`"."') components from
     PATH as much as possible.  This function does not access the
     filesystem.

 -- Function: decompose-path path
     Returns three values; the directory part of PATH, the basename
     without extension of PATH, and the extension of PATH.    If the
     pathname doesn't have an extension, the third value is `#f'.  If
     the pathname ends with a directory separator, the second and third
     values are `#f'. (Note: This treatment of the trailing directory
     separator differs from `sys-dirname'/`sys-basename'; those follow
     popular shell's convention, which ignores trailing slashes.)
          (decompose-path "/foo/bar/baz.scm")
            => "/foo/bar", "baz", "scm"
          (decompose-path "/foo/bar/baz")
            => "/foo/bar", "baz", #f

          (decompose-path "baz.scm")
            => ".", "baz", "scm"
          (decompose-path "/baz.scm")
            => "/", "baz", "scm"

          ;; Boundary cases
          (decompose-path "/foo/bar/baz.")
            => "/foo/bar", "baz", ""
          (decompose-path "/foo/bar/.baz")
            => "/foo/bar", ".baz", #f
          (decompose-path "/foo/bar.baz/")
            => "/foo/bar.baz", #f, #f

 -- Function: path-extension path
 -- Function: path-sans-extension path
     Returns an extension of PATH, and  a pathname of PATH without
     extension, respectively.  If PATH doesn't have an extension, `#f'
     and PATH is returned respectively.

          (path-extension "/foo/bar.c")       => "c"
          (path-sans-extension "/foo/bar.c")  => "/foo/bar"

          (path-extension "/foo/bar")         => #f
          (path-sans-extension "/foo/bar")    => "/foo/bar"

 -- Function: path-swap-extension path newext
     Returns a pathname in which the extension of PATH is replaced by
     NEWEXT.  If PATH doesn't have an extension, "." and NEWEXT is
     appended to PATH.

     If NEWEXT is `#f', it returns PATH without extension.

          (path-swap-extension "/foo/bar.c" "o")  => "/foo/bar.o"
          (path-swap-extension "/foo/bar.c" #f)   => "/foo/bar"

 -- Function: find-file-in-paths name &keyword paths pred
     Looks for a file that has name NAME in the given list of pathnames
     PATHS and that satisfies a predicate PRED.  If found, the absolute
     pathname of the file is returned.  Otherwise, `#f' is returned.

     If NAME is an absolute path, only the existence of NAME and
     whether it satisfies PRED are checked.

     The default value of PATHS is taken from the environment variable
     `PATH', and the default value of PRED is `file-is-executable?'
     (*Note File attribute utilities::).  That is, `find-file-in-paths'
     searches the named executable file in the command search paths by
     default.

          (find-file-in-paths "ls")
            => "/bin/ls"

          ;; example of searchin user preference file of my application
          (find-file-in-paths "userpref"
            :paths `(,(expand-path "~/.myapp")
                     "/usr/local/share/myapp"
                     "/usr/share/myapp")
            :pred  file-is-readable?)


File: gauche-refe.info,  Node: File attribute utilities,  Next: File operations,  Prev: Pathname utilities,  Up: Filesystem utilities

11.11.3 File attribute utilities
--------------------------------

 -- Function: file-type path &keyword follow-link?
 -- Function: file-perm path &keyword follow-link?
 -- Function: file-mode path &keyword follow-link?
 -- Function: file-ino path &keyword follow-link?
 -- Function: file-dev path &keyword follow-link?
 -- Function: file-rdev path &keyword follow-link?
 -- Function: file-nlink path &keyword follow-link?
 -- Function: file-uid path &keyword follow-link?
 -- Function: file-gid path &keyword follow-link?
 -- Function: file-size path &keyword follow-link?
 -- Function: file-atime path &keyword follow-link?
 -- Function: file-mtime path &keyword follow-link?
 -- Function: file-ctime path &keyword follow-link?
     These functions return the attribute of file/directory specified by
     PATH.  The attribute name corresponds to the slot name of
     `<sys-stat>' class (*Note File stats::).  If the named path
     doesn't exist, `#f' is returned.

     If PATH is a symbolic link, these functions queries the attributes
     of the file pointed by the link, unless an optional argument
     FOLLOW-LINK? is given and false.

     MzScheme and Chicken have `file-size'.  Chicken also has
     `file-modification-time', which is `file-mtime'.

 -- Function: file-is-readable? path
 -- Function: file-is-writable? path
 -- Function: file-is-executable? path
     Returns `#t' if PATH exists and readable/writable/executable by
     the current effective user, respectively.  This API is taken from
     STk.

 -- Function: file-is-symlink? path
     Returns `#t' if PATH exists and a symbolic link.  See also
     `file-is-regular?' and `file-is-directory?' in *note File stats::.

 -- Function: file-eq? path1 path2
 -- Function: file-eqv? path1 path2
 -- Function: file-equal? path1 path2
     Compares two files specified by PATH1 and PATH2.  `file-eq?' and
     `file-eqv?' checks if PATH1 and PATH2 refers to the identical
     file, that is, whether they are on the same device and have the
     identical inode number.  The only difference is when the last
     component of PATH1 and/or PATH2 is a symbolic link, `file-eq?'
     doesn't resolve the link (so compares the links themselves) while
     FILE-EQV? resolves the link and compares the files referred by the
     link(s).

     `file-equal?' compares PATH1 and PATH2 considering their content,
     that is, when two are not the identical file in the sense of
     `file-eqv?', `file-equal?' compares their content and returns `#t'
     if all the bytes match.

     The behavior of `file-equal?' is undefined when PATH1 and PATH2
     are both directories.  Later, it may be extended to scan the
     directory contents.

 -- Generic Function: file-mtime=? f1 f2
 -- Generic Function: file-mtime<? f1 f2
 -- Generic Function: file-mtime<=? f1 f2
 -- Generic Function: file-mtime>? f1 f2
 -- Generic Function: file-mtime>=? f1 f2
     Compares file modification time stamps.  There are a bunch of
     methods defined, so each argument can be either one of the
     followings.

        * String pathname.   The mtime of the specified path is used.

        * `<sys-stat>' object (*Note File stats::).  The mtime is taken
          from the stat structure.

        * `<time>' object.  The time is used as the mtime.

        * Number.  It is considered as the number of seconds since Unix
          Epoch, and used as mtime.

          ;; compare "foo.c" is newer than "foo.o"
          (file-mtime>? "foo.c" "foo.o")

          ;; see if "foo.log" is updated within last 24 hours
          (file-mtime>? "foo.c" (- (sys-time) 86400))

 -- Generic Function: file-ctime=? f1 f2
 -- Generic Function: file-atime=? f1 f2
     Same as `file-mtime=?', except these checks file's change time and
     access time, respectively.  All the variants of `<', `<=', `>',
     `>=' are also defined.


File: gauche-refe.info,  Node: File operations,  Prev: File attribute utilities,  Up: Filesystem utilities

11.11.4 File operations
-----------------------

 -- Function: touch-file path
 -- Function: touch-files paths
     Updates timestamp of PATH, or each path in the list PATHS, to the
     current time.  If the specified path doesn't exist, a new file
     with size zero is created.  See also `sys-utime' (*Note File
     stats::).

 -- Function: copy-file src dst &keyword if-exists backup-suffix safe
          keep-timestamp keep-mode follow-link?
     Copies file from SRC to DST.  The source file SRC must exist.  The
     behavior when the destination DST exists varies by the keyword
     argument IF-EXISTS;

    `:error'
          (Default) Signals an error when DST exists.

    `:supersede'
          Replaces DST to the copy of `src'.

    `:backup'
          Keeps DST by renaming it.

    `#f'
          Doesn't copy and returns `#f' when DST exists.

     `Copy-file' returns `#t' after completion.

     If SRC is a symbolic link, `copy-file' follows the symlink and
     copies the actual content by default.  An error is raised if SRC
     is a dangling symlink.

     Giving `#f' to the keyword argument FOLLOW-LINK?  makes
     `copy-file' to copy the link itself.  It is possible that SRC is a
     dangling symlink in this case.

     If IF-EXISTS is `:backup', the keyword argument BACKUP-SUFFIX
     specifies the suffix attached to the DST to be renamed.  The
     default value is `".orig"'.

     By default, `copy-file' starts copying to DST directly.  However,
     if the keyword argument SAFE is a true value, it copies the file
     to a temporary file in the same directory of DST, then renames it
     to DST when copy is completed.  If copy is interrupted for some
     reason, the filesystem is "rolled back" properly.

     If the keyword argument KEEP-TIMESTAMP is true, `copy-file' sets
     the destination's timestamp to the same as the source's timestamp
     after copying.

     If the keyword argument KEEP-MODE is true, the destination file's
     permission bits are set to the same as the source file's.  If it
     is false (default), the destination file's permission remains the
     same if the destination already exists and the SAFE argument is
     false, otherwise it becomes `#o666' masked by umask settings.

 -- Function: move-file src dst &keyword if-exists backup-suffix
     Moves file SRC to DST.   The source SRC must exist.  The behavior
     when DST exists varies by the keyword argument IF-EXISTS, as
     follows.
    `:error'
          (Default) Signals an error when DST exists.

    `:supersede'
          Replaces DST by `src'.

    `:backup'
          Keeps DST by renaming it.

    `#f'
          Doesn't move and returns `#f' when DST exists.

     `Move-file' returns `#t' after completion.

     If IF-EXISTS is `:backup', the keyword argument BACKUP-SUFFIX
     specifies the suffix attached to the DST to be renamed.  The
     default value is `".orig"'.

     The file SRC and DST can be on the different filesystem.  In such
     a case, `move-file' first copies SRC to the temporary file on the
     same directory as DST, then renames it to DST, then removes SRC.

 -- Function: remove-files paths
 -- Function: delete-files paths
     Removes each path in a list PATHS.  If the path is a file, it is
     `unlink'ed.  If it is a directory, its contents are recursively
     removed by `remove-directory*'.  If the path doesn't exist, it is
     simply ignored.

     `delete-files' is just an alias of `remove-files'.

 -- Function: file->string filename options ...
 -- Function: file->list reader filename options ...
 -- Function: file->string-list filename options ...
 -- Function: file->sexp-list filename options ...
     Convenience procedures to read from a file FILENAME.  They first
     open the named file, then call `port->string', `port->list',
     `port->string-list' and `port->sexp-list' on the opened file,
     respectively.  (*Note Input utility functions::).  The file is
     closed if all the content is read or an error is signalled during
     reading.

     Those procedures take the same keyword arguments as
     `call-with-input-file'.  When the named file doesn't exist, the
     behavior depends on :IF-DOES-NOT-EXIST keyword argument--an error
     is signalled if it is `:error', and `#f' is returned if the
     argument is `#f'.


File: gauche-refe.info,  Node: Mathematic constants,  Next: Mersenne-Twister random number generator,  Prev: Filesystem utilities,  Up: Library modules - Utilities

11.12 `math.const' - Mathematic constants
=========================================

 -- Module: math.const
     This module defines several commonly-used mathematic constants.

 -- Constant: pi
 -- Constant: pi/2
 -- Constant: pi/4
 -- Constant: pi/180
 -- Constant: 1/pi
 -- Constant: 180/pi
     Bound to pi, pi/2, pi/4, pi/180, 1/pi and 180/pi, respectively.

 -- Constant: e
     e.


File: gauche-refe.info,  Node: Mersenne-Twister random number generator,  Next: RFC822 message parsing,  Prev: Mathematic constants,  Up: Library modules - Utilities

11.13 `math.mt-random' - Mersenne Twister Random number generator
=================================================================

 -- Module: math.mt-random
     Provides a pseudo random number generator (RNG) based on "Mersenne
     Twister" algorithm developed by Makoto Matsumoto and Takuji
     Nishimura.   It is fast, and has huge period of 2^19937-1.  See
     *note MT: MT, for details about the algorithm.

 -- Class: <mersenne-twister>
     A class to encapsulate the state of Mersenne Twister RNG.  Each
     instance of this class has its own state, and can be used as an
     independent source of random bits if initialized by individual
     seed.

     The random seed value can be given at the instantiation time by
     `:seed' initialization argument, or by using `mt-random-set-seed!'
     described below.

          (define m (make <mersenne-twister> :seed (sys-time)))

          (mt-random-real m) => 0.10284287848537865
          (mt-random-real m) => 0.463227748348805
          (mt-random-real m) => 0.8628500643709712
          ...

 -- Function: mt-random-set-seed! mt seed
     Sets random seed value SEED to the Mersenne Twister RNG MT.  SEED
     can be an arbitrary positive exact integer, or arbitrary length of
     u32vector (*Note Homogeneous vectors::).  If it is an integer, the
     lower 32bits are used for initialization.  If it is a u32vector,
     up to 624 elements are used for initialization.

 -- Function: mt-random-get-state mt
 -- Function: mt-random-set-state! mt state
     Retrieves and reinstalls the state of Mersenne Twister RNG MT.
     The state is represented by a u32vector of 625 elements.  The state
     can be stored elsewhere, and then restored to an instance of
     `<mersenne-twister>' to continue to generate the pseudo random
     sequence.

 -- Function: mt-random-real mt
 -- Function: mt-random-real0 mt
     Returns a random real number between 0.0 and 1.0.  1.0 is not
     included in the range.  `Mt-random-real' doesn't include 0.0
     either, while `mt-random-real0' does.  Excluding 0.0 is from the
     draft SRFI-27.

 -- Function: mt-random-integer mt range
     Returns a random exact positive integer between 0 and RANGE-1.
     RANGE can be any positive exact integer.

 -- Function: mt-random-fill-u32vector! mt u32vector
 -- Function: mt-random-fill-f32vector! mt f32vector
 -- Function: mt-random-fill-f64vector! mt f64vector
     Fills the given uniform vector by the random numbers.  For
     `mt-random-fill-u32vector!', the elements are filled by exact
     positive integers between 0 and 2^32-1.  For
     `mt-random-fill-f32vector!' and `mt-random-fill-f64vector!', it is
     filled by an inexact real number between 0.0 and 1.0, exclusive.

     If you need a bunch of random numbers at once, these are much
     faster than getting one by one.


File: gauche-refe.info,  Node: RFC822 message parsing,  Next: Base64 encoding/decoding,  Prev: Mersenne-Twister random number generator,  Up: Library modules - Utilities

11.14 `rfc.822' - RFC822 message parsing
========================================

 -- Module: rfc.822
     Defines a set of functions that parses and constructs the "Internet
     Message Format", a text format used to exchange e-mails.  The most
     recent specification can be found in RFC2822 (*note [RFC2822]:
     rfc2822.).  The format was originally defined in RFC 822, and
     people still call it "RFC822 format", hence I named this module.
     In the following document, I also refer to the format as "RFC822
     format".

Parsing message headers
-----------------------

 -- Function: rfc822-read-headers iport &keyword strict? reader
     Reads RFC822 format message from an input port IPORT, until it
     reaches the end of the message header.  The header fields are
     broken into a list of the following format:
          ((name body) ...)
     NAME ... are the field names, and BODY ... are the corresponding
     field body, both as strings.  Field names are converted to
     lower-case characters.  Field bodies are not modified, except the
     folded line is unfolded.  The order of fields are preserved.

     By default, the parser works permissively.  If EOF is encountered
     during parsing header, it is taken as the end of the message.  And
     if a line that doesn't consist neither continuing (folded) line
     nor start a new header field, it is simply ignored.  You can
     change this behavior by giving true value to the keyword argument
     STRICT?; then the parser raises an error for such a malformed
     header.

     The keyword argument READER takes a procedure that reads a line
     from IPORT.  Its default is `read-line', which should be enough
     for most cases.

 -- Function: rfc822-header->list iport &keyword strict? reader
     This is an old name of `rfc822-read-headers'.  This is kept for
     the backward compatibility.  The new code should use
     `rfc822-read-headers' instead.

 -- Function: rfc822-header-ref header-list field-name &optional default
     An utility procedure to get a specific field from the parsed
     header list, which is returned by `rfc822-read-headers'.

     FIELD-NAME specifies the field name in a lowercase string.  If the
     field with given name is in HEADER-LIST, the procedure returns its
     value in a string.  Otherwise, if DEFAULT is given, it is
     returned, and if not, `#f' is returned.

Basic field parsers
-------------------

Several procedures are provided to parse "structured" header fields of
RFC2822 messages.  These procedures deal with the body of a header
field, i.e. if the header field is "`To: Wandering Schemer
<schemer@example.com>'", they parse "`Wandering Schemer
<schemer@example.com>'".

   Most of procedures take an input port.  Usually you first parse the
entire header fields by `rfc822-read-headers', obtain the body of the
header by `rfc822-header-ref', then open an input string port for the
body and use those procedures to parse them.

   The reason for this complexity is because you need different
tokenization schemes depending on the type of the field.  Rfc2822 also
allows comments to appear between tokens for most cases, so a
simple-minded regexp won't do the job, since rfc2822 comment can be
nested and can't be represented by regular grammar.  So, this layer of
procedures are designed flexible enough to handle various syntaxes.
For the standard header types, high-level parsers are also provided;
see "specific field parsers" below.

 -- Function: rfc822-next-token iport &optional tokenizer-specs
     A basic tokenizer.  First it skips whitespaces and/or comments
     (`CFWS') from IPORT, if any.  Then reads one token according to
     TOKENIZER-SPECS.  If IPORT reaches EOF before any token is read,
     EOF is returned.

     TOKENIZER-SPECS is a list of tokenizer spec, which is either a
     char-set or a cons of a char-set and a procedure.

     After skipping `CFWS', the procedure peeks a character at the head
     of IPORT, and checks it against the char-sets in TOKENIZER-SPECS
     one by one.  If a char-set that contains the character belongs to
     is found, then a token is retrieved as follows: If the tokenizer
     spec is just a char-set, a sequence of characters that belong to
     the char-set consists a token.  If it is a cons, the procedure is
     called with IPORT to read a token.

     If the head character doesn't match any char-sets, the character
     is taken from IPORT and returned.

     The default TOKENIZER-SPECS is as follows:
          (list (cons #["] rfc822-quoted-string)
                (cons *rfc822-atext-chars* rfc822-dot-atom))
     Where `rfc822-quoted-string' and `rfc822-dot-atom' are tokenizer
     procedures described below, and `*rfc822-atext-chars*' is bound to
     a char-set of `atext' specified in rfc2822.  This means
     `rfc822-next-token' retrieves a token either `quoted-string' or
     `dot-atom' specified in rfc2822 by default.

     Using TOKENIZER-SPECS, you can customize how the header field is
     parsed.  For example, if you want to retrieve a token that is
     either (1) a word constructed by alphabetic characters, or (2) a
     quoted string, then you can call `rfc822-next-token' by this:

          (rfc822-next-token iport
             `(#[[:alpha:]] (#["] . ,rfc822-quoted-string)))

 -- Function: rfc822-field->tokens field &optional tokenizer-specs
     A convenience procedure.  Creates an input string port for a field
     body FIELD, and calls `rfc822-next-token' repeatedly on it until
     it consumes all input, then returns a list of tokens.
     TOKENIZER-SPECS is passed to `rfc822-next-token'.

 -- Function: rfc822-skip-cfws iport
     A utility procedure that consumes any comments and/or whitespace
     characters from IPORT, and returns the head character that is
     neither a whitespece nor a comment.  The returned character
     remains in IPORT.

 -- Constant: *rfc822-atext-chars*
     Bound to a char-set that is a valid constituent of `atom'.

 -- Constant: *rfc822-standard-tokenizers*
     Bound to the default TOKENIZER-SPECS.

 -- Function: rfc822-atom iport
 -- Function: rfc822-dot-atom iport
 -- Function: rfc822-quoted-string iport
     Tokenizers for `atom', `dot-atom' and `quoted-string',
     respectively.  The double-quotes and escaping backslashes within
     `quoted-string' are removed by `rfc822-quoted-string'.

Specific field parsers
----------------------

 -- Function: rfc822-parse-date string
     Takes RFC-822 type date string, and returns eight values:
          year, month, day-of-month, hour, minutes, seconds, timezone, day-of-week.

     _Timezone_ is an offset from UT in minutes.  _Day-of-week_ is a
     day from sunday, and may be #f if that information is not
     available.  _Month_ is an integer between 1 and 12, inclusive.  If
     the string is not parsable, all the elements are #f.

 -- Function: rfc822-date->date string
     Parses RFC822 type date format and returns SRFI-19 `<date>' object
     (see *note SRFI-19 Date::).  If STRING can't be parsed, returns
     `#f' instead.

Message constructors
--------------------

 -- Function: rfc822-write-headers headers &keyword output continue
          check
     This is a sort of inverse function of `rfc822-read-headers'.  It
     receives a list of header data, in which each header data consists
     of `(<name> <body>)', and writes them out in RFC822 header field
     format to the output port specified by the OUTPUT keyword
     argument.  The default output is the current output port.

     By default, the procedure assumes HEADERS contains all the header
     fields, and adds an empty line in the end of output to indicate
     the end of the header.  You can pass a true value to the CONTINUE
     keyword argument to prevent this, enabling more headers can be
     added later.

     I said "a sort of" above.  That's because this function doesn't
     (and can't) do the exact inverse.  Specifically, the caller is
     responsible for line folding and make sure each header line
     doesn't exceed the "hard limit" defined by RFC2822 (998 octets).
     This procedure cannot do the line folding on behalf of the caller,
     because the places where line folding is possible depend on the
     semantics of each header field.

     It is also the caller's responsibility to make sure header field
     bodies don't have any characters except non-NUL US-ASCII
     characters.  If you want to include characters outside of that
     range, you should convert them in the way allowed by the protocol,
     e.g. MIME.  The `rfc.mime' module (*Note MIME message handling::)
     provides a convenience procedure `mime-encode-text' for such
     purpose.  Again, this procedure cannot do the encoding
     automatically, since the way the field should be encoded depends
     on header fields.

     What this procedure can do is to check and report such violations.
     By default, it runs several checks and signals an error if it
     finds any violations of RFC2822.  You can control this checking
     behavior by the CHECK keyword argument.  It can take one of the
     following values:

    `:error'
          Default.  Signals an error if a violation is found.

    `#f, :ignore'
          Doesn't perform any check.  Trust the caller.

    `PROCEDURE'
          When `rfc822-write-headers' finds a violation, the procedure
          is called with three arguments; the header field name, the
          header field body, and the type of violation explained below.
          The procedure may correct the problem and return two values,
          the corrected header field name and body.  The returned values
          are checked again.  If the procedure returns the header field
          name and body unchanged, an error is signalled in the same
          way as `:error' is specified.

     The third argument passed to the procedure given to the CHECK
     argument is one of the following symbols.  New symbols may be
     added in future versions for more checks.

    `incomplete-string'
          Incomplete string is passed.

    `bad-character'
          Header field contains characters outside of US-ASCII or NUL.

    `line-too-long'
          Line length exceeds 998 octet limit.

    `stray-crlf'
          The string contains CR and/or LF character that doesn't
          consist of proper line folding.



File: gauche-refe.info,  Node: Base64 encoding/decoding,  Next: HTTP cookie handling,  Prev: RFC822 message parsing,  Up: Library modules - Utilities

11.15 `rfc.base64' - Base64 encoding/decoding
=============================================

 -- Module: rfc.base64
     This module defines a few functions to encode/decode Base64 format,
     defined in RFC 2045 (*note [RFC2045]: rfc2045.), section 6.3 and
     RFC3548 (*note [RFC3548]: rfc3548.)

 -- Function: base64-encode &keyword line-width
     Reads byte stream from the current input port, encodes it in Base64
     format and writes the result character stream to the current
     output port.  The conversion ends when it reads EOF from the
     current input port.

     Newline characters can be inserted to keep the maximum line width
     to the value given to the LINE-WIDTH keyword argument.  The default
     value of LINE-WIDTH is 76, as specified in RFC2045.  You can give
     `#f' or zero to LINE-WIDTH to suppress line splitting.

 -- Function: base64-encode-string string &keyword line-width
     Converts contents of STRING to Base64 encoded format.  Input
     string can be either complete or incomplete string; it is always
     interpreted as a byte sequence.

 -- Function: base64-decode
     Reads character stream from the current input port, decodes it
     from Base64 format and writes the result byte stream to the
     current output port.  The conversion ends when it reads EOF or the
     termination character (`=').  The characters which does not in
     legal Base64 encoded character set are silently ignored.

 -- Function: base64-decode-string string
     Decodes a Base64 encoded string STRING and returns the result as a
     string.  The conversion terminates at the end of STRING or the
     termination character (`=').  The characters which does not in
     legal Base64 encoded character set are silently ignored.


File: gauche-refe.info,  Node: HTTP cookie handling,  Next: FTP,  Prev: Base64 encoding/decoding,  Up: Library modules - Utilities

11.16 `rfc.cookie' - HTTP cookie handling
=========================================

 -- Module: rfc.cookie
     Defines a set of functions to parse and construct a "cookie"
     information defined in RFC 2965 (*note RFC2965: rfc2965.).

 -- Function: parse-cookie-string string &optional version
     Parse a cookie string STRING, which is the value of "Cookie"
     request header.  Usually, the same information is available to CGI
     program via the environemnt variable `HTTP_COOKIE'.

     If the cookie version is known, via "Cookie2" request header, the
     integer version must be passed to VERSION.  Otherwise,
     `parse-cookie' figures out the version from STRING.

     The result has the following format.
          ((<name> <value> [:path <path>] [:domain <domain>] [:port <port>])
           ...)
     where <NAME> is the attribute name, and <VALUE> is the
     corresponding value.  If the attribute doesn't have value, <VALUE>
     is `#f'.  (Note that it differs from the attribute having null
     value, `""'.)  If the attribute has path, domain or port options,
     it is given as a form of keyword-value pair.

 -- Function: construct-cookie-string specs &optional version
     Given list of cookie specs, creates a cookie string suitable for
     `Set-cookie2' or `Set-cookie' header.

     Optional VERSION argument specifies cookie protocol version.  0
     for the old Netscape style format, and 1 for RFC2965 style format.
     When omitted, version 1 is assumed.

     Each cookie spec has the following format.
          (<name> <value> [:comment <comment>] [:comment-url <url>]
                          [:discard <bool>] [:domain <domain>]
                          [:max-age <age>] [:path <path>]
                          [:port <port-list>] [:secure <bool>]
                          [:version <version>] [:expires <date>])
     Where,
    `<name>'
          A string.  Name of the cookie.

    `<value>'
          Value of the cookie.  May be a string, or `#f' if no value is
          needed.

    `<comment> <url> <domain> <path> <port-list>'
          Strings.

    `<bool>'
          Boolean value

    `<age> <version>'
          Integers

    `<date>'
          Either an integer (seconds since Epoch) or a formatted date
          string following the netscape cookie specification.

     The attribute values are quoted appropriately.  If the specified
     attribute is irrelevant for the VERSION, it is ignored.  So you
     can pass the same specs to generate both old-style and new-style
     cookie strings.

     Return value is a list of cookie strings, each of which stands for
     each cookie.  For old-style protocol (using `Set-cookie' header)
     you must send each of them by individual header.  For new-style
     protocol (using `Set-cookie2' header), you can join them with
     comma and send it at once.  See RFC2965 for further details.

     Some examples:
          (construct-cookie-string
             `(("name" "foo" :domain "foo.com" :path "/"
                             :expires ,(+ (sys-time) 86400) :max-age 86400)))
           => ("name=foo;Domain=foo.com;Path=/;Max-age=86400")

          (construct-cookie-string
             `(("name" "foo" :domain "foo.com" :path "/"
                             :expires ,(+ (sys-time) 86400) :max-age 86400))
             0)
           =>
           ("name=foo;Domain=foo.com;Path=/;Expires=Sun, 09-Sep-2001 01:46:40 GMT")


File: gauche-refe.info,  Node: FTP,  Next: HMAC keyed-hashing,  Prev: HTTP cookie handling,  Up: Library modules - Utilities

11.17 `rfc.ftp' - FTP client
============================

 -- Module: rfc.ftp
     This module provides a set of convenient functions to access ftp
     servers.

 -- Class: <ftp-connection>
     An object to keep FTP connection to a server.  It has the following
     public slots.

      -- Instance Variable of <ftp-connection>: transfer-type
          FTP transfer type.  Must be one of the following symbols:
          `ascii', `binary' (default), and `image'.

      -- Instance Variable of <ftp-connection>: passive
          True if the client uses passive connection.c

      -- Instance Variable of <ftp-connection>: log-drain
          This slot must hold a `<log-drain>' instance (*Note
          User-level logging::) or `#f'.  If it has a `<log-drain>'
          instance, ftp communication logs are put to it.


 -- Condition Type: <ftp-error>
     This type of exception is thrown when the ftp server returns an
     error code.  Inherits `<error>'.  The message field contains the
     server reply, including the status code.

 -- Function: call-with-ftp-connection host proc &keyword passive port
          username password account log-drain
     A high-level convenience routine to open an ftp connection to an
     ftp server and calls the given procedure.

     The server is specified by HOST.  Optionally, you can add user
     name and/or port number by the form `USER@SERVERNAME:PORT'.  If
     present, user and port portion in HOST supersedes the keyword
     arguments.

     If ftp connection to HOST is established successfully, PROC is
     called with one argument, which is an instance of
     `<ftp-connection>'.  When PROC returns, the connection is closed
     and the return value(s) of PROC is/are returned from
     `call-with-ftp-connection'.  When an exception is thrown, the ftp
     connection is closed before the exception escapes from
     `call-with-ftp-connection'.

     When a true value is given to the keyword argument PASSIVE,
     created ftp connection will use passive mode to send/receive data.
     The default is the active mode.

     The keyword argument PORT, USERNAME, and PASSWORD specify the port
     number, username, and password, respectively.  When omitted, the
     port number defaults to 21, USERNAME to `"anonymous"', and
     PASSWORD to `"anonymous@"'.  Note that the port number and/or
     username are ignored when those information is given in the HOST
     argument.

     If the keyword arugment ACCOUNT is given, its value is passed to
     ftp `ACCT' command when requested by the server at login time.
     The defalut value is a null string `""'.

     The keyword argument LOG-DRAION is set to the created ftp
     connection's `log-drain' slot.

 -- Function: ftp-transfer-type conn
     Returns the transfer type of the ftp connection `conn'.  Can be
     used with setter, e.g. `(set! (ftp-transfer-type conn) 'ascii)'.

 -- Function: ftp-passive? conn
     Returns true iff ftp connection uses passive data retrieval.

 -- Function: ftp-login host &keyword passive port username password
          account log-drain
     Connects to the ftp server specified by HOST, authenticate the
     user, and returns a newly created `<ftp-connection>' instance.
     This procedure is called implicitly when you use
     `call-with-ftp-connection'.  The semantics of the HOST argument
     and the keyword arguments are the same as
     `call-with-ftp-connection'.

 -- Function: ftp-quit conn
     Sends ftp `QUIT' command to the connection CONN and shutdown the
     connection.  This procedure is called implicitly when you use
     `call-with-ftp-connection'.

     Once a connection is shut down, you cannot communicate through
     this connection.

 -- Function: ftp-chdir conn dirname
     Changes the remote directory to DIRNAME.

 -- Function: ftp-remove conn path
     Removes the remote file named by PATH.

 -- Function: ftp-help conn &optional option ...
     Sends ftp `HELP' commands.  OPTIONs must be strings, and will be
     passed to the `HELP' command arguments.

 -- Function: ftp-mkdir conn dirname
     Creates a directory DIRNAME.  Returns the created directory name.

 -- Function: ftp-current-directory conn
     Returns the current remote directory.

 -- Function: ftp-site conn arg
     Sends ftp `SITE' command with the argument ARG.  The `SITE'
     command's semantics depends on the server.  Returns the server
     reply.

 -- Function: ftp-rmdir conn dirname
     Removes remote directory specified by DIRNAME.  Returns the server
     reply.

 -- Function: ftp-stat conn &optional pathname
     Sends ftp `STAT' command to the server.  RFC959 defines several
     different semantics of this command.  See RFC959 for the details.
     Returns the server reply.

 -- Function: ftp-system conn
     Queries the server's operating system by ftp `SYST' command.
     Returns the server reply without status code.

          (call-with-ftp-connection "localhost" ftp-system)
            => "UNIX Type: L8"

 -- Function: ftp-size conn path
     Queries the size of the remote file specified by PATH.  Returns
     the integer value.

 -- Function: ftp-mdtm conn path
     Queries the modification time of the remote file specified by PATH.
     This function returns the server's reply as is, including the
     status code.  Use `ftp-mtime' below to obtain a parsed result.

 -- Function: ftp-mtime conn path &optional local-time?
     Queries the modification time of the remote file specified by PATH,
     and returns the result in a `<date>' object (*Note Time data types
     and procedures::).  If a true value is given to `local-time?', the
     returned date is in local time.  Otherwise, the returned date is
     in UTC.

 -- Function: ftp-noop conn
     Sends ftp `NOOP' command and returns the server's reply.

 -- Function: ftp-list conn &optional path
     Returns the information about the files within the remote file or
     directory specified by PATH, or the current remote directory, much
     like `ls(1)' format.  Returns a list of strings, where each string
     is for each line of the server's reply.  The exact format depends
     on the server.  Return the list of names in the specfied PATH, or
     the current remote directory, without any other information.
     `ftp-ls' is just an alias of `ftp-name-list' for the convenience.

     Note that the server may return an error if there's no files in
     the remote directory.

 -- Function: ftp-get conn path &keyword sink flusher
     Retrieves a remote file PATH.  The retrieved data is sent to an
     output port given to SINK.  Once all the data is retrieved, a
     procedure given to FLUSHER is called with the port SINK as an
     argument, and its return value(s) is/are returned from `ftp-get'.

     The default values of SINK and FLUSHER are a newly created string
     port and `get-output-string', respectively.  That is, `ftp-get'
     returns the retrieved data as a string by default.  You don't want
     this behavior if the retrieved file is huge.

 -- Function: ftp-put conn from-file &optional to-file
     Sends the local file specified by FROM-FILE to the remote server
     as the name specified by TO-FILE.  If TO-FILE is omitted, the
     basename of FROM-FILE is used.  Returns the server response.

 -- Function: ftp-put-unique conn from-file
     Sends the local file specified by FROM-FILE to the remote server.
     The remote side filename is guaranteed to be unique.  Returns two
     values--the final server response, and the remote file name.  The
     second value can be `#f' if the remote host doesn't support
     RFC1123 (which must be rare).

 -- Function: ftp-rename conn from-name to-name
     Renames the remote file specified by FROM-NAME to the name
     TO-NAME.  Returns the final response of the server.


File: gauche-refe.info,  Node: HMAC keyed-hashing,  Next: HTTP,  Prev: FTP,  Up: Library modules - Utilities

11.18 `rfc.hmac' - HMAC keyed-hashing
=====================================

 -- Module: rfc.hmac
     This module implements HMAC algorithm, Keyed-hashing for message
     authentication, defined in RFC 2104.

     For simple batched keyed hashing, you can use high-level API
     `hmac-digest' and `hmac-digest-string'.  Or you can create
     `<hmac>' object and update its state as the data coming in.

 -- Class: <hmac>
     Keeps state information of HMAC algorithm.  Key and the hashing
     algorithm should be given at the construction time, using `:key'
     and `:hasher' keyword-arguments respectively.  You can pass any
     class object that implements message digest interface (*Note
     Message digester framework::), such as `<md5>' (*Note MD5 message
     digest::) or `<sha256>' (*Note SHA message digest::).

     Example:
          (make <hmac> :key (make-byte-string 16 #x0b) :hasher <md5>)

 -- Method: hmac-update! (hmac <hmac>) data
     Updates the internal state of HMAC by DATA, which must be
     represented by a (possibly incomplete) string.

 -- Method: hmac-final! (hmac <hmac>)
     Finalizes the internal state of HMAC and returns the hashed string
     in incomplete string.  You can use `digest-hexify' (*Note Message
     digester framework::) to obtain "hexified" result.  Once
     finalized, you can't call `hmac-update!' or `hmac-final!' on HMAC.

 -- Method: hmac-digest &keyword key hasher
     Creates an `<hmac>' object and hash the data stream from the
     current input port, then returns the hashed result in an
     incomplete string.

 -- Method: hmac-digest-string string &keyword key hasher
     Creates an `<hmac>' object and hash the data in STRING, then
     returns the hashed result in an incomplete string.


File: gauche-refe.info,  Node: HTTP,  Next: IP packets,  Prev: HMAC keyed-hashing,  Up: Library modules - Utilities

11.19 `rfc.http' - HTTP
=======================

 -- Module: rfc.http
     This module provides a simple client API for HTTP/1.1, defined in
     RFC2616, "Hypertext Transfer Protocol - HTTP/1.1" (*note
     [RFC2616]: rfc2616.).

     Current API implements only a part of the protocol.  Only GET,
     HEAD, and POST requests are supported, it doesn't talk with
     HTTP/1.0 server yet, and it doesn't support HTTP/1.1 advanced
     features such as persistent connection.  Support for those
     features may be added in the future versions.

 -- Condition Type: <http-error>
     This type of condition is raised when the server terminates
     connection prematurely or server's response has invalid header
     fields.  Inherits `<error>'.

 -- Function: http-get server request-uri &keyword sink flusher
          no-redirect ...
 -- Function: http-head server request-uri &keyword no-redirect ...
 -- Function: http-post server request-uri body &keyword sink flusher
          no-redirect ...
     Send http GET, HEAD and POST requests to the http SERVER,
     respectively, and returns the server's reply.

     If the server returns "3xx" redirection reply, these procedures
     try to follow the URI returned in the "location" reply message
     header by default.  See the "keyword arguments" heading below to
     suppress redirection following.

     *Required arguments:* The SERVER argument specifies http server
     name in a string.  A server name can be optionally followed by
     colon and a port number.  Examples: `"w3c.org"',
     `"mycompany.com:8080"'.

     The REQUEST-URI argument is the request-uri specified in RFC2616;
     usually, this is the path part of http url.

     `Http-post' takes the third argument, BODY, which is a string to
     be posted to the server.   The body is sent "as is"; the caller
     has to take care of necessary escaping or encoding.

     So, the most simple form of retrieving the content will be
     something like this:
          (http-get "practical-scheme.net" "/gauche/index.html")

     Access via proxy can be done by specifying proxy server to SERVER
     and passing the entire URI to REQUEST-URI, but the author haven't
     tested yet.

     *Return values:* All procedures return three values.

     The first value is the status code defined in RFC2616 in a string
     (such as "200" for success, "404" for "not found").

     The second value is a list of parsed headers--each element of list
     is a list of `(HEADER-NAME VALUE ...)', where HEADER-NAME is a
     string name of the header (such as "content-type" or "location"),
     and VALUE is the corresponding value in a string.  The header name
     is converted to lowercase letters.  The value is untouched except
     that "soft line breaks" are removed, as defined in RFC2822.   If
     the server returns more than one headers with the same name, their
     values are consolidated to one list.  Except that, the order of
     the header list in the second return value is the same as the
     order in the server's reply.

     The third value is for the message body of the server's reply.  By
     default, it is a message body itself in a string.   If the server's
     reply doesn't have a body, the third value is `#f'.  You can
     change how the message body is handled by keyword arguments; for
     example, you can directly store the returned message body to a
     file without creating intermediate string.  The details are
     explained below.

     *Keyword arguments:* By default, these procedures only attaches
     `"Host"' header field to the request message.  You can give
     keyword arguments to add more header fields.
          (http-get "foo.bar.com" "/index.html"
            :accept-language "ja"
            :user-agent "My Scheme Program/1.0")

     The following keyword arguments are recognized by the procedure
     and do not appear in the request headers.

    NO-REDIRECT
          If a true value is given, suppress the redirection tracking;
          i.e. the procedures return "3xx" message as is.

    SINK, FLUSHER
          You can customize how the message body is handled by these
          keyword arguments.  You have to pass an output port to SINK,
          and a procedure that takes two arguments to FLUSHER.

          When the procedure starts receiving the message body, it
          feeds the received chunk to SINK.  When the procedure
          receives entire message body, FLUSHER method is called with
          SINK and a list of message header fields (in the same format
          to be returned in the second value from the procedure).  The
          return value of FLUSHER becomes the third return value from
          the procedure.

          So, the default value of SINK is a newly opened string port
          and the default value of FLUSHER is `(lambda (sink headers)
          (get-output-string sink))'.

          The following example saves the message body directly to a
          file, without allocating (potentially very big) string buffer.
               (call-with-output-file "page.html"
                 (lambda (out)
                   (http-get "www.schemers.org" "/"
                      :sink out :flusher (lambda _ #t))))




File: gauche-refe.info,  Node: IP packets,  Next: ICMP packets,  Prev: HTTP,  Up: Library modules - Utilities

11.20 `rfc.ip' - IP packets
===========================

 -- Module: rfc.ip
     This module provides some basic utilities to parse raw IP packets.

   The PACKET argument in the following functions must be any type of
uniform vector (*Note Uniform vectors::), containing a raw IP packet
including its IP header.  Those functions work for both IPv4 and IPv6
packets; however, reading from a raw IPv6 socket returns a packet
without IPv6 header, so you usually don't need to use these functions.

   The OFFSET argument specifies the beginnig of the IP packet in
PACKET.  If PACKET contains only one IP packet you can pass 0.  It is
not an optional argument, since these routines may be used in
speed-sensitive inner loop.

 -- Function: ip-version packet offset
     Returns the IP version number (either 4 or 6) of the given IP
     packet.

 -- Function: ip-header-length packet offset
     Returns the size of IP header of the given packet in octets,
     including any IP header options.

 -- Function: ip-protocol packet offset
     Returns the IP protocol number of the given packet.

 -- Function: ip-source-address packet offset
 -- Function: ip-destination-address packet offset
     Returns the source and destination address in the given packet in
     an integer, respectively.


File: gauche-refe.info,  Node: ICMP packets,  Next: MD5 message digest,  Prev: IP packets,  Up: Library modules - Utilities

11.21 `rfc.icmp' - ICMP packets
===============================

 -- Module: rfc.icmp
     This module provides some basic utilities to construct and parse
     ICMP packets.

   For the functions below, BUFFER should be a writable u8vector of the
enough size.

   Parsing functions takes OFFSET as well as BUFFER, which specifies
the beginning of the ICMP packet.  Using the offset you can carry the
whole IP packet in BUFFER, without creating a new buffer to extract
ICMP portion.

 -- Function: icmp4-fill-echo! buffer ident sequence data
     Fills BUFFER with the ICMPv4 Echo Request packet.  DATA must be a
     u8vector.  The checksum field is left to be zero, which can be
     filled by `icmp4-fill-checksum!'.

 -- Function: icmp4-fill-checksum! buffer size
     Calculates the ICMPv4 checksum of the packet in the BUFFER, of
     SIZE length (the size of the packet, not the buffer), and fills
     the checksum field of the packet.

 -- Function: icmp6-fill-echo! buffer ident sequence data
     Fills BUFFER with the ICMPv6 Echo Request packet.  DATA must be a
     u8vector.  The checksum field is left to be zero, which is to be
     filled by the kernel (so you don't need to fill by yourself).

 -- Function: icmp-packet-type buffer offset
 -- Function: icmp-packet-code buffer offset
 -- Function: icmp-packet-ident buffer offset
 -- Function: icmp-packet-sequence buffer offsetj
     Extracts type, code, ident and sequence fields of ICMP packet.
     These functions are common to both ICMPv4/v6.

 -- Function: icmp4-describe-packet buffer offset
 -- Function: icmp6-describe-packet buffer offset
     Prints out a simple text description of the given ICMPv4 and v6
     packet, respectively.

 -- Function: icmp4-message-type->string type
 -- Function: icmp4-unreach-code->string code
 -- Function: icmp4-redirect-code->string code
 -- Function: icmp4-router-code->string code
 -- Function: icmp4-exceeded-code->string code
 -- Function: icmp4-parameter-code->string code
 -- Function: icmp4-security-code->string code
 -- Function: icmp6-message-type->string type
 -- Function: icmp6-unreach-code->string code
 -- Function: icmp6-exceeded-code->string code
 -- Function: icmp6-parameter-code->string code
     Returns a text description of ICMPv4 and ICMPv6 types and codes.


File: gauche-refe.info,  Node: MD5 message digest,  Next: MIME message handling,  Prev: ICMP packets,  Up: Library modules - Utilities

11.22 `rfc.md5' - MD5 message digest
====================================

 -- Module: rfc.md5
     This module implements MD5 message digest algorithm, defined in
     RFC 1321 (*note [RFC1321]: rfc1321.).  The module extends
     util.digest (*Note Message digester framework::).

 -- Class: <md5>
     The instance of this class keeps internal state of MD5 digest
     algorithm.

     This class implements `util.digest' framework interface,
     `digest-update!', `digest-final!', `digest', and `digest-string'.
     *Note Message digester framework::, for detailed explanation of
     these methods.

   Besides the digester framework, this module provides to short-cut
procedures.

 -- Function: md5-digest
     Reads data from the current input port until EOF, and returns its
     digest in an incomplete string.

 -- Function: md5-digest-string string
     Digest the data in STRING, and returns the result in an incomplete
     string.


File: gauche-refe.info,  Node: MIME message handling,  Next: Quoted-printable encoding/decoding,  Prev: MD5 message digest,  Up: Library modules - Utilities

11.23 `rfc.mime' - MIME message handling
========================================

 -- Module: rfc.mime
     This module provides utility procedures to handle Multipurpose
     Internet Mail Extensions (MIME) messages, defined in RFC2045
     thorough RFC2049.  This module is supposed to be used with
     `rfc.822' module (*Note RFC822 message parsing::).

Utilities for header fields
---------------------------

A few utility procedures to parse and generate MIME-specific header
fields.

 -- Function: mime-parse-version field
     If FIELD is a valid header field for MIME-Version, returns its
     major and minor versions in a list.  Otherwise, returns `#f'.  It
     is allowed to pass `#f' to FIELD, so that you can directly pass
     the result of `rfc822-header-ref' to it.  Given parsed header list
     by `rfc822-read-headers', you can get mime version (currently, it
     should be `(1 0)') by the following code.
          (mime-parse-version (rfc822-header-ref headers "mime-version"))

     Note: simple regexp such as `#/\d+\.\d+/' doesn't do this job, for
     FIELD may contain comments between tokens.

 -- Function: mime-parse-content-type field
     Parses the "content-type" header field, and returns a list such as:
          (type subtype (attribute . value) ...)
     where type and subtype are MIME media type and subtype in a
     string, respectively

          (mime-parse-content-type "text/html; charset=iso-2022-jp")
           => ("text" "html" ("charset" . "iso-2022-jp"))

     If FIELD is not a valid content-type field, `#f' is returned.

 -- Function: mime-decode-word word
     Decodes RFC2047-encoded word.  If WORD isn't an encoded word, it
     is returned as is.

     Note that this procedure decodes only if the entire WORD is an
     "encoded word" defined in RFC2047.  If you are dealing with a
     field that may contain multiple encoded word and/or unencoded
     parts, use `mime-decode-text' below.

          (mime-decode-word "=?iso-8859-1?q?this=20is=20some=20text?=")
           => "this is some text"


 -- Function: mime-decode-text text
     Returns a string in which all encoded words contained within TEXT
     are decoded.  This procedure can deal with a header field body
     that may contain mixture of non-encoded and encoded parts, and/or
     multiple encoded parts.  One of such header field is the Subject
     field of email.

          (mime-decode-text "This is =?US-ASCII?q?some=20text?=")
           => "This is some text"

     Care should be taken if you apply this procedure to a "structured"
     header field body (see RFC2822 section 2.2.2).  The proper way of
     parsing a structured header field body is to tokenize it first,
     then to decode each word using `mime-decode-word'.  since the
     decoded text may contain characters that affects the tokenization.
     (However, if you can just show the header field in human readable
     way for informational purposes, you may just use `mime-decode-text'
     on entire header field for the convenience).

 -- Function: mime-encode-word word &keyword charset transfer-encoding
     Encodes WORD in the RFC2047 format.  The keyword argument CHARSET
     specifies the character encoding scheme in string or symbol.
     whose default is `utf-8'.  If CHARSET differs from Gauche's
     internal encoding and WORD is a complete string, the procedure
     convers the character encoding to CHARSET, then performs transfer
     encoding.

          (mime-encode-word "this is some text")
           => "=?utf-8?B?dGhpcyBpcyBzb21lIHRleHQ=?="

     The keyword argument TRANSFER-ENCODING specifies how the octets
     are encoded to transfer-safe characters.  You can give a symbol
     `b', `B' or `base64' for Base64, and `Q', `q', `quoted-printable'
     for Quoted-printable transfer encodings.  An error is raised if
     you pass values other than those.  The default is Base64 encoding.

     This procedure does not consider the length of the resulting
     encoded word, which RFC2047 recommends to be less than 75 octets.
     Use `mime-encode-text' below to conform the line length limit.

     (Note: In most Gauche procedures, a keyword argument `encoding' is
     used to specify character encodings.  In this context we have two
     encodings, however, and to avoid the confusion we chose to use the
     terms "charset" and "transfer-encoding" that appear in RFC
     documents.)

 -- Function: mime-encode-text text &keyword charset transfer-encoding
          line-width start-column force
     Encode TEXT in RFC2047 format if necessary, and considering line
     foling if the result gets too long.

     The keyword arguments CHARSET and TRANSFER-ENCODING are the same
     as `mime-encode-word'.

     If the TEXT only consists of printable ASCII characters, no
     encoding is done, and only line folding is considered.  However,
     if a true value is given to the FORCE argument, even ASCII-only
     TEXT is encoded.

     The LINE-WIDTH specifies the maximum line width of the result.
     Its default is 76.  If the encoded word gets too long, it is
     splitted to multiple encoded words and CR LF SPC sequence
     ("folding white space" defined in RFC2822) are inserted inbetween.
     You can suppress this behavior by passing `#f' or `0' to
     LINE-WIDTH.  Since encoded word needs some overhead characters, it
     doesn't make much sense to specify small value to `line-width'.
     Current implementation rejects `line-width' smaller than 30.

     The START-COLUMN keyword argument can be used to shorten the first
     of folded lines to make room for header field name.  For example,
     if you want to encode the body of a Subject header field, you can
     pass the value of `(string-length "Subject: ")' so that the
     encoded result can directly concatenated after the header field
     name.  The default value is 0.

     This procedure is not designed to encode parts of structured
     header fields, which have further restrictions such as which parts
     can be encoded and where the folding white spaces can be inserted.
     The robust way is to encode some parts first, then construct a
     structured header fields, considering line folding.

Streaming parser
----------------

The streaming parser is designed so that you can decide how to do with
the message body before the entire message is read.

 -- Function: mime-parse-message port headers handler
     The fundamental streaming parser.  PORT is an input port from
     where the message is read.  HEADERS is a list of headers parsed by
     `rfc822-read-headers'; that is, this procedure is supposed to be
     called after the header part of the message is parsed from PORT:
          (let* ((headers (rfc822-read-headers port)))
            (if (mime-parse-version (rfc822-header-ref headers "mime-version"))
               ;; parse MIME message
               (mime-parse-message port headers handler)
               ;; retrieve a non-MIME body
               ...))

     `Mime-parse-message' analyzes HEADERS, and calls HANDLER on each
     message body with two arguments:

          (handler PART-INFO XPORT)

     PART-INFO is a `<mime-part>' structure described below that
     encapsulates the information of this part of the message.  XPORT
     is an input port, initially points to the beginning of the body of
     message.  The handler can read from the port as if it is reading
     from the original PORT.  However, XPORT recognizes MIME boundary
     internally, and returns EOF when it reaches the end of the part.
     (Do not read from the original PORT directly, or it will mess up
     the internal state of VPORT).

     HANDLER can read the part into the memory, or save it to the disk,
     or even discard the part.  Whatever it does, it has to read from
     VPORT until it returns EOF.

     The return value of HANDLER will be set in the `content' slot of
     PART-INFO.  If the message has nested multipart messages, HANDLER
     is called for each "leaf" part, in depth-first order.  HANDLER can
     know its nesting level by examining PART-INFO structure.  The
     message doesn't need to be a multipart type; if it is a MIME
     `message' type, HANDLER is called on the body of enclosed message.
     If it is other media types such as `text' or `application',
     HANDLER is called on the (only) message body.

 -- Class: <mime-part>
     A structure that encloses metainformation about a MIME part.  It
     is constructed when the header of the part is read, and passed to
     the handler that reads the body of the part.

     It has the following slots:

      -- Instance Variable of <mime-part>: type
          MIME media type string.  If `content-type' header is omitted
          to the part, an appropriate default value is set.

      -- Instance Variable of <mime-part>: subtype
          MIME media subtype string.  If `content-type' header is
          omitted to the part, an appropriate default value is set.

      -- Instance Variable of <mime-part>: parameters
          Associative list of parameters given to `content-type' header
          field.

      -- Instance Variable of <mime-part>: transfer-encoding
          The value of `content-transfer-encoding' header field.  If
          the header field is omitted, an appropriate default value is
          set.

      -- Instance Variable of <mime-part>: headers
          The list of header fields, as parsed by `rfc822-read-headers'.

      -- Instance Variable of <mime-part>: parent
          If this is a part of multipart message or encapsulated
          message, points to the enclosing part's `<mime-part>'
          structure.  Otherwise `#f'.

      -- Instance Variable of <mime-part>: index
          Sequence number of this part within the same parent.

      -- Instance Variable of <mime-part>: content
          If this part is multipart/* or message/* media type, this
          slot contains a list of parts within it.  Otherwise, the
          return value of HANDLER is stored.

 -- Function: mime-retrieve-body part-info xport outp
     A procedure to retrieve message body.  It is intended to to be a
     building block of HANDLER to be passed to `mime-parse-message'.

     PART-INFO is a `<mime-part>' object.  XPORT is an input port
     passed to the handler, from which the MIME part can be read.  This
     procedure read from XPORT until it returns EOF.  It also looks at
     the `transfer-encoding' of PART-INFO, and decodes the body
     accordingly; that is, base64 encoding and quoted-printable
     encoding is handled.  The result is written out to an output port
     OUTP.

     This procedure does not handle charset conversion.  The caller
     must use CES conversion port as OUTP (*Note Character code
     conversion::) if desired.

   A couple of convenience procedures are defined for typical cases on
top of `mime-retrieve-body'.

 -- Function: mime-body->string part-info xport
 -- Function: mime-body->file part-info xport filename
     Reads in the body of mime message, decoding transfer encoding, and
     returns it as a string or writes it to a file, respectively.

   The simplest form of MIME message parser would be like this:

     (let ((headers (rfc822-read-headers port)))
       (mime-parse-message port headers
                           (cut mime-body->string <> <>)))

   This reads all the message on memory (i.e. the "leaf" `<mime-part>'
objects' `content' field would hold the part's body as a string), and
returns the top `<mime-part>' object.  Content transfer encoding is
recognized and handled, but character set conversion isn't done.

   You may want to feed the message body to a file directly, or even
want to skip some body according to mime media types and/or other
header information.  Then you can put the logic in the handler closure.
That's the reason that this module provides building blocks, instead of
all-in-one procedure.


File: gauche-refe.info,  Node: Quoted-printable encoding/decoding,  Next: SHA message digest,  Prev: MIME message handling,  Up: Library modules - Utilities

11.24 `rfc.quoted-printable' - Quoted-printable encoding/decoding
=================================================================

 -- Module: rfc.quoted-printable
     This module defines a few functions to encode/decode
     Quoted-printable format, defined in RFC 2045 (*note [RFC2045]:
     rfc2045.), section 6.7.

 -- Function: quoted-printable-encode &keyword line-width binary
     Reads byte stream from the current input port, encodes it in
     Quoted-printable format and writes the result character stream to
     the current output port.  The conversion ends when it reads EOF
     from the current input port.  The keyword argument LINE-WIDTH
     specifies the maximum line width of the generated output in
     characters.  If the encoded output creates a long line, the
     procedure inserts a "soft line break" so that the each line is
     equal to or shorter than this number.  Soft line breaks are
     removed when quoted-printable text is decoded.  The default line
     width is 76.  (The minimum meaningful number of line-width is 4).
     You can suppress soft line breaks by giving `#f' or `0' to
     LINE-WIDTH.  By default, `quoted-printable-encode' generates
     `CR-LF' sequence for each line break in the input ("hard line
     break").  When a true value is given to the keyword argument
     BINARY, however, octets `#x0a' and `#x0d' in the input are encoded
     as `=0A' and `=0D', respectively.  See RFC2045 section 6.7 for the
     details.

 -- Function: quoted-printable-encode-string string &keyword line-width
          binary
     Converts contents of STRING to Quoted-printable encoded format.
     Input string can be either complete or incomplete string; it is
     always interpreted as a byte sequence.

     The keyword arguments are the same as `quoted-printable-encode'.

 -- Function: quoted-printable-decode
     Reads character stream from the current input port, decodes it
     from Quoted-printable format and writes the result byte stream to
     the current output port.  The conversion ends when it reads EOF.
     If it encounters illegal character sequence (such as '=' followed
     by non-hexadecimal characters), it copies them literally to the
     output.

 -- Function: quoted-printable-decode-string string
     Decodes a Quoted-printable encoded string STRING and returns the
     result as a string.


File: gauche-refe.info,  Node: SHA message digest,  Next: URI parsing and construction,  Prev: Quoted-printable encoding/decoding,  Up: Library modules - Utilities

11.25 `rfc.sha' - SHA message digest
====================================

 -- Module: rfc.sha
     This module implements US Secure Hash Algorithm defined in RFC
     4634.  It provides SHA-1, SHA-224, SHA-256, SHA-384 and SHA-512
     (the latter four are sometimes referred as SHA-2 collectively).

     The module extends util.digest (*Note Message digester
     framework::).

 -- Module: rfc.sha1
     This is the old module that provided only SHA-1.  It is kept as an
     alias of `rfc.sha' for the backward compatibility.  New code
     should use `rfc.sha'.

 -- Class: <sha1>
 -- Class: <sha224>
 -- Class: <sha256>
 -- Class: <sha384>
 -- Class: <sha512>
     An instance of these class keeps internal state of SHA digest
     algorithm.

     This class implements `util.digest' framework interface,
     `digest-update!', `digest-final!', `digest', and `digest-string'.
     *Note Message digester framework::, for detailed explanation of
     these methods.

   Besides the digester framework, this module provides to short-cut
procedures.

 -- Function: sha1-digest
 -- Function: sha224-digest
 -- Function: sha256-digest
 -- Function: sha384-digest
 -- Function: sha512-digest
     Reads data from the current input port until EOF, and returns its
     digest in an incomplete string.

 -- Function: sha1-digest-string string
 -- Function: sha224-digest-string string
 -- Function: sha256-digest-string string
 -- Function: sha384-digest-string string
 -- Function: sha512-digest-string string
     Digest the data in STRING, and returns the result in an incomplete
     string.


File: gauche-refe.info,  Node: URI parsing and construction,  Next: Zlib compression library,  Prev: SHA message digest,  Up: Library modules - Utilities

11.26 `rfc.uri' - URI parsing and construction
==============================================

 -- Module: rfc.uri
     Provides a set of functions to parse Uniform Resource Identifiers
     defined in RFC 2396 (*note [RFC2396]: rfc2396.).

 -- Function: uri-parse uri
 -- Function: uri-scheme&specific uri
 -- Function: uri-decompose-hierarchical specific
 -- Function: uri-decompose-authority authority
     General parser of URI.  These functions does not decode URI
     encoding, since the parts to be decoded differ among the uri
     schemes.   After parsing uri, use `uri-decode' below to decode
     them.

     `uri-parse' is the most handy procedure.  It breaks the uri into
     the following parts and returns them as multiple values.  If the
     uri doesn't have the corresponding parts, `#f' are returned for
     the parts.

        * URI scheme as a string (e.g. `"mailto"' in
          `"mailto:foo@example.com"').

        * User-info in the authority part (e.g. `"anonymous"' in
          `ftp://anonymous@ftp.example.com/pub/foo').

        * Hostname in the authority part (e.g. `"ftp.example.com"' in
          `ftp://anonymous@ftp.example.com/pub/foo').

        * Port number in the authority part, as an integer (e.g. `8080'
          in `http://www.example.com:8080/').

        * Path part (e.g. `"/index.html"' in
          `http://www.example.com/index.html').

        * Query part (e.g. `"key=xyz&lang=en"' in
          `http://www.example.com/search?key=xyz&lang=en').

        * Fragment part (e.g. `"section4"' in
          `http://www.example.com/document.html#section4').

     The following procedures are finer grained and break up uris with
     different stages.

     `uri-scheme&specific' takes a URI URI, and returns two values, its
     scheme part and its scheme-specific part.  If URI doesn't have a
     scheme part, #F is returned for it.
          (uri-scheme&specific "mailto:sclaus@north.pole")
            => "mailto" and "sclaus@north.pole"
          (uri-scheme&specific "/icons/new.gif")
            => #f and "/icons/new.gif"

     If the URI scheme uses hierarchical notation, i.e.
     "`//AUTHORITY/PATH?QUERY#FRAGMENT'", you can pass the
     scheme-specific part to `uri-decompose-hierarchical' and it
     returns four values, AUTHORITY, PATH, QUERY and FRAGMENT.
          (uri-decompose-hierarchical "//www.foo.com/about/company.html")
            => "www.foo.com", "/about/company.html", #f and #f
          (uri-decompose-hierarchical "//zzz.org/search?key=%3fhelp")
            => "zzz.org", "/search", "key=%3fhelp" and #f
          (uri-decompose-hierarchical "//jjj.jp/index.html#whatsnew")
            => "jjj.jp", "/index.html", #f and "whatsnew"
          (uri-decompose-hierarchical "my@address")
            => #f, #f, #f and #f

     Furthermore, you can parse AUTHORITY part of the hierarchical URI
     by `uri-decompose-authority'.  It returns USERINFO, HOST and PORT.
          (uri-decompose-authority "yyy.jp:8080")
            => #f, "yyy.jp" and "8080"
          (uri-decompose-authority "mylogin@yyy.jp")
            => "mylogin", "yyy.jp" and #f

 -- Function: uri-compose &keyword scheme userinfo host port authority
          path path* query fragment specific
     Compose a URI from given components.  There can be various
     combinations of components to create a valid URI--the following
     diagram shows the possible 'paths' of combinations:

                  /-----------------specific-------------------\
                  |                                            |
           scheme-+------authority-----+-+-------path*---------+-
                  |                    | |                     |
                  \-userinfo-host-port-/ \-path-query-fragment-/

     If `#f' is given to a keyword argument, it is equivalent to the
     absence of that keyword argument.  It is particularly useful to
     pass the results of parsed uri.

     If a component contains a character that is not appropriate for
     that component, it must be properly escaped before being passed to
     `url-compose'.

     Some examples:
          (uri-compose :scheme "http" :host "foo.com" :port 80
                       :path "/index.html" :fragment "top")
            => "http://foo.com:80/index.html#top"

          (uri-compose :scheme "http" :host "foo.net"
                       :path* "/cgi-bin/query.cgi?keyword=foo")
            => "http://foo.net/cgi-bin/query.cgi?keyword=foo"

          (uri-compose :scheme "mailto" :specific "a@foo.org")
            => "mailto:a@foo.org"

          (receive (authority path query fragment)
             (uri-decompose-hierarchical "//foo.jp/index.html#whatsnew")
           (uri-compose :authority authority :path path
                        :query query :fragment fragment))
            => "//foo.jp/index.html#whatsnew"

 -- Function: uri-decode &keyword :cgi-decode
 -- Function: uri-decode-string string &keyword :cgi-decode :encoding
     Decodes "URI encoding", i.e. `%'-escapes.  `uri-decode' takes
     input from the current input port, and writes decoded result to
     the current output port.  `uri-decode-string' takes input from
     STRING and returns decoded string.

     If CGI-DECODE is true, also replaces `+' to a space character.

     To `uri-decode-string' you can provide the external character
     encoding by the ENCODING keyword argument.  When it is given, the
     decoded octet sequence is assumed to be in the specified encoding
     and converted to the Gauche's internal character encoding.

 -- Function: uri-encode &keyword :noescape
 -- Function: uri-encode-string string &keyword :noescape :encoding
     Encodes unsafe characters by `%'-escape.  `uri-encode' takes input
     from the current input port and writes the result to the current
     output port.  `uri-encode-string' takes input from STRING and
     returns the encoded string.

     By default, characters that are not specified "unreserved" in
     RFC3986 are escaped.  You can pass different character set to
     NOESCAPE argument to keep from being encoded.  For example, the
     older RFC2396 has several more "unreserved" characters, and
     passing `*rfc2396-unreserved-char-set*' (see below) prevents those
     characters from being escaped.

     The multibyte characters are encoded as the octet stream of
     Gauche's native multibyte representation by default.  However, you
     can pass the `encoding' keyword argument to `uri-encode-string',
     to convert STRING to the specified character encoding.

 -- Constant: *rfc2396-unreserved-char-set*
 -- Constant: *rfc3986-unreserved-char-set*
     These constants are bound to character sets that represents
     "unreserved" characters defined in RFC2396 and RFC3986,
     respectively.  (See *note Character set::, and *note Character-set
     library::, for operations on character sets).


File: gauche-refe.info,  Node: Zlib compression library,  Next: SLIB,  Prev: URI parsing and construction,  Up: Library modules - Utilities

11.27 `rfc.zlib' - zlib compression library
===========================================

 -- Module: rfc.zlib
     This module provides bindings to zlib compression library.  Most
     features of zlib can be used through this module.

     Zlib supports reading and writing of Zlib compressed data format
     (RFC1950), DEFLATE compressed data format (RFC1951), and GZIP file
     format (RFC1052).  It also provides procedures to calculate CRC32
     and Adler32 checksums.

     Compression and decompression are done through specialized ports.
     There are number of parameters to fine-tune compression; refer to
     zlib documentation for the details.

Condition types
---------------

The following condition types are defined to represent errors during
processing by zlib.

 -- Condition Type: <zlib-error>
     Subclass of `<error>' and superclass of the following condition
     types.  This class is an abstract class to catch any of the
     zlib-specific errors.  Zlib-specific errors raised by procedures
     in `rfc.zlib' are always an instance (or a compound condition
     including) one of the following specific classes.

 -- Condition Type: <zlib-need-dict-error>
 -- Condition Type: <zlib-stream-error>
 -- Condition Type: <zlib-data-error>
 -- Condition Type: <zlib-memory-error>
 -- Condition Type: <zlib-version-error>
     Subclasses of `<zlib-error>'.  Those condition type correspond to
     zlib's `Z_NEED_DICT_ERROR', `Z_STREAM_ERROR', `Z_DATA_ERROR',
     `Z_MEMORY_ERROR', and `Z_VERSION_ERROR' errors.

     When an error occurs during reading data, a compound condition of
     a subclass of `<zlib-error>' and `<io-read-error>' is raised.
     When an error occurs without I/O, a simple condition of a subclass
     of `<zlib-error>' is raised.  Errors unrelated to zlib, such as
     invalid argument error, would be a simple `<error>' condition.

Compression/decompression ports
-------------------------------

 -- Class: <deflating-port>
 -- Class: <inflating-port>
     Compression and decompression functions are provided via ports.  A
     _deflating port_ is an output port that compresses the output
     data.  An _inflating port_ is an input that reads compressed data
     and decompress it.

     When an inflating port encounters a corrupted compressed data, a
     compound condition of `<io-read-error>' and `<zlib-data-error>' is
     raised during read operation.

 -- Function: open-deflating-port drain &keyword compression-level
          buffer-size window-bits memory-level strategy dictionary
          owner?
     Creates and returns an instance of `<deflating-port>', an output
     port that compresses the output data and sends the compressed data
     to another output port DRAIN.  This combines the functionality of
     zlib's `deflateInit2()' and `deflateSetDictionary()'.

     You can specify an exact integer between 1 and 9 (inclusive) to
     COMPRESSION-LEVEL.  Larger integer means larger compression ratio.
     When omitted, a default compression level is used, which is
     usually 6.

     The following constants are defined to specify COMPRESSION-LEVEL
     conveniently:

      -- Constant: Z_NO_COMPRESSION
      -- Constant: Z_BEST_SPEED
      -- Constant: Z_BEST_COMPRESSION
      -- Constant: Z_DEFAULT_COMPRESSION

     The BUFFER-SIZE argument specifies the buffer size of the port in
     bytes.  The default is 4096.

     The WINDOW-BITS argument specifies the size of the window in exact
     integer.   Typically the value should be between 8 and 15,
     inclusive, and it specifies the base two logarithm of the window
     size used in compression.  Larger number yields better compression
     ratio, but more memory usage.  The default value is 15.

     There are a couple of special modes specifiable by WINDOW-BITS.
     When an integer between -8 and -15 is given to WINDOW-BITS, the
     port produces a raw deflated data, that lacks zlib header and
     trailer.  In this case, Adler32 checksum isn't calculated.  The
     actual window size is determiend by the absolute value of
     WINDOW-BITS.

     When WINDOW-BITS is between 24 and 31, the port uses GZIP encoding;
     that is, instead of zlib wrapper, the compressed data is enveloped
     by simple gzip header and trailer.  The gzip header added by this
     case doesn't have filenames, comments, header CRC and other data,
     and have zero modified time, and 255 (unknown) in the OS field.
     The `zstream-adler32' procedure will return CRC32 checksum instead
     of Adler32.  The actual window size is determined by
     WINDOW-BITS-16.

     The MEMORY-LEVEL argument specifies how much memory should be
     allocated to keep the internal state during compression.  1 means
     smallest memory, which causes slow and less compression.  9 means
     fastest and best compression with largest amount of memory.  The
     default value is 8.

     To fine tune compression algorithm, you can use the STRATEGY
     argument.  The following constants are defined as the valid value
     as STRATEGY:

      -- Constant: Z_DEFAULT_STRATEGY
          The default strategy, suitable for most ordinary data.

      -- Constant: Z_FILTERED
          Suitable for data genereated by filters.  Filtered data
          consists mostly of small values with a random distribution,
          and this makes the compression algorithm to use more huffman
          encoding and less string match.

      -- Constant: Z_HUFFMAN_ONLY
          Force huffman encoding only (no string match).

      -- Constant: Z_RLE
          Limit match distance to 1 (that is, to force run-length
          encoding).  It is as fast as `Z_HUFFMAN_ONLY' and gives
          better compression for png image data.

      -- Constant: Z_FIXED
          Prohibits dynamic huffman encoding.  It allows a simple
          decoder for special applications.

     The choice of STRATEGY only affects compression ratio and speed.
     Any choice produces correct and decompressable data.

     You can give an initial dictionary to the DICTIONARY argument to
     be used in compression.  The compressor and decompressor must use
     exactly the same dictionary.  See the zlib documentation for the
     details.

     By default, a deflating port leaves DRAIN open after all
     conversion is done, i.e. the deflating port itself is closed.  If
     you don't want to bother closing DRAIN, give a true value to the
     OWNER? argument; then DRAIN is closed after the deflating port is
     closed and all data is written out.

     Note: You _must_ close a deflating port explicitly, or the
     compressed data can be chopped prematurely.  When you leave a
     deflating port open to be GCed, the finalizer will close it;
     however, the order in which finalizers are called is
     undeterministic, and it is possible that the DRAIN port is closed
     before the deflating port is closed.  In such cases, the deflating
     port's attempt to flush the buffered data and trailer will fail.

 -- Function: open-inflating-port source &keyword buffer-size
          window-bits dictionary owner?
     Takes an input port SOURCE from which a compressed data can be
     read, and creates and returns a new instance of
     `<inflating-port>', that is, a port that allows decompressed data
     from it.  This procedure covers zlib's functionarity of
     `inflateInit2()' and `inflateSetDictionary()'.

     The meaning of BUFFER-SIZE and OWNER are the same as
     `open-deflating-port'.

     The meaning of WINDOW-BITS is almost the same, except that if a
     value incresed by 32 is given, the inflating port automatically
     detects whether the source stream is zlib or gzip by its header.

     If the input data is compressed with specified dictionary, the
     same dictionary must be given to the DICTIONARY argument.
     Otherwise, a compound condition of `<io-read-error>' and
     `<zlib-need-dict-error>' will be raised.

Operations on inflating/deflating ports
---------------------------------------

 -- Function: zstream-total-in xflating-port
 -- Function: zstream-total-out xflating-port
 -- Function: zstream-adler32 xflating-port
 -- Function: zstream-data-type xflating-port
     The XFLATING-PORT argument must be either inflating and deflating
     port, or an error is raised.

     Returns the value of `total_in', `total_out', ADLER32, and
     `data_type' fields of the `z_stream' structure associated to the
     given inflating or deflating port, respectively.

     The value of `data_type' can be one of the following constants:

      -- Constant: Z_BINARY
      -- Constant: Z_TEXT
      -- Constant: Z_ASCII
      -- Constant: Z_UNKNOWN


 -- Function: zstream-params-set! deflating-port &keyword
          compression-level strategy
     Changes compression level and/or strategy during compressing.

 -- Function: zstream-dictionary-adler32 deflating-port
     When a dictionary is given to `open-deflating-port', the
     dictionary's adler32 checksum is calculated.  This procedure
     returns the checksum.  If no dictionary has been given, this
     procedure returns `#f'.

 -- Function: deflating-port-full-flush deflating-port
     Flush the data buffered in the DEFLATING-PORT, and resets
     compression state.  The decompression routine can skip the data to
     the full-flush point by `inflate-sync'.

 -- Function: inflate-sync inflating-port
     Skip the (possibly corrupted) compressed data up to the next
     full-flush point marked by `deflating-port-full-flush'.  You may
     want to use this procedure when you get `<zlib-data-error>'.
     Returns the number of bytes skipped when the next full-flush point
     is found, or `#f' when the input reaches EOF before finding the
     next point.

Miscellaneous API
-----------------

 -- Function: zlib-version
     Returns Zlib's version in string.

 -- Function: deflate-string string options ...
     Compresses the given string and returns zlib-compressed data in a
     string.  All optional arguments are passed to
     `open-deflating-port' as they are.

 -- Function: inflate-string string options ...
     Takes zlib-compressed data in string, and returns decompressed data
     in a string.  All optional arguments are passed to
     `open-inflating-port' as they are.

 -- Function: gzip-encode-string string options ...
 -- Function: gzip-decode-string string options ...
     Like `deflate-string' and `inflate-string', but uses the gzip
     format instead.  It is same as giving more than 15 to the
     WINDOW-BITS argument of `deflate-string' and `inflate-string'.

 -- Function: crc32 string &optional checksum
     Returns CRC32 checksum of STRING.  If optional CHECKSUM is given,
     the returned checksum is an update of CHECKSUM by STRING.

 -- Function: alder32 string &optional checksum
     Returns Adler32 checksum of STRING.  If optional CHECKSUM is
     given, the returned checksum is an update of CHECKSUM by STRING.

     Calculating Adler32 is faster than CRC32, but it is known to
     produce uneven distribution of hash values for small input.  See
     RFC3309 for the detailed description.  If it matters, use CRC32
     instead.


File: gauche-refe.info,  Node: SLIB,  Next: Functional XML parser,  Prev: Zlib compression library,  Up: Library modules - Utilities

11.28 `slib' - SLIB interface
=============================

 -- Module: slib
     This module is the interface to the Aubrey Jaffer's SLIB.  To use
     SLIB, say `(use slib)'.   SLIB itself is not included in Gauche
     distribution.   If you don't have it on your system, get it from
     `http://www-swiss.ai.mit.edu/~jaffer/SLIB.html'.

     This module redefines `require', shadowing the Gauche's original
     `require'.  If it gets a symbol as an argument, it works as SLIB's
     `require', while if it gets a string, it works as Gauche's
     `require'.   The same applies to `provide' and `provided?'.

     All SLIB symbol bindings, loaded by `require', stay in the module
     `slib'.

     (use slib)         ; load and set up slib
     (require 'getopt)  ; load SLIB's getopt module
     (require "foo")    ; load Gauche's foo module


File: gauche-refe.info,  Node: Functional XML parser,  Next: SXML Query Language,  Prev: SLIB,  Up: Library modules - Utilities

11.29 `sxml.ssax' - Functional XML parser
=========================================

 -- Module: sxml.ssax
     `sxml.*' modules are the adaptation of Oleg Kiselyov's SXML
     framework (*note SSAX: ssax.), which is based on S-expression
     representation of XML structure.

     SSAX is a parser part of SXML framework.  This is a quote from
     SSAX webpage:

          A SSAX functional XML parsing framework consists of a
          DOM/SXML parser, a SAX parser, and a supporting library of
          lexing and parsing procedures.  The procedures in the package
          can be used separately to tokenize or parse various pieces of
          XML documents.  The framework supports XML Namespaces,
          character, internal and external parsed entities, attribute
          value normalization, processing instructions and CDATA
          sections. The package includes a semi-validating SXML parser
          : a DOM-mode parser that is an instantiation of a SAX parser
          (called SSAX).

     The current version is based on the SSAX CVS version newer than
     the last 'official' release of SXML toolset (4.9), and
     SXML-gauche-0.9 package which was based on SXML-4.9.  There is an
     important change from that release.  Now the API uses lowercase
     letter suffix `ssax:' instead of uppercase `SSAX:'--the difference
     matters since Gauche is case sensitive by default.  Alias names
     are defined for backward compatibility, but the use of uppercase
     suffixed names are deprecated.

   I derived the content of this part of the manual from SSAX source
code, just by converting its comments into texinfo format.  The
original text is by Oleg Kiselyov.  Shiro Kawai should be responsible
for any typographical error or formatting error introduced by
conversion.

   The manual entries are ordered in "bottom-up" way, beginning from
the lower-level constructs towards the high-level utilities.  If you
just want to parse XML document and obtain SXML, check out
`ssax:xml->sxml' in *note SSAX Highest-level parsers - XML to SXML::.

* Menu:

* SSAX data types::
* SSAX low-level parsing code::
* SSAX higher-level parsers and scanners::
* SSAX Highest-level parsers - XML to SXML::


File: gauche-refe.info,  Node: SSAX data types,  Next: SSAX low-level parsing code,  Prev: Functional XML parser,  Up: Functional XML parser

11.29.1 SSAX data types
-----------------------

_TAG-KIND_
     a symbol '`START', '`END', '`PI', '`DECL', '`COMMENT', '`CDSECT'
     or '`ENTITY-REF' that identifies a markup token.

_UNRES-NAME_
     a name (called `GI' in the XML Recommendation) as given in an xml
     document for a markup token: start-tag, `PI' target, attribute
     name.  If a `GI' is an `NCName', UNRES-NAME is this `NCName'
     converted into a Scheme symbol. If a `GI' is a `QName', UNRES-NAME
     is a pair of symbols: (PREFIX . LOCALPART)

_RES-NAME_
     An expanded name, a resolved version of an UNRES-NAME.  For an
     element or an attribute name with a non-empty namespace URI,
     RES-NAME is a pair of symbols, (URI-SYMB . LOCALPART).  Otherwise,
     it's a single symbol.

_ELEM-CONTENT-MODEL_
     A symbol:
     `ANY'                anything goes, expect an END tag.
     `EMPTY-TAG'          no content, and no END-tag is coming.
     `EMPTY'              no content, expect the END-tag as the next
                          token.
     `PCDATA'             expect character data only, and no children
                          elements.
     `MIXED'              
     `ELEM-CONTENT'       

_URI-SYMB_
     A symbol representing a namespace URI - or other symbol chosen by
     the user to represent URI. In the former case, URI-SYMB is created
     by `%'-quoting of bad URI characters and converting the resulting
     string into a symbol.

_NAMESPACES_
     A list representing namespaces in effect. An element of the list
     has one of the following forms:

    `(PREFIX URI-SYMB . URI-SYMB)'
          or,

    `(PREFIX USER-PREFIX . URI-SYMB)'
          USER-PREFIX is a symbol chosen by the user to represent the
          URI.

    `(#f USER-PREFIX . URI-SYMB)'
          Specification of the user-chosen prefix and a URI-SYMBOL.

    `(*DEFAULT* USER-PREFIX . URI-SYMB)'
          Declaration of the default namespace

    `(*DEFAULT* #f . #f)'
          Un-declaration of the default namespace. This notation
          represents overriding of the previous declaration

     A NAMESPACES list may contain several elements for the same PREFIX.
     The one closest to the beginning of the list takes effect.

_ATTLIST_
     An ordered collection of (NAME . VALUE) pairs, where NAME is a
     RES-NAME or an UNRES-NAME. The collection is an ADT.

_STR-HANDLER_
     A procedure of three arguments: `(STRING1 STRING2 SEED)' returning
     a new SEED.  The procedure is supposed to handle a chunk of
     character data STRING1 followed by a chunk of character data
     STRING2.  STRING2 is a short string, often "\n" and even ""

_ENTITIES_
     An assoc list of pairs:
            (NAMED-ENTITY-NAME . NAMED-ENTITY-BODY)
     where NAMED-ENTITY-NAME is a symbol under which the entity was
     declared, NAMED-ENTITY-BODY is either a string, or (for an
     external entity) a thunk that will return an input port (from
     which the entity can be read).  NAMED-ENTITY-BODY may also be
     `#f'. This is an indication that a NAMED-ENTITY-NAME is currently
     being expanded. A reference to this NAMED-ENTITY-NAME will be an
     error: violation of the WFC nonrecursion.

_XML-TOKEN_
     A record with two slots, KIND and TOKEN.  This record represents a
     markup, which is, according to the XML Recommendation, "takes the
     form of start-tags, end-tags, empty-element tags, entity
     references, character references, comments, CDATA section
     delimiters, document type declarations, and processing
     instructions."
    KIND
          a TAG-KIND

    HEAD
          an UNRES-NAME. For xml-tokens of kinds '`COMMENT' and
          '`CDSECT', the head is `#f'

     For example,
          <P>  => kind='START, head='P
          </P> => kind='END, head='P
          <BR/> => kind='EMPTY-EL, head='BR
          <!DOCTYPE OMF ...> => kind='DECL, head='DOCTYPE
          <?xml version="1.0"?> => kind='PI, head='xml
          &my-ent; => kind = 'ENTITY-REF, head='my-ent
     Character references are not represented by xml-tokens as these
     references are transparently resolved into the corresponding
     characters.

_XML-DECL_
     A record with three slots, ELEMS, ENTITIES, and NOTATIONS.

     The record represents a datatype of an XML document: the list of
     declared elements and their attributes, declared notations, list of
     replacement strings or loading procedures for parsed general
     entities, etc. Normally an xml-decl record is created from a DTD or
     an XML Schema, although it can be created and filled in in many
     other ways (e.g., loaded from a file).

     ELEMS: an (assoc) list of decl-elem or `#f'. The latter instructs
     the parser to do no validation of elements and attributes.

     DECL-ELEM: declaration of one element: `(ELEM-NAME ELEM-CONTENT
     DECL-ATTRS)'; ELEM-NAME is an UNRES-NAME for the element.
     ELEM-CONTENT is an ELEM-CONTENT-MODEL.  DECL-ATTRS is an ATTLIST,
     of `(ATTR-NAME . VALUE)' associations.  This element can declare a
     user procedure to handle parsing of an element (e.g., to do a
     custom validation, or to build a hash of IDs as they're
     encountered).

     DECL-ATTR: an element of an ATTLIST, declaration of one attribute
     `(ATTR-NAME CONTENT-TYPE USE-TYPE DEFAULT-VALUE)': ATTR-NAME is an
     UNRES-NAME for the declared attribute; CONTENT-TYPE is a symbol:
     `CDATA', NMTOKEN, NMTOKENS, ...; or a list of strings for the
     enumerated type.  USE-TYPE is a symbol: `REQUIRED', `IMPLIED',
     `FIXED' default-value is a string for the default value, or `#f'
     if not given.

 -- Function: make-empty-attlist
 -- Function: attlist-add attlist name-value
 -- Function: attlist-null?
 -- Function: attlist-remove-top attlist
 -- Function: attlist->alist attlist
 -- Function: attlist-fold
     Utility procedures to deal with attribute list, which keeps
     name-value association.

 -- Function: make-xml-token kind head
 -- Function: xml-token? token
     A constructor and a predicate for a XML-TOKEN record.

 -- Macro: xml-token-kind token
 -- Macro: xml-token-head token
     Accessor macros of a XML-TOKEN record.


File: gauche-refe.info,  Node: SSAX low-level parsing code,  Next: SSAX higher-level parsers and scanners,  Prev: SSAX data types,  Up: Functional XML parser

11.29.2 SSAX low-level parsing code
-----------------------------------

They deal with primitive lexical units (Names, whitespaces, tags) and
with pieces of more generic productions. Most of these parsers must be
called in appropriate context. For example, `ssax:complete-start-tag'
must be called only when the start-tag has been detected and its `GI'
has been read.

 -- Function: ssax:skip-S port
     Skip the S (whitespace) production as defined by
           [3] S ::= (#x20 | #x9 | #xD | #xA)
     The procedure returns the first not-whitespace character it
     encounters while scanning the PORT. This character is left on the
     input stream.

 -- Function: ssax:ncname-starting-char? a-char
     Check to see if a-char may start a `NCName'.

 -- Function: ssax:read-NCName port
     Read a `NCName' starting from the current position in the PORT and
     return it as a symbol.

 -- Function: ssax:read-QName port
     Read a (namespace-) Qualified Name, `QName', from the current
     position in the PORT.

     From REC-xml-names:
           [6] QName ::= (Prefix ':')? LocalPart
           [7] Prefix ::= NCName
           [8] LocalPart ::= NCName

     Return: an UNRES-NAME.

 -- Variable: ssax:Prefix-XML
     The prefix of the pre-defined XML namespace, i.e. '`xml'.

 -- Function: ssax:read-markup-token port
     This procedure starts parsing of a markup token. The current
     position in the stream must be `#\<'. This procedure scans enough
     of the input stream to figure out what kind of a markup token it
     is seeing. The procedure returns an xml-token structure describing
     the token. Note, generally reading of the current markup is not
     finished! In particular, no attributes of the start-tag token are
     scanned.

     Here's a detailed break out of the return values and the position
     in the PORT when that particular value is returned:
    `PI-token'
          only `PI'-target is read.  To finish the Processing
          Instruction and disregard it, call `ssax:skip-pi'.
          `ssax:read-attributes' may be useful as well (for `PI's whose
          content is attribute-value pairs)

    `END-token'
          The end tag is read completely; the current position is right
          after the terminating `#\>' character.

    `COMMENT'
          is read and skipped completely. The current position is right
          after "`-->'" that terminates the comment.

    `CDSECT'
          The current position is right after "`<!CDATA['".  Use
          `ssax:read-cdata-body' to read the rest.

    `DECL'
          We have read the keyword (the one that follows "`<!'")
          identifying this declaration markup. The current position is
          after the keyword (usually a whitespace character)

    `START-token'
          We have read the keyword (`GI') of this start tag.  No
          attributes are scanned yet. We don't know if this tag has an
          empty content either.  Use `ssax:complete-start-tag' to
          finish parsing of the token.

 -- Function: ssax:skip-pi port
     The current position is inside a `PI'. Skip till the rest of the
     `PI'.

 -- Function: ssax:read-pi-body-as-string port
     The current position is right after reading the `PITarget'. We
     read the body of `PI' and return it as a string. The port will
     point to the character right after '`?>'' combination that
     terminates `PI'.
           [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'

 -- Function: ssax:skip-internal-dtd port
     The current pos in the port is inside an internal DTD subset
     (e.g., after reading `#\[ 'that begins an internal DTD subset)
     Skip until the "`]>'" combination that terminates this DTD

 -- Function: ssax:read-cdata-body port str-handler seed
     This procedure must be called after we have read a string
     "`<![CDATA['" that begins a `CDATA' section. The current position
     must be the first position of the `CDATA' body. This function
     reads _lines_ of the `CDATA' body and passes them to a
     STR-HANDLER, a character data consumer.

     The str-handler is a STR-HANDLER, a procedure `string1' STRING2
     SEED.  The first STRING1 argument to STR-HANDLER never contains a
     newline.  The second STRING2 argument often will. On the first
     invocation of the STR-HANDLER, the seed is the one passed to
     `ssax:read-cdata-body' as the third argument. The result of this
     first invocation will be passed as the seed argument to the second
     invocation of the line consumer, and so on. The result of the last
     invocation of the STR-HANDLER is returned by the
     `ssax:read-cdata-body'.  Note a similarity to the fundamental
     '`fold'' iterator.

     Within a `CDATA' section all characters are taken at their face
     value, with only three exceptions:
        * `CR', `LF', and `CRLF' are treated as line delimiters, and
          passed as a single `#\newline' to the STR-HANDLER.

        * "`]]>'" combination is the end of the `CDATA' section.

        * `&gt;' is treated as an embedded `#\>' character.  Note,
          `&lt;' and `&amp;' are not specially recognized (and are not
          expanded)!

 -- Function: ssax:read-char-ref port
           [66]  CharRef ::=  '&#' [0-9]+ ';'
                            | '&#x' [0-9a-fA-F]+ ';'
     This procedure must be called after we we have read "`&#'" that
     introduces a char reference.  The procedure reads this reference
     and returns the corresponding char.  The current position in PORT
     will be after "`;'" that terminates the char reference.  Faults
     detected: `WFC: XML-Spec.html#wf-Legalchar'.

     According to Section "4.1 Character and Entity References" of the
     XML Recommendation:

          "[Definition: A character reference refers to a specific
          character  in the ISO/IEC 10646 character set, for example
          one not directly  accessible from available input devices.]"
     Therefore, we use a `ucscode->char' function to convert a character
     code into the character - _regardless_ of the current character
     encoding of the input stream.

 -- Function: ssax:handle-parsed-entity port name entities
          content-handler str-handler seed
     Expand and handle a parsed-entity reference
        * PORT - a PORT

        * NAME - the name of the parsed entity to expand, a symbol.

        * ENTITIES - see ENTITIES

        * CONTENT-HANDLER - procedure PORT ENTITIES SEED that is
          supposed to return a SEED.

        * STR-HANDLER - a STR-HANDLER. It is called if the entity in
          question turns out to be a pre-declared entity
     The result is the one returned by CONTENT-HANDLER or STR-HANDLER.

     Faults detected:
            WFC: XML-Spec.html#wf-entdeclared
            WFC: XML-Spec.html#norecursion

 -- Function: ssax:read-attributes port entities
     This procedure reads and parses a production `Attribute*'
           [41] Attribute ::= Name Eq AttValue
           [10] AttValue ::=  '"' ([^<&"] | Reference)* '"'
                           | "'" ([^<&'] | Reference)* "'"
           [25] Eq ::= S? '=' S?
     The procedure returns an ATTLIST, of NAME (as UNRES-NAME), VALUE
     (as string) pairs.  The current character on the PORT is a
     non-whitespace character that is not an ncname-starting character.

     Note the following rules to keep in mind when reading an 'AttValue'
     "Before the value of an attribute is passed to the application or
     checked for validity, the XML processor must normalize it as
     follows:
        * a character reference is processed by appending the referenced
          character to the attribute value

        * an entity reference is processed by recursively processing the
          replacement text of the entity [see ENTITIES] [named entities
          amp lt gt quot apos are assumed pre-declared]

        * a whitespace character (`#x20', `#xD', `#xA', `#x9') is
          processed by appending `#x20' to the normalized value, except
          that only a single `#x20' is appended for a "`#xD#xA'"
          sequence that is part of an external parsed entity or the
          literal entity value of an internal parsed entity

        * other characters are processed by appending them to the
          normalized value "

     Faults detected:
           WFC: XML-Spec.html#CleanAttrVals
           WFC: XML-Spec.html#uniqattspec

 -- Function: ssax:resolve-name port unres-name namespaces
          apply-default-ns?
     Convert an UNRES-NAME to a RES-NAME given the appropriate
     NAMESPACES declarations.  The last parameter APPLY-DEFAULT-NS?
     determines if the default namespace applies (for instance, it does
     not for attribute names)

     Per `REC-xml-names/#nsc-NSDeclared', "xml" prefix is considered
     pre-declared and bound to the namespace name
     "`http://www.w3.org/XML/1998/namespace'".

     This procedure tests for the namespace constraints:
     `http://www.w3.org/TR/REC-xml-names/#nsc-NSDeclared'.

 -- Function: ssax:uri-string->symbol uri-str
     Convert a URI-STR to an appropriate symbol.

 -- Function: ssax:complete-start-tag tag port elems entities namespaces
     This procedure is to complete parsing of a start-tag markup. The
     procedure must be called after the start tag token has been read.
     TAG is an UNRES-NAME.  ELEM S is an instance of `xml-decl::elems';
     it can be `#f' to tell the function to do _no_ validation of
     elements and their attributes.

     This procedure returns several values:
    ELEM-GI
          a RES-NAME.

    ATTRIBUTES
          element's attributes, an ATTLIST of `(RES-NAME . STRING)'
          pairs. The list does _not_ include `xmlns' attributes.

    NAMESPACES
          the input list of namespaces amended with namespace
          (re-)declarations contained within the start-tag under parsing
          ELEM-CONTENT-MODEL.

     On exit, the current position in PORT will be the first character
     after `#\>' that terminates the start-tag markup.

     Faults detected:
           VC: XML-Spec.html#enum
           VC: XML-Spec.html#RequiredAttr
           VC: XML-Spec.html#FixedAttr
           VC: XML-Spec.html#ValueType
           WFC: XML-Spec.html#uniqattspec (after namespaces prefixes are resolved)
           VC: XML-Spec.html#elementvalid
           WFC: REC-xml-names/#dt-NSName

     Note, although XML Recommendation does not explicitly say it,
     XMLNS and XMLNS: attributes don't have to be declared (although
     they can be declared, to specify their default value).

 -- Function: ssax:read-external-id port
     This procedure parses an `ExternalID' production.
           [75] ExternalID ::= 'SYSTEM' S SystemLiteral
                           | 'PUBLIC' S PubidLiteral S SystemLiteral
           [11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'")
           [12] PubidLiteral ::=  '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
           [13] PubidChar ::=  #x20 | #xD | #xA | [a-zA-Z0-9]
                          | [-'()+,./:=?;!*#@$_%]
     This procedure is supposed to be called when an `ExternalID' is
     expected; that is, the current character must be either `#\S' or
     `#\P' that start correspondingly a `SYSTEM' or `PUBLIC' token.
     This procedure returns the `SystemLiteral' as a string. A
     `PubidLiteral' is disregarded if present.


File: gauche-refe.info,  Node: SSAX higher-level parsers and scanners,  Next: SSAX Highest-level parsers - XML to SXML,  Prev: SSAX low-level parsing code,  Up: Functional XML parser

11.29.3 SSAX higher-level parsers and scanners
----------------------------------------------

They parse productions corresponding to the whole (document) entity or
its higher-level pieces (prolog, root element, etc).

 -- Function: ssax:scan-Misc port
     Scan the `Misc' production in the context:
          [1]  document ::=  prolog element Misc*
          [22] prolog ::= XMLDecl? Misc* (doctypedec l Misc*)?
          [27] Misc ::= Comment | PI |  S
     The following function should be called in the prolog or epilog
     contexts.  In these contexts, whitespaces are completely ignored.
     The return value from `ssax:scan-Misc' is either a `PI'-token, a
     `DECL'-token, a `START' token, or EOF.  Comments are ignored and
     not reported.

 -- Function: ssax:read-char-data port expect-eof? str-handler seed
     This procedure is to read the character content of an XML document
     or an XML element.
           [43] content ::=
                  (element | CharData | Reference | CDSect | PI
                   | Comment)*
     To be more precise, the procedure reads `CharData', expands
     `CDSect' and character entities, and skips comments. The procedure
     stops at a named reference, EOF, at the beginning of a `PI' or a
     start/end tag.

    PORT
          a port to read

    EXPECT-EOF?
          a boolean indicating if EOF is normal, i.e., the character
          data may be terminated by the EOF. EOF is normal while
          processing a parsed entity.

    STR-HANDLER
          a STR-HANDLER.

    SEED
          an argument passed to the first invocation of STR-HANDLER.

     The procedure returns two results: SEED and TOKEN.

     The SEED is the result of the last invocation of STR-HANDLER, or
     the original seed if STR-HANDLER was never called.

     TOKEN can be either an eof-object (this can happen only if
     EXPECT-EOF? was `#t'), or:
        * an xml-token describing a START tag or an END-tag; For a
          start token, the caller has to finish reading it.

        * an xml-token describing the beginning of a `PI'. It's up to an
          application to read or skip through the rest of this `PI';

        * an xml-token describing a named entity reference.

     `CDATA' sections and character references are expanded inline and
     never returned. Comments are silently disregarded.

     As the XML Recommendation requires, all whitespace in character
     data must be preserved. However, a `CR' character (`#xD') must be
     disregarded if it appears before a `LF' character (`#xA'), or
     replaced by a `#xA' character otherwise. See Secs. 2.10 and 2.11
     of the XML Recommendation. See also the canonical XML
     Recommendation.

 -- Function: ssax:assert-token token kind gi error-cont
     Make sure that TOKEN is of anticipated KIND and has anticipated GI.
     Note GI argument may actually be a pair of two symbols, Namespace
     URI or the prefix, and of the localname.  If the assertion fails,
     ERROR-CONT is evaluated by passing it three arguments: TOKEN KIND
     GI.  The result of ERROR-CONT is returned.


File: gauche-refe.info,  Node: SSAX Highest-level parsers - XML to SXML,  Prev: SSAX higher-level parsers and scanners,  Up: Functional XML parser

11.29.4 SSAX Highest-level parsers - XML to SXML
------------------------------------------------

These parsers are a set of syntactic forms to instantiate a SSAX parser.
A user can instantiate the parser to do the full validation, or no
validation, or any particular validation. The user specifies which `PI'
he wants to be notified about. The user tells what to do with the
parsed character and element data. The latter handlers determine if the
parsing follows a SAX or a DOM model.

 -- Macro: ssax:make-pi-parser my-pi-handlers
     Create a parser to parse and process one Processing Element (`PI').

     MY-PI-HANDLERS: An assoc list of pairs (PI-TAG . PI-HANDLER) where
     PI-TAG is an NCNAME symbol, the `PI' target, and PI-HANDLER is a
     procedure PORT PI-TAG SEED where PORT points to the first symbol
     after the `PI' target.  The handler should read the rest of the
     `PI' up to and including the combination '`?>'' that terminates
     the `PI'. The handler should return a new seed.  One of the
     PI-TAGs may be a symbol `*DEFAULT*'. The corresponding handler
     will handle `PI's that no other handler will. If the `*DEFAULT*'
     PI-TAG is not specified, `ssax:make-pi-parser' will make one,
     which skips the body of the `PI'.

     The output of the `ssax:make-pi-parser' is a procedure PORT PI-TAG
     SEED, that will parse the current `PI' accoding to user-specified
     handlers.

 -- Macro: ssax:make-elem-parser my-new-level-seed my-finish-element
          my-char-data-handler my-pi-handlers
     Create a parser to parse and process one element, including its
     character content or children elements. The parser is typically
     applied to the root element of a document.

    MY-NEW-LEVEL-SEED
          procedure ELEM-GI ATTRIBUTES NAMESPACES EXPECTED-CONTENT SEED
          where ELEM-GI is a RES-NAME of the element about to be
          processed.  This procedure is to generate the seed to be
          passed to handlers that process the content of the element.

    MY-FINISH-ELEMENT
          procedure ELEM-GI ATTRIBUTES NAMESPACES PARENT-SEED SEED
          This procedure is called when parsing of ELEM-GI is finished.
          The SEED is the result from the last content parser (or from
          MY-NEW-LEVEL-SEED if the element has the empty content).
          PARENT-SEED is the same seed as was passed to
          MY-NEW-LEVEL-SEED.  The procedure is to generate a seed that
          will be the result of the element parser.

    MY-CHAR-DATA-HANDLER
          A STR-HANDLER.

    MY-PI-HANDLERS
          See `ssax:make-pi-handler' above.

     The generated parser is a: procedure START-TAG-HEAD PORT ELEMS
     ENTITIES NAMESPACES PRESERVE-WS? SEED.
     The procedure must be called after the start tag token has been
     read. START-TAG-HEAD is an UNRES-NAME from the start-element tag.
     ELEMS is an instance of `xml-decl::elems'.  See
     `ssax:complete-start-tag::preserve-ws?'

     Faults detected:
           VC: XML-Spec.html#elementvalid
           WFC: XML-Spec.html#GIMatch

 -- Macro: ssax:make-parser user-handler-tag user-handler-proc ...
     Create an XML parser, an instance of the XML parsing framework.
     This will be a SAX, a DOM, or a specialized parser depending on
     the supplied user-handlers.

     USER-HANDLER-TAG is a symbol that identifies a procedural
     expression that follows the tag. Given below are tags and
     signatures of the corresponding procedures. Not all tags have to
     be specified. If some are omitted, reasonable defaults will apply.

    `tag: DOCTYPE'
          handler-procedure: PORT DOCNAME SYSTEMID INTERNAL-SUBSET? SEED

          If INTERNAL-SUBSET? is `#t', the current position in the port
          is right after we have read `#\[' that begins the internal
          DTD subset.  We must finish reading of this subset before we
          return (or must call skip-internal-subset if we aren't
          interested in reading it).  The port at exit must be at the
          first symbol after the whole DOCTYPE declaration.

          The handler-procedure must generate four values:
          ELEMS ENTITIES NAMESPACES SEED
          See `xml-decl::elems' for ELEMS.  It may be `#f' to switch
          off the validation.  NAMESPACES will typically contain
          USER-PREFIXes for selected URI-SYMBs.  The default
          handler-procedure skips the internal subset, if any, and
          returns `(values #f '() '() seed)'.

    `tag: UNDECL-ROOT'
          handler-procedure: ELEM-GI SEED
          where ELEM-GI is an UNRES-NAME of the root element. This
          procedure is called when an XML document under parsing
          contains _no_ `DOCTYPE' declaration.  The handler-procedure,
          as a DOCTYPE handler procedure above, must generate four
          values:
          ELEMS ENTITIES NAMESPACES SEED
          The default handler-procedure returns `(values #f '() '()
          seed)'.

    `tag: DECL-ROOT'
          handler-procedure: ELEM-GI SEED
          where ELEM-GI is an UNRES-NAME of the root element. This
          procedure is called when an XML document under parsing does
          contains the `DOCTYPE' declaration.  The handler-procedure
          must generate a new `seed' (and verify that the name of the
          root element matches the doctype, if the handler so wishes).
          The default handler-procedure is the identity function.

    `tag: NEW-LEVEL-SEED'
          handler-procedure: see `ssax:make-elem-parser',
          MY-NEW-LEVEL-SEED

    `tag: FINISH-ELEMENT'
          handler-procedure: see `ssax:make-elem-parser',
          MY-FINISH-ELEMENT

    `tag: CHAR-DATA-HANDLER'
          handler-procedure: see `ssax:make-elem-parser',
          MY-CHAR-DATA-HANDLER

    `tag: PI'
          handler-procedure: see `ssax:make-pi-parser'.
          The default value is `'()'.

     The generated parser is a
     procedure PORT SEED

     This procedure parses the document prolog and then exits to an
     element parser (created by ssax:make-elem-parser) to handle the
     rest.

           [1]  document ::=  prolog element Misc*
           [22] prolog ::= XMLDecl? Misc* (doctypedec | Misc*)?
           [27] Misc ::= Comment | PI |  S

           [28] doctypedecl ::=  '<!DOCTYPE' S Name (S ExternalID)? S?
                                  ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
           [29] markupdecl ::= elementdecl | AttlistDecl
                                | EntityDecl
                                | NotationDecl | PI
                                | Comment

   A few utility procedures that turned out useful.

 -- Function: ssax:reverse-collect-str fragments
     given the list of FRAGMENTS (some of which are text strings)
     reverse the list and concatenate adjacent text strings.

 -- Function: ssax:reverse-collect-str-drop-ws fragments
     given the list of fragments (some of which are text strings)
     reverse the list and concatenate adjacent text strings.  We also
     drop "unsignificant" whitespace, that is, whitespace in front,
     behind and between elements. The whitespace that is included in
     character data is not affected.  We use this procedure to
     "intelligently" drop "insignificant" whitespace in the parsed
     SXML. If the strict compliance with the XML Recommendation
     regarding the whitespace is desired, please use the
     `ssax:reverse-collect-str' procedure instead.

 -- Function: ssax:xml->sxml port namespace-prefix-assig
     This is an instance of a SSAX parser above that returns an SXML
     representation of the XML document to be read from PORT.
     NAMESPACE-PREFIX-ASSIG is a list of `(USER-PREFIX . URI-STRING)'
     that assigns USER-PREFIXes to certain namespaces identified by
     particular URI-STRINGs. It may be an empty list.  The procedure
     returns an SXML tree. The port points out to the first character
     after the root element.


File: gauche-refe.info,  Node: SXML Query Language,  Next: Manipulating SXML structure,  Prev: Functional XML parser,  Up: Library modules - Utilities

11.30 `sxml.sxpath' - SXML Query Language
=========================================

 -- Module: sxml.sxpath
     SXPath is a query language for SXML, an instance of XML Information
     set (Infoset) in the form of s-expressions.

     It is originally written by Oleg Kiselyov, and improved by Dmitry
     Lizorkin and Kirill Lisovsky.  This module also incorporates
     various procedures written for SXPath by Dmitry Lizorkin and
     Kirill Lisovsky.

     Current version is based on sxpathlib.scm,v 3.915, sxpath.scm,v
     1.1, and sxpath-ext.scm,v 1.911.

   This manual is mostly derived from the comments in the original
source files.

   The module consists of three layers.
  1. Basic converters and applicators, which provides the means to
     access and translate SXML tree.

  2. High-level query language compiler, which takes abbreviated SXPath
     and returns a Scheme function that selects a nodeset that
     satisfies the specified path from the given nodeset.

  3. Extension libraries, which implements SXML counterparts to W3C
     XPath Core Functions Library.

* Menu:

* SXPath basic converters and applicators::
* SXPath query language::
* SXPath extension::


File: gauche-refe.info,  Node: SXPath basic converters and applicators,  Next: SXPath query language,  Prev: SXML Query Language,  Up: SXML Query Language

11.30.1 SXPath basic converters and applicators
-----------------------------------------------

A converter is a function
       type Converter = Node|Nodeset -> Nodeset
   A converter can also play a role of a predicate: in that case, if a
converter, applied to a node or a nodeset, yields a non-empty nodeset,
the converter-predicate is deemed satisfied. Throughout this file a nil
nodeset is equivalent to `#f' in denoting a failure.

 -- Function: nodeset? x
     Returns `#t' if given object is a nodeset.

 -- Function: as-nodeset x
     If X is a nodeset - returns it as is, otherwise wrap it in a list.

 -- Function: sxml:element? obj
     Predicate which returns #T if OBJ is SXML element, otherwise
     returns #F.

 -- Function: ntype-names?? crit
     The function `ntype-names??' takes a list of acceptable node names
     as a criterion and returns a function, which, when applied to a
     node, will return `#t' if the node name is present in criterion
     list and `#f' othervise.
           ntype-names?? :: ListOfNames -> Node -> Boolean

 -- Function: ntype?? crit
     The function `ntype??' takes a type criterion and returns a
     function, which, when applied to a node, will tell if the node
     satisfies the test.
            ntype?? :: Crit -> Node -> Boolean

     The criterion CRIT is one of the following symbols:
    `id'
          tests if the Node has the right name (id)

    `@'
          tests if the Node is an ATTRIBUTES-LIST.

    `*'
          tests if the Node is an ELEMENT.

    `*text*'
          tests if the Node is a text node.

    `*data*'
          tests if the Node is a data node (text, number, boolean,
          etc., but not pair).

    `*PI*'
          tests if the Node is a `PI' node.

    `*COMMENT*'
          tests if the Node is a `COMMENT' node.

    `*ENTITY*'
          tests if the Node is a `ENTITY' node.

    `*any*'
          `#t' for any type of Node.

 -- Function: ntype-namespace-id?? ns-id
     This function takes a namespace-id, and returns a predicate `Node
     -> Boolean', which is `#t' for nodes with this very namespace-id.
     NS-ID is a string.  `(ntype-namespace-id?? #f)' will be `#t' for
     nodes with non-qualified names.

 -- Function: sxml:invert pred
     This function takes a predicate and returns it inverted .  That is
     if the given predicate yields `#f' or '`()' the inverted one
     yields the given node (`#t') and vice versa.

 -- Function: node-eq? other
 -- Function: node-equal? other
     Curried equivalence converter-predicates, i.e.
            ((node-eq? a) b)    == (eq? a b)
            ((node-equal? a) b) == (equal? a b)

 -- Function: node-pos n
           node-pos:: N -> Nodeset -> Nodeset, or
           node-pos:: N -> Converter

     Select the N'th element of a Nodeset and return as a singular
     Nodeset; Return an empty nodeset if the Nth element does not exist.
     `((node-pos 1) Nodeset)' selects the node at the head of the
     Nodeset, if exists; `((node-pos 2) Nodeset)' selects the Node
     after that, if exists.  N can also be a negative number: in that
     case the node is picked from the tail of the list.  `((node-pos
     -1) Nodeset)' selects the last node of a non-empty nodeset;
     `((node-pos -2) Nodeset)' selects the last but one node, if exists.

 -- Function: sxml:filter pred?
           filter:: Converter -> Converter

     A filter applicator, which introduces a filtering context. The
     argument converter is considered a predicate, with either `#f' or
     nil result meaning failure.

 -- Function: take-until pred?
           take-until:: Converter -> Converter, or
           take-until:: Pred -> Node|Nodeset -> Nodeset

     Given a converter-predicate and a nodeset, apply the predicate to
     each element of the nodeset, until the predicate yields anything
     but #F or nil. Return the elements of the input nodeset that have
     been processed till that moment (that is, which fail the
     predicate).  `take-until' is a variation of the filter above:
     `take-until' passes elements of an ordered input set till (but not
     including) the first element that satisfies the predicate.  The
     nodeset returned by `((take-until (not pred)) nset)' is a subset -
     to be more precise, a prefix - of the nodeset returned by
     `((filter pred) nset)'.

 -- Function: take-after pred?
          take-after:: Converter -> Converter, or
          take-after:: Pred -> Node|Nodeset -> Nodeset

     Given a converter-predicate and a nodeset, apply the predicate to
     each element of the nodeset, until the predicate yields anything
     but `#f' or nil. Return the elements of the input nodeset that
     have not been processed: that is, return the elements of the input
     nodeset that follow the first element that satisfied the predicate.
     `take-after' along with `take-until' partition an input nodeset
     into three parts: the first element that satisfies a predicate,
     all preceding elements and all following elements.

 -- Function: map-union proc lst
     Apply proc to each element of lst and return the list of results.
     If proc returns a nodeset, splice it into the result.

     From another point of view, `map-union' is a function
     Converter->Converter, which places an argument-converter in a
     joining context.

 -- Function: node-reverse node-or-nodeset
          node-reverse :: Converter, or
          node-reverse:: Node|Nodeset -> Nodeset

     Reverses the order of nodes in the nodeset.  This basic converter
     is needed to implement a reverse document order (see the XPath
     Recommendation).

 -- Function: node-trace title
           node-trace:: String -> Converter

     `(node-trace title)' is an identity converter. In addition it
     prints out a node or nodeset it is applied to, prefixed with the
     'title'.  This converter is very useful for debugging.

   What follow are Converter combinators, higher-order functions that
transmogrify a converter or glue a sequence of converters into a
single, non-trivial converter. The goal is to arrive at converters that
correspond to XPath location paths.

   From a different point of view, a combinator is a fixed, named
_pattern_ of applying converters. Given below is a complete set of such
patterns that together implement XPath location path specification. As
it turns out, all these combinators can be built from a small number of
basic blocks: regular functional composition, map-union and filter
applicators, and the nodeset union.

 -- Function: select-kids test-pred?
          select-kids:: Pred -> Node -> Nodeset
     Given a Node, return an (ordered) subset its children that satisfy
     the Pred (a converter, actually).

          select-kids:: Pred -> Nodeset -> Nodeset
     The same as above, but select among children of all the nodes in
     the Nodeset.

 -- Function: node-self pred
           node-self:: Pred -> Node -> Nodeset, or
           node-self:: Converter -> Converter

     Similar to select-kids but apply to the Node itself rather than to
     its children. The resulting Nodeset will contain either one
     component, or will be empty (if the Node failed the Pred).

 -- Function: node-join . selectors
           node-join:: [LocPath] -> Node|Nodeset -> Nodeset, or
           node-join:: [Converter] -> Converter

     join the sequence of location steps or paths as described in the
     title comments above.

 -- Function: node-reduce . converters
           node-reduce:: [LocPath] -> Node|Nodeset -> Nodeset, or
           node-reduce:: [Converter] -> Converter

     A regular functional composition of converters.  From a different
     point of view, `((apply node-reduce converters) nodeset)' is
     equivalent to `(foldl apply nodeset converters)' i.e., folding, or
     reducing, a list of converters with the nodeset as a seed.

 -- Function: node-or . converters
           node-or:: [Converter] -> Converter

     This combinator applies all converters to a given node and
     produces the union of their results.  This combinator corresponds
     to a union, '`|'' operation for XPath location paths.

 -- Function: node-closure test-pred?
           node-closure:: Converter -> Converter

     Select all _descendants_ of a node that satisfy a
     converter-predicate.  This combinator is similar to `select-kids'
     but applies to grand... children as well.  This combinator
     implements the "`descendant::'" XPath axis.  Conceptually, this
     combinator can be expressed as
           (define (node-closure f)
                (node-or
                  (select-kids f)
          	 (node-reduce (select-kids (ntype?? '*)) (node-closure f))))

     This definition, as written, looks somewhat like a fixpoint, and it
     will run forever.  It is obvious however that sooner or later
     `(select-kids (ntype?? '*))' will return an empty nodeset. At this
     point further iterations will no longer affect the result and can
     be stopped.


File: gauche-refe.info,  Node: SXPath query language,  Next: SXPath extension,  Prev: SXPath basic converters and applicators,  Up: SXML Query Language

11.30.2 SXPath query language
-----------------------------

 -- Function: sxpath abbrpath . ns-binding
     Evaluates an abbreviated SXPath

           sxpath:: AbbrPath -> Converter, or
           sxpath:: AbbrPath -> Node|Nodeset -> Nodeset

     ABBRPATH is a list. It is translated to the full SXPath according
     to the following rewriting rules:
           (sxpath '()) -> (node-join)
           (sxpath '(path-component ...)) ->
                          (node-join (sxpath1 path-component) (sxpath '(...)))
           (sxpath1 '//) -> (node-or
                               (node-self (ntype?? '*any*))
                               (node-closure (ntype?? '*any*)))
           (sxpath1 '(equal? x)) -> (select-kids (node-equal? x))
           (sxpath1 '(eq? x))    -> (select-kids (node-eq? x))
           (sxpath1 '(or@ ...))  -> (select-kids (ntype-names??
                                                    (cdr '(or@ ...))))
           (sxpath1 '(not@ ...)) -> (select-kids (sxml:invert
                                                   (ntype-names??
                                                    (cdr '(not@ ...)))))
           (sxpath1 '(ns-id:* x)) -> (select-kids
                                                (ntype-namespace-id?? x))
           (sxpath1 ?symbol)     -> (select-kids (ntype?? ?symbol))
           (sxpath1 ?string)     -> (txpath ?string)
           (sxpath1 procedure)   -> procedure
           (sxpath1 '(?symbol ...)) -> (sxpath1 '((?symbol) ...))
           (sxpath1 '(path reducer ...)) ->
                          (node-reduce (sxpath path) (sxpathr reducer) ...)
           (sxpathr number)      -> (node-pos number)
           (sxpathr path-filter) -> (filter (sxpath path-filter))

Some wrapper functions around `sxpath':

 -- Function: if-sxpath path
     `sxpath' always returns a list, which is `#t' in Scheme.
     `if-sxpath' returns `#f' instead of empty list.

 -- Function: if-car-sxpath path
     Returns first node found, if any.  Otherwise returns `#f'.

 -- Function: car-sxpath path
     Returns first node found, if any.  Otherwise returns empty list.

 -- Function: sxml:id-alist node . lpaths
     Built an index as a list of `(ID_VALUE . ELEMENT)' pairs for given
     node.  LPATHS are location paths for attributes of type ID.


File: gauche-refe.info,  Node: SXPath extension,  Prev: SXPath query language,  Up: SXML Query Language

11.30.3 SXPath extension
------------------------

SXML counterparts to W3C XPath Core Functions Library.

 -- Function: sxml:string object
     The counterpart to XPath `string' function (section 4.2 XPath Rec.)
     Converts a given object to a string.  NOTE:
       1. When converting a nodeset - a document order is not preserved

       2. NUMBER->STRING function returns the result in a form which is
          slightly different from XPath Rec. specification

 -- Function: sxml:boolean object
     The counterpart to XPath `boolean' function (section 4.3 XPath
     Rec.)  Converts its argument to a boolean.

 -- Function: sxml:number obj
     The counterpart to XPath `number' function (section 4.4 XPath Rec.)
     Converts its argument to a number NOTE:
       1. The argument is not optional (yet?).

       2. `string->number' conversion is not IEEE 754 round-to-nearest.

       3. NaN is represented as 0.

 -- Function: sxml:string-value node
     Returns a string value for a given node in accordance to XPath
     Rec. 5.1 - 5.7

 -- Function: sxml:node? node
     According to XPath specification 2.3, this test is true for any
     XPath node.  For SXML auxiliary lists and lists of attributes has
     to be excluded.

 -- Function: sxml:attr-list obj
     Returns the list of attributes for a given SXML node.  Empty list
     is returned if the given node is not an element, or if it has no
     list of attributes

 -- Function: sxml:id id-index
     Select SXML element by its unique IDs.  (XPath Rec. 4.1) Returns a
     converter that takes OBJECT, which is a nodeset or a datatype
     which can be converted to a string by means of a '`string''
     function.

     ID-INDEX is `( (id-value . element) (id-value . element) ... )'.

     This index is used for selection of an element by its unique ID.

   Comparators for XPath objects:

 -- Function: sxml:equality-cmp bool-op number-op string-op
     A helper for XPath equality operations: `=' , `!=' BOOL-OP,
     NUMBER-OP and 'STRING-OP are comparison operations for a pair of
     booleans,  numbers and strings respectively.

 -- Function: sxml:equal? a b
 -- Function: sxml:not-equal? a b
     Counterparts of XPath equality operations: `=' , `!=', using
     default equality tests.

 -- Function: sxml:relational-cmp op
     Creates a relational operation ( `<' , `>' , `<=' , `>=' ) for two
     XPath objects.  `op' is comparison procedure: `<' , `>' , `<=' or
     `>='.

   XPath axises.  An order in resulting nodeset is preserved.

 -- Function: sxml:attribute test-pred?
     Attribute axis.

 -- Function: sxml:child test-pred?
     Child axis.  This function is similar to '`select-kids'', but it
     returns an empty child-list for PI, Comment and Entity nodes.

 -- Function: sxml:parent test-pred?
     Parent axis.

     Given a predicate, it returns a function `RootNode -> Converter'
     which yields a ` node -> parent ' converter then applied to a
     rootnode.

     Thus, such a converter may be constructed using ` ((sxml:parent
     test-pred) rootnode) ' and returns a parent of a node it is
     applied to.  If applied to a nodeset, it returns the list of
     parents of nodes in the nodeset. The rootnode does not have to be
     the root node of the whole SXML tree - it may be a root node of a
     branch of interest.  The `parent::' axis can be used with any SXML
     node.

 -- Function: sxml:ancestor test-pred?
     Ancestor axis

 -- Function: sxml:ancestor-or-self test-pred?
     Ancestor-or-self axis

 -- Function: sxml:descendant test-pred?
     Descendant axis

 -- Function: sxml:descendant-or-self test-pred?
     Descendant-or-self axis

 -- Function: sxml:following test-pred?
     Following axis

 -- Function: sxml:following-sibling test-pred?
     Following-sibling axis

 -- Function: sxml:namespace test-pred?
     Namespace axis

 -- Function: sxml:preceding test-pred?
     Preceding axis

 -- Function: sxml:preceding-sibling test-pred?
     Preceding-sibling axis

   Popular shortcuts:

 -- Function: sxml:child-nodes nodeset
          ((sxml:child sxml:node?) nodeset)

 -- Function: sxml:child-elements nodeset
          ((select-kids sxml:element?) nodeset)


File: gauche-refe.info,  Node: Manipulating SXML structure,  Next: Serializing XML and HTML from SXML,  Prev: SXML Query Language,  Up: Library modules - Utilities

11.31 `sxml.tools' - Manipulating SXML structure
================================================

 -- Module: sxml.tools
     This module is a port of Kirill Lisofsky's sxml-tools, a
     collection of convenient procedures that work on SXML structure.
     The current version is derived from sxml-tools CVS revision 3.13.

     The manual entry is mainly derived from the comments in the
     original source code.

* Menu:

* SXML predicates::
* SXML accessors::
* SXML modifiers::
* SXPath auxiliary utilities::
* SXML to markup conversion::


File: gauche-refe.info,  Node: SXML predicates,  Next: SXML accessors,  Prev: Manipulating SXML structure,  Up: Manipulating SXML structure

11.31.1 SXML predicates
-----------------------

 -- Function: sxml:empty-element? obj
     A predicate which returns #T if given element OBJ is empty.  Empty
     element has no nested elements, text nodes, `PI's, Comments or
     entities but it may contain attributes or namespace-id.  It is a
     SXML counterpart of XML `empty-element'.

 -- Function: sxml:shallow-normalized? obj
     Returns `#t' if the given OBJ is shallow-normalized SXML element.
     The element itself has to be normalized but its nested elements
     are not tested.

 -- Function: sxml:normalized? obj
     Returns `#t' if the given OBJ is normalized SXML element.  The
     element itself and all its nested elements have to be normalised.

 -- Function: sxml:shallow-minimized? obj
     Returns `#t' if the given OBJ is shallow-minimized SXML element.
     The element itself has to be minimised but its nested elements are
     not tested.

 -- Function: sxml:minimized? obj
     Returns `#t' if the given OBJ is minimized SXML element.  The
     element itself and all its nested elements have to be minimised.


File: gauche-refe.info,  Node: SXML accessors,  Next: SXML modifiers,  Prev: SXML predicates,  Up: Manipulating SXML structure

11.31.2 SXML accessors
----------------------

 -- Function: sxml:name obj
     Returns a name of a given SXML node.  It's just an alias of `car',
     but introduced for the sake of encapsulation.

 -- Function: sxml:element-name obj
     A version of `sxml:name', which returns `#f' if the given OBJ is
     not a SXML element.  Otherwise returns its name.

 -- Function: sxml:node-name obj
     Safe version of `sxml:name', which returns `#f' if the given OBJ
     is not a SXML node.  Otherwise returns its name.

 -- Function: sxml:ncname obj
     Returns Local Part of Qualified Name (Namespaces in XML production
     [6]) for given obj, which is "`:'"-separated suffix of its
     Qualified Name.  If a name of a node given is `NCName' (Namespaces
     in XML production [4]), then it is returned as is.  Please note
     that while SXML name is a symbol this function returns a string.

 -- Function: sxml:name->ns-id sxml-name
     Returns namespace-id part of given name, or #F if it's LocalName

 -- Function: sxml:content obj
     Returns the content of given SXML element or nodeset (just text
     and element nodes) representing it as a list of strings and nested
     elements in document order.  This list is empty if OBJ is empty
     element or empty list.

 -- Function: sxml:content-raw obj
     Returns all the content of normalized SXML element except
     ATTR-LIST and AUX-LIST.  Thus it includes `PI', `COMMENT' and
     `ENTITY' nodes as well as `TEXT' and `ELEMENT' nodes returned by
     `sxml:content'.  Returns  a list of nodes in document order or
     empty list if OBJ is empty element or empty list.  This function
     is faster than `sxml:content'.

   In SXML normal form, an element is represented by a list as this:
       (NAME ATTR-LIST AUX-LIST CONTENT ...)
   where ATTR-LIST is a list beginning with `@', and AUX-LIST is a list
beginning with `@@'.

   In the minimized form, AUX-LIST can be omitted when it is empty.
ATTR-LIST can be omitted when it is empty _and_ AUX-LIST is absent.

   The following procedures extract ATTR-LIST and AUX-LIST.

 -- Function: sxml:attr-list-node obj
     Returns ATTR-LIST for a given OBJ, or `#f' if it is absent

 -- Function: sxml:attr-as-list obj
     Returns ATTR-LIST wrapped in list, or '`((@))' if it is absent and
     AUX-LIST is present, or '`()' if both lists are absent.

 -- Function: sxml:aux-list-node obj
     Returns AUX-LIST for a given OBJ, or `#f' if it is absent.

 -- Function: sxml:aux-as-list obj
     Returns AUX-LIST wrapped in list, or '`()' if it is absent.

 -- Function: sxml:attr-list-u obj
     Returns the list of attributes for given element or nodeset.
     Analog of `((sxpath '(@ *)) OBJ)'.  Empty list is returned if
     there is no list of attributes.

     The `-u' suffix indicates it can be used for non-normalized SXML
     node.  ('u' stands for 'universal').

 -- Function: sxml:aux-list obj
     Returns the list of auxiliary nodes for given element or nodeset.
     Analog of `((sxpath '(@@ *)) OBJ)'.  Empty list is returned if a
     list of auxiliary nodes is absent.

 -- Function: sxml:aux-list-u obj
     Returns the list of auxiliary nodes for given element or nodeset.
     Analog of `((sxpath '(@@ *)) OBJ)'.  Empty list is returned if a
     list of auxiliary nodes is absent.

     The `-u' suffix indicates it can be used for non-normalized SXML
     node.  ('u' stands for 'universal').

 -- Function: sxml:aux-node obj aux-name
     Return the first aux-node with AUX-NAME given in SXML element OBJ
     or `#f' is such a node is absent.  Note: it returns just the
     _first_ node found even if multiple nodes are present, so it's
     mostly intended for nodes with unique names .

 -- Function: sxml:aux-nodes obj aux-name
     Return a list of aux-node with AUX-NAME given in SXML element OBJ
     or '`()' if such a node is absent.

 -- Function: sxml:attr obj attr-name
     Accessor for an attribute ATTR-NAME of given SXML element OBJ.  It
     returns: the value of the attribute if the attribute is present, or
     #F if there is no such an attribute in the given element.

 -- Function: sxml:num-attr obj attr-name
     Accessor for a numerical attribute ATTR-NAME of given SXML element
     OBJ.  It returns: a value of the attribute as the attribute as a
     number if the attribute is present and its value may be converted
     to number using `string->number', or `#f' if there is no such an
     attribute in the given element or its value can't be converted to
     a number.

 -- Function: sxml:attr-u obj attr-name
     Accessor for an attribute ATTR-NAME of given SXML element OBJ which
     may also be an attributes-list or nodeset (usually content of SXML
     element).

     It returns: the value of the attribute if the attribute is present,
     or `#f' if there is no such an attribute in the given element.

     The `-u' suffix indicates it can be used for non-normalized SXML
     node.  ('u' stands for 'universal').

 -- Function: sxml:ns-list obj
     Returns the list of namespaces for given element.  Analog of
     `((sxpath '(@@ *NAMESPACES* *)) OBJ)' Empty list is returned if
     there is no list of namespaces.

 -- Function: sxml:ns-id->nodes obj namespace-id
     Returns the list of namespace-assoc's for given NAMESPACE-ID in
     SXML element OBJ.  Analog of `((sxpath '(@@ *NAMESPACES*
     namespace-id)) OBJ)'.  Empty list is returned if there is no
     namespace-assoc with NAMESPACE-ID given.

 -- Function: sxml:ns-id->uri obj namespace-id
     Returns a URI for NAMESPACE-ID given, or `#f' if there is no
     namespace-assoc with NAMESPACE-ID given.

 -- Function: sxml:ns-uri->id obj uri
     Returns a namespace-id for namespace URI given.

 -- Function: sxml:ns-id ns-assoc
     Returns namespace-id for given namespace-assoc list.

 -- Function: sxml:ns-uri ns-assoc
     Returns URI for given namespace-assoc list.

 -- Function: sxml:ns-prefix ns-assoc
     It returns namespace prefix for given namespace-assoc list.
     Original (as in XML document) prefix for namespace-id given has to
     be strored as the third element in namespace-assoc list if it is
     different from namespace-id.  If original prefix is omitted in
     namespace-assoc then namespace-id is used instead.


File: gauche-refe.info,  Node: SXML modifiers,  Next: SXPath auxiliary utilities,  Prev: SXML accessors,  Up: Manipulating SXML structure

11.31.3 SXML modifiers
----------------------

Constructors and mutators for normalized SXML data.  These functions
are optimized for normalized SXML data.  They are not applicable to
arbitrary non-normalized SXML data.

   Most of the functions are provided in two variants:
  1. side-effect intended functions for linear update of given elements.
     Their names are ended with exclamation mark.  Note that the
     returned value of this variant is unspecified, unless explicitly
     noted.  An example: `sxml:change-content!'.

  2. pure functions without side-effects which return modified elements.
     An example: `sxml:change-content'.

 -- Function: sxml:change-content obj new-content
 -- Function: sxml:change-content! obj new-content
     Change the content of given SXML element to NEW-CONTENT.  If
     NEW-CONTENT is an empty list then the OBJ is transformed to an
     empty element.  The resulting SXML element is normalized.

 -- Function: sxml:change-attrlist obj new-attrlist
 -- Function: sxml:change-attrlist! obj new-attrlist
     The resulting SXML element is normalized.  If NEW-ATTRLIST is
     empty, the cadr of OBJ is `(@)'.

 -- Function: sxml:change-name obj new-name
 -- Function: sxml:change-name! obj new-name
     Change a name of SXML element destructively.

 -- Function: sxml:add-attr obj attr
     Returns SXML element OBJ with attribute ATTR added, or `#f' if the
     attribute with given name already exists.  ATTR is `(ATTR-NAME
     ATTR-VALUE)'.  Pure functional counterpart to `sxml:add-attr!'.

 -- Function: sxml:add-attr! obj attr
     Add an attribute ATTR for an element OBJ.  Returns `#f' if the
     attribute with given name already exists.  The resulting SXML node
     is normalized.  Linear update counterpart to `sxml:add-attr'.

 -- Function: sxml:change-attr obj attr
     Returns SXML element OBJ with changed value of attribute ATTR, or
     `#f' if where is no attribute with given name.  ATTR is
     `(ATTR-NAME ATTR-VALUE)'.

 -- Function: sxml:change-attr! obj attr
     Change value of the attribute for element OBJ.  ATTR is
     `(ATTR-NAME ATTR-VALUE)'.  Returns `#f' if where is no such
     attribute.

 -- Function: sxml:set-attr obj attr
 -- Function: sxml:set-attr! obj attr
     Set attribute ATTR of element OBJ.  If there is no such attribute
     the new one is added.

 -- Function: sxml:add-aux obj aux-node
     Returns SXML element OBJ with an auxiliary node AUX-NODE added.

 -- Function: sxml:add-aux! obj aux-node
     Add an auxiliary node AUX-NODE for an element OBJ.

 -- Function: sxml:squeeze obj
 -- Function: sxml:squeeze! obj
     Eliminates empty lists of attributes and aux-lists for given SXML
     element OBJ and its descendants ("minimize" it).  Returns a
     minimized and normalized SXML element.

 -- Function: sxml:clean obj
     Eliminates empty lists of attributes and all aux-lists for given
     SXML element OBJ and its descendants.  Returns a minimized and
     normalized SXML element.


File: gauche-refe.info,  Node: SXPath auxiliary utilities,  Next: SXML to markup conversion,  Prev: SXML modifiers,  Up: Manipulating SXML structure

11.31.4 SXPath auxiliary utilities
----------------------------------

These are convenience utilities to extend SXPath functionalities.

 -- Function: sxml:add-parents obj . top-ptr
     Returns an SXML nodeset with a 'parent pointer' added.  A parent
     pointer is an aux node of the form `(*PARENT* THUNK)', where THUNK
     returns the parent element.

 -- Function: sxml:node-parent rootnode
     Returns a fast 'node-parent' function, i.e.  a function of one
     argument - SXML element - which returns its parent node using
     `*PARENT*' pointer in aux-list.  '`*TOP-PTR*' may be used as a
     pointer to root node.  It return an empty list when applyed to
     root node.

 -- Function: sxml:lookup id index
     Lookup an element using its ID.


File: gauche-refe.info,  Node: SXML to markup conversion,  Prev: SXPath auxiliary utilities,  Up: Manipulating SXML structure

11.31.5 SXML to markup conversion
---------------------------------

Procedures to generate XML or HTML marked up text from SXML.  For more
advanced conversion, see the SXML serializer (*note Serializing XML and
HTML from SXML::).

 -- Function: sxml:clean-feed . fragments
     Filter the 'fragments'.  The fragments are a list of strings,
     characters, numbers, thunks, `#f' - and other fragments.  The
     function traverses the tree depth-first, and returns a list of
     strings, characters and executed thunks, and ignores `#f' and
     '`()'.

     If all the meaningful fragments are strings, then (APPLY
     STRING-APPEND ... ) to a result of this function will return its
     string-value.

     It may be considered as a variant of Oleg Kiselyov's
     `SRV:send-reply': While `SRV:send-reply' displays fragments, this
     function returns the list of meaningful fragments and filter out
     the garbage.

 -- Function: sxml:attr->xml attr
     Creates the XML markup for attributes.

 -- Function: sxml:string->xml string
     Return a string or a list of strings where all the occurences of
     characters `<', `>', `&', `"', or `'' in a given string are
     replaced by corresponding character entity references. See also
     `sxml:string->html'.

 -- Function: sxml:sxml->xml tree
     A version of dispatch-node specialized and optimized for SXML->XML
     transformation.

 -- Function: sxml:attr->html attr
     Creates the HTML markup for attributes.

 -- Function: sxml:string->html string
     Given a string, check to make sure it does not contain characters
     <, >, &, " that require encoding.  See also `html-escape-string'
     in *note Simple HTML document construction::.

 -- Function: sxml:non-terminated-html-tag? tag
     This predicate yields `#t' for "non-terminated" HTML 4.0 tags.

 -- Function: sxml:sxml->html tree
     A version of dispatch-node specialized and optimized for SXML->HTML
     transformation.


File: gauche-refe.info,  Node: Serializing XML and HTML from SXML,  Next: CSV tables,  Prev: Manipulating SXML structure,  Up: Library modules - Utilities

11.32 `sxml.serializer' -  Serializing XML and HTML from SXML
=============================================================

 -- Module: sxml.serializer
     This module contains a full-featured serializer from SXML into XML
     and HTML, partially conforming to XSLT 2.0 and XQuery 1.0
     Serialization
     (`http://www.w3.org/TR/2005/CR-xslt-xquery-serialization-20051103/').
     It's more powerful than sxml:sxml->xml and sxml:sxml->html from
     sxml.tools.

     The manual entry is mainly derived from the comments in the
     original source code.

* Menu:

* Simple SXML serializing::
* Custom SXML serializing::


File: gauche-refe.info,  Node: Simple SXML serializing,  Next: Custom SXML serializing,  Prev: Serializing XML and HTML from SXML,  Up: Serializing XML and HTML from SXML

11.32.1 Simple SXML serializing
-------------------------------

The SXML serializer provides some convenient high-level converters which
should be enough for most tasks.

 -- Function: srl:sxml->xml sxml-obj &optional port-or-filename
     Serializes the SXML-OBJ into XML, with indentation to facilitate
     readability by a human.

     If PORT-OR-FILENAME is not supplied, the functions return a string
     that contains the serialized representation of the SXML-OBJ.

     If PORT-OR-FILENAME is supplied and is a port, the functions write
     the serialized representation of SXML-OBJ to this port and return
     an unspecified result.

     If PORT-OR-FILENAME is supplied and is a string, this string is
     treated as an output filename, the serialized representation of
     SXML-OBJ is written to that filename and an unspecified result is
     returned. If a file with the given name already exists, the effect
     is unspecified.

 -- Function: srl:sxml->xml-noindent sxml-obj &optional port-or-filename
     Serializes the SXML-OBJ into XML, without indentation.

     Argument PORT-OR-FILENAME works like described in `srl:sxml->xml'.

 -- Function: srl:sxml->html sxml-obj &optional port-or-filename
     Serializes the SXML-OBJ into HTML, with indentation to facilitate
     readability by a human.

     Argument PORT-OR-FILENAME works like described in `srl:sxml->xml'.

 -- Function: srl:sxml->html-noindent sxml-obj &optional
          port-or-filename
     Serializes the SXML-OBJ into HTML, without indentation.

     Argument PORT-OR-FILENAME works like described in `srl:sxml->xml'.


File: gauche-refe.info,  Node: Custom SXML serializing,  Prev: Simple SXML serializing,  Up: Serializing XML and HTML from SXML

11.32.2 Custom SXML serializing
-------------------------------

These functions provide full access to all configuration parameters of
the XML serializer.

 -- Function: srl:parameterizable sxml-obj &optional port-or-filename
          params*
     Generalized serialization procedure, parameterizable with all the
     serialization parameters supported by this implementation.

     SXML-OBJ - an SXML object to serialize

     PORT-OR-FILENAME - either `#f', a port or a string; works like in
     srl:sxml->xml (*note Simple SXML serializing::).

     PARAMS - each parameter is a cons of param-name (a symbol) and
     param-value.  The available parameter names and their values are
     described below:

     `method' - Either the symbol `xml' or `html'.  For a detailed
     explanation of the difference between XML and HTML methods, see
     XSLT 2.0 and XQuery 1.0 Serialization
     (`http://www.w3.org/TR/2005/CR-xslt-xquery-serialization-20051103/').

     `indent' - Whether the output XML should include whitespace for
     human readability (`#t' or `#f').  You can also supply a string,
     which will be used as the indentation unit.

     `omit-xml-declaration?' - Whether the XML declaration should be
     omitted.  Default: `#t'.

     `standalone' - Whether to define the XML document as standalone in
     the XML declaration.  Should be one of the symbols `yes', `no' or
     `omit', the later causing standalone declaration to be supressed.
     Default: `omit'.

     `version' - The XML version used in the declaration.  A string or
     a number.  Default: `"1.0"'.

     `cdata-section-elements' - A list of SXML element names (as
     symbols).  The contents of those elements will be escaped as CDATA
     sections.

     `ns-prefix-assig' - A list of `(cons prefix namespace-uri)', where
     each `prefix' is a symbol and each `namespace-uri' a string.  Will
     serialize the given namespaces with the corresponding prefixes.
     ATTENTION: If a parameter name is unexpected or a parameter value
     is ill-formed, the parameter is silently ignored!

     Example usage:

          (srl:parameterizable
            '(tag (@ (attr "value")) (nested "text node") (empty))
            (current-output-port)
            '(method . xml)  ; XML output method is used by default
            '(indent . "\t")  ; use a single tabulation to indent
            '(omit-xml-declaration . #f)  ; add XML declaration
            '(standalone . yes)  ; denote a standalone XML document
            '(version . "1.0"))  ; XML version

          param ::= (cons param-name param-value)
          param-name ::= symbol

          cdata-section-elements
          value ::= (listof sxml-elem-name)
          sxml-elem-name ::= symbol

          indent
          value ::= 'yes | #t | 'no | #f | whitespace-string

          method
          value ::= 'xml | 'html

          ns-prefix-assig
          value ::= (listof (cons prefix namespace-uri))
          prefix ::= symbol
          namespace-uri ::= string

          omit-xml-declaration?
          value ::= 'yes | #t | 'no | #f

          standalone
          value ::= 'yes | #t | 'no | #f | 'omit

          version
          value ::= string | number

 -- Function: srl:sxml->string sxml-obj cdata-section-elements indent
          method ns-prefix-assig omit-xml-declaration? standalone
          version
     Same as `srl:parameterizable' returning a string and without the
     overhead of parsing parameters.  This function interface may
     change in future versions of the library.

 -- Function: srl:display-sxml sxml->obj port-or-filename
          cdata-section-elements indent method ns-prefix-assig
          omit-xml-declaration? standalone version
     Same as `srl:parameterizable' writing output to PORT-OR-FILENAME
     and without the overhead of parsing parameters.  This function
     interface may change in future versions of the library.


File: gauche-refe.info,  Node: CSV tables,  Next: Calculate difference of text streams,  Prev: Serializing XML and HTML from SXML,  Up: Library modules - Utilities

11.33 `text.csv' - CSV tables
=============================

 -- Module: text.csv
     Provides a function to parse/generate CSV (comma separated value)
     tables, including the format defined in RFC4180.  You can
     customize the separator and quoter character to deal with
     variations of CSV formats.

     CSV table is consisted by a series of RECORDS, separated by a
     newline.  Each record contains number of FIELDS, separated by a
     separator character (by default, a comma).  A field can contain
     comma or newline if quoted, i.e. surrounded by double-quote
     characters.  To include double-quote character in a quoted field,
     use two consecutive double-quote character.   Usually, the
     whitespaces around the field are ignored.


   Right now, the following two low-level procedures are exported.  A
plan is to provide higher features, such as labelling fields and
automatic conversions.

 -- Function: make-csv-reader separator &optional (quote-char #\")
     Returns a procedure with one argument, input port.  When the
     procedure is called, it reads one record from the port, and
     returns a list of fields.  If input reaches EOF, it returns EOF.

 -- Function: make-csv-writer separator &optional newline (quote-char
          #\")
     Returns a procedure with two arguments, output port and a list of
     fields.  When the procedure is called, it outputs a
     SEPARATOR-separated fields with proper escapes, to the output
     port.   You can also specify the record delimiter string by
     NEWLINE; for example, you can pass `"\r\n"' to prepare a file to
     be read by Windows programs.


File: gauche-refe.info,  Node: Calculate difference of text streams,  Next: Localized messages,  Prev: CSV tables,  Up: Library modules - Utilities

11.34 `text.diff' - Calculate difference of text streams
========================================================

 -- Module: text.diff
     This module calculates the difference of two text streams or
     strings, using `util.lcs' (*Note The longest common subsequence::).

 -- Function: diff src-a src-b &keyword reader eq-fn
     Generates an "edit list" from text sources SRC-A and SRC-B.

     Each of text sources, SRC-A and SRC-B, can be either an input port
     or a string.  If it is a string, it is converted to a string input
     port internally.  Then, the text streams from both sources are
     converted to sequences by calling READER repeatedly on them; the
     default of READER is `read-line', and those sequences are passed
     to `lcs-edit-list' to calculate the edit list.  The equality
     function EQ-FN is also passed to `lcs-edit-list'.

     An edit list is a set of commands that turn the text sequence from
     `src-a' to the one from `src-b'.  See the description of
     `lcs-edit-list' for the detailed explanation of the edit list.

          (diff "a\nb\nc\nd\n" "b\ne\nd\nf\n")
          =>
            (((- 0 "a"))
             ((- 2 "c") (+ 1 "e"))
             ((+ 3 "f")))

 -- Function: diff-report src-a src-b &keyword reader eq-fn writer
     A convenience procedure to take the diff of two text sources and
     display the result nicely.  This procedure calls `lcs-fold' to
     calculate the difference of two text sources.  The meanings of
     SRC-A, SRC-B, READER and EQ-FN are the same as `diff''s.

     WRITER is a procedure that takes two arguments, the text element
     and a type, which is either a symbol `+', a symbol `-', or `#f'.
     If the text element is only in SRC-A, WRITER is called with the
     element and `-'.  If the text element is only in SRC-B, it is
     called with the element and `+'.  If the text element is in both
     sources, it is called with the element and `#f'.   The default
     procedure of WRITER prints the passed text element to the current
     output port in unified-diff-like format:
          (diff-report "a\nb\nc\nd\n" "b\ne\nd\nf\n")
     displays:
          - a
            b
          - c
          + e
            d
          + f


File: gauche-refe.info,  Node: Localized messages,  Next: Simple HTML document construction,  Prev: Calculate difference of text streams,  Up: Library modules - Utilities

11.35 `text.gettext' - Localized messages
=========================================

 -- Module: text.gettext
     This module provides utilities to deal with localized messages.
     The API is compatible to GNU's gettext, and the messages are read
     from `*.po' and `*.mo' files, so that you can use the GNU gettext
     toolchain to prepare localized messages.  However, the code is
     written from scratch by Alex Shinn and doesn't depend on GNU's
     gettext library.

     This implementation extends GNU's gettext API in the following
     ways:
        * It can read from multiple message files in cascaded way,
          allowing applications to share a part of message files.

        * It supports multiple locale/domain simultaneously.

     SRFI-29 (*Note Localization::) provides another means of message
     localization.  A portable program may wish to use srfi-29, but
     generally `text.gettext' is recommended in Gauche scripts because
     of its flexibility and compatibility to existing message files.

Gettext-compatible API
----------------------

 -- Function: textdomain domain-name &optional locale dirs cdir cached?
          lookup-cached?
     Sets up the default domain and other parameters for the
     application.  The setting affects to the following `gettext' call.

     DOMAIN is a string or list of strings specifying the domain (name
     of `.mo' or `.po' files) as in C gettext.  You can pass `#f' as
     DOMAIN-NAME just to get the default domain accessor procedure.
     You can alo pass multiple domains to DOMAIN-NAME.
          (textdomain '("myapp" "gimp"))  ; search 1st myapp, then gimp
          (gettext "/File/Close")         ; "Close" from gimp unless overridden

     LOCALE is a string or list of strings in the standard Unix format
     of `LANG[_REGION][.ENCODING]'.  You can also pass a list of locales
     to specify fallbacks.

          (textdomain "myapp" '("ru" "uk"))  ; search 1st Russian then Ukranian,
          (gettext "Hello, World!")          ; which are somewhat similar

     DIRS is the search path of directories which should hold the
     `LOCALE/CDIR/' directories which contain the actual message
     catalogs.  This is always appended with the system default, e.g.
     `"/usr/share/locale"', and may also inherit from the
     `GETTEXT_PATH' colon-delimited environment variable.

     CDIR is the category directory, defaulting to either the
     `LC_CATEGORY' environment variable or the appropriate system
     default (e.g. `LC_MESSAGES').  You generally won't need this.

     CACHED?  means to cache individual messages, and defaults to `#t'.

     LOOKUP-CACHED?  means to cache the lookup dispatch generated by
     these parameters, and defaults to `#t'.

     `Textdomain' just passes these parameters to the internal
     `make-gettext', and binds the result to the global dispatch used
     by `gettext'.  You may build these closures manually for
     convenience in using multiple separate domains or locales at once
     (useful for server environments).  See the description of
     `make-gettext' below.

     `Textdomain' returns an _accessor procedure_ which packages
     information of the domain.  See `make-gettext' below for the
     details.

 -- Function: gettext msg-id
     Returns a translated message of MSG-ID.  If there's no translated
     message, MSG-ID itself is returned.

 -- Function: ngettext msg-id &optional msg-id2 num
     Similar to GETTEXT, but it can be used to handle plural forms.
     Pass a singular form to MSG-ID, and plural form to `msg-id2'.  The
     NUM argument is used to determine the plural form.  If no message
     catalog is found, MSG-ID is returned when NUM is 1, and MSG-ID2
     otherwise.

 -- Function: bindtextdomain domain dirs
     Sets the search path of domain DOMAIN to DIRS, which may be just a
     single directory name or a list of directory names.

 -- Function: dgettext domain msg-id
 -- Function: dcgettext domain msg-id locale
     Returns a translated message of MSG-ID in DOMAIN.  `Dcgettext'
     takes LOCALE as well.

Low-level flexible API
----------------------

The following procedure is more flexible interface, on top of which the
gettext-compatible APIs are written.

 -- Function: make-gettext &optional domain locale dirs gettext-cached?
          lookup-cached?
     Creates and returns an _accessor procedure_, which encapsulates
     methods to retrieve localized messages.

     The meaning of arguments are the same as `textdomain' above.
     Indeed, `textdomain' just calls `make-gettext', and later it binds
     the result to the global parameter.   If you wish to have multiple
     independent domains within a single program, you can call
     `make-gettext' directly and manage the created accessor procedure
     by yourself.

          (define my-gettext (make-gettex "myapp"))
          (define (_ (my-gettext 'getter)))
          (_ "Hello, World!")


File: gauche-refe.info,  Node: Simple HTML document construction,  Next: Parsing input stream,  Prev: Localized messages,  Up: Library modules - Utilities

11.36 `text.html-lite' - Simple HTML document construction
==========================================================

 -- Module: text.html-lite
     Provides procedures to construct an HTML document easily.  For
     example, you can construct an HTML table by the following code:
          (html:table
            (html:tr (html:th "Item No") (html:th "Quantity"))
            (html:tr (html:td 1) (html:td 120))
            (html:tr (html:td 2) (html:td 30))
            (html:tr (html:td 3) (html:td 215)))
     See the description of `html:ELEMENT' below for details.

     This module does little check for the constructed html documents,
     such as whether the attributes are valid, and whether the content
     of the element matches DTD.  It does not provide a feature to parse
     the html document neither.  Hence the name `lite'.

 -- Function: html-escape
 -- Function: html-escape-string string
     Escapes the "unsafe" characters in HTML.  `html-escape' reads
     input string from the current input port and writes the result to
     the current output port.   `html-escape-string' takes the input
     from STRING and returns the result in a string.

 -- Function: html-doctype &keyword type
     Returns a doctype declaration for an HTML document.  TYPE can be
     either one of the followings (default is `:html-4.01-strict').
    `:html-4.01-strict, :html-4.01, :strict'
          HTML 4.01 Strict DTD

    `:html-4.01-transitional, :transitional'
          HTML 4.01 Transitional DTD

    `:html-4.01-frameset, :frameset'
          HTML 4.01 Frameset DTD

    `:xhtml-1.0-strict, :xhtml-1.0'
          XHTML 1.0 Strict DTD

    `:xhtml-1.0-transitional'
          XHTML 1.0 Transitional DTD

    `:xhtml-1.0-frameset'
          XHTML 1.0 Frameset DTD

    `:xhtml-1.1'
          XHTML 1.1 DTD

 -- Function: html:ELEMENT ARGS ...
     Construct an HTML element ELEMENT.  Right now, the following
     elements are provided.  (The elements defined in HTML 4.01 DTD,
     `http://www.w3.org/TR/html4/sgml/dtd.html').
          a        abbr       acronym    address     area      b
          base     bdo        big        blockquote  body      br
          button   caption    cite       code        col       colgroup
          dd       del        dfn        div         dl        dt
          em       fieldset   form       frame       frameset
          h1       h2         h3         h4          h5        h6
          head     hr         html       i           iframe    img
          input    ins        kbd        label       legend    li
          link     map        meta       nofrmaes    noscript  object
          ol       optgroup   option     p           param     pre
          q        samp       script     select      small     span
          strong   style      sub        sup         table     tbody
          td       textarea   tfoot      th          thead     title
          tr       tt         ul         var

     The result of these functions is a tree of text segments, which
     can be written out to a port by `write-tree' or can be converted
     to a string by `tree->string' (*Note Lazy text construction::).

     You can specify attributes of the element by using a keyword-value
     notation before the actual content.
          (tree->string (html:a :href "http://foo/bar" "foobar"))
            =>
            "<a href=\"http://foo/bar\">foobar</a\n>"

          (tree->string
            (html:table :width "100%" :cellpading 0 "content here"))
            =>
            "<table width=\"100%\" cellpadding=\"0\">content here</table\n>"

     The boolean value given to the attribute has a special meaning.
     If `#t' is given, the attribute is rendered without a value.  If
     `#f' is given, the attribute is not rendered.
          (tree->string (html:table :border #t))
            => "<table border></table\n>"

          (tree->string (html:table :border #f))
            => "<table></table\n>"

     Special characters in attribute values are escaped by the function,
     but the ones in the content are not.  It is caller's responsibility
     to escape them.

     The functions signal an error if a content is given to the HTML
     element that doesn't take a content.   They do not check if the
     given attribute is valid, neither if the given content is valid
     for the element.

     _Note:_ You might have noticed that these procedures insert a
     newline before `>' of the closing tag.  That is, the rendered HTML
     would look like this:

          <table><tr><td>foo</td
          ><td>bar</td
          ></tr
          ></table
          >

     We intentionally avoid inserting newlines after the closing tag,
     since _it depends on the surrounding context whether the newline
     is significant or not_.  We may be able to insert newlines after
     the elements directly below a `<head>' element, for example, but
     we cannot in a `<p>' element.

     There are three possible solutions: (1) not to insert newlines at
     all, (2) to insert newlines within tags, and (3) to insert
     newlines only at the safe position.  The first one creates one
     long line of HTML, and although it is still valid HTML, it is
     inconvenient to handle it with line-oriented tools.  The third one
     requires the rendering routine to be aware of DTD.  So we took the
     second approach.


File: gauche-refe.info,  Node: Parsing input stream,  Next: Showing progress on text terminals,  Prev: Simple HTML document construction,  Up: Library modules - Utilities

11.37 `text.parse' - Parsing input stream
=========================================

 -- Module: text.parse
     A collection of utilities that does simple parsing from the input
     port.   The API is inspired, and compatible with Oleg Kiselyov's
     input parsing library (*note OLEG1: oleg1.).  His library is used
     in lots of other libraries, notably, a full-Scheme XML
     parser/generator SSAX (*note SSAX: ssax.).

     You can use this module in place of his `input-parse.scm' and
     `look-for-str.scm'.

     I reimplemented the functions to be efficient on Gauche.
     Especially, usage of `string-set!' is totally avoided.  I extended
     the interface a bit so that they can deal with character sets and
     predicates, as well as a list of characters.

     These functions work sequentially on the given input port, that
     is, they read from the port as much as they need, without
     buffering extra characters.

 -- Function: find-string-from-port? str in-port &optional max-no-chars
     Looks for a string STR from the input port IN-PORT.  The optional
     argument MAX-NO-CHARS limits the maximum number of characters to
     be read from the port; if omitted, the search span is until EOF.

     If STR is found, this function returns the number of characters it
     has read.   The next read from IN-PORT returns the next char of
     STR.  If STR is not found, it returns `#f'.

     Note: Although this procedure has ``?'' in its name, it may return
     non-boolean value, contrary to the Scheme convention.

 -- Function: peek-next-char &optional port
     Discards the current character and peeks the next character from
     PORT.  Useful to look ahead one character.  If PORT is omitted,
     the current input port is used.

   In the following functions, CHAR-LIST refers to one of the
followings:
   * A character set.

   * A list of characters, character sets and/or symbol `*eof*'.
   That denotes a set of characters.  If a symbol `*eof*' is included,
the EOF condition is also included.  Without `*eof*', the EOF condition
is regarded as an error.

 -- Function: assert-curr-char char-list string &optional port
     Reads a character from PORT.  If it is included in CHAR-LIST,
     returns the character.  Otherwise, signals an error with a message
     containing STRING.  If PORT is omitted, the current input port is
     used.

 -- Function: skip-until char-list/number &optional port
     CHAR-LIST/NUMBER is either a char-list or a number.  If it is a
     number; it reads that many characters and returns `#f'.  If the
     input is not long enough, an error is signalled.  If
     CHAR-LIST/NUMBER is a char-list, it reads from PORT until it sees
     a character that belongs to the char-list.  Then the character is
     returned.  If PORT is omitted, the current input port is used.

 -- Function: skip-while char-list &optional port
     Reads from PORT until it sees a character that does not belong to
     CHAR-LIST.  The character remains in the stream.  If it reaches
     EOF, an EOF is returned.  If PORT is omitted, the current input
     port is used.

     This example skips whitespaces from input.  Next read from port
     returns the first non-whitespace character.
          (skip-while #[\s] port)

 -- Function: next-token prefix-char-list break-char-list &optional
          comment port
     Skips any number of characters in PREFIX-CHAR-LIST, then collects
     the characters until it sees BREAK-CHAR-LIST.  The collected
     characters are returned as a string.  The break character remains
     in the PORT.

     If the function encounters EOF and `*eof*' is not included in
     BREAK-CHAR-LIST, an error is signalled with COMMENT is included in
     the message.

 -- Function: next-token-of char-list/pred &optional port
     Reads and collects the characters as far as it belongs to
     CHAR-LIST/PRED, then returns them as a string.  The first
     character that doesn't belong to CHAR-LIST/PRED remains on the
     port.

     CHAR-LIST/PRED may be a char-list or a predicate that takes a
     character.   If it is a predicate, each character is passed to it,
     and the character is regarded to "belong to" CHAR-LIST/PRED when
     it returns a true value.

 -- Function: read-string n &optional port
     Reads up to N characters, collects them into a string, and returns
     it.  If the input stream contains less characters, the returns
     string contains as many characters available.


File: gauche-refe.info,  Node: Showing progress on text terminals,  Next: SQL parsing and construction,  Prev: Parsing input stream,  Up: Library modules - Utilities

11.38 `text.progress' - Showing progress on text terminals
==========================================================

 -- Module: text.progress
     This module provides a utility to report a progress of processing
     on a text terminal, using characters to display bar chart.  The
     generic format of a progress bar consists of a single line of
     text, which is splitted into several parts; a header, which
     displays the title; followed by a bar, a numeric part, and a time
     part, as shown in the followig example (only the line beginning
     with "foo" is actually displayed).
          <-header-> <-------bar---------> <-num-><-time->      <---info---->
          foo       |#############        |123/211   01:21 ETA  compiling...
                    ^
                    separator

     Various things like the character used in the bar chart or the
     format of the numeric progress can be configured.

     Internally a progress bar maintains two numbers, the maximum (goal)
     value and the current value.  The bar shows the proportion of the
     current value relative to the maximum value.  The numeric progress
     shows the current value over the maximum value by default, but you
     can configure it to show only the current value or percentage, for
     example.

     A progress bar also has two states, "in progress" and "finished".
     When it is in progress, every time the text is displayed it is
     followed by `#\return', so that the next display overwrites the
     bar, and the time part shows ETA (estimated time of arrival).
     Once it becomes finished, the last line of text is displayed with
     `#\newline', and the time part shows the actual time it took to
     finish.

   This module provides only one procedure, `make-text-progress-bar',
which packages the progress bar feature in a closure and returns it.

 -- Function: make-text-progress-bar &keyword header header-width
          bar-char bar-width num-width num-format time-width info
          info-width separator-char max-value port
     Returns a procedure that packages operations on the progress bar.
     The procedure can be called with a symbol indicating an operation,
     and an optional numeric argument.

    `PROC 'show'
          Redisplays the progress bar.  All other operations implies
          redisplay, so you don't need to use this unless you have a
          specific reason to redisplay the current state.

    `PROC 'set VALUE'
          Sets the current value to VALUE, then redisplays the progress
          bar.  If VALUE exceeds the max value, it is clipped by the
          max value.

    `PROC 'inc VALUE'
          Increments the current value by VALUE, then redisplays the
          progress bar.  If the current value exceeds the max value, it
          is clipped by the max value.

    `PROC 'finish'
          Puts the progress bar to the "finished" state, then
          redisplays it.  The time part shows the total elapsed time,
          and the line is terminated by `#\newline' so that it won't be
          clobbered.   Once a progress bar becomes "finished", there's
          no way to put it back "in progress".

    `PROC 'set-info TEXT'
          Changes the text displayed in the "info" part.  To use the
          info part, you have to give a positive value to INFO-WIDTH
          keyword argument of `make-text-progress-bar'.

    `PROC 'set-header TEXT'
          Changes the text displayed in the "header' area.

     The keyword arguments are used to customize the display:
    HEADER
          The text to be displayed in the header part.  This can be
          changed later, by sending `set-header' message to the created
          progress bar.

    HEADER-WIDTH
          The width of the header part, in number of characters.  The
          header text is displayed left-aligned in the part.  If the
          header text is longer than the width, the excess characters
          are omitted.  The default is 14.

    BAR-CHAR
          A character used to draw a bar chart.  The default is `#\#'.

    BAR-WIDTH
          The width of the bar chart part, in number of characters.
          The default is 40.

    NUM-WIDTH
          The width of the numeric part, in number of characters.  The
          default is 9.  Setting this to 0 hides the numeric part.

    NUM-FORMAT
          A procedure to format the numeric part.  Two arguments are
          passed; the current value and the maximum value.  It must
          return a string.  The default is the following procedure.
               (lambda (cur max)
                 (format "~d/~d" cur max))

    TIME-WIDTH
          The width of the time part, in number of characters.  The
          default is 7.  Settings this to 0 hides the time part.

    INFO
          The text to be displayed in the info part.  This text can be
          changed later by sending `set-info' message to the created
          progress bar.  Note that you have to give a positive number
          to INFO-WIDTH keyword argument to enable the info part.

    INFO-WIDTH
          The width of the info part.  The default value is zero, which
          means the info part is not displayed.

    SEPARATOR-CHAR
          A character put around the bar part.  Default is `#\|'.  You
          can pass `#f' not to display the separators.

    MAX-VALUE
          The maximum value of the progress bar.  Default is 100.

    PORT
          An output port to which the progress bar is displayed.  The
          default value is the current output port when
          `make-text-progress-bar' is called.

   Here's a simple example, using customized numeric part:

     (use text.progress)

     (define (main args)
       (define (num-format cur max)
         (format "~d/~d(~3d%)" cur max
                 (round->exact (/. (* cur 100) max))))

       (let ((p (make-text-progress-bar :header "Example"
                                        :header-width 10
                                        :bar-char #\o
                                        :num-format num-format
                                        :num-width 13
                                        :max-value 256)))
         (do ((i 0 (+ i 1)))
             ((= i 256) (p 'finish))
           (p 'inc 1)
           (sys-select #f #f #f 50000))))


File: gauche-refe.info,  Node: SQL parsing and construction,  Next: Transliterate characters,  Prev: Showing progress on text terminals,  Up: Library modules - Utilities

11.39 `text.sql' - SQL parsing and construction
===============================================

 -- Module: text.sql
     This module provides a utility to parse and construct SQL
     statement.

     It is currently under development, and we only have a tokenization
     routine.  The plan is to define S-expression syntax of SQL and
     provides a routine to translate one form to the other.

     Note: If you're looking for a routine to escape strings to be safe
     in SQL, see `dbi-escape-sql' in *note DBI user API::.

 -- Function: sql-tokenize sql-string
     Tokenize a SQL statement SQL-STRING.  The return value is a list
     of tokens, where each token is represented by one of the following
     forms.

          <symbol>              Special delimiter.  One of the followings:
                                + - * / < = > <> <= >= ||
          <character>           Special delimiter.  One of the followings:
                                #\, #\. #\( #\) #\;
          <string>              Regular identifier
          (delimited <string>)  Delimited identifier
          (parameter <num>)     Positional parameter (?)
          (parameter <string>)  Named parameter (:foo)
          (string    <string>)  Character string literal
          (number    <string>)  Numeric literal
          (bitstring <string>)  Binary string.  <string> is like "01101"
          (hexstring <string>)  Binary string.  <string> is like "3AD20"

     If it encounters an untokenizable string, it raises an
     `<sql-parse-error>' condition.

 -- Condition Type: <sql-parse-error>
     A condition to indicate an SQL parse error.  Inherits `<error>'.

      -- Instance Variable of <sql-parse-error>: sql-string
          Holds the source SQL string.


File: gauche-refe.info,  Node: Transliterate characters,  Next: Lazy text construction,  Prev: SQL parsing and construction,  Up: Library modules - Utilities

11.40 `text.tr' - Transliterate characters
==========================================

 -- Module: text.tr
     This module implements a transliterate function, that substitutes
     characters of the input string.  This functionality is realized in
     Unix `tr(1)' command, and incorporated in various programs such as
     `sed(1)' and `perl'.

     Gauche's `tr' is aware of multibyte characters.

 -- Function: tr from-list to-list &keyword :complement :delete
          :squeeze :table-size :input :output
     Reads from INPUT and writes to OUTPUT, with transliterating
     characters in FROM-LIST to the corresponding ones in TO-LIST.
     Characters that doesn't appear in FROM-LIST are passed through.

     The default values of INPUT and OUTPUT are current input port and
     current output port, respectively.

     Both FROM-LIST and TO-LIST must be strings.  They may contain the
     following special syntax.  Other characters that doesn't fits in
     the syntax are taken as they are.

    `x-y'
          Expanded to the increasing sequence of characters from `x' to
          `y', inclusive.  The order is determined by the internal
          character encoding system; generally it is safer to limit use
          of this within the range of the same character class.   The
          character `x' must be before `y'.

    `x*n'
          Repeat `x' for `n' times.  `n' is a decimal number notation.
          Meaningful only in TO-LIST; it is an error to use this form
          in FROM-LIST.  If `n' is omitted or zero, `x' is repeated
          until TO-LIST matches the length of FROM-LIST (any character
          after it is ignored).

    ``\'x'
          Represents `x' itself.  Use this escape to avoid a special
          character to be interpreted as itself.   Note that if you
          place a backslash in a string, you must write `\\', for the
          Scheme reader also interprets backslash as a special
          character.

          There's no special sequence to represent non-graphical
          characters, for you can put such characters by the string
          syntax.

     Here's some basic examples.
          ;; swaps case of input
          (tr "A-Za-z" "a-zA-Z")

          ;; replaces 7-bit non-graphical characters to `?'
          (tr "\x00-\x19\x7f" "?*")

     If TO-LIST is shorter than FROM-LIST, the behavior depends on the
     keyword argument DELETE.  If a true value is given,  characters
     that appear in FROM-LIST but not in TO-LIST are deleted.
     Otherwise, the extra characters in FROM-LIST are just passed
     through.

     When a true value is specified to COMPLEMENT, the character set in
     FROM-LIST is complemented.  Note that it implies _huge_ set of
     characters, so it is not very useful unless either output character
     set is a single character (using `*') or used with `delete'
     keyword.

     When a true value is specified to SQUEEZE, the sequence of the
     same replaced characters is squeezed to one.  If TO-LIST is empty,
     the sequence of the same characters in FROM-LIST is squeezed.

     Internally, `tr' builds a table to map the characters for
     efficiency.  Since Gauche can deal with potentially huge set of
     characters, it limits the use of the table for only smaller
     characters (<256 by default).  If you want to transliterate
     multibyte characters on the large text, however, you might want to
     use larger table, trading off the memory usage.  You can specify
     the internal table size by TABLE-SIZE keyword argument.  For
     example, if you transliterate lots of EUC-JP hiragana text to
     katakana, you may want to set table size greater than 42483 (the
     character code of the last katakana).

     Note that the pre-calculation to build the transliterate table
     needs some overhead.  If you want to call `tr' many times inside
     loop, consider to use `build-transliterator' described below.

 -- Function: string-tr string from-list to-list &keyword :complement
          :delete :squeeze :table-size
     Works like `tr', except that input is taken from a string STRING.

 -- Function: build-transliterator from-list to-list &keyword
          :complement :delete :squeeze :table-size :input :output
     Returns a procedure that does the actual transliteration.  This
     effectively "pre-compiles" the internal data structure.   If you
     want to run `tr' with the same sets repeatedly, you may build the
     procedure once and apply it repeatedly, saving the overhead of
     initialization.

     A note for an edge case: When INPUT and/or OUTPUT keyword
     arguments are omitted, the created transliterator is set up to use
     current-input-port and/or current-output-port at the time
     transliterator is called.

          (with-input-from-file "huge-file.txt"
            (lambda ()
              (let loop ((line (read-line)))
                (unless (eof-object? line) (tr "A-Za-z" "a-zA-Z")))))

          ;; runs more efficiently...

          (with-input-from-file "huge-file.txt"
            (lambda ()
              (let ((ptr (build-transliterator "A-Za-z" "a-zA-Z")))
                (let loop ((line (read-line)))
                  (unless (eof-object? line) (ptr))))))



File: gauche-refe.info,  Node: Lazy text construction,  Next: Combination library,  Prev: Transliterate characters,  Up: Library modules - Utilities

11.41 `text.tree' - Lazy text construction
==========================================

 -- Module: text.tree
     Defines simple but commonly used functions for a text construction.

     When you generate a text by a program, It is a very common
     operation to concatenate text segments.  However, using
     string-append repeatedly causes unnecessary copying of
     intermediate strings, and sometimes such intermediate strings are
     discarded due to the error situation (for example, think about
     constructing an HTML document in the CGI script).

     The efficient technique is to delay concatenation of those text
     segments until it is needed.  In Scheme it is done very easily by
     just consing the text segments together, thus forming a tree of
     text, and then traverse the tree to construct a text.  You can
     even directly writes out the text during traversal, avoiding
     intermediate string buffer.  (Hans Boehm's "cord" library, which
     comes with his garbage collector library, uses this technique and
     proves it is very efficient for editor-type application).

     Although the traversal of the tree can be written in a few lines
     of Scheme, I provide this module in the spirits of
     OnceAndOnlyOnce.   Also it's easier if we have a common interface.

 -- Generic Function: write-tree tree &optional out
     Writes out an TREE as a tree of text, to the output port OUT.  If
     OUT is omitted, the current output port is used.

     Two methods are defined for this generic function, as shown below.
     If you have more complex behavior, you can define more methods to
     customize the behavior.

 -- Method: write-tree ((tree <list>) out)
 -- Method: write-tree ((tree <top>) out)
     Default methods.  For a list, `write-tree' is recursively called
     for each element.  Any objects other than list is written out
     using `display'.

 -- Function: tree->string tree
     Just calls the `write-tree' method for TREE using an output string
     port, and returns the result string.


File: gauche-refe.info,  Node: Combination library,  Next: Message digester framework,  Prev: Lazy text construction,  Up: Library modules - Utilities

11.42 `util.combinations' - Combination library
===============================================

 -- Module: util.combinations
     This module implements several useful procedures of combinations,
     permutations and related operations.

     Most procedures in the module have two variants: a procedure
     without star (e.g. `permutations') treats all elements in the given
     set distinct, while a procedure with star (e.g. `permutations*')
     considers duplication.  The procedures with star take optional EQ
     argument that is used to test equality, which defaults to `eqv?'.

 -- Function: permutations set
 -- Function: permutations* set &optional eq
     Returns a list of all permutations of a list SET.

          (permutations '(a b c))
            => ((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))

          (permutations '(a a b))
            => ((a a b) (a b a) (a a b) (a b a) (b a a) (b a a))

          (permutations* '(a a b))
            => ((a a b) (a b a) (b a a))

     The number of possible permutations explodes if SET has more than
     several elements.  Use with care.  If you want to process each
     permutation at a time, consider `permutations-for-each' below.

 -- Function: permutations-for-each proc set
 -- Function: permutations*-for-each proc set &optional eq
     For each permutation of a list SET, calls PROC.  Returns an
     undefined value.

 -- Function: combinations set n
 -- Function: combinations* set n &optional eq
     Returns a list of all possible combinations of N elements out of a
     list SET.

          (combinations '(a b c) 2)
            => ((a b) (a c) (b c))

          (combinations '(a a b) 2)
            => ((a a) (a b) (a b))

          (combinations* '(a a b) 2)
            => ((a a) (a b))

     Watch out the explosion of combinations when SET is large.

 -- Function: combinations-for-each proc set n
 -- Function: combinations*-for-each proc set n &optional eq
     Calls PROC for each combination of N elements out of SET.  Returns
     an undefined value.

 -- Function: power-set set
 -- Function: power-set* set &optional eq
     Returns power set (all subsets) of a list SET.

          (power-set '(a b c))
            => (() (a) (b) (c) (a b) (a c) (b c) (a b c))

          (power-set* '(a a b)
            => (() (a) (b) (a a) (a b) (a a b))

 -- Function: power-set-for-each proc set
 -- Function: power-set*-for-each proc set &optional eq
     Calls PROC for each subset of SET.

 -- Function: power-set-binary set
     Returns power set of SET, like `power-set', but in different order.
     `Power-set-binary' traverses subset space in depth-first order,
     while `power-set' in breadth-first order.

          (power-set-binary '(a b c))
            => (() (c) (b) (b c) (a) (a c) (a b) (a b c))

 -- Function: cartesian-product list-of-sets
 -- Function: cartesian-product-right list-of-sets
     Returns a cartesian product of sets in LIST-OF-SETS.
     `Cartesian-product' construct the result in left fixed order (the
     rightmost element varies first), while `cartesian-product-right'
     in right fixed order (the leftmost element varies first).

          (cartesian-product '((a b c) (0 1)))
            => ((a 0) (a 1) (b 0) (b 1) (c 0) (c 1))

          (cartesian-product-right '((a b c) (0 1)))
            => ((a 0) (b 0) (c 0) (a 1) (b 1) (c 1))


File: gauche-refe.info,  Node: Message digester framework,  Next: Determine isomorphism,  Prev: Combination library,  Up: Library modules - Utilities

11.43 `util.digest' - Message digester framework
================================================

 -- Module: util.digest
     This module provides a base class and common interface for message
     digest algorithms, such as MD5 (*Note MD5 message digest::) and
     SHA (*Note SHA message digest::).

 -- Class: <message-digest-algorithm-meta>
     A metaclass of message digest algorithm implementation.

 -- Class: <message-digest-algorithm>
     A base class of message digest algorithm implementation.

   The concrete subclass of message digest algorithm has to implement
the following methods.

 -- Generic function: digest-update! algorithm data
     Takes the instance of massage-digest algorithm, and updates it
     with the data DATA, represented in a (possibly incomplete) string.

 -- Generic function: digest-final! algorithm
     Finalizes the instance of message-digest algorithm, and returns
     the digest result in an incomplete string.

 -- Generic function: digest class
     A wrapper of digest routines.  Given message-digest algorithm
     CLASS, this function reads the input data from current input port
     until EOF, and returns the digest result in an incomplete string.

 -- Generic function: digest-string class string
     A wrapper of digest routines.  Given message-digest algorithm
     CLASS, this function reads the input data from STRING, and returns
     the digest result in an incomplete string.

 -- Function: digest-hexify digest-result
     An utility procedure.  Given the result of digest, DIGEST-RESULT,
     converts it to a hexified string.


File: gauche-refe.info,  Node: Determine isomorphism,  Next: The longest common subsequence,  Prev: Message digester framework,  Up: Library modules - Utilities

11.44 `util.isomorph' - Determine isomorphism
=============================================

 -- Module: util.isomorph
     Provides a procedure that determines whether two structures are
     isomorphic.

 -- Function: isomorphic? obj1 obj2 &optional context
     Returns `#t' if OBJ1 and OBJ2 are isomorphic.

     CONTEXT is used if you want to call `isomorphic?' recursively
     inside `object-isomorphic?' described below.

          (isomorphic? '(a b) '(a b)) => #t

          (define x (cons 0 0))
          (define y (cons 0 0))
          (isomorphic? (cons x x)
                       (cons x y))
           => #f
          (isomorphic? (cons x x)
                       (cons y y))
           => #t

 -- Generic Function: object-isomorphic? obj1 obj2 context
     With this method, you can customize how to determine isomorphism of
     two objects.  Basically, you will call `isomorphic?' recursively
     for each slots of object you want to traverse; the method should
     return `#t' if all of the test succeeds, or return `#f' otherwise.
     CONTEXT is an opaque structure that keeps the traversal context,
     and you should pass it to `isomorphic?' as is.

     The default method returns `#t' if OBJ1 and OBJ2 are equal (in the
     sense of `equal?').


File: gauche-refe.info,  Node: The longest common subsequence,  Next: Additional list library,  Prev: Determine isomorphism,  Up: Library modules - Utilities

11.45 `util.lcs' - The longest common subsequence
=================================================

 -- Module: util.lcs
     This module implements the algorithm to find the longest common
     subsequence of two given sequences.  The implemented algorithm is
     based on Eugene Myers' O(ND) algorithm (*note [Myers86]: myers86.).

     One of the applications of this algorithm is to calculate the
     difference of two text streams; see *note Calculate difference of
     text streams::.

 -- Function: lcs seq-a seq-b &optional eq-fn
     Calculates and returns the longest common sequence of two lists,
     SEQ-A and SEQ-B.  Optional EQ-FN specifies the comparison
     predicate; if omitted, `equal?' is used.

          (lcs '(x a b y) '(p a q b))
           => (a b)

 -- Function: lcs-with-positions seq-a seq-b &optional eq-fn
     This is the detailed version of `lcs'.  The arguments are the same.

     Returns a list of the following structure:

          (LENGTH ((ELT A-POS B-POS) ...))

     LENGTH is an integer showing the length of the found LCS.  What
     follows is a list of elements of LCS; each sublist consists of the
     element, the integer position of the element in SEQ-A, then the
     integer position of the element in SEQ-B.

          (lcs-with-positions '(a) '(a))
           => (1 ((a 0 0)))

          (lcs-with-positions '(x a b y) '(p q a b))
           => (2 ((a 1 2) (b 2 3)))

          (lcs-with-positions '(x a b y) '(p a q b))
           => (2 ((a 1 1) (b 2 3)))

          (lcs-with-positions '(x y) '(p q))
           => (0 ())

 -- Function: lcs-fold a-proc b-proc both-proc seed a b &optional eq-fn
     A fundamental iterator over the "edit list" derived from two lists
     A and B.

     A-PROC, B-PROC, BOTH-PROC are all procedures that take two
     arguments.   The second argument is a intermediate state value of
     the calculation.  The first value is an element only in A for
     A-PROC, or an element only in B for B-PROC, or an element in both
     A and B for BOTH-PROC.  The return value of each procedure is used
     as the state value of the next call of either one of the
     procedures.  SEED is used as the initial value of the state value.
     The last state value is returned from `lcs-fold'.

     The three procedures are called in the following order: Suppose
     the sequence A consists of A'CA", and B consists of B'CB", where
     A', B', A", and B" are subsequences, and C is the head of the LCS
     of A and B.   Then A-PROC is called first on each element in A',
     B-PROC is called second on each element in B', then BOTH-PROC is
     called on C.  Afterwards, the process is repeated using A" and B".

 -- Function: lcs-edit-list a b &optional eq-fn
     Calculates 'edit-list' from two lists A and B, which is the
     smallest set of commands (additions and deletions) that changes A
     into B.  This procedure is built on top of `lcs-fold' above.

     Returns a list of _hunk_s, which is a contiguous section of
     additions and deletions.  Each hunk consists of a list of
     directives, which is a form of:
          (+|- POSITION ELEMENT)

     Here's an example.  Suppose A and B are the following lists,
     respectively.

          A == ("A" "B" "C" "E" "H" "J" "L" "M" "N" "P")
          B == ("B" "C" "D" "E" "F" "J" "K" "L" "M" "R" "S" "T")

     Then, `(lcs-edit-list a b equal?)' returns the following list.
          (((- 0 "A"))
           ((+ 2 "D"))
           ((- 4 "H") (+ 4 "F"))
           ((+ 6 "K"))
           ((- 8 "N") (- 9 "P") (+ 9 "R") (+ 10 "S") (+ 11 "T"))
          )
     The result consists of five hunks.  The first hunk consists of one
     directive, `(- 0 "A")', which means the element `"A"' at the
     position 0 of list A has to be deleted.  The second hunk also
     consists of one directive, `(+ 2 "D")', meaning the element `"D"'
     at the position 2 of list B has to be added.  The third hunk means
     `"H"' at the position 4 of list A should be removed and `"F"' at
     the position 4 of list B should be added, and so on.

     If you are familiar with Perl's Algorithm::Diff module, you may
     notice that this is the same structure that its `diff' procedure
     returns.

