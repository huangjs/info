This is gauche-refe.info, produced by makeinfo version 4.13 from
gauche-refe.texi.

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* Gauche: (gauche-refe.info).	        An R5RS Scheme implementation.
END-INFO-DIR-ENTRY


File: gauche-refe.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

   This is a reference manual of Gauche, an R5RS Scheme implementation.
This manual is for version 0.8.14.

* Menu:

* Introduction::
* Concepts::
* Programming in Gauche::
* Core syntax::
* Macros::
* Core library::
* Object system::
* Library modules - Overview::
* Library modules - Gauche extensions::
* Library modules - SRFIs::
* Library modules - Utilities::
* References::
* C to Scheme mapping::
* Function and Syntax Index::
* Module Index::
* Class Index::
* Variable Index::


File: gauche-refe.info,  Node: Introduction,  Next: Concepts,  Prev: Top,  Up: Top

1 Introduction
**************

This is a users' guide and reference manual of the Gauche Scheme system.
Here I tried to describe the implementation precisely, sometimes
referring to background design choices.

   The target readers are those who already know Scheme and want to
write useful programs in Gauche.  For those who are new to Scheme,
it'll be easier to start from some kind of tutorial.  I'm planning to
write one.

   This manual only deals with Scheme side of things.  Gauche has
another face, a C interface.   Details of it will be discussed in a
separate document to be written.  Those who wants to use Gauche as an
embedded language, or wants to write an extension, need that volume.

   For the Scheme side, I tried to make this manual self-contained for
the reader's convenience, i.e. as far as you want to look up Gauche's
features you don't need to refer to other documents.  For example,
description of functions defined in the standard documents are included
in this manual, instead of saying "see the standard document".
However, this document is not a verbatim copy of the standard
documents; sometimes I omit detailed discussions for brevity.  I put
pointers to the original documents, so please consult them if you need
to refer to the standards.

   If you're reading this document off-line, you may find the most
recent version on the web:
     `http://practical-scheme.net/gauche/'.

* Menu:

* Overview of Gauche::
* Notations::


File: gauche-refe.info,  Node: Overview of Gauche,  Next: Notations,  Prev: Introduction,  Up: Introduction

1.1 Overview of Gauche
======================

Gauche is a script interpreter based on Scheme.  Gauche conforms the
language standard "Revised^5 Report on the Algorithmic Language Scheme"
(*note [R5RS]: r5rs.), and supports various common libraries defined in
SRFIs (`http://srfi.schemers.org').

   The goal of Gauche is to provide a handy tool for programmers and
system administrators to handle daily works conveniently and
efficiently in the production environment.

   There are lots of Scheme implementations available, and each of them
has its design emphasis and weaknesses.  Gauche is designed with
emphasis on the following criteria.

Quick startup
     One of the situation Gauche is aiming at is in the production
     environment, where you write ten-lines throw-away script that may
     invoked very frequently.  This includes CGI scripts as well.
     Gauche includes a set of most common features in its executable,
     while splits less common stuffs into libraries which are to be
     loaded on demand, to make itself start quickly.

Multibyte strings
     We can no longer live happily in ASCII-only or
     1-byte-per-character world.  The practical language
     implementations are required to handle multibyte (wide) characters.
     Gauche supports multibyte strings natively, providing robust and
     consistent support than ad hoc library-level implementation.
     *Note Multibyte Strings::, for details.

Modular development
     Gauche has a simple module system to separate namespaces, which
     allows the developers to work in parallel without worrying name
     collision.

Integrated object system
     A powerful CLOS-like object system with MetaObject protocol
     (mostly compatible with STklos and Guile) is provided.

System interface
     Although Scheme abstracts lots of details of the machine,
     sometimes you have to bypass these high-level layers and go down
     to the basement to make things work.  Gauche has built-in support
     of most of POSIX.1 system calls.  Other modules, such as
     networking module, usually provide both high-level abstract
     interface and low-level interface close to system calls.

Enhanced I/O
     No real application can be written without dealing with I/O.
     Scheme neatly abstracts I/O as a port, but defines least
     operations on it.  Gauche uses a port object as a unified
     abstraction, providing utility functions to operate on the
     underlying I/O system.  *Note Input and output::, for the basic
     I/O support.

   On the other hand, Gauche is _not_ designed for applications such
like high-performance number cruncher or very large scale database
handling.  It is an interpreter, after all.

   You can still use Gauche as a "glue" language for such applications,
however.  For example, you can write a performance-critical part in
another language that compiles to native code, and use Gauche to set up.


File: gauche-refe.info,  Node: Notations,  Prev: Overview of Gauche,  Up: Introduction

1.2 Notations
=============

In this manual, each entry is represented like this:

 -- Category: foo arg1 arg2
     [spec] Description of foo ...

   CATEGORY denotes the category of the entry foo.  The following
category will appear in this manual:

Function                      A Scheme function.
Special Form                  A special form (in the R5RS term,
                              "syntax").
Macro                         A macro.
Module                        A module
Class                         A class.
Generic Function              A generic function
Method                        A method
Reader Syntax                 A lexical syntax that is interpreted by
                              the reader.

   For functions, special forms and macros, the entry may followed by
one or more arguments.  In the argument list, the following notations
may appear:

ARG ...
     Indicates zero or more arguments.

&OPTIONAL X Y Z
&OPTIONAL (X X-DEFAULT) (Y Y-DEFAULT) Z
     Indicates it may take up to three optional arguments.  The second
     form specifies default values.  Note that Gauche doesn't really
     support Common-Lisp style `&optional' argument specifier in the
     lambda list.  I use this notation since it is useful to indicate
     valid pattern of arguments.

&KEYWORD X Y Z
&KEYWORD (X X-DEFAULT) (Y Y-DEFAULT) Z
     Indicates it may take keyword arguments X, Y and Z.  Note that
     Gauche doesn't really support Common-Lisp style `&keyword'
     argument specifier in the lambda list.  I use this notation since
     it is useful to indicate valid pattern of arguments.

&REST ARGS
     Indicates it may take rest arguments.  Note that Gauche doesn't
     really support Common-Lisp style `&rest' argument specifier in the
     lambda list.  I use this notation since it is useful to indicate
     valid pattern of arguments.

   The description of the entry follows the entry line.  If the
specification of the entry comes from some standard or implementation,
its origin is noted in the bracket at the beginning of the description.
The following origins are noted:

[R5RS]
[R5RS+]
     The entry works as specified in "Revised^5 Report of Algorithmic
     Language Scheme.".  If it is marked as "[R5RS+]", the entry has
     additional functionality.

[SRFI-N]
[SRFI-N+]
     The entry works as specified in SRFI-N.  If it is marked as
     "[SRFI-N+]", the entry has additional functionality.

[POSIX]
     The API of the entry reflects the API specified in POSIX.


File: gauche-refe.info,  Node: Concepts,  Next: Programming in Gauche,  Prev: Introduction,  Up: Top

2 Concepts
**********

In this chapter I describe a few Gauche's design concepts that help you
to understand how Gauche works.

* Menu:

* Standard conformance::
* Multibyte Strings::
* Multibyte scripts::
* Case-sensitivity::
* Integrated Object System::
* Module system::
* Compilation::


File: gauche-refe.info,  Node: Standard conformance,  Next: Multibyte Strings,  Prev: Concepts,  Up: Concepts

2.1 Standard conformance
========================

Gauche conforms "Revised^5 Report of Algorithmic Language Scheme,"
including optional syntax and procedures, except the following features.

   * By default, Gauche reads symbols in case-sensitive way.  You can
     switch the reader's case sensitivity by a command-line option or
     special reader directive (*Note Case-sensitivity::, for details).

   * Continuations created in a certain situation (specifically, inside
     a Scheme code that is called from external C routine) have limited
     extent (*Note Continuation::, for details).

   * Full numeric tower (integer, rational, real and complex numbers)
     are supported, but ratinals are only exact, and complex numbers
     are always inexact.  The reader can recognize '`#'' as
     insignificant digits.

   * Procedures `rationalize', `transcript-on' and `transcript-off' are
     not supported.

   (Note: A new Scheme standard R6RS has been ratified on September
2007.  Although we don't have a plan to change Gauche to conform R6RS
in near future, we'll gradually add modules that are compatible to
R6RS).

   Gauche also supports the following SRFIs (Scheme Request for
Implementation).

SRFI-0, Feature-based conditional expansion construct.
     As an autoloaded macro.   *Note Feature conditional::.

SRFI-1, List library.
     Supported by the module `srfi-1'.  *Note List library::.  (Some of
     SRFI-1 procedures are built-in).

SRFI-2, AND-LET*: an AND with local bindings, a guarded LET* special form.
     Supported natively.  *Note Binding constructs::.

SRFI-4, Homogeneous numeric vector datatypes.
     The module `gauche.uvector' provides a superset of `srfi-4'
     procedures, including arithmetic operations and generic interface
     on the SRFI-4 vectors.  *Note Uniform vectors::.

SRFI-5, A compatible let form with signatures and rest arguments
     Supported by the module `srfi-5'.  *Note A compatible let form
     with signatures and rest arguments::.

SRFI-6, Basic String Ports.
     SRFI-6 procedures are built-in.  *Note String ports::.

SRFI-7, Feature-based program configuration language
     Supported as an autoloaded macro.  *Note Feature-based program
     configuration language::.

SRFI-8, receive: Binding to multiple values.
     Syntax `receive' is built-in.  *Note Binding constructs::.

SRFI-9, Defining record types.
     Supported by the module `srfi-9'.  *Note Record types::.

SRFI-10, Sharp-comma external form.
     Built-in.  *Note Read-time constructor::.

SRFI-11, Syntax for receiving multiple values.
     Supported by the module `srfi-11'.  *Note Let-values::.

SRFI-13, String library
     Supported by the module `srfi-13'.  *Note String library::.  (Some
     of SRFI-13 procedures are built-in).

SRFI-14, Character-set library
     Character-set object and a few SRFI-14 procedures are built-in.
     *Note Character set::.  Complete set of SRFI-14 is supported by
     the module `srfi-14'.  *Note Character-set library::.

SRFI-16, Syntax for procedures of variable arity (case-lambda)
     Built-in.  *Note Making Procedures::.

SRFI-17, Generalized set!
     Built-in.  *Note Assignments::.

SRFI-18, Multithreading support
     Some SRFI-18 features are built-in, and the rest is in
     `gauche.threads' module.  *Note Threads::.

SRFI-19, Time Data Types and Procedures.
     Time data type is Gauche built-in (*Note Time::).  Complete set of
     SRFI-19 is supported by the module `srfi-19'.  *Note Time data
     types and procedures::.

SRFI-22, Running Scheme scripts on Unix
     Supported.  *Note Writing Scheme scripts::.

SRFI-23, Error reporting mechanism.
     Built-in.   *Note Signalling exceptions::.

SRFI-25, Multi-dimensional array primitives.
     Supported by the module `gauche.array', which defines superset of
     SRFI-25.  *Note Arrays::.

SRFI-26, Notation for specializing parameters without currying.
     As an autoloaded macro.  *Note Making Procedures::.

SRFI-27, Sources of Random Bits.
     Supported by the module `srfi-27'.  *Note Sources of random bits::.

SRFI-28, Basic format strings.
     Gauche's built-in `format' procedure is a superset of SRFI-28
     `format'.  *Note Output::.

SRFI-29, Localization
     Supported by the module `srfi-29'.  *Note Localization::.

SRFI-30, Nested multi-line comments.
     Supported by the native reader.  *Note Lexical structure::.

SRFI-31, A special form rec for recursive evaluation
     Defined as an autoloaded macro.  *Note Binding constructs::.

SRFI-34, Exception Handling for Programs
     Built-in.  *Note Exceptions::.  (However, Gauche implements
     srfi-18's semantics of `raise' literally, which differs slightly
     from srfi-34's.  This may be changed in future.)

SRFI-35, Conditions
     Built-in.  *Note Conditions::.

SRFI-36, I/O Conditions
     Partly supported.  *Note Conditions::.

SRFI-37, args-fold: a program argument processor
     Supported by the module `srfi-37'.  *Note A program argument
     processor::.

SRFI-38, External Representation for Data With Shared Structure
     Built-in.  See *note Reading data:: and *note Output::.

SRFI-39, Parameter objects
     Supported by the module `gauche.parameter'.  *Note Parameters::.

SRFI-40, A Library of Streams
     Supported by the module `util.stream'.  *Note Stream library::.

SRFI-42, Eager comprehensions
     Supported by the module `srfi-42'.  *Note Eager comprehensions::.

SRFI-43, Vector library
     Supported by the module `srfi-43'.  *Note Vector library::.

SRFI-45, Primitives for Expressing Iterative Lazy Algorithms
     Built-in.  *Note Delayed evaluation::.

SRFI-55, require-extension
     Supported as an autoloaded macro.  *Note Requiring extensions::.

SRFI-61, A more general `cond' clause
     Supported natively.  *Note Conditionals::.

SRFI-62, S-expression comments
     Supported by the native reader.  *Note Lexical structure::.

SRFI-87, `=>' in case clauses
     Supported natively.  *Note Conditionals::.



File: gauche-refe.info,  Node: Multibyte Strings,  Next: Multibyte scripts,  Prev: Standard conformance,  Up: Concepts

2.2 Multibyte Strings
=====================

Traditionally, a string is considered as a simple array of bytes.
Programmers tend to imagine a string as a simple array of characters
(though a character may occupy more than one byte).  It's not the case
in Gauche.

   Gauche supports _multibyte string_ natively, which means characters
are represented by variable number of bytes in a string.   Gauche
retains semantic compatibility of Scheme string, so such details can be
hidden, but it'll helpful if you know a few points.

   A string object keeps a type tag and a pointer to the storage of the
string body.  The storage of the body is managed in a sort of
"copy-on-write" way--if you take substring, e.g. using directly by
`substring' or using regular expression matcher, or even if you copy a
string by `copy-string', the underlying storage is shared (the "anchor"
of the string is different, so the copied string is not `eq?' to the
original string).  The actual string is copied only if you
destructively modify it.

   Consequently the algorithm like pre-allocating a string by
`make-string' and filling it with `string-set!' becomes _extremely_
inefficient in Gauche.  Don't do it.  (It doesn't work with mulitbyte
strings anyway).  Sequential access of string is much more efficient
using _string ports_ (*Note String ports::).

   String search primitives such as `string-scan' (*Note String
utilities::) and regular expression matcher (*Note Regular expression::)
can return a matched string directly, without using index access at all.

   You can choose _internal_ encoding scheme at the time of compiling
Gauche.   At runtime, a procedure `gauche-character-encoding' can be
used to query the internal encoding.  Currently, the following internal
encodings are supported.

`euc-jp'
     EUC-JP encoding of ASCII, JIS X 0201 kana, JIS X 0212 and JIS X
     0213:2000 Japanese character set.

`sjis'
     Shift-JIS encoding of JIS X 0201 kana and JIS X 0213:2000 Japanese
     character set.  For source-code compatibility, the character code
     between 0 and 0x7f is mapped to ASCII.

`utf-8'
     UTF-8 encoding of Unicode.

`none'
     8-bit fixed-length character encoding, with the code between 0 and
     0x7f matches ASCII.  It's up to the application to interpret the
     string with certain character encodings.

   Conversions from other encoding scheme is provided as a special
port. *Note Character code conversion::, for details.

   The way to specify the encoding of source programs will be explained
in the next section.


File: gauche-refe.info,  Node: Multibyte scripts,  Next: Case-sensitivity,  Prev: Multibyte Strings,  Up: Concepts

2.3 Multibyte scripts
=====================

You can use characters other than `us-ascii' not only in literal
strings and characters, but in in commens, symbol names, literal
regular expressions, and so on.

   So far, Gauche treats any characters other than `us-ascii' as symbol
constituent characters.  Unicode defines more than dozen "space"
characters, though, and they will be treated as whitespace characters
in future.  So it's better to avoid those characters (except in the
strings, regexps and characters) for the time being.

   By default, Gauche assumes a Scheme program is written in its
internal character encoding.   It is fine as far as you're writing
scripts to use your own environment, but it becomes a problem if
somebody else tries to use your script and finds out you're using
different character encoding than his/hers.

   So, if Gauche finds a comment something like the following within
the first two lines of the program source, it assumes the rest of the
source code is written in `<encoding-name>', and does the appropriate
character encoding conversion to read the source code:
     ;; coding: <encoding-name>

   More precisely, a comment in either first or second line that matches
a regular expression `#/coding[:=]\s*([\w.-]+)/' is recognized, and the
first submatch is taken as an encoding name.  If there are multiple
matches, only the first one is effective.  The first two lines must not
contain characters other than us-ascii in order for this mechanism to
work.

   The following example tells Gauche that the script is written in
EUC-JP encoding.   Note that the string "`-*-'" around the coding would
be recognized by Emacs to select the buffer's encoding appropriately.

     #!/usr/bin/gosh
     ;; -*- coding: euc-jp -*-

     ... script written in euc-jp ...

   Internally, the handling of this _magic comment_ is done by a
special type of port.  See *note Coding-aware ports:: for the details.
See also *note Loading Scheme file:: for how to disable this feature.


File: gauche-refe.info,  Node: Case-sensitivity,  Next: Integrated Object System,  Prev: Multibyte scripts,  Up: Concepts

2.4 Case-sensitivity
====================

Historically, most Lisp-family languages are case-insensitive for
symbols.  Scheme is no exception and R5RS defines symbols are read in
case-insensitive way.  (Note that symbols are case-sensitive internally
even in R5RS Scheme; case-insensitivity is about readers.)

   However, nowadays programming is hardly completed in one language.
When you have to interact with other languages that distinguish
uppercase and lowercase characters, it is desirable that Scheme
distinguishes them as well.

   So Gauche has two modes in reading and writing symbols.  _By
default, Gauche reads and writes symbols in case-sensitive manner_.
This behavior doesn't conform R5RS.

     ; In case-sensitive mode (default)
     (eq? 'a 'A) => #f  ; #t in R5RS
     (symbol->string 'ABC) => "ABC"
     (symbol->string 'abc) => "abc"
     (display (string->symbol "ABC")) => writes ABC
     (display (string->symbol "abc")) => writes abc

   You can make Gauche case-insensitive by giving `-fcase-fold'
command-line option to the `gosh' interpreter (*Note Invoking Gosh::).
In this mode, the reader folds uppercase characters in symbols to
lowercase ones.  If a symbol name contains uppercase characters, it is
written out using |-escape (*Note Symbols::).

     ; In case-insensitive mode (with -fcase-fold option)
     (eq? 'a 'A) => #t
     (symbol->string 'ABC) => "abc"
     (symbol->string 'abc) => "abc"
     (display (string->symbol "ABC")) => writes |ABC|
     (display (string->symbol "abc")) => writes abc

   Alternatively, if the reader sees a token `#!fold-case', the reader
switches to case-insensitive mode.  A token `#!no-fold-case' has an
opposite effect--to make the reader case-sensitive.  These tokens
affect the port from which they are read, and are in effect until EOF
or another instance of these tokens are read.  See *note Lexical
structure:: for more details on `#!' syntax.


File: gauche-refe.info,  Node: Integrated Object System,  Next: Module system,  Prev: Case-sensitivity,  Up: Concepts

2.5 Integrated Object System
============================

Gauche has a STklos-style object system, similar to CLOS.  If you have
used some kind of object oriented (OO) languages, you'll find it easy
to understand the basic usage:
     ;; Defines a class point, that has x and y coordinate
     (define-class point ()
       ((x :init-value 0)
        (y :init-value 0))
       )

     (define-method move ((p point) dx dy)
       (inc! (slot-ref p 'x) dx)
       (inc! (slot-ref p 'y) dy))

     (define-method write-object ((p point) port)
       (format port "[point ~a ~a]"
               (slot-ref p 'x)
               (slot-ref p 'y)))

   However, if you are familiar with mainstream OO languages but new to
CLOS-style object system, Gauche's object system may look strange when
you look deeper into it.  Here I describe several characteristics of
Gauche object system quickly.  *Note Object system::, for details.

_Everything is an object (if you care)_
     You have seen this tagline for the other languages.  And yes, in
     Gauche, everything is an object in the sense that you can query
     its class, and get various meta information of the object at run
     time.  You can also define a new method on any class, including
     built-in ones.

     Note that, however, in CLOS-like paradigm it doesn't really matter
     whether everything is an object or not, because of the following
     characteristics:

_Method is dispatched by all of its arguments._
     Unlike other object-oriented languages such as C++, Objective-C,
     Python, Ruby, etc., in which a method always belong to a single
     class, a Gauche method doesn't belong to a specific class.

     For example, suppose you define a numeric vector class
     `<num-vector>' and a numeric matrix class `<num-matrix>'.  You can
     define a method `product' with all possible combinations of those
     type of arguments:

            (product <num-vector> <num-matrix>)
            (product <num-matrix> <num-vector>)
            (product <num-vector> <num-vector>)
            (product <num-matrix> <num-matrix>)
            (product <number>     <num-vector>)
            (product <number>     <num-matrix>)
            (product <number>     <number>)

     Each method belongs to neither `<num-vector>' class nor
     `<num-matrix>' class.

     Since a method is not owned by a class, you can always define your
     own method on the existing class (except a few cases that the
     system prohibits altering pre-defined methods).  The above example
     already shows it; you can make `product' method work on the
     built-in class `<number>'.   That is why I said it doesn't make
     much sense to discuss whether everything is object or not in
     CLOS-style object system.

     To step into the details a bit, the methods are belong to a
     _generic function_, which is responsible for dispatching
     appropriate methods.

_Class is also an instance._
     By default, a class is also an instance of class `<class>', and a
     generic function is an instance of class `<generic>'.  You can
     subclass `<class>' to customize how a class is initialized or how
     its slots are accessed.  You can subclass `<generic>' to customize
     how the applicable methods are selected, which order those methods
     are called, etc.   The mechanism is called _metaobject protocol_.
     Metaobject protocol allows you to extend the language by the
     language itself.

     To find examples, see the files `lib/gauche/singleton.scm' and
     `lib/gauche/mop/validator.scm' included in the distribution.  You
     can also read `lib/gauche/mop/object.scm', which actually defines
     how a class is defined in Gauche.  For more details about
     metaobject protocol, see *note [MOP]: mop.

_Class doesn't create namespace_
     In the mainstream OO language, a class often creates its own
     namespace.  This isn't the case in CLOS-style object system.  In
     Gauche, a namespace is managed by the module system which is
     orthogonal to the object system.



File: gauche-refe.info,  Node: Module system,  Next: Compilation,  Prev: Integrated Object System,  Up: Concepts

2.6 Module system
=================

Gauche has a simple module system that allows modularlized development
of large software.

   A higher level interface is simple enough from the user's point of
view.   It works like this: When you want to use the features provided
by module `foo', you just need to say `(use foo)' in your code.  This
form is a macro and interpreted at compile time.  Usually it loads the
files that defines `foo''s features, and imports the external APIs into
the calling module.

   The `use' mechanism is built on top of two independent lower
mechanisms, namespace separation and file loading mechanism.  Those two
lower mechanisms can be used separately, although it is much more
convenient when used together.

   The `use' mechanism is not transitive; that is, if a module B uses a
module A, and a module C uses the module B, C doesn't see the bindings
in A.  It is because B and A is not in the IS-A relationship.  Suppose
the module A implements a low-level functionality and the module B
implements a high-level abstraction; if C is using B, what C wants to
see is just a high-level abstraction, and doesn't concern how B
implements such functionality.  If C wants to access low-level stuff, C
has to USE A explicitly.

   There is another type of relationship, though.  You might want to
take an exiting module A, and add some interface to it and provide the
resulting module B as an extension of A.  In such a case, B is-a A, and
it'd be natural that the module that uses B can also see A's bindings.
In Gauche, it is called _module inheritance_ and realized by `extend'
form.

   The following sections in this manual describes modules in details.
   * *note Writing Gauche modules:: explains the convention of writing
     modules.

   * *note Modules:: describes special forms and macros to define and
     to use modules, along the built-in functions to introspect module
     internals.


File: gauche-refe.info,  Node: Compilation,  Prev: Module system,  Up: Concepts

2.7 Compilation
===============

Gauche is a Scheme interpreter, in the sense that it reads a Scheme
form at a time and evaluates it.   Actually, Gauche compiles every
toplevel form into an intermediate form before executing.

   Built-in syntaxes and macros are recognized and expanded at the
compilation time.  Some built-in procedures are expanded in-line as far
as the compiler can see the global binding is not altered at the time
the form is compiled.

   This raises a few problems you should care.

_load is done at run time._
     `load' is a procedure in Gauche, therefore evaluated at run time.
     If the loaded program defines a macro, which is available for the
     compiler after the toplevel form containing `load' is evaluated.
     So, suppose `foo.scm' defines a macro `foo', and you use the macro
     like this:
          ;; in "foo.scm"
          (define-syntax foo
            (syntax-rules () ((_ arg) (quote arg))))

          ;; in your program
          (begin (load "foo") (foo (1 2 3)))
            => error, bad procedure: `1'

          (load "foo")
          (foo (1 2 3)) => '(1 2 3)
     The `(begin (load ...))' form fails,  because the compiler doesn't
     know `foo' is a special form at the compilation time and compiles
     `(1 2 3)' as if it is a normal procedure call.  The latter example
     works, however, since the execution of the toplevel form `(load
     "foo")' is done before `(foo (1 2 3))' is compiled.

     To avoid this kind of subtleties, use `require' or `use' to load a
     program fragments.  Those are recognized by the compiler.

_require is done at compile time_
     On the other hand, since `require' and `use' is recognized by the
     compiler, the specified file is loaded even if the form is in the
     conditional expression.   If you really need to load a file on
     certain condition, use `load' or do dispatch in macro (i.e. at
     compile time).


File: gauche-refe.info,  Node: Programming in Gauche,  Next: Core syntax,  Prev: Concepts,  Up: Top

3 Programming in Gauche
***********************

* Menu:

* Invoking Gosh::
* Interactive development::
* Writing Scheme scripts::
* Debugging::
* Platform-dependent features::
* Profiling and tuning::
* Writing Gauche modules::
* Using extension packages::


File: gauche-refe.info,  Node: Invoking Gosh,  Next: Interactive development,  Prev: Programming in Gauche,  Up: Programming in Gauche

3.1 Invoking Gosh
=================

Gauche can be used either as an independent Scheme interpreter or as an
embedded Scheme library.   The interpreter which comes with Gauche
distribution is a program named `gosh'.

 -- Program: gosh [options] [scheme-file arg ...]
     Gauche's interpreter.   Without SCHEME-FILE, `gosh' works
     interactively, i.e. it reads a Scheme expression from the standard
     input, evaluates it, and prints the result, and repeat that until
     it reads EOF or is terminated.

     If `gosh' is invoked without SCHEME-FILE, but the input is not a
     terminal, it enters read-eval-print loop but not writes out a
     prompt while waiting input form.  This is useful when you pipe
     Scheme program into `gosh'.  You can force this behavior or
     suppress this behavior by `-b' and `-i' options.

     If SCHEME-FILE is specified, `gosh' runs it as a Scheme program
     and exit.  *Note Writing Scheme scripts::, for details.

Command-line options
--------------------

The following command line options are recognized by `gosh'.  The first
command line argument which doesn't begin with `-' is recognized as the
script file.  If you want to specify a file that begins with a minus
sign, use a dummy option ``--''.

 -- Command Option: -I path
     Prepends PATH to the load path list.  You can specify this option
     more than once to add multiple paths.

 -- Command Option: -A path
     Appends PATH to the tail of the load path list.  You can specify
     this option more than once to add multiple paths.

 -- Command Option: -q
     Makes `gosh' not to load the default initialization file.

 -- Command Option: -V
     Prints the `gosh' version and exits.

 -- Command Option: -u module
     Use MODULE.  Before starting execution of SCHEME-FILE or entering
     the read-eval-print loop, the specified module is USEd, i.e.  it
     is loaded and imported (*Note Defining and selecting modules::,
     for details of `use').  You can specify this option more than once
     to use multiple modules.

 -- Command Option: -l file
     Load FILE before starting execution of SCHEME-FILE or entering the
     read-eval-print loop.   The file is loaded in the same way as
     `load' (*Note Loading Scheme file::).  You can specify this option
     more than once to load multiple files.

 -- Command Option: -e scheme-expression
     Evaluate SCHEME-EXPRESSION before starting execution of
     SCHEME-FILE or entering the read-eval-print loop.   Evaluation is
     done in the INTERACTION-ENVIRONMENT (*Note Eval and repl::).  You
     can specify this option more than once to evaluate multiple
     expressions.

 -- Command Option: -E scheme-expression
     Same as -e, except the SCHEME-EXPRESSION is read as if it is
     surrounded by parenthesis.  For example:
          % gosh -umath.const -E"print (sin (* pi/180 15))" -Eexit
          0.25881904510252074

 -- Command Option: -b
     Batch. Does not print prompts even if the input is a terminal.

 -- Command Option: -i
     Interactive. Print prompts even if the input is not a terminal.

 -- Command Option: -f compiler-option
     This option controls compiler and runtime behavior.  For now we
     have following options available:
    no-inline
          Prohibits the compiler from inlining procedures and
          constants. Equivalent to no-inline-globals, no-inline-locals
          and no-inline constants combined.

    no-inline-globals
          Prohibits the compiler from inlining global procedures.

    no-inline-locals
          Prohibits the compiler from inlining local procedures.

    no-inline-constants
          Prohibits the compiler from inlining constants.

    load-verbose
          Reports whenever a file is loaded.

    no-source-info
          Don't keep source information for debugging.  Consumes less
          memory.

    case-fold
          Ignore case for symbols as specified in R5RS.  (It is
          distinguished by default).  *Note Case-sensitivity::.

    test
          Adds "`../src'" and "`../lib'" to the load path before loading
          initialization file.  This is useful when you want to test the
          compiled `gosh' interpreter inside source tree, without
          installing it.

 -- Command Option: -p profiler-option
     Turn on the profiler.  The following PROFILER-OPTION is recognized:

    `time'
          Records and reports time spent on function calls and number
          of times each function is called.

    `load'
          Records and reports time spent on loading each modules.
          Useful to tune start-up time of the scripts.  (Results are in
          elapsed time).

     See *note Using profiler:: for the details of the profiler.

 -- Command Option: `--'
     When `gosh' sees this option, it stops processing the options and
     takes next command line argument as a script file.  It is useful
     in case if you have a script file that begins with a minus sign,
     although it is not generally recommended.

   The options -I, -A, -l, -u, -e and -E are processes in the order of
appearance.  For example, adding a load path by -I affects the -l and
-u option after it but not before it.

Environment variables
---------------------

The following environment variables are recognized:

 -- Environment variable: GAUCHE_LOAD_PATH
     You can specify additional load paths by this environment
     variable, delimiting the paths by '`:''.  The paths are appended
     before the system default load paths.

 -- Environment variable: GAUCHE_DYNLOAD_PATH
     You can specify additional load paths for dynamically loaded
     objects by this environment variable, delimiting the paths by
     '`:''.  The paths are appended before the system default load
     paths.


File: gauche-refe.info,  Node: Interactive development,  Next: Writing Scheme scripts,  Prev: Invoking Gosh,  Up: Programming in Gauche

3.2 Interactive development
===========================

When `gosh' is invoked without any script files, it goes into
interactive read-eval-print loop.

   To exit the interpreter, type EOF (usually Control-D in Unix
terminals) or evaluate `(exit)'.

   In interactive session, `gosh' loads `gauche.interactive' module
(*Note Interactive session::) for the convenience.  The module also
loads a file `.gaucherc' under the user's home directory if it exists.
You may put settings there that would help interactive debugging.  (As
of Gauche release 0.7.3, `.gaucherc' is no longer loaded when `gosh' is
run in script mode.)

   I recommend you to run `gosh' inside Emacs, for it has rich features
useful to interact with internal Scheme process.  Put the following
line to your `.emacs' file:
     (setq scheme-program-name "gosh -i")
   And you can run `gosh' by <M-x run-scheme>.

   If you want to use multibyte characters in the interaction, make
sure your terminal's settings is in sync with `gosh''s internal
character encodings.

   Currently `gosh' has no fancy features such as line-editing or
command history.   They'll be added in future.


File: gauche-refe.info,  Node: Writing Scheme scripts,  Next: Debugging,  Prev: Interactive development,  Up: Programming in Gauche

3.3 Writing Scheme scripts
==========================

When a Scheme program file is given to `gosh', it bounds a global
variable `*argv*' to the list of the remaining command-line arguments,
then loads the Scheme program.  If the first line of SCHEME-FILE begins
with two character sequence "`#!'", the entire line is ignored by
`gosh'.  This is useful to write a Scheme program that works as an
executable script in unix-like systems.

   Typical Gauche script has the first line like these
     #!/usr/local/bin/gosh
       or,
     #!/usr/bin/env gosh
       or,
     #!/bin/sh
     :; exec gosh -- $0 "$@"
   The second and third form uses a "shell trampoline" technique so
that the script works as far as `gosh' is in the PATH.  The third form
is useful when you want to pass extra arguments to `gosh', for
typically `#!'-magic of executable scripts has limitations for the
number of arguments to pass the interpreter.

   After the file is successfully loaded, `gosh' calls a procedure
named ``main'' if it is defined in the user module.  `Main' receives a
single argument, a list of command line arguments.  Its first element
is the script name itself.

   When `main' returns, and its value is an integer, `gosh' uses it for
exit code of the program.  Otherwise, `gosh' exits with exit code 70
(`EX_SOFTWARE').  This behavior is compatible with the SRFI-22.

   If the `main' procedure is not defined, `gosh' exits after loading
the script file.

   Although you can still write the program main body as toplevel
expressions, like shell scripts or Perl scripts, it is much convenient
to use this ``main'' convention, for you can load the script file
interactively to debug.

 -- Variable: *argv*
     The program arguments passed to the Scheme script is bound to this
     variable.  If `gosh' is invoked in an interactive mode, this
     variable always contains `()'.

     STk uses this variable to pass the command line argument as well,
     but other Scheme implementations use different ways.  It is better
     to define `main' procedure and uses its argument to receive
     command line arguments, for it is expected to be more portable.

 -- Variable: *program-name*
     This variable is bound to the script file name passed to `gosh'.
     If `gosh' is invoked in the interactive mode, this variable
     contains the pathname of `gosh' itself.

     STk uses the same variable to access the program/script name.
     Other Scheme implementations use different ways.

   Now I show several simple examples below.  First, this script works
like `cat(1)', without any command-line option processing and error
handling.

     #!/usr/bin/env gosh

     (define (main args)   ;entry point
       (if (null? (cdr args))
           (copy-port (current-input-port) (current-output-port))
           (for-each (lambda (file)
                       (call-with-input-file file
                         (lambda (in)
                           (copy-port in (current-output-port)))))
                     (cdr args)))
       0)

   The following script is a simple grep command.

     #!/usr/bin/env gosh

     (define (usage)
       (format (current-error-port)
               "Usage: ~a regexp file ...\n" *program-name*)
       (exit 2))

     (define (grep rx port)
       (with-input-from-port port
         (lambda ()
           (port-for-each
            (lambda (line)
              (when (rxmatch rx line)
                (format #t "~a:~a: ~a\n"
                        (port-name port)
                        (- (port-current-line port) 1)
                        line)))
            read-line))))

     (define (main args)
       (if (null? (cdr args))
           (usage)
           (let ((rx (string->regexp (cadr args))))
             (if (null? (cddr args))
                 (grep rx (current-input-port))
                 (for-each (lambda (f)
                             (call-with-input-file f
                               (lambda (p) (grep rx p))))
                           (cddr args)))))
       0)

   See also *note Parsing command-line options::, for a convenient way
to parse command-line options.


File: gauche-refe.info,  Node: Debugging,  Next: Platform-dependent features,  Prev: Writing Scheme scripts,  Up: Programming in Gauche

3.4 Debugging
=============

Gauche doesn't have much support for debugging yet.  The idea of good
debugging interfaces are welcome.

   For now, the author uses the classic 'debug print stub' technique
when necessary.  A special reader syntax `#?=EXPR' is defined, which is
read as `(debug-print EXPR)'.  The macro `debug-print' evaluates and
returns the result(s), printing messages before and after evaluation of
EXPR.

     gosh> #?=(+ 2 3)
     #?="(stdin)":1:(+ 2 3)
     #?-    5
     5
     gosh> #?=(begin (print "foo") (values 'a 'b 'c))
     #?="(stdin)":2:(begin (print "foo") (values 'a 'b 'c))
     foo
     #?-    a
     #?+    b
     #?+    c
     a
     b
     c
     gosh> (define (fact n)
             (if (zero? n)
                 1
                 (* n #?=(fact (- n 1)))))
     fact
     gosh> (fact 5)
     #?="(stdin)":6:(fact (- n 1))
     #?="(stdin)":6:(fact (- n 1))
     #?="(stdin)":6:(fact (- n 1))
     #?="(stdin)":6:(fact (- n 1))
     #?="(stdin)":6:(fact (- n 1))
     #?-    1
     #?-    1
     #?-    2
     #?-    6
     #?-    24
     120

   You can also use trace/untrace macros in Gauche, written by
Shigenobu Kimura: `http://homepage.mac.com/skimu/ggc/'.


File: gauche-refe.info,  Node: Platform-dependent features,  Next: Profiling and tuning,  Prev: Debugging,  Up: Programming in Gauche

3.5 Using platform-dependent features
=====================================

Gauche tries to provide low-level APIs close to what the underlying
system provides, but sometimes they vary among systems.  For example,
POSIX does not require `symlink', so some systems may lack
`sys-symlink' (*Note Directory manipulation::).  Quite a few
unix-specific system functions are not available on Windows platform.
To allow writing a portable program across those platforms, Gauche uses
`cond-expand' (*Note Feature conditional::) extensively.  A set of
extended _feature-identifier_s is provided to check availability of
specific features.  For example, on systems that has `symlink', a
feature identifier `gauche.sys.symlink' is defined.   So you can write
a code that can switch based on the availability of `sys-symlink' as
follows:

     (cond-expand
      (gauche.sys.symlink
        ... code that uses sys-symlink ...)
      (else
        ... alternative code ...)
      )

   If you're familiar with system programming in C, you can think it
equivalent to the following C idiom:

     #if defined(HAVE_SYMLINK)
     ... code that uses symlink ...
     #else
     ... alternative code ...
     #endif

   There are quite a few such feature identifiers; each identifier is
explained in the maunal entry of the procedures that depend on the
feature.  Here we list a few important ones:

`gauche'
     This feature identifier is always defined.  It is useful when you
     write Scheme code portable across multiple implementations.

`gauche.os.windows'
     Defined on Windows native platform (currently using MinGW, but
     we'll have VC++ version in future).  Note that cygwin is
     considered unix.

`gauche.sys.pthreads'
     Defined if Gauche is compiled with pthread support.

`gauche.net.ipv6'
     Defined if Gauche is compiled with IPv6 support.

   Because `cond-expand' is a macro, the body of clauses are expanded
into toplevel if `cond-expand' itself is in toplevel.  That means you
can switch toplevel definitions:

     (cond-expand
      (gauche.os.windows
       (define (get-current-user)
         ... get current username ...))
      (else
       (define (get-current-user)
         (sys-uid->user-name (sys-getuid)))))

   Or even conditionally "use" the modules:

     (cond-expand
      (gauche.os.windows
        (use "my-windows-compatibility-module"))
      (else))

   The traditional technique of testing a toplevel binding at runtime
(using `global-variable-bound?', *Note Module introspection::) does not
work well, since the test is done in runtime, while the `use' form
takes effect at compile time.  It is strongly recommended to use
`cond-expand' whenever possible.

   Currently the set of feature identifiers are fixed at the build time
of Gauche, so it's less flexible than C preprocessor conditionals.  We
have a plan to extend this feature to enable adding new feature
identifiers; but such feature can complicate semantics when compilation
and execution is interleaved, so we're carefully assessing the effects
now.

   A couple of notes:

   Feature identifiers are not variables.  They can only be used within
the FEATURE-REQUIREMENT part of `cond-expand' (see *note Feature
conditional:: for the complete definition of feature requirements).

   By definition of `srfi-0', `cond-expand' raises an error if no
feature requirements are satisfied and there's no `else' clause.  A
rule of thumb is to provide `else' clause always, even it does nothing
(like the above example that has empty `else' clause).


File: gauche-refe.info,  Node: Profiling and tuning,  Next: Writing Gauche modules,  Prev: Platform-dependent features,  Up: Programming in Gauche

3.6 Profiling and tuning
========================

If you find your script isn't running fast enough, there are several
possibilities to improve its performance.

   It is always a good idea to begin with finding which part of the
code is consuming the execution time.   Gauche has a couple of basic
tools to help it.  A built-in sampling profiler, explained in the
following subsection, can show how much time is spent in each
procedure, and how many times it is called.  The `gauche.time' module
(*note Measure timings::) provides APIs to measure execution time of
specific parts of the code.

   Optimization is specialization--you look for the most common
patterns of execution, and put a special path to support those patterns
efficiently.  Gauche itself is no exception, so there are some patterns
Gauche can handle very efficiently, while some patterns it cannot.  The
next subsection, *note Performance tips::, will give you some tips of
how to adapt your code to fit the patterns Gauche can execute well.

* Menu:

* Using profiler::
* Performance tips::


File: gauche-refe.info,  Node: Using profiler,  Next: Performance tips,  Prev: Profiling and tuning,  Up: Profiling and tuning

3.6.1 Using profiler
--------------------

As of 0.8.4, Gauche has a built-in profiler.  It is still experimental
quality and only be tested on Linux.  It isn't available for all
platforms.   It works only in single-thread applications for now.

   To use the profiler non-interactively, give `-ptime' command-line
option to gosh.

     % gosh -ptime your-script.scm

   After the execution of `your-script.scm' is completed, Gauche prints
out the table of functions with its call count and its consumed time,
sorted by the total consumed time.

     Profiler statistics (total 1457 samples, 14.57 seconds)
                                                         num    time/    total
     Name                                                calls  call(ms) samples
     ---------------------------------------------------+------+-------+-----------
     combinations*                                       237351  0.0142   337( 23%)
     (lset-difference #f)                               1281837  0.0020   256( 17%)
     (make-anchor make-anchor)                          3950793  0.0005   198( 13%)
     member                                             4627246  0.0004   190( 13%)
     filter                                              273238  0.0030    81(  5%)
     every                                              1315131  0.0004    59(  4%)
     (lset-difference #f #f)                            1281837  0.0004    54(  3%)
     (make-entry make-entry)                             730916  0.0005    40(  2%)
     (clear? #f)                                         730884  0.0005    33(  2%)
     (initialize #f)                                     599292  0.0005    32(  2%)
     fold                                                237307  0.0013    30(  2%)
     acons                                               806406  0.0004    29(  1%)
     clear?                                               33294  0.0084    28(  1%)
     (combinations* #f)                                  805504  0.0002    15(  1%)
     (make-exit make-exit)                               730884  0.0002    15(  1%)
     lset-difference                                     237318  0.0006    15(  1%)
     reverse!                                            475900  0.0001     6(  0%)
     (fold <top> <top> <list>)                           237323  0.0003     6(  0%)
     procedure?                                          238723  0.0002     4(  0%)
     pair?                                               237307  0.0001     3(  0%)
      :
      :

   Note that the time profiler uses statistic sampling.  Every 10ms the
profiler interrupts the process and records the function that is
executed then.   Compared to the individual execution time per function
call, which is the order of nanoseconds, this sampling rate is very
sparse.  However, if we run the program long enough, we can expect the
distribution of samples per each function approximately reflects the
distribution of time spent in each function.

   Keep in mind that the number is only approximation; the number of
sample counts for a function may easily vary if the program deals with
different data sets.   It should also be noted that, for now, GC time
is included in the function in which GC is triggered.  This sometimes
causes a less important function to "float up" to near-top of the list.
To know the general pattern, it is a good custom to run the program
with several different data sets.

   On the other hand, the call count is accurate since Gauche actually
counts each call.

   Because all functions are basically anonymous in Scheme, the 'name'
field of the profiler result is only a hint.  The functions bound at
toplevel is generally printed with the global variable name it is bound
at the first time.  Internal functions are printed as a list of names,
reflecting the nesting of functions.  Methods are also printed as a
list of the name and specializers.

   The profiler has its own overhead; generally the total process time
will increase 20-30%.  If you want to turn on the profiler selectively,
or you're running a non-stop server program and want to obtain the
statistics without exiting the server, you can call the profiler API
from your program; see *note Profiler API::, for the details.


File: gauche-refe.info,  Node: Performance tips,  Prev: Using profiler,  Up: Profiling and tuning

3.6.2 Performance tips
----------------------

Don't guess, just benchmark.  It is the first rule of performance
tuning.  Especially for the higher-level languages like Scheme, what
impacts on performance greatly depends on the implementation.  Certain
operations that are very cheap on an implementation may be costly on
others.  Gauche has such implementation-specific characteristics, and
to know some of them would help to see what to look out in the
benchmark results.

   "80% of execution time is spent in 20% of the code" is another old
saying.  Don't obscure your code by "potential" optimization that has
little impact on the actual execution.  We describe some tips below,
but it doesn't mean you need to watch them all the time.  It is better
to keep most of the code clean and easy to understand, and only do
tricks on the innermost loop.

   *Ports*: To satisfy the specification of SRFI-18 (Threading), every
call to I/O primitives of Gauche locks the port.  This overhead may be
visible if the application does a lot of I/O with smaller units (e.g.
every bytes).   The primitives that deals with larger unit, such as
`read' and `read-block', are less problematic, since usually they just
lock the port once per call and do all the low-level I/O without the
lock overhead.  (Note: this doesn't mean those primitives _guarantee_
to lock the port throughout the execution of the function; furthermore,
the port locking feature is optimized for the case that port accesses
rarely collide.  If you know it is possible that more than one threads
read from or write to the same port, it is your responsibility to use
mutex explicitly to avoid the collision.)

   If you find out the locking is indeed a bottleneck, there are couple
of things you can consider: (1) Try using the larger-unit primitives,
instead of calling the smaller-unit ones.  (2) Use `with-port-locking'
(see *note Port and threads::) to lock the port in larger context.

   *Strings*: Because of the multibyte strings, two operations are
particularly heavy in Gauche: string mutation and indexed string access.
It is a design choice; we encourage the programming style that avoids
those operations.  When you sequentially access the string, string
ports (see *note String ports::) provide a cleaner and more efficient
way.  When you search and retrieve a substring, there are various
higher-level primitives are provided (see *note String utilities::,
*note Regular expression::, and *note String library::, for example).
If you're using strings to represent an octet sequence, use uniform
vectors (see *note Uniform vectors::) instead.

   *Deep recursion*: Gauche's VM uses a stack for efficient local frame
allocation.  If recursion goes very deep (depending on the code, but
usually several hundreds to a thousand), the stack overflows and Gauche
moves the content of the stack into the heap.  This incurs some
overhead.  If you observe a performance degradation beyond a certain
amount of data, check out this possibility.

   *Generic functions*: Because of its dynamic nature, generic function
calls are slower than procedure calls.  Not only because of the runtime
dispatch overhead, but also because Gauche's compile-time optimizer
can't do much optimization for generic function calls.  You don't need
to avoid generic functions because of performance reasons in general,
but if you do find single function call consuming a large part of
execution time and it is calling a generic function in its inner
loop--then it may be worth to modify it.

   *Redefining builtin functions*: Gauche inlines some builtin
functions if they are not redefined.  Although sometimes it is useful
to redefine basic functions, you may want to limit the effect.  For
example, put redefined functions in a separate module and use the
module in the code that absolutely needs those functions replaced.

   *Closure creation*: When you create a closure, its closing
environment is copied to the heap.  This overhead is small, but it
still may be visible when a closure is created within an innermost loop
that is called millions of times.   If you suspect this is a problem,
try disassemble the function.   Gauche's compiler uses some basic
techniques of closure analysis to avoid creating closures for typical
cases, in which case you see the local function's bodies are inlined.
If you see a `CLOSURE' instruction, though, it means a closure is
created.

   This list isn't complete, and may change when Gauche's implementation
is improved, so don't take this as fixed features.  We'll adjust it
occasionally.


File: gauche-refe.info,  Node: Writing Gauche modules,  Next: Using extension packages,  Prev: Profiling and tuning,  Up: Programming in Gauche

3.7 Writing Gauche modules
==========================

Gauche's libraries are organized by modules.   Although Gauche can load
any valid Scheme programs, there is a convention that Gauche's
libraries follow.    When you write a chunk of Scheme code for Gauche,
it is convenient to make it a module, so that it can be shared and/or
reused.

   Usually a module is contained in a file, but you can make a
multi-file module.  First I explain the structure of a single-file
module.  The following template is the convention used in Gauche's
libraries.

     ;; Define the module interface
     (define-module foo
       (use xxx)
       (use yyy)
       (export foo1 foo2 foo3)
       )
     ;; Enter the module
     (select-module foo)

     ... module body ...

     ;; Make `require' happy
     (provide "foo")

   This file must be saved as "foo.scm" in some directory in the
`*load-path*'.

   The `define-module' form creates a module `foo'.  It also loads and
imports some other modules by ``use'' macros, and declares which
symbols the `foo' module exports, by ``export'' syntax.  (See section
*note Defining and selecting modules::, for detailed specification of
those syntaxes).

   Those `use' forms or `export' forms are not required to appear in
the `define-module' form, but it is a good convention to keep them in
there at the head of the file so that it is visually recognizable which
modules `foo' depends and which symbols it exports.

   The second form, ``select-module'', specifies the rest of the file
is evaluated in the module `foo' you just defined.   Again, this is
just a convention; you can write entire module body inside
`define-module'.  However, I think it is error-prone, for the closing
parenthesis can be easily forgotten or the automatic indentation
mechanism of editor will be confused.

   After `select-module' you can write whatever Scheme expression.  It
is evaluated in the selected module, `foo'.   Only the bindings of the
exported symbols will be directly accessible from outside.

   The last `provide' form is just a cliche.  It is needed since the
`use' mechanism uses traditional require-provide mechanism (if you
don't know about it, it's ok-just put it as a magic spell).

   So, that's it.   Other programs can use your module by just saying
``(use foo)''.   If you want to make your module available on your site,
you can put it to the site library location, which can be obtained by
     (gauche-site-library-directory)
   in gosh, or
     gauche-config --sitelibdir
   from shell.

   If you feel like to conserve global module name space, you can
organize modules hierarchically.   Some Gauche libraries already does
so.  *Note Library modules - Overview::, for examples.  For example,
`text.tr' module is implemented in "text/tr.scm" file.  Note that the
pathname separator `/' in the file becomes a period in the module name.


File: gauche-refe.info,  Node: Using extension packages,  Prev: Writing Gauche modules,  Up: Programming in Gauche

3.8 Using extension packages
============================

Building and installing packages
--------------------------------

Gauche comes with some amount of libraries, but they aren't enough at
all to use Gauche in the production environment.  There are number of
additional libraries available.   We call them _extension packages_, or
simply packages.  Each package usually provides one or more modules
that adds extra functionality.   Most of the packages provide binding
to other C libraries, such as graphics libraries or database clients.
If the package has some C code, it is likely that you need to compile
it on your machine with the installed Gauche system.

   Usually a package is in the form of compressed tarball, and the
standard "ungzip + untar + configure + make + make install" sequence
does the job.  Read the package's document, for you may be able to
tailor the library for your own needs by giving command-line options to
the `configure' script.

   From Gauche 0.8, an utility script called `gauche-package' is
installed for the convenience.  It automates the build and install
process of packages.

   Suppose you have downloaded a package `Package-1.0.tar.gz'.  If the
package follows the convention, all you have to do is to type this:

     $ gauche-package install Package-1.0.tar.gz

   It ungzips and untars the package, `cd' into the `Package-1.0'
subdirectory, run configure, make, and make install.  By default,
`gauche-package' untars the tarball in the current working directory.
You can change it by a customization file; see below.

   If you need a special priviledge to install the files, you can use
`--install-as' option which runs `make install' part via the `sudo'
program.

     $ gauche-package install --install-as=root Package-1.0.tar.gz

   If it doesn't work for you, you can just build the package by
`gauche-package build Package-1.0.tar.gz', then manually cd to the
`Package-1.0' directory and run `make install'.

   You can give configuration options via `-C' or `--configure-options'
command-line argument, like this:

     $ gauche-package install -C "--prefix=/usr/local" Package-1.0.tar.gz

   If the package has adopted the new package description file, it can
remember the configuration options you have specified, and it will
automatically reuse them when you install the package again.  (If
you're a package developer, check out `examples/spigot/README' file in
the Gauche source tree to see how to cooperate with Gauche's package
management system.)

   If you don't have a tarball in your local directory, but you know
the URL where you can download it, you can directly give the URL to
`gauche-package'.  It understands `http' and `ftp', and uses either
`wget' or `ncftpget' to download the tarball, then runs configure and
make.

     $ gauche-package install http://www.example.com/download/Package-1.0.tar.gz

Customizing `gauche-package'
----------------------------

The `gauche-package' program reads `~/.gauche-package' if it exists.
It must contain an associative list of parameters.  It may look like
this:

     (
      (build-dir . "/home/shiro/tmp")
      (gzip      . "/usr/local/bin/gzip")
      (bzip2     . "/usr/local/bin/bzip2")
      (tar       . "/usr/local/bin/gtar")
     )

   The following is a list of recognized parameters.  If the program
isn't given in the configuration file, `gauche-package' searches `PATH'
to find one.

`build-dir'
     A directory where the tarball is extracted.  If URL is given, the
     downloaded file is also placed in this directory.

`bzip2'
     Path to the program `bzip2'.

`cat'
     Path to the program `cat'.

`make'
     Path to the program `make'.

`ncftpget'
     Path to the program `ncftpget'.

`rm'
     Path to the program `rm'.

`sudo'
     Path to the program `sudo'.

`tar'
     Path to the program `tar'.

`wget'
     Path to the program `wget'.


File: gauche-refe.info,  Node: Core syntax,  Next: Macros,  Prev: Programming in Gauche,  Up: Top

4 Core syntax
*************

* Menu:

* Lexical structure::
* Literals::
* Making Procedures::
* Assignments::
* Conditionals::
* Binding constructs::
* Sequencing::
* Iteration::
* Quasiquotation::
* Definitions::
* Modules::


File: gauche-refe.info,  Node: Lexical structure,  Next: Literals,  Prev: Core syntax,  Up: Core syntax

4.1 Lexical structure
=====================

Gauche extends R5RS Scheme parser in some ways:

_Nested block comments (SRFI-30)_
     A text surrounded by '`#|'' and '`|#'' becomes a comment.  It can
     be nested.

_Numeric literals_
     Either integral part or fraction part of inexact real numbers can
     be omitted if it is zero, i.e. `30.', `.25', `-.4' are read as
     real numbers.  The number reader recognizes '`#'' as insignificant
     digits.  Complex numbers can be written both in the rectangular
     format (e.g. `1+0.3i') and in the polar format (e.g. 3.0@1.57).
     Inexact real numbers include the positive infinity, the negative
     infinity, and NaN, which are represented as `+inf.0', `-inf.0' and
     `+nan.0', respectively.  (`-nan.0' is also read as NaN.)

_Symbol names_
     Symbol names are case sensitive by default (*Note
     Case-sensitivity::).  Symbol name can begin with digits, '`+'' or
     '`-'', as long as the entire token doesn't consist valid number
     syntax.  Other weird characters can be included in a symbol name
     by surrounding it with '|', e.g. '`|this is a symbol|''.  *Note
     Symbols::, for details.

_Character literal by character code_
     Character literals can be written using its code, by `#\xNN'
     (Gauche internal code) or `#\uNN' (Unicode).  *Note Characters::,
     for details.

_Extended sharp syntax_
     Many more special tokens begins with '`#'' are defined.  See the
     table below.

   The table below lists sharp-syntaxes.

`#!'               [R6RS][SRFI-22] It is either a beginning of
                   an interpreter line       (shebang) of a
                   script, or a special token that affects the
                   mode       of the reader.  See `hash-bang
                   token' section below.
`#"', `##', `#$',  Unused.
`#%', `#&', `#''   
`#('               [R5RS] Introduces a vector.
`#)'               Unused.
`#*'               If followed by a double quote, denotes an
                   incomplete string.  *Note Strings::.
`#+'               Unused.
`#,'               [SRFI-10] Introduces reader constructor
                   syntax.
`#-', `#.'         Unused.
`#/'               Introduces a literal regular expression.
                   *Note Regular expression::.
`#0' ... `#9'      [SRFI-38] Shared substructure definition and
                   reference.
`#:'               Unused
`#;'               [SRFI-62] S-expression comment.  Reads next
                   one S-expression and       discard it.
`#<'               Introduces an unreadable object.
`#=', `#>'         Unused.
`#?'               Introduces debug macros.  *Note Debugging::.
`#@'               Unused.
`#a'               Unused.
`#b'               [R5RS] Binary number prefix.
`#c'               Unused.
`#d'               [R5RS] Decimal number prefix.
`#e'               [R5RS] Exact number prefix.
`#f'               [R5RS] Boolean false, or       introducing
                   SRFI-4 uniform vector.  *Note Uniform
                   vectors::.
`#g', `#h'         Unused.
`#i'               [R5RS] Inxact number prefix.
`#j', `#k', `#l',  Unused.
`#m', `#n'         
`#o'               [R5RS] Octal number prefix.
`#p', `#q', `#r'   Unused.
`#s'               [SRFI-4] introducing SRFI-4 uniform vector.
                   *Note Uniform vectors::.
`#t'               [R5RS] Boolean true.
`#u'               [SRFI-4] introducing SRFI-4 uniform vector.
                   *Note Uniform vectors::.
`#v', `#w'         Unused.
`#x'               [R5RS] Hexadecimal number prefix.
`#y', `#z'         Unused.
`#['               Introduces a literal character set.  *Note
                   Character set::.
`#\'               [R5RS] Introduces a literal character.
                   *Note Characters::.
`#]', `#^', `#_'   Unused.
`#`'               Introduces an interpolated string.  *Note
                   String interpolation::.
`#{'               Unused.
`#|'               [SRFI-30] Introduces a block comment.
                   Comment ends by matching '`|#''.
`#}', `#~'         Unused.

Hash-bang token
---------------

A character sequence `#!' has two completely different semantics,
depending on how and where it occurs.

   If a file begins with `#!/' or `#! ' (hash, bang, and a space), then
the reader assumes it is an interpreter line (shebang) of a script and
ignores the rest of characters until the end of line.  (Actually the
source doesn't need to be a file.  The reader checks whether it is the
beginning of a port.)

   Other than the above case, `#!IDENTIFIER' is read as a token with
special meanings.  This kind token can be a special directive for the
reader, instead of read as a datum.

   By default, three of such tokens are recognized.  `#!fold-case' and
`#!no-fold-case' switches the reader's case sensitivity; `#!fold-case'
makes the reader case insensitive, and `#!no-fold-case' makes it case
sensitive.  (Also see *note Case-sensitivity::).

   The token `#!r6rs' is introduced in R6RS and used to indicate the
program is strictly conforms R6RS.  Gauche doesn't support R6RS, and
currently it issues warning when it sees `#!r6rs' token, though it
keeps reading on.


File: gauche-refe.info,  Node: Literals,  Next: Making Procedures,  Prev: Lexical structure,  Up: Core syntax

4.2 Literals
============

 -- Special Form: quote datum
     [R5RS] Evaluates to DATUM.
          (quote x) => x
          (quote (1 2 3)) => (1 2 3)

 -- Reader Syntax: `'DATUM'
     [R5RS] Equivalent to `(quote datum)'.
          'x => x
          '(1 2 3) => (1 2 3)

_Note:_  R5RS says it is an error to alter the value of a literal
expression.  Gauche doesn't check constant-ness of pairs and vectors,
and does not signal an error if you modify them using the destructive
procedures such as `set-car!' and `vector-set!'.  Doing so will cause
unexpected results.  Gauche does check constant-ness of strings, and
signals an error if you try to alter a constant string.


File: gauche-refe.info,  Node: Making Procedures,  Next: Assignments,  Prev: Literals,  Up: Core syntax

4.3 Making Procedures
=====================

 -- Special Form: lambda formals body ...
     [R5RS] Evaluates to a procedure.  The environment in effect when
     this expression is evaluated is stored in the procedure.   When
     the procedure is called, BODY is evaluated sequentially in the
     stored environment extended by the bindings of the formal
     arguments, and returns the value(s) of the last expression in the
     body.

     FORMALS should have one of the following forms:
        * `(VARIABLE ...)' : The procedure takes a fixed number of
          arguments.  The actual arguments are bound to the
          corresponding variables.

        * `VARIABLE' : The procedure takes any number of arguments.
          The actual arguments are collected to form a new list and
          bound to the variable.

        * `(VARIABLE_0 ... VARIABLE_N-1. VARIABLE_N)' : The procedure
          takes at least N arguments.  The actual arguments up to N is
          bound to the corresponding variables.  If more than N
          arguments are given, the rest arguments are collected to form
          a new list and bound to VARIABLE_N.

          (lambda (a b) (+ a b))
            => procedure that adds two arguments

          ((lambda (a b) (+ a b)) 1 2)
            => 3

_Note:_ Some Scheme implementations extend the syntax of FORMALS to
have notation of optional arguments or keyword arguments, similar to
CommonLisp's.  Gauche doesn't have such extensions now.

 -- Macro: cut expr-or-slot expr-or-slot2 ...
 -- Macro: cute expr-or-slot expr-or-slot2 ...
     [SRFI-26] Convenience macros to notate a procedure compactly.
     This form can be used to realize partial application, a.k.a
     sectioning or projection.

     Each EXPR-OR-SLOT must be either an expression or a symbol `<>',
     indicating a 'slot'.  The last EXPR-OR-SLOT can be a symbol
     `<...>', indicating a 'rest-slot'.  `Cut' expands into a `lambda'
     form that takes as many arguments as the number of slots in the
     given form, and whose body is an expression
            (EXPR-OR-SLOT EXPR-OR-SLOT2 ...)
     where each occurrence of `<>' is replaced to the corresponding
     argument.  In case there is a rest-slot symbol, the resulting
     procedure is also of variable arity, and all the extra arguments
     are passed to the call of EXPR-OR-SLOT.  See the fourth example
     below.

          (cut cons (+ a 1) <>)  == (lambda (x2) (cons (+ a 1) x2))
          (cut list 1 <> 3 <> 5) == (lambda (x2 x4) (list 1 x2 3 x4 5))
          (cut list)             == (lambda () (list))
          (cut list 1 <> 3 <...>)
             == (lambda (x2 . xs) (apply list 1 x2 3 xs))
          (cut <> a b)           == (lambda (f) (f a b))

          ;; Usage
          (map (cut * 2 <>) '(1 2 3 4))
          (for-each (cut write <> port) exprs)

     `Cute' is a variation of `cut' that evaluates `expr-or-slot's
     before creating the procedure.

          (cute cons (+ a 1) <>)
             == (let ((xa (+ a 1))) (lambda (x2) (cons xa x2)))

     Gauche also has a built-in procedure `pa$' for partial application
     (*Note Combinators::).

 -- Macro: case-lambda clause ...
     [SRFI-16] Each CLAUSE should have the form (FORMALS EXPR ...),
     where FORMALS is a formal arguments list as for `lambda'.

     This expression evaluates to a procedure that accepts a variable
     number of arguments and is lexically scoped in the same manner as
     procedures resulting from `lambda' expressions.  When the
     procedure is called with some arguments, then the first CLAUSE for
     which the arguments agree with FORMALS is selected, where
     agreement is specified as for the FORMALS of a `lambda' expression.
     The variables of `formals' are bound to the given arguments, and
     the EXPR ... are evaluated within the environment.

     It is an error for the arguments not to agree with the FORMALS of
     any CLAUSE.


File: gauche-refe.info,  Node: Assignments,  Next: Conditionals,  Prev: Making Procedures,  Up: Core syntax

4.4 Assignments
===============

 -- Special Form: set! symbol expression
 -- Special Form: set! (proc arg ...) expression
     [R5RS][SRFI-17] First, EXPRESSION is evaluated.  In the first
     form, the binding of SYMBOL is modified so that next reference of
     SYMBOL will return the result of EXPRESSION.  If SYMBOL is not
     locally bound, the global variable named SYMBOL must already
     exist, or an error is signalled.

     The second form is a "generalized set!" specified in SRFI-17.  It
     is a syntactic sugar of the following form.
          ((setter PROC) ARG ... EXPRESSION)
     Note the order of the arguments of the setter method differs from
     CommonLisp's `setf'.

     Some examples:

          (define x 3)
          (set! x (list 1 2))  => undefined
          x                    => (1 2)

          (set! (car x) 5)     => undefined
          x                    => (5 2)

 -- Macro: set!-values (var ...) expr
     Sets values of multiple variables at once.  EXPR must yield as
     many values as VAR ....  Each value is set to the corresponding
     VAR.
          (define a 0)
          (define b 1)
          (set!-values (a b) (values 3 4)) => undefined
          a => 3
          b => 4
          (set!-values (a b) (values b a)) => undefined
          a => 4
          b => 3

 -- Function: setter proc
     [SRFI-17] Returns a setter procedure associated to the procedure
     PROC.  If no setter is associated to PROC, its behavior is
     undefined.

     A setter procedure G of a procedure F is such that when used as
     `(g a b ... v)', the next evaluation of `(f a b ...)' returns V.

     To associate a setter procedure to another procedure, you can use
     the setter of `setter', like this:
          (set! (setter F) G)

     A procedure's setter can be "locked" to it.  System default
     setters, like `set-car!' for `car', is locked and can't be set by
     the above way.   In order to lock a setter to a user defined
     procedure, use `getter-with-setter' below.

     If PROC is not a procedure, a setter generic function of
     `object-apply' is returned; it allows the applicable object
     extension to work seamlessly with the generalized `set!'.  *Note
     Applicable objects::, for the details.

 -- Function: has-setter? proc
     Returns `#t' if a setter is associated to PROC.

 -- Function: getter-with-setter get set
     [SRFI-17] Takes two procedure GET and SET.  Returns a new
     procedure which does the same thing as GET, and its setter is
     locked to SET.

     The intention of this procedure is, according to the SRFI-17
     document, to allow implementations to inline setters efficiently.
     Gauche hasn't implement such optimization yet.

   A few macros that adopts the same semantics of generalized `set!'
are also provided.  They are built on top of `set!'.

 -- Macro: push! place item
     Conses ITEM and the value of PLACE, then sets the result to PLACE.
     PLACE is either a variable or a form (PROC ARG ...), as the second
     argument of `set!'.   The result of this form is undefined.

          (define x (list 2))
          (push! x 3) => undefined
          x => (3 2)

          (push! (cdr x) 4) => undefined
          x => (3 4 2)

     When PLACE is a list, it roughly expands like the following.

          (push! (foo x y) item)
           ==
           (let ((tfoo foo)
                 (tx x)
                 (ty y))
             ((setter tfoo) tx ty (cons item (tfoo tx ty))))

     Note: Common Lisp's `push' macro takes its argument reverse order.
      I adopted this order since it is consistent with other
     destructive operations.  Perl's `push' function takes the same
     argument order, but it appends ITEM at the end of the array
     (Perl's `unshift' is closer to `push!').  You can use a queue
     (*Note Queue::) if you need a behavior of Perl's `push'.

 -- Macro: pop! place
     Retrieves the value of PLACE, sets its cdr back to PLACE and
     returns its car.

          (define x (list 1 2 3))
          (pop! x) => 1
          x => (2 3)

          (define x (vector (list 1 2 3)))
          x => #((1 2 3))
          (pop! (vector-ref x 0)) => 1
          x => #((2 3))

     Note: This works the same as Common Lisp's `pop'.  Perl's `pop'
     pops value from the end of the sequence; its `shift' does the same
     thing as `pop!'.

 -- Macro: inc! place &optional delta
 -- Macro: dec! place &optional delta
     Evaluates the value of PLACE.  It should be a number.  Adds
     (`inc!') or subtracts (`dec!') DELTA to/from it, and then stores
     the result to PLACE.  The default value of DELTA is 1.

     This is Common Lisp's `incf' and `decf'.

 -- Macro: update! place proc
     Generalized form of `push!' etc.  PROC must be a procedure which
     takes one argument and returns one value.   The original value of
     PLACE is passed to the PROC, then its result is set to PLACE.
          (define a (cons 2 3))
          (update! (car a) (lambda (v) (* v 3))) => undefined
          a => (6 . 3)

          (update! (cdr a) (cut - <> 3))
          a => (6 . 0)


File: gauche-refe.info,  Node: Conditionals,  Next: Binding constructs,  Prev: Assignments,  Up: Core syntax

4.5 Conditionals
================

 -- Special Form: if test consequent alternative
 -- Special Form: if test consequent
     [R5RS] TEST is evaluated.  If it yields a true value, CONSEQUENT
     is evaluated.  Otherwise, ALTERNATIVE is evaluated.  If
     ALTERNATIVE is not provided, it results undefined value.

          (if (number? 3) 'yes 'no) => yes
          (if (number? #f) 'yes 'no) => no

          (let ((x '(1 . 2)))
            (if (pair? x)
                (values (car x) (cdr x))
                (values #f #f)))
            => 1 and 2

 -- Special Form: cond clause1 clause2 ...
     [R5RS][SRFI-61] Each `clause' must be the form
          (TEST EXPR ...)
          (TEST => EXPR)
          (TEST GUARD => EXPR)
          (else EXPR EXPR2 ...)
     The last form can appear only as the last clause.

     `cond' evaluates TEST of each clauses in order, until it yields a
     true value.   Once it yields true, if the clause is the first
     form,  the corresponding EXPRs are evaluated and the result(s) of
     last EXPR is(are) returned; if the clause is the second form, the
     EXPR is evaluated and it must yield a procedure that takes one
     argument.  Then the result of TEST is passed to it, and the
     result(s) it returns will be returned.

     The third form is specified in SRFI-61.  In this form, TEST can
     yield arbitrary number of values.  The result(s) of TEST is(are)
     passed to GUARD; if it returns a true value, EXPR is applied with
     an equivalent argument list, and its result(s) is(are) returned.
     If GUARD returns `#f', the evaluation proceeds to the next clause.

     If no test yields true, and the last clause is not the fourth form
     (else clause), an undefined value is returned.

     If the last clause is else clause and all tests are failed, EXPRs
     in the else clause are evaluated, and its last EXPR's result(s)
     is(are) returned.

          (cond ((> 3 2) 'greater)
                ((< 3 2) 'less)) => greater
          (cond ((> 3 3) 'greater)
                ((< 3 3) 'less)
                (else 'equal)) => equal
          (cond ((assv 'b '((a 1) (b 2))) => cadr)
                (else #f)) => 2

 -- Special Form: case key clause1 clause2 ...
     [R5RS][SRFI-87] KEY may be any expression.  Each CLAUSE should
     have the form
          ((DATUM ...) EXPR EXPR2 ...)
          ((DATUM ...) => PROC)
     where each DATUM is an external representation of some object.
     All the DATUMs must be distinct. The last CLAUSE may be an "else
     clause," which has the form
          (else EXPR EXPR2 ...)
          (else => PROC)

     First, KEY is evaluated and its result is compared against each
     DATUM.  If the result of evaluating KEY is equivalent (using
     `eqv?', *Note Equivalence::), to a DATUM, then the expressions in
     the corresponding clause are evaluated sequentially, and the
     result(s) of the last expression in the CLAUSE is(are) returned
     from the case expression.  The forms containing `=>' are specified
     in SRFI-87.  In these forms, the result of KEY is passed to PROC,
     and its result(s) is(are) returned from the case expression.

     If the result of evaluating KEY is different from every DATUM,
     then if there is an else clause its expressions are evaluated and
     the result(s) of the last is(are) the result(s) of the case
     expression; otherwise the result of the case expression is
     undefined.
          (case (* 2 3)
            ((2 3 5 7) 'prime)
            ((1 4 6 8 9) 'composite)) => composite

          (case (car '(c d))
            ((a) 'a)
            ((b) 'b)) => undefined

          (case (car '(c d))
            ((a e i o u) 'vowel)
            ((w y) 'semivowel)
            (else 'consonant)) => consonant

          (case 6
            ((2 4 6 8) => (cut + <> 1))
            (else => (cut - <> 1))) => 7

          (case 5
            ((2 4 6 8) => (cut + <> 1))
            (else => (cut - <> 1))) => 4

 -- Special Form: and test ...
     [R5RS] The TEST expressions are evaluated from left to right, and
     the value of the first expression that evaluates to a false value
     is returned.  Any remaining expressions are not evaluated.  If all
     the expressions evaluate to true values, the value of the last
     expression is returned.  If there are no expressions then `#t' is
     returned.

          (and (= 2 2) (> 2 1)) => #t
          (and (= 2 2) (< 2 1)) => #f
          (and 1 2 'c '(f g))   => (f g)
          (and)                 => #t

 -- Special Form: or test ...
     [R5RS] The TEST expressions are evaluated from left to right, and
     the value of the first expression that evaluates to a true value
     is returned. Any remaining expressions are not evaluated.  If all
     expressions evaluate to false values, the value of the last
     expression is returned. If there are no expressions then `#f' is
     returned.

          (or (= 2 2) (> 2 1)) => #t
          (or (= 2 2) (< 2 1)) => #t
          (or #f #f #f)        => #f
          (or (memq 'b '(a b c))
              (/ 3 0)) => (b c)

 -- Special Form: when test body ...
 -- Special Form: unless test body ...
     Evaluates TEST.  If it yields true value (or false in case of
     `unless'), BODY ... are evaluated sequentially, and the result(s)
     of the last evaluation is(are) returned.  Otherwise, undefined
     value is returned.


File: gauche-refe.info,  Node: Binding constructs,  Next: Sequencing,  Prev: Conditionals,  Up: Core syntax

4.6 Binding constructs
======================

 -- Special Form: let ((var expr) ...) body ...
 -- Special Form: let* ((var expr) ...) body ...
 -- Special Form: letrec ((var expr) ...) body ...
     [R5RS] Creates a local scope where VAR ... are bound to the value
     of EXPR ..., then evaluates BODY ....  VARs must be symbols, and
     there shouldn't be a duplication.  The value(s) of the last
     expression of BODY ... becomes the value(s) of this form.

     The three forms differ in terms of the scope EXPRs are evaluated.
     `Let' evaluates EXPRs before (outside of) `let' form.  `Let*'
     evaluates EXPRs in the scope where VARs before it are bound.
     `Letrec' evaluates EXPRs in the environment where VARs are already
     bound (to an undefined value, initially).  `letrec' is necessary
     to define mutually recursive local procedures.
          (define x 'top-x)

          (let  ((x 3) (y x)) (cons x y)) => (3 . top-x)
          (let* ((x 3) (y x)) (cons x y)) => (3 . 3)

          (let ((cons (lambda (a b) (+ a b)))
                (list (lambda (a b) (cons a (cons b 0)))))
            (list 1 2))  => (1 2 . 0)

          (letrec ((cons (lambda (a b) (+ a b)))
                   (list (lambda (a b) (cons a (cons b 0)))))
            (list 1 2))  => 3

 -- Macro: let1 var expr body ...
     A convenient macro when you have only one variable.  Expanded as
     follows.

          (let ((VAR EXPR)) BODY ...)

 -- Macro: if-let1 var expr then
 -- Macro: if-let1 var expr then else
     This macro simplifies the following idiom:
          (let1 VAR EXPR
            (if VAR THEN ELSE))

 -- Macro: rlet1 var expr body ...
     This macro simplifies the following idiom:
          (let1 VAR EXPR
            BODY ...
            VAR)

 -- Macro: and-let* (binding ...) body ...
     [SRFI-2] In short, it works like `let*', but returns `#f'
     immediately whenever the expression in BINDINGs evaluates to `#f'.

     Each BINDING should be one of the following form:
    (VARIABLE EXPRESSION)
          The EXPRESSION is evaluated; if it yields true value, the
          value is bound to VARIABLE, then proceed to the next binding.
          If no more bindings, evaluates BODY ....   If EXPRESSION
          yieds `#f', stops evaluation and returns `#f' from `and-let*'.

    (EXPRESSION)
          In this form, VARIABLE is omitted.  EXPRESSION is evaluated
          and the result is used just to determine whether we continue
          or stop further evaluation.

    BOUND-VARIABLE
          In this form, BOUND-VARIABLE should be an identifier denoting
          a bound variable.  If its value is not `#f', we continue the
          evaluation of the clauses.

     Let's see some examples.  The following code searches KEY from an
     assoc-list ALIST and returns its value if found.
          (and-let* ((entry (assoc key alist))) (cdr entry))

     If ARG is a string representation of an exact integer, returns its
     value; otherwise, returns 0:
          (or (and-let* ((num (string->number arg))
                         ( (exact? num) )
                         ( (integer? num) ))
                num)
              0)

     The following is a hypothetical code that searches a certain
     server port number from a few possibilities (environment variable,
     configuration file, ...)
          (or (and-let* ((val (sys-getenv "SERVER_PORT")))
                (string->number val))
              (and-let* ((portfile (expand-path "~/.server_port"))
                         ( (file-exists? portfile) )
                         (val (call-with-input-string portfile port->string)))
                (string->number val))
              8080) ; default


 -- Macro: fluid-let ((var val) ...) body ...
     A macro that emulates dynamic scoped variables.  VARs must be
     variables bound in the scope including `fluid-let' form.  VALs are
     expressions.  `Fluid-let' first evaluates VALs, then evaluates
     BODY ..., with binding VARs to the corresponding values during the
     dynamic scope of BODY ....

     Note that, in multithreaded environment, the change of the value
     of VARs are visible from all the threads.   This form is provided
     mainly for the porting convenience.   Use parameter objects instead
     (*Note Parameters::) for thread-local dynamic state.
          (define x 0)

          (define (print-x) (print x))

          (fluid-let ((x 1))
            (print-x))  => ;; prints 1

 -- Special Form: receive formals expression body ...
     [SRFI-8] This is the way to receive multiple values.  FORMALS can
     be a (maybe-improper) list of symbols.  EXPRESSION is evaluated,
     and the returned value(s) are bound to FORMALS like the binding of
     lambda formals, then BODY ... are evaluated.

          (define (divrem n m)
            (values (quotient n m) (remainder n m)))

          (receive (q r) (divrem 13 4) (list q r))
            => (3 1)

          (receive all (divrem 13 4) all)
            => (3 1)

          (receive (q . rest) (divrem 13 4) (list q rest))
            => (3 (1))

     See also `call-with-values' in *note Multiple values:: which is
     the procedural equivalent of `receive'.  You can use
     `define-values' (*Note Definitions::) to bind multiple values to
     the toplevel variables simultaneously.  Also `let-values' and
     `let*-values' in SRFI-11 (*note Let-values::) provides `let'-like
     syntax with multiple values.

 -- Macro: rec var expr
 -- Macro: rec (name . vars) expr ...
     [SRFI-31] A macro to evaluate an expression with recursive
     reference.

     In the first form, evaluates expr while VAR in EXPR is bound to
     the result of EXPR.  The second form is equivalent to the
     followings.
          (rec NAME (lambda VARS EXPR ...))

     Some examples:

          ;; constant infinite stream
          (rec s (cons 1 (delay s)))

          ;; factorial function
          (rec (f n)
            (if (zero? n)
                1
                (* n (f (- n 1)))))


File: gauche-refe.info,  Node: Sequencing,  Next: Iteration,  Prev: Binding constructs,  Up: Core syntax

4.7 Sequencing
==============

 -- Special Form: begin form ...
     [R5RS] Evaluates FORMs sequentially, and returns the last
     result(s).

     `Begin' doesn't introduce new "block" like `let', that is, you
     can't place "internal define" at the beginning of FORMs generally.
      Semantically `begin' behaves as if FORMs are spliced into the
     surrounding context.  For example, topleve expression like the
     following is the same as two toplevel definitions:

          (begin (define x 1) (define y 2))

     Here's a trickier example:

          (let ()
            (begin
              (define x 2)
              (begin
                (define y 3)
              ))
            (+ x y))

            ==

          (let ()
            (define x 2)
            (define y 3)
            (+ x y))

 -- Macro: begin0 exp0 exp1 ...
     Evaluates EXP0, EXP1, ..., then returns the result(s) of EXP0.
     The name is taken from MzScheme.  This is called `prog1' in
     CommonLisp.

     Unlike `begin', this _does_ creates a "block", for the `begin0'
     form is expanded as follows.

          (receive tmp EXP0
            EXP1 ...
            (apply values tmp))


File: gauche-refe.info,  Node: Iteration,  Next: Quasiquotation,  Prev: Sequencing,  Up: Core syntax

4.8 Iteration
=============

 -- Special Form: do ((variable init [step]) ...) (test expr ...) body
          ...
     [R5RS]

 -- Special Form: let name bindings body ...
     [R5RS]

 -- Macro: dotimes (variable limit [result]) body ...
 -- Macro: dolist (variable lexpr [result]) body ...
     Imported from Common Lisp.  These are equivalent to the following
     forms, respectively.
          (dotimes (variable limit result) body ...)
          ==>
          (do ((tlimit limit)
               (variable 0 (+ variable 1)))
              ((>= variable tlimit) result)
            body ...)

          (dolist (variable lexpr result) body ...)
          ==>
          (begin
            (for-each (lambda (variable) body ...) lexpr)
            (let ((variable '())) result))

 -- Macro: while expr body ...
 -- Macro: while expr `=>' var body ...
 -- Macro: while expr guard `=>' var body ...
     VAR is an identifier and GUARD is a procedure that takes one
     argument.

     In the first form, EXPR is evaluated, and if it yields a true
     value, BODY ... are evaluated.  It is repeated while EXPR yields
     true value.

     In the second form, VAR is bound to a result of EXPR in the scope
     of BODY ....

     In the third form, the value EXPR yields are passed to GUARD, and
     the execution of BODY ... is repeated while GUARD returns a true
     value.  VAR is bound to the result of EXPR.

     The return value of `while' form itself isn't specified.

          (let ((a '(0 1 2 3 4)))
            (while (pair? a)
              (write (pop! a)))) => prints "01234"

          (let ((a '(0 1 2 3 #f 5 6)))
            (while (pop! a) integer? => var
              (write var))) => prints "0123"

 -- Macro: until expr body ...
 -- Macro: until expr guard `=>' var body ...
     Like `while', but the condition is reversed.  That is, the first
     form repeats evaluation of EXPR and BODY ...  until EXPR yields
     true.  In the second form, the result of EXPR is passed to GUARD,
     and the execution is repeated until it returns true.  VAR is bound
     to the result of EXPR.

     (The second form without GUARD isn't useful in `until', since VAR
     would always be bound to `#f').

     The return value of `until' form itself isn't specified.

          (let ((a '(0 1 2 3 4)))
            (until (null? a)
              (write (pop! a)))) => prints "01234"

          (until (read-char) eof-object? => ch
            (write-char ch))
           => reads from stdin and writes char until EOF is read


File: gauche-refe.info,  Node: Quasiquotation,  Next: Definitions,  Prev: Iteration,  Up: Core syntax

4.9 Quasiquotation
==================

 -- Special Form: quasiquote template
     [R5RS] Quasiquotation is a convenient way to build a structure
     that has some fixed parts and some variable parts.  See the
     explanation below.

 -- Reader Syntax: ``TEMPLATE'
     [R5RS] The syntax ``x' is read as `(quasiquote x)'.

 -- Special Form: unquote datum
 -- Special Form: unquote-splicing datum
     [R5RS] These syntaxes have meaning only when they appear in the
     TEMPLATE of quasiquoted form.  The standard says nothing about
     these syntaxes appear outside of quasiquote.  Gauche signals an
     error in such case, for it usually indicates you forget quasiquote
     somewhere.  See the explanation below for the meaning of these.

 -- Reader Syntax: `,DATUM'
 -- Reader Syntax: `,@DATUM'
     [R5RS] The syntaxes `,x' and `,@x' are read as `(unquote x)' and
     `(unquote-splicing x)', respectively.

Quasiquote basics
-----------------

Suppose you want to create a list `(foo bar X Y)', where `foo' and
`bar' are symbols, and X and Y are the value determined at runtime.
(For the sake of explanation, let's assume we have variables X and Y
that provides those values.)  One way to do that is to call the
function `list' explicitly.

     (let ((x 0) (y 1))
       (list 'foo 'bar x y)) => (foo bar 0 1)

   You can do the same thing with quasiquote, like this:

     (let ((x 0) (y 1))
       `(foo bar ,x ,y))  => (foo bar 0 1)

   The difference between the two notations is that the explicit version
quotes the parts that you want to insert literally into the result,
while the quasiquote version _unquotes_ the parts that you don't want
to quote.

   The quasiquote version gets simpler and more readable when you have
lots of static parts with scattered variable parts in your structure.

   That's why quasiquote is frequently used with legacy macros, which
are basically a procedure that create program fragments from variable
parts provided as macro arguments.  See the simple-minded `my-if' macro
that expands to `cond' form:

     (define-macro (my-if test then else)
       `(cond (,test ,then)
              (else ,else)))

     (macroexpand '(my-if (< n 0) n (- n)))
       => (cond ((< n 0) n) (else (- n)))

   Note the two `else's in the macro definition; one isn't unquoted,
thus appears liteally in the output, while another is unquoted and the
corresponding macro argument is inserted in its place.

   Of course you can use quasiquotes unrelated to macros.  It is a
general way to construct structures.  Some even prefer using quasiquote
to explicit construction even most of the structure is variable, for
quasiquoted form can be more concise.  Gauche also tries to minimize
runtime allocation for quasiquoted forms, so it may potentially be more
efficient; see "How static are quasiquoted forms?" below.

Splicing
--------

When `(unquote-splicing EXPR)' appears in a quasiquoted form, EXPR must
evaluate to a list, which is _spliced_ into the surrounding context.
It's easier to see examples:

     (let ((x '(1 2 3)))
       `(a ,@x b)) => (a 1 2 3 b)

     (let ((x '(1 2 3)))
       `(a ,x b)) => (a (1 2 3) b)

     (let ((x '(1 2 3)))
       `#(a ,@x b)) => #(a 1 2 3 b)

   Compare the unquote version and unquote-splicing version.  Splicing
also works within a vector.

Some edge cases
---------------

How static are quasiquated forms?
---------------------------------

When quasiquoted form contains variable parts, what happens at runtime
is just the same as when an explicit form is used: ``(,x ,y)' is
evaluated exactly like `(list x y)'.  However, Gauche tries to minimize
runtime allocation when a quasiquoted form has static parts.

   First of all, if there's no variable parts in quasiquoted form, like
``(a b c)', the entire form is allocated statically.  If there is a
static tail in the sturcture, it is also allocated statically; e.g.
``((,x a b) (,y c d))' works like `(list (cons x '(a b)) (cons y '(c
d)))'.

   Furthermore, when an unquoted expression is a constant expressoin,
Gauche embeds it into the static form.  If you've defined a constant
like `(define-constant x 3)', then the form ``(,x ,(+ x 1))' is
compiled as the constant `'(3 4)'.  (See *note Definitions::, for the
explanation of `define-constant' form.)

   In general it is hard to say which part of quasiquoted form is
compiled as a static datum and which part is not, so you shouldn't
write a code that assumes some parts of the structure returned from
quasiquote are freshly allocated.  In other words, you better avoid
mutating such structures.


File: gauche-refe.info,  Node: Definitions,  Next: Modules,  Prev: Quasiquotation,  Up: Core syntax

4.10 Definitions
================

 -- Special Form: define variable expression
 -- Special Form: define (variable . formals) body ...
     [R5RS] This form has different meanings in the toplevel (without no
     local bindings) or inside a local scope.

     On toplevel, it defines a global binding to a symbol VARIABLE.  In
     the first form, it globally binds a symbol VARIABLE to the value
     of EXPRESSION, in the current module.
          (define x (+ 1 2))
          x => 3
          (define y (lambda (a) (* a 2)))
          (y 8) => 16

     The second form is a syntactic sugar of defining a procedure.  It
     is equivalent to the following form.
          (define (NAME . ARGS) BODY ...)
            == (define NAME (lambda ARGS BODY ...))

     If the form appears inside a local scope (internal define), this
     introduce a local binding of the variable.

     Note that `begin' (*Note Sequencing::) doesn't introduce a new
     scope.  `Define's in the `begin' act as if `begin' and surrounding
     parenthesis are not there.  Thus these two forms are equivalent.
          (let ((x 0))
            (begin
              (define (foo y) (+ x y)))
            (foo 3))
           ==
          (let ((x 0))
            (define (foo y) (+ x y))
            (foo 3))

 -- Macro: define-values (var ...) expr
     EXPR is evaluated, and it should return as many values as VARs.
     Then each value of the results are bound to each variable in VAR
     ....  *Note Let-values::.
          (define-values (lo hi) (min&max 3 -1 15 2))

          lo => -1
          hi => 15

 -- Special Form: define-constant variable expression
 -- Special Form: define-constant (variable . formals) body ...
     Like `define', but that the compiler assumes the value of VARIABLE
     won't change and generates optimized code.

     An error is signalled when you use `set!' to change the value of
     VARIABLE.   It is allowed to redefine VARIABLE, but a warning is
     printed.

 -- Special Form: define-in-module module variable expression
 -- Special Form: define-in-module module (variable . formals) body ...
     This form creates a global binding of VARIABLE in MODULE, which
     must be either a symbol of the module name or a module object.  If
     MODULE is a symbol, the named module must exist.

     EXPRESSION is evaluated in the current module.

     The second form is merely a syntactic sugar of:
          (define-in-module module variable (lambda formals body ...))

   Note: to find out if a symbol has definition (global binding) in the
current module, you can use `global-variable-bound?' (*Note Module
introspection::).


File: gauche-refe.info,  Node: Modules,  Prev: Definitions,  Up: Core syntax

4.11 Modules
============

This section describes the semantics of Gauche modules and its API.
See also *note Writing Gauche modules::, for the conventions Gauche is
using for its modules.

* Menu:

* Module semantics::
* Modules and libraries::
* Defining and selecting modules::
* Using modules::
* Module inheritance::
* Module introspection::
* Predefined modules::


File: gauche-refe.info,  Node: Module semantics,  Next: Modules and libraries,  Prev: Modules,  Up: Modules

4.11.1 Module semantics
-----------------------

Module is an object that maps symbols onto _bindings_, and affects the
resolution of global variable reference.

   Unlike CommonLisp's packages, which map names to symbols, in Gauche
symbols are always `eq?' if two have the same name.  However, Gauche's
symbol doesn't have a 'value' slot in it.  From a given symbol, a
module finds its binding that keeps a value.  Different modules can
associate different bindings to the same symbol, that yield different
values.

     ;; Makes two modules A and B, and defines a global variable 'x' in them
     (define-module A (define x 3))
     (define-module B (define x 4))

     ;;  #<symbol 'x'> ---[module A]--> #<binding that has 3>
     (with-module A x) => 3

     ;;  #<symbol 'x'> ---[module B]--> #<binding that has 4>
     (with-module B x) => 4

   A module can _export_ a part or all of its bindings for other module
to use.  A module can _import_ other modules, and their exported
bindings become visible to the module.  A module can import any number
of modules.

     (define-module A
       (export pi)
       (define pi 3.1416))

     (define-module B
       (export e)
       (define e 2.71828))

     (define-module C
       (import A B))

     (select-module C)
     (* pi e) => 8.539748448

   A module can also be _inherited_, that is, you can extend the
existing module by inheriting it and adding new bindings and exports.
From the new module, all ancestor's bindings (including non-exported
bindings) are visible.  (A new module inherits the `gauche' module by
default, which is why the built-in procedures and syntax of `gauche'
are available in the new module).  From outside, the new module looks
like having all exported bindings of the original module plus the newly
defined and exported bindings.

     ;; Module A defines and exports deg->rad.
     ;; A binding of pi is not exported.
     (define-module A
       (export deg->rad)
       (define pi 3.1416)   ;; not exported
       (define (deg->rad deg) (* deg (/ pi 180))))

     ;; Module Aprime defines and exports rad->deg.
     ;; The binding of pi is visible from inside Aprime.
     (define-module Aprime
       (extend A)
       (export rad->deg)
       (define (rad->deg rad) (* rad (/ 180 pi))))

     ;; Module C imports Aprime.
     (define-module C
       (import Aprime)
       ;; Here, both deg->rad and rad->deg are visible,
       ;; but pi is not visible.
       )

   At any moment of the compilation, there is one "current module"
available, and the global variable reference is looked for from the
module.  If there is a visible binding of the variable, the variable
reference is compiled to the access of the binding.  If the compiler
can't find a visible binding, it marks the variable reference with the
current module, and delays the resolution of binding at the time the
variable is actually used.  That is, when the variable is referenced at
run time, the binding is again looked for from the marked module (_not_
the current module at the run time) and if found, the variable
reference code is replaced for the the code to access the binding.  If
the variable reference is not found even at run time, an 'undefined
variable' error is signalled.

   Once the appropriate binding is found for the global variable, the
access to the binding is hard-wired in the compiled code and the global
variable resolution will never take place again.

   The definition special form such as `define' and `define-syntax'
inserts the binding to the current module.   Thus it may shadow the
binding of imported or inherited modules.

   The resolution of binding of a global variable happens like this.
First, the current module is searched.  Then, each imported module is
taken in the reverse order of import, and searched, including each
module's ancestors.  Note that import is not transitive; imported
module list is not chased recursively.  Finally, ancestors of the
current module are searched in order.

   This order is important when more than one modules defines the same
name and your module imports both.  Assuming your module don't define
that name, if you first import a module `A' then a module `B', you'll
see `B''s binding.

   If you import `A', then `B', then `A' again, the last import takes
precedence; that is, you'll see `A''s binding.


File: gauche-refe.info,  Node: Modules and libraries,  Next: Defining and selecting modules,  Prev: Module semantics,  Up: Modules

4.11.2 Modules and libraries
----------------------------

Modules are run-time data structure; you can procedurally create
modules with arbitrary names at run-time.

   However, most libraries use modules to create their own namespace,
so that they can control which bindings to be visible from library
users.

   Usually a library is provided in the form of one or more Scheme
source file(s), so it is convenient to have a convention to map module
names to file names, and vice versa; then, you can load a library file
and import its module by one action with `use' macro, for example.

   For the time being, Gauche uses a simple rules for this mapping:
Module names are organized hierarchically, using period ``.'' for
separator, e.g. `gauche.mop.validator'.  If such a module is requested
and doesn't exist in the current running environment, Gauche maps the
module name to a pathname by replacing periods to directory separator,
i.e.  `gauche/mop/validator', and look for `gauche/mop/validator.scm'
in the load paths.

   Note that this is just a default behavior.  Theoretically, one
Scheme source file may contain multiple modules, or one module
implementation may span to multiple files.  In future, there may be
some hook to customize this mapping for special cases.  So, when you
are writing routines that deal with modules and library files, do not
apply the above default rule blindly.   Gauche provides two procedures,
`module-name->path' and `path->module-name', to do mapping for you (see
*note Module introspection::, for details).


File: gauche-refe.info,  Node: Defining and selecting modules,  Next: Using modules,  Prev: Modules and libraries,  Up: Modules

4.11.3 Defining and selecting modules
-------------------------------------

 -- Special Form: define-module name body ...
     NAME must be a symbol.  If a module named NAME does not exist,
     create one.  Then evaluates BODY sequentially in the module.

 -- Special Form: select-module name
     Makes a module named NAME as the current module.  It is an error
     if no module named NAME exists.

     If `select-module' is used in the Scheme file, its effect is
     limited inside the file, i.e. even if you load/require a file that
     uses `select-module' internally, the current module of requirer is
     not affected.

 -- Special Form: with-module name body ...
     Evaluates BODY sequentially in the module named NAME.  Returns the
     last result(s).  If no module named NAME, an error is signalled.

 -- Special Form: current-module
     Evaluates to the current module in the compile context.  Note that
     this is a special form, not a function.  Module in Gauche is
     statically determined at compile time.
          (define-module foo
            (export get-current-module)
            (define (get-current-module) (module-name (current-module))))

          (define-module bar
            (import foo)
            (get-current-module)) => foo ; not bar


File: gauche-refe.info,  Node: Using modules,  Next: Module inheritance,  Prev: Defining and selecting modules,  Up: Modules

4.11.4 Using modules
--------------------

 -- Special Form: export symbol ...
     Makes bindings of SYMBOLs in the current module available to
     modules that imports the current module.

 -- Special Form: export-all
     Makes all bindings in the current module available to modules that
     imports it.

 -- Special Form: import module-name ...
     Makes all exported bindings in the module named MODULE-NAME
     available in the current module.   The named modules should exist
     when the compiler sees this special form.

     Note that imports are not transitive.  The modules that
     MODULE-NAMEs are importing are not automatically imported to the
     current module.  This keeps modules' modularity; a library module
     can import whatever modules it needs without worrying about
     polluting the namespace of the user of the module.

 -- Macro: use name
     A convenience macro that combines module imports and on-demand
     file loading.  Basically, `(use foo)' is equivalent to the
     following two forms:
          (require "foo")
          (import foo)
     That is, it loads the library file named "`foo'" (if not yet
     loaded) which defines a module named `foo' in it, and then import
     the module `foo' into the current module.

     Although the files and modules are orthogonal concept, it is
     practically convenient to separate files by modules.  Gauche
     doesn't force you to do so, and you can always use `require' and
     `import' separately.  However, all modules provided with Gauche
     are arranged so that they can be used by `use' macro.

     If a module is too big to fit in one file, you can split them into
     several subfiles and one main file.  The main file defines the
     module, and either loads, requires, or autoloads subfiles.

     Actually, the file pathname of the given module name is obtained
     by the procedure `module-name->path' below.  The default rule is
     to replace periods ``.'' in the NAME for ``/'';  for example,
     `(use foo.bar.baz)' is expanded to:
          (require "foo/bar/baz")
          (import foo.bar.baz)
     This is not very Scheme-ish way, but nevertheless convenient.  In
     future, there may be some mechanism to customize this mapping.


File: gauche-refe.info,  Node: Module inheritance,  Next: Module introspection,  Prev: Using modules,  Up: Modules

4.11.5 Module inheritance
-------------------------

The export-import mechanism doesn't work well in some cases, such as:

   * You want to create a module that is mostly the same as the
     existing one, but adding or altering some definitions.

   * You wrote a bunch of related modules that are often used together,
     and not want your users to repeat a bunch of 'use' forms every time
     they use your module.

   You can use module inheritance in these cases.

 -- Macro: extend module-name ...
     Makes the current module inherit from named modules.  The current
     inheritance information is altered by the inheritance information
     calculated from given modules.

     A new module inherits from `gauche' module when created.  If you
     put `(extend scheme)' in that module, for example, the module
     resets to inherit directly from `scheme' module that has only
     bindings defined in R5RS, hence, after the export form, you can't
     use 'import' or any other `gauche'-specific bindings in the module.

     If a named module is not defined yet, `extend' tries to load it,
     using the same convention `use' macro does.

     A module can inherit multiple modules, exactly the same way as a
     class can inherit from multiple classes.  The resolution of order
     of inheritance needs to be explained a bit.

     Each module has a _module precedence list_, which lists modules in
     the order of how they are searched.  When the module inherits
     multiple modules, module precedence lists of inherited modules are
     merged into a single list, keeping the constraints that: (1) if a
     module A appears before module B in some module precedence list, A
     has to appear before B in the resulting module precedence list;
     and (2) if a module A appears before module B in `extend' form, A
     has to appear before B in the resulting module precedence list.
     If no precedence list can be constructed with these constraints,
     an error is signalled.

   For example, suppose you wrote a library in modules `mylib.base',
`mylib.util' and `mylib.system'.  You can bundle those modules into one
module by creating a module `mylib', as follows:

     (define-module mylib
       (extend mylib.system mylib.util mylib.base))

   The user of your module just says `(use mylib)' and all exported
symbols from three submodules become available.


File: gauche-refe.info,  Node: Module introspection,  Next: Predefined modules,  Prev: Module inheritance,  Up: Modules

4.11.6 Module introspection
---------------------------

This subsection lists procedures that operates on modules at run-time.
With these procedures you can introspect the modules, create new modules
procedurally, or check the existence of certain modules/libraries, for
example.  However, don't forget that modules are primarily compile-time
structures.  Tweaking modules at run-time is only for those who know
what they are doing.

 -- Builtin Class: <module>
     A module class.

 -- Function: module? obj
     Returns true if OBJ is a module.

 -- Function: find-module name
     Returns a module object whose name is a symbol NAME.  If the named
     module doesn't exist, `#f' is returned.

 -- Function: make-module name &keyword if-exists
     Creates and returns a module that has symbol NAME.  If the named
     module already exists, the behavior is specified by IF-EXISTS
     keyword argument.  If it is `:error' (default), an error is
     signalled.  If it is `#f', `#f' is returned.

     Note that creating modules on-the-fly isn't usually necessary for
     ordinal scripts, since to execute already written program requires
     modules to be specified by name, i.e. syntax `define-module',
     `import', `extend', `with-module' all takes module names, not
     modules.  It is because module are inherently compile-time
     structure.  However, there are some cases that dynamically created
     modules are useful, especially the program itself is dynamically
     created.  You can pass a module to `eval' to compile and evaluate
     such dynamically created programs in it (*Note Eval and repl::).

     You can also pass `#f' to NAME to create _anonymous_ module.
     Anonymous modules can't be looked up by `find-module', nor can be
     imported or inherited (since `import' and `extend' take module
     names, not modules).  It is useful when you want to have a
     temporary, segregated namespace dynamically--for example, you can
     create an anonymous module to evaluate code fragments sent from
     other program, and discards the module when the connection is
     terminated.  Anonymous modules are not registered in the system
     dictionary and are garbage collected when nobody keeps reference
     to it.

 -- Function: all-modules
     Returns a list of all named modules.  Anonymous modules are not
     included.

 -- Function: module-name module
 -- Function: module-imports module
 -- Function: module-exports module
 -- Function: module-table module
     Accessors of a module object.  Returns the name of the module (a
     symbol), list of imported modules, list of exported symbols, and a
     hash table that maps symbols to bindings, of the MODULE are
     returned, respectively.

     If the MODULE exports all symbols, `module-exports' returns `#t'.

     It is an error to pass a non-module object.

 -- Function: module-parents module
 -- Function: module-precedence-list module
     Returns the information of module inheritance.  `Module-parents'
     returns the modules MODULE directly inherits from.
     `Module-precedence-list' returns the module precedence list of
     MODULE (*Note Module inheritance::).

 -- Function: global-variable-bound? module symbol
     Returns true if SYMBOL's global binding is visible from MODULE.
     MODULE must be a module object or a symbol name of an existing
     module.

     Note: there used to be the `symbol-bound?' procedure to check
     whether a global variable is bound.  It is deprecated and the new
     code should use `global-variable-bound?' instead.  The reason of
     change is that because of the name `symbol-bound?' and the fact
     that it assumes current-module by default, it gives an illusion as
     if a global bound value is somewhat 'stored' in a symbol itself
     (like CommonLisp's model).  It caused a lot of confusion when the
     current module differs between compile-time and runtime.  The new
     name and API made it clear that you are querying module's property.

 -- Function: global-variable-ref module symbol &optional default
     Returns a value globally bound to the SYMBOL visible from MODULE.
     MODULE must be a module object or a symbol name of an existing
     module.  If there's no visible global binding from MODULE for
     SYMBOL, an error is signalled, unless the DEFAULT argument is
     provided, in which case it is returned instead.

 -- Function: module-name->path symbol
     Converts a module name SYMBOL to a fragment of pathname string
     (which you use for `require' and `provide').

 -- Function: path->module-name string
     Reverse function of `module-name->path'.

   If you want to find out specific libraries and/or modules are
installed in the system and available from the program, see *note
Operations on libraries::.


File: gauche-refe.info,  Node: Predefined modules,  Prev: Module introspection,  Up: Modules

4.11.7 Predefined modules
-------------------------

Several modules are predefined in Gauche.

 -- Builtin Module: null
     This module corresponds to the null environment referred in R5RS.
     This module contains only syntactic bindings of R5RS syntax.

 -- Builtin Module: scheme
     This module contains all the binding of `null' module, and the
     binding of procedures defined in R5RS.

   Note that if you change the current module to `null' or `scheme' by
`select-module', there will be no way to switch back to other modules,
since module-related syntaxes and procedures are not visible from
`null' and `scheme' modules.

 -- Builtin Module: gauche
     This module contains all the bindings of `scheme' module, plus
     Gauche specific built-in procedures.

 -- Builtin Module: user
     This module is the default module the user code is compiled.  all
     the bindings of `gauche' module is imported.


File: gauche-refe.info,  Node: Macros,  Next: Core library,  Prev: Core syntax,  Up: Top

5 Macros
********

Gauche supports both R5RS hygienic macros and traditional macros.

   Macro of Lisp-family language is very different feature from ones of
other languages, such as C preprocessor macros.  It allows you to
extend the original language syntax.  You can use macros to change
Gauche syntax so that you can run a Scheme program written to other
Scheme implementations, and you can even design your own mini-language
to solve your problem easily.

* Menu:

* Hygienic Macros::
* Traditional Macros::
* Macro expansion::
* Macro utilities::


File: gauche-refe.info,  Node: Hygienic Macros,  Next: Traditional Macros,  Prev: Macros,  Up: Macros

5.1 Hygienic Macros
===================

R5RS hygienic macro is based on a special pattern language, and
guaranteed that no "variable capture" occurs.  "Variable capture" means
that if you insert new variable bindings in the expanded form, the new
bindings shadows the bindings in the form passed to the macro.

 -- Special Form: define-syntax name transformer-spec
     [R5RS]

 -- Special Form: let-syntax ((name transformer-spec) ...) body
 -- Special Form: letrec-syntax ((name transformer-spec) ...) body
     [R5RS]

 -- Special Form: syntax-rules literals clause1 clause2 ...
     [R5RS]


File: gauche-refe.info,  Node: Traditional Macros,  Next: Macro expansion,  Prev: Hygienic Macros,  Up: Macros

5.2 Traditional Macros
======================

 -- Special Form: define-macro name procedure
 -- Special Form: define-macro (name . formals) body ...
     Defines NAME to be a global macro whose transformer is PROCEDURE.
     The second form is a shorthand notation of the following form:
          (define-macro name (lambda formals body ...))

     When a form `(name ARG ...)' is seen by the compiler, it calls
     PROCEDURE with ARG ....  When PROCEDURE returns, the compiler
     inserts the returned form in place of the original form, and
     compile it again.


File: gauche-refe.info,  Node: Macro expansion,  Next: Macro utilities,  Prev: Traditional Macros,  Up: Macros

5.3 Macro expansion
===================

 -- Function: macroexpand form
 -- Function: macroexpand-1 form
     If FORM is a list and its first element is a variable globally
     bound to a macro, `macroexpand-1' invokes its macro transformer and
     returns the expanded form.  Otherwise, returns FORM as is.

     `macroexpand' repeats `macroexpand-1' until the FORM can't be
     expanded.

     These procedures can be used to expand globally defined macros.

 -- Special Form: %macroexpand form
 -- Special Form: %macroexpand-1 form


File: gauche-refe.info,  Node: Macro utilities,  Prev: Macro expansion,  Up: Macros

5.4 Macro utilities
===================

 -- Macro: syntax-error msg arg ...
 -- Macro: syntax-errorf fmt arg ...
     Signal an error.  They are same as `error' and `errorf' (*Note
     Signalling exceptions::), except that the error is signalled at
     macro-expansion time (i.e. compile time) rather than run time.

     They are useful to tell the user the wrong usage of macro in the
     comprehensive way, instead of the cryptic error from the macro
     expander.   Because of the purpose, ARG ... are first passed to
     `unwrap-syntax' described below, to strip off the internal
     syntactic binding informations.

          (define-syntax my-macro
            (syntax-rules ()
              ((_ a b)   (foo2 a b))
              ((_ a b c) (foo3 a b c))
              ((_ . ?)
               (syntax-error "malformed my-macro" (my-macro . ?)))))

          (my-macro 1 2 3 4)
            => error: "malformed my-macro: (mymacro 1 2 3 4)"


 -- Function: unwrap-syntax form
     Removes internal syntactic information from FORM.  In order to
     implement a hygienic macro, macro expander replaces symbols in the
     macro form for identifiers, which captures the syntactic
     environment where they are defined.  Although it is necessary
     information for the compiler, it is rather confusing for users if
     it appears in the messages.  This function replaces occurrences of
     identifiers in FORM to the original symbols.


File: gauche-refe.info,  Node: Core library,  Next: Object system,  Prev: Macros,  Up: Top

6 Core library
**************

* Menu:

* Equivalence::
* Numbers::
* Booleans::
* Pairs and Lists::
* Symbols::
* Keywords::
* Identifiers::
* Characters::
* Character set::
* Strings::
* Regular expression::
* Vectors::
* Hashtables::
* Treemaps::
* Weak pointers::
* Control features::
* Exceptions::
* Eval and repl::
* Input and output::
* Loading Programs::
* Comparison and sorting::
* System interface::
* Development helper API::


File: gauche-refe.info,  Node: Equivalence,  Next: Numbers,  Prev: Core library,  Up: Core library

6.1 Equivalence
===============

Scheme has three different general equivalence test predicates.  Other
than these, some types have their own comparison predicates.

 -- Function: eq? obj1 obj2
     [R5RS] This is the fastest and finest predicate.  Returns `#t' if
     OBJ1 and OBJ2 are allocated objects of the same types, and denote
     the same location.  Returns `#t' if both objects are `#f', `#t',
     or `()'.  You can think EQ? as a pointer comparison.  Note that
     the result is unspecified in Scheme standard when both objects are
     characters or numbers.

          (eq? #t #t)               => #t
          (eq? #t #f)               => #f
          (eq? 'a 'a)               => #t
          (eq? 'a 'b)               => #f
          (eq? (list 'a) (list 'a)) => #f
          (let ((x (list 'a)))
            (eq? x x))              => #t

 -- Function: eqv? obj1 obj2
     [R5RS] When OBJ1 and OBJ2 are both exact or both inexact numbers,
     EQV? returns `#t' iff `(= OBJ1 OBJ2)' is true.  When OBJ1 and OBJ2
     are both characters, EQV? returns `#t' iff `(char=? OBJ1 OBJ2)' is
     true.  Otherwise, `eqv?' is the same as `eq?' on Gauche.

          (eqv? #\a #\a)             => #t
          (eqv? #\a #\b)             => #f
          (eqv? 1.0 1.0)             => #t
          (eqv? 1 1)                 => #t
          (eqv? 1 1.0)               => #f
          (eqv? (list 'a) (list 'a)) => #f
          (let ((x (list 'a)))
            (eqv? x x))              => #t

 -- Function: equal? obj1 obj2
     [R5RS+] If OBJ1 and OBJ2 are both aggregate types, `equal?'
     compares its elements recursively.  Otherwise, `equal?' behaves
     the same as `eqv?'.

     If OBJ1 and OBJ2 are other than booleans, numbers, characters,
     pairs, strings and vectors, and the class of both objects are the
     same, `equal?' calls the generic function `object-equal?'.  By
     defining the method, users can extend the behavior of `equal?' for
     user-defined classes.

          (equal? (list 1 2) (list 1 2)) => #t
          (equal? "abc" "abc")           => #t
          (equal? 100 100)               => #t
          (equal? 100 100.0)             => #f

     Note: If both OBJ1 and OBJ2 have circular structure, `equal?' may
     diverge.  You might want to use `isomorph?' instead (see *note
     Determine isomorphism::).

 -- Generic Function: object-equal? obj1 obj2
     This generic function is called when `equal?' is called on the
     objects it doesn't know about.  You can define this method on your
     class so that `equal?' can check equivalence.   This method is
     supposed to return `#t' if OBJ1 is equal to OBJ2, `#f' otherwise.
     If you want to check equivalence of elements recursively, do not
     call `object-equal?' directly; call `equal?' on each element.

          (define-class <foo> ()
            ((x :init-keyword :x)
             (y :init-keyword :y)))

          (define-method object-equal? ((a <foo>) (b <foo>))
            (and (equal? (slot-ref a 'x) (slot-ref b 'x))
                 (equal? (slot-ref a 'y) (slot-ref b 'y))))

          (equal? (make <foo> :x 1 :y (list 'a 'b))
                  (make <foo> :x 1 :y (list 'a 'b)))
            => #t

          (equal? (make <foo> :x 1 :y (make <foo> :x 3 :y 4))
                  (make <foo> :x 1 :y (make <foo> :x 3 :y 4)))
            => #t

   Sometimes you want to test if two aggregate structures are
topologically equal, i.e., if one has a shared substructure, the other
has a shared substructure in the same way.  `Equal?' can't handle it;
module `util.isomorph' provides a procedure `isomorphic?' which does
the job (*Note Determine isomorphism::).


File: gauche-refe.info,  Node: Numbers,  Next: Booleans,  Prev: Equivalence,  Up: Core library

6.2 Numbers
===========

Gauche supports the following types of numbers
multi-precision exact integer
     There's no limit of the size of number except the memory of the
     machine.

multi-precision exact non-integral rational numbers.
     Both denominator and numerator are represented by exact integers.
     There's no limit of the size of number except the memory of the
     machine.

inexact floating-point real numbers
     Using `double'-type of underlying C compiler, usually IEEE 64-bit
     floating point number.

inexact floating-point complex numbers
     Real part and imaginary part are represented by inexact
     floating-point real numbers.

* Menu:

* Number classes::
* Numerical predicates::
* Numerical comparison::
* Arithmetics::
* Numerical conversions::
* Bitwise operations::


File: gauche-refe.info,  Node: Number classes,  Next: Numerical predicates,  Prev: Numbers,  Up: Numbers

6.2.1 Number classes
--------------------

 -- Builtin Class: <number>
 -- Builtin Class: <complex>
 -- Builtin Class: <real>
 -- Builtin Class: <rational>
 -- Builtin Class: <integer>
     These classes consist a class hierarchy of number objects.
     `<complex>' inherits `<number>', `<real>' inherits
     `<complex>',`<rational>' inherits `<real>'  and `<integer>'
     inherits `<rational>'.

     Note that these classes does not exactly corresponds to the number
     hierarchy defined in R5RS.  Especially, only exact integers are
     the instances of the `<integer>' class.  That is,
          (integer? 1)        => #t
          (is-a? 1 <integer>) => #t
          (is-a? 1 <real>)    => #t

          (integer? 1.0)        => #t
          (is-a? 1.0 <integer>) => #f
          (is-a? 1.0 <real>)    => #t

          (class-of (expt 2 100)) => #<class <integer>>
          (class-of (sqrt -3)) => #<class <complex>>


File: gauche-refe.info,  Node: Numerical predicates,  Next: Numerical comparison,  Prev: Number classes,  Up: Numbers

6.2.2 Numerical predicates
--------------------------

 -- Function: number? obj
 -- Function: complex? obj
 -- Function: real? obj
 -- Function: rational? obj
 -- Function: integer? obj
     [R5RS] Returns `#t' if OBJ is a number, a complex number, a real
     number, a rational number or an integer, respectively.   In
     Gauche, a set of numbers is the same as a set of complex numbers,
     and a set of rational numbers is the same as a set of real numbers
     (since we have only limited-precision floating numbers).

          (complex? 3+4i)   => #t
          (complex? 3)      => #t
          (real? 3)         => #t
          (real? -2.5+0.0i) => #t
          (real? #e1e10)    => #t
          (integer? 3+0i)   => #t
          (integer? 3.0)    => #t

 -- Function: exact? obj
 -- Function: inexact? obj
     [R5RS] Returns `#t' if OBJ is an exact number and an inexact
     number, respectively.

          (exact? 1)       => #t
          (exact? 1.0)     => #f
          (inexact? 1)     => #f
          (inexact? 1.0)   => #t

          (exact? (modulo 5 3)) => #t
          (inexact? (modulo 5 3.0)) => #f

 -- Function: zero? z
     [R5RS] Returns `#t' if a number Z equals to zero.

          (zero? 1)        => #f
          (zero? 0)        => #t
          (zero? 0.0)      => #t
          (zero? 0.0+0.0i) => #t

 -- Function: positive? x
 -- Function: negative? x
     [R5RS] Returns `#t' if a real number X is positive and negative,
     respectively.  It is an error to pass a non-real number.

 -- Function: odd? n
 -- Function: even? n
     [R5RS] Returns `#t' if an integer N is odd and even, respectively.
     It is an error to pass a non-integral number.

          (odd? 3)     => #t
          (even? 3)    => #f
          (odd? 3.0)   => #t

 -- Function: fixnum? n
 -- Function: bignum? n
     Returns `#t' iff N is an exact integer whose internal
     representation is FIXNUM and BIGNUM, respectively.  Portable
     Scheme programs don't need to care about the internal
     representation of integer.   These are for certain low-level
     routines that does particular optimization.


File: gauche-refe.info,  Node: Numerical comparison,  Next: Arithmetics,  Prev: Numerical predicates,  Up: Numbers

6.2.3 Numerical comparison
--------------------------

 -- Function: `=' z1 z2 z3 ...
     [R5RS] If all the numbers Z are equal, returns `#t'.

          (= 2 2)          => #t
          (= 2 3)          => #f
          (= 2 2.0)        => #t
          (= 2 2.0 2.0+0i) => #t
          (= 2/4 1/2)      => #t

 -- Function: `<' x1 x2 x3 ...
 -- Function: `<=' x1 x2 x3 ...
 -- Function: `>' x1 x2 x3 ...
 -- Function: `>=' x1 x2 x3 ...
     [R5RS] Returns `#t' If all the real numbers X are monotonically
     increasing, monotonically nondecreasing, monotonically decreasing,
     or monotonically nonincreasing, respectively.

 -- Function: max x1 x2 ...
 -- Function: min x1 x2 ...
     [R5RS] Returns a maximum or minimum number in the given real
     numbers, respectively.

 -- Function: min&max x1 x2 ...
     Returns a maximum and minimum number in the given real numbers.


File: gauche-refe.info,  Node: Arithmetics,  Next: Numerical conversions,  Prev: Numerical comparison,  Up: Numbers

6.2.4 Arithmetics
-----------------

 -- Function: `+' z ...
 -- Function: `*' z ...
     [R5RS] Returns the sum or the product of given numbers,
     respectively.  If no argument is given, `(+)' yields 0 and `(*)'
     yields 1.

 -- Function: `-' z1 z2 ...
 -- Function: `/' z1 z2 ...
     [R5RS] If only one number Z1 is given, returns its negation and
     reciprocal, respectively.

     If more than one number are given, returns:
          Z1 - Z2 - Z3 ...
          Z1 / Z2 / Z3 ...
     respectively.

          (- 3)       => -3
          (- -3.0)    => 3.0
          (- 5+2i)    => -5.0-2.0i
          (/ 3)       => 1/3
          (/ 5+2i)    => 0.172413793103448-0.0689655172413793i

          (- 5 2 1)     => 2
          (- 5 2.0 1)   => 2.0
          (- 5+3i -i)   => 5.0+2.0i
          (/ 14 6)      => 7/3
          (/ 6+2i 2)    => 3.0+1.0i

     Note: Gauche didn't have exact rational number support until 0.8.8;
     before that, `/' coerced the result to inexact even if both
     divisor and dividend were exact numbers, when the result wasn't a
     whole number.  It is not the case anymore.

     If the existing code relies on the old behavior, it runs very
     slowly on the newer versions of Gauche, since the calculation
     proceeds with exact rational arithmetics that is much slower than
     floating point arithmetics.  You want to use `/.' below to use
     fast inexact arithmetics (unless you need exact results).

 -- Function: +. z ...
 -- Function: *. z ...
 -- Function: -. z1 z2 ...
 -- Function: /. z1 z2 ...
     Like `+', `*', `-', and `/', but the arguments are coerced to
     inexact number.  So they always return inexact number.  These are
     useful when you know you don't need exact calculation and want to
     avoid accidental overhead of bignums and/or exact rational numbers.

 -- Function: abs z
     [R5RS+] For real number Z, returns an absolute value of it.  For
     complex number Z, returns the magnitude of the number.  The
     complex part is Gauche extension.
          (abs -1)   => 1
          (abs -1.0) => 1.0
          (abs 1+i)  => 1.4142135623731

 -- Function: quotient n1 n2
 -- Function: remainder n1 n2
 -- Function: modulo n1 n2
     [R5RS] Returns the quotient, remainder and modulo of dividing an
     integer N1 by an integer N2.   The result is an exact number only
     if both N1 and N2 are exact numbers.

     Remainder and modulo differ when either one of the arguments is
     negative.  Remainder R and quotient Q have the following
     relationship.
            N1 = Q * N2 + R
     where `abs(Q) = floor(abs(N1)/abs(N2))'.  Consequently, R's sign
     is always the same as N1's.

     On the other hand, modulo works as expected for positive N2,
     regardless of the sign of N1 (e.g. `(modulo -1 N2) == N2 - 1').
     If N2 is negative, it is mapped to the positive case by the
     following relationship.
            modulo(N1, N2) = -modulo(-N1, -N2)
     Consequently, MODULO's sign is always the same as N2's.
          (remainder 10 3)    => 1
          (modulo 10 3)       => 1

          (remainder -10 3)   => -1
          (modulo -10 3)      => 2

          (remainder 10 -3)   => 1
          (modulo 10 -3)      => -2

          (remainder -10 -3)  => -1
          (modulo -10 -3)     => -1

 -- Function: quotient&remainder n1 n2
     Calculates the quotient and the remainder of dividing integer N1
     by integer N2 simultaneously, and returns them as two values.

 -- Function: gcd n ...
 -- Function: lcm n ...
     [R5RS] Returns the greatest common divisor or the least common
     multiplier of the given integers, respectively

 -- Function: numerator q
 -- Function: denominator q
     [R5RS] Returns the numerator and denominator of a rational number
     Q.

 -- Function: floor x
 -- Function: ceiling x
 -- Function: truncate x
 -- Function: round x
     [R5RS] The argument X must be a real number.  `Floor' and
     `ceiling' return a maximum integer that isn't greater than X and a
     minimum integer that isn't less than X, respectively.  TRUNCATE
     returns an integer that truncates X towards zero.  ROUND returns
     an integer that is closest to X.  If fractional part of X is
     exactly 0.5, ROUND returns the closest even integer.

 -- Function: floor->exact x
 -- Function: ceiling->exact x
 -- Function: truncate->exacte x
 -- Function: round->exact x
     These are convenience procedures of the popular phrase
     `(inexact->exact (floor x))' etc.

 -- Function: clamp x &optional min max
     Returns
           MIN if X `<' MIN
           X   if MIN `<=' X `<=' MAX
           MAX if MAX `<' X
     If MIN or MAX is omitted or `#f', it is regarded as -INFINITY or
     +INFINITY, respectively.  Returns an exact integer only if all the
     given numbers are exact integers.
          (clamp 3.1 0.0 1.0) => 1.0
          (clamp 0.5 0.0 1.0) => 0.5
          (clamp -0.3 0.0 1.0) => 0.0
          (clamp -5 0)        => 0
          (clamp 3724 #f 256) => 256

 -- Function: exp z
 -- Function: log z
 -- Function: log z1 z2
 -- Function: sin z
 -- Function: cos z
 -- Function: tan z
 -- Function: asin z
 -- Function: acos z
 -- Function: atan z
     [R5RS][R6RS] Transcendental functions.  Work for complex numbers
     as well.

     The two-argument version of `log' is added in R6RS, and returns
     base-Z2 logarithm of Z1.

 -- Function: atan y x
     [R5RS] For real numbers X and Y, returns `atan(Y/X)'.

 -- Function: sinh z
 -- Function: cosh z
 -- Function: tanh z
 -- Function: asinh z
 -- Function: acosh z
 -- Function: atanh z
     Hyperbolic trigonometric functions.  Work for complex numbers as
     well.

 -- Function: sqrt z
     [R5RS] Returns a square root of a complex number Z.  The branch
     cut scheme is the same as Common Lisp.  For real numbers, it
     returns a positive root.

 -- Function: expt z1 z2
     [R5RS] Returns Z1^Z2 (Z1 powered by Z2), where Z1 and Z2 are
     complex numbers.

 -- Function: fixnum-width
 -- Function: greatest-fixnum
 -- Function: least-fixnum
     [R6RS] These procedures return the width of fixnum (W), the
     greatest integer representable by fixnum (2^W - 1), and the least
     integer representable by fixnum (- 2^W), respectively.  You might
     want to care the fixnum range when you are writing a
     performance-critical section.

     These names are defined in R6RS.  Common Lisp and ChezScheme have
     `most-positive-fixnum' and `most-negative-fixnum'.


File: gauche-refe.info,  Node: Numerical conversions,  Next: Bitwise operations,  Prev: Arithmetics,  Up: Numbers

6.2.5 Numerical conversions
---------------------------

 -- Function: make-rectangular x1 x2
 -- Function: make-polar x1 x2
     [R5RS] Creates a complex number from two real numbers, X1 and X2.
     `make-rectangular' returns X1 + iX2.  `make-polar' returns
     X1e^(iX2).

 -- Function: real-part z
 -- Function: imag-part z
 -- Function: magnitude z
 -- Function: angle z
     [R5RS] Decompose a complex number Z and returns a real number.
     `real-part' and `imag-part' return Z's real and imaginary part,
     respectively.  `magnitude' and `angle' return Z's magnitude and
     angle, respectively.

 -- Function: decode-float x
     For a given floating-point number, returns a vector of three exact
     integers, `#(M, E, SIGN)', where
            X = (* SIGN M (expt 2.0 E))
            SIGN is either 1, 0 or -1.
     The API is taken from ChezScheme.
          (decode-float 3.1415926)
           => #(7074237631354954 -51 1)
          (* 7074237631354954 (expt 2.0 -51))
           => 3.1415926

 -- Function: fmod x y
 -- Function: modf x
 -- Function: frexp x
 -- Function: ldexp x n
     [POSIX] These procedures can be used to compose and decompose
     floating point numbers.  `Fmod' computes the remainder of dividing
     X by Y, that is, it returns X-N*Y where N is the quotient of X/Y
     rounded towards zero to an integer.   `Modf' returns two values; a
     fractional part of X and an integral part of X.   `Frexp' returns
     two values, FRACTION and EXPONENT of X, where X = FRACTION *
     2^EXPONENT, and 0 <= FRACTION <= 0.5.  LDEXP is a reverse
     operation of `frexp'; it returns a real number X * 2^N.
          (fmod 32.1 10.0)  => 2.1
          (fmod 1.5 1.4)    => 0.1
          (modf 12.5)       => 0.5 and 12.0
          (frexp 3.14)      => 0.785 and 2
          (ldexp 0.785 2)   => 3.14

 -- Function: exact->inexact z
 -- Function: inexact->exact z
     [R5RS] Converts an exact number to an inexact number, or vice
     versa.

     Since we have finite precision to represent floating numbers, it
     is always possible to convert arbitrary inexact real number to an
     exact rational number.  It may not be what you want, though.  See
     the following example:

          (inexact->exact 3.1415926535879)
            => 7074237752024177/2251799813685248

     If you intend to obtain an exact integer by rounding an inexact
     real number, you have to use one of `floor', `ceiling', `truncate'
     or `round' explicitly.  You may also use `floor->exact',
     `round->exact' etc.

          (inexact->exact (round 3.1415926535879)) => 3

          (round->exact 3.1415926535879)           => 3

     Gauche doesn't support exact complex numbers.  Passing an inexact
     complex number with non-zero imaginary part to `inexact->exact'
     causes an error.

     If you pass an inexact number to `exact->inexact' or an exact
     number to `inexact->exact', Gauche returns the argument as is,
     instead of reporting an error.  This is also an implementation
     dependent behavior and you shouldn't count on that.

 -- Function: number->string z &optional radix use-upper?
 -- Function: string->number string &optional radix
     [R5RS+] These procedures convert a number and its string
     representation in radix RADIX system.  RADIX must be between 2 and
     36 inclusive.  If RADIX is omitted, 10 is assumed.

     `Number->string' takes a number Z and returns a string.  If Z is
     not an exact integer, RADIX must be 10.  For the numbers with
     radix more than 10, lower case alphabet character is used for
     digits, unless the optional argument USE-UPPER? is true, in that
     case upper case characters are used.  The argument USE-UPPER? is
     Gauche's extension.

     `String->number' takes a string STRING and parses it as a number
     in radix RADIX system.  If the number looks like non-exact number,
     only radix 10 is allowed.  If the given string can't be a number,
     `#f' is returned.

 -- Generic Function: x->number obj
 -- Generic Function: x->integer obj
     Generic coercion functions.  Returns `natural' interpretation of
     OBJ as a number or an exact integer, respectively.  The default
     methods are defined for numbers and strings; a string is
     interpreted by STRING->NUMBER, and if the string can't be
     interpreted as a number, 0 is returned.  Other OBJ is simply
     converted to 0.  If OBJ is naturally interpreted as a number that
     is not an exact integer, `x->integer' uses `round' and
     `inexact->exact' to obtain an integer.

     Other class may provide a method to customize the behavior.


File: gauche-refe.info,  Node: Bitwise operations,  Prev: Numerical conversions,  Up: Numbers

6.2.6 Bitwise operations
------------------------

These procedures treat integers as half-open bit vectors.  If an
integer is positive, it is regarded as if infinite number of zeros are
padded to the left.  If an integer is negative, it is regarded in 2's
complement form, and infinite number of 1's are padded to the left.

   The API is consistent to SLIB's "logical" module.

 -- Function: ash n count
     Shifts integer N left with COUNT bits.  If COUNT is negative,
     `ash' shifts N right with -COUNT bits.

          ; Note: 6  == [...00110], and
          ;       -6 == [...11010]
          (ash 6 2)   => 24  ;[...0011000]
          (ash 6 -2)  => 1   ;[...0000001]
          (ash -6 2)  => -24 ;[...1101000]
          (ash -6 -2) => -2  ;[...1111110]

 -- Function: logand n1 n2 ...
 -- Function: logior n1 n2 ...
 -- Function: logxor n1 n2 ...
     Returns bitwise and, bitwise inclusive or and bitwise exclusive or
     of two or more integers N1, N2 ....

 -- Function: lognot n
     Returns bitwise not of an integer N.

 -- Function: logtest n1 n2 ...
     == `(not (zero? (logand N1 N2 ...)))'

 -- Function: logbit? index n
     Returns `#t' if INDEX-th bit of integer N is 1, #F otherwise.

 -- Function: bit-field n start end
     Extracts START-th bit (inclusive) to END-th bit (exclusive) from
     an exact integer N, where START < END.

 -- Function: copy-bit index n bit
     If BIT is true, sets INDEX-th bit of an exact integer N.  If BIT
     is false, resets INDEX-th bit of an exact integer N.

 -- Function: copy-bit-field n start end from
     Returns an exact integer, each bit of which is the same as N
     except the START-th bit (inclusive) to END-th bit (exclusive),
     which is a copy of the lower `(END-START)'-th bits of an exact
     integer FROM.

          (number->string (copy-bit-field #b10000000 1 5 -1) 2)
            => "10011110"

          (number->string (copy-bit-field #b10000000 1 7 #b010101010) 2)
            => "11010100"

 -- Function: logcount n
     If N is positive, returns the number of `1''s in the bits of N.
     If N is negative, returns the number of `0''s in the bits of 2's
     complement representation of N.

          (logcount 0)      => 0
          (logcount #b0010) => 1
          (logcount #b0110) => 2
          (logcount #b1111) => 4

          (logcount #b-0001) => 0  ;; 2's complement:  ....111111
          (logcount #b-0010) => 1  ;; 2's complement:  ....111110
          (logcount #b-0011) => 1  ;; 2's complement:  ....111101
          (logcount #b-0100) => 2  ;; 2's complement:  ....111100

 -- Function: integer-length n
     Returns the minimum number of bits required to represent an exact
     integer N.  Negative integer is assumed to be in 2's complement
     form.  A sign bit is not considered.

          (integer-length 255)  => 8
          (integer-length 256)  => 9

          (integer-length -256)  => 8
          (integer-length -257)  => 9


File: gauche-refe.info,  Node: Booleans,  Next: Pairs and Lists,  Prev: Numbers,  Up: Core library

6.3 Booleans
============

 -- Builtin Class: <boolean>
     A boolean class.  Only `#t' and `#f' belong to this class.

 -- Function: not obj
     [R5RS] Returns `#t' if and only if OBJ is `#f', and returns `#f'
     otherwise.

 -- Function: boolean? obj
     [R5RS] Returns `#t' if OBJ is a boolean value.

 -- Function: boolean obj
     Returns `#f' iff OBJ is `#f', and returns `#t' otherwise.
     Convenient to coerce a value to boolean.


File: gauche-refe.info,  Node: Pairs and Lists,  Next: Symbols,  Prev: Booleans,  Up: Core library

6.4 Pairs and Lists
===================

Pairs and lists are one of the most fundamental data structure in
Scheme.  Gauche core provides all standard list procedures, plus some
useful procedures that are commonly supported in lots of
implementations.  If they are not enough, you can find more procedures
in the modules described in *note List library::, *note Additional list
library::, and *note Combination library::.  See also *note Collection
framework:: and *note Sequence framework:: for generic
collection/sequence operations.

* Menu:

* Pair and null class::
* List predicates::
* List constructors::
* List accessors and modifiers::
* Other list procedures::


File: gauche-refe.info,  Node: Pair and null class,  Next: List predicates,  Prev: Pairs and Lists,  Up: Pairs and Lists

6.4.1 Pair and null class
-------------------------

 -- Builtin Class: <list>
     An abstract class represents lists.   A parent class of `<null>'
     and `<pair>'.   Inherits `<sequence>'.

     Note that a circular list is also an instance of the `<list>'
     class, while R5RS procedure `list?' returns false on the circular
     lists and dotted lists.
          (use srfi-1)
          (list? (circular-list 1 2)) => #f
          (is-a? (circular-list 1 2) <list>) => #t

 -- Builtin Class: <null>
     A class of empty list.  `()' is the only instance.

 -- Builtin Class: <pair>
     A class of pairs.


File: gauche-refe.info,  Node: List predicates,  Next: List constructors,  Prev: Pair and null class,  Up: Pairs and Lists

6.4.2 List predicates
---------------------

 -- Function: pair? obj
     [R5RS] Returns `#t' if OBJ is a pair, `#f' otherwise.

 -- Function: null? obj
     [R5RS] Returns `#t' if OBJ is an empty list, `#f' otherwise.

 -- Function: list? obj
     [R5RS] Returns `#t' if OBJ is a proper list, `#f' otherwise.  This
     function returns `#f' if OBJ is a dotted or circular list.

     See also `proper-list?', `circular-list?' and `dotted-list?' in
     *note SRFI-1 List predicates::.


File: gauche-refe.info,  Node: List constructors,  Next: List accessors and modifiers,  Prev: List predicates,  Up: Pairs and Lists

6.4.3 List constructors
-----------------------

 -- Function: cons obj1 obj2
     [R5RS] Constructs a pair of OBJ1 and OBJ2 and returns it.
          (cons 'a 'b) => (a . b)

 -- Function: acons obj1 obj2 obj3
     Returns `(cons (cons OBJ1 OBJ2) OBJ3)'.  Useful to put an entry at
     the head of an associative list.
          (acons 'a 'b '((c . d))) => ((a . b) (c . d))

 -- Function: make-list len &optional fill
     [SRFI-1] Makes a proper list of length LEN.  If optional argument
     FILL is provided, each element is initialized by it.  Otherwise
     each element is undefined.
          (make-list 5 #t) => (#t #t #t #t #t)

 -- Function: list obj ...
     [R5RS] Makes a list, whose elements are OBJ ....
          (list 1 2 3) => (1 2 3)
          (list) => ()

 -- Function: list* obj1 obj2 ...
     Like `list', but the last argument becomes cdr of the last pair.
     SRFI-1 defines the same function with the name `cons*'.
          (list* 1 2 3) => (1 2 . 3)
          (list* 1) => 1

 -- Function: list-copy list
     [SRFI-1] Shallow copies LIST.  If LIST is circular, this function
     diverges.


File: gauche-refe.info,  Node: List accessors and modifiers,  Next: Other list procedures,  Prev: List constructors,  Up: Pairs and Lists

6.4.4 List accessors and modifiers
----------------------------------

 -- Function: car pair
 -- Function: cdr pair
     [R5RS] Returns car and cdr of PAIR, respectively.

 -- Function: set-car! pair obj
 -- Function: set-cdr! pair obj
     [R5RS] Modifies car and cdr of PAIR, by OBJ, respectively.

     Note: `(setter car)' == `set-car!', and `(setter cdr)' ==
     `set-cdr!'.

 -- Function: caar pair
 -- Function: cadr pair
     ...

 -- Function: cdddar pair
 -- Function: cddddr pair
     [R5RS] `caar' == `(car (car x))', `cadr' == `(car (cdr x))', and
     so on.

     The corresponding setters are also defined.
          (let ((x (list 1 2 3 4 5)))
            (set! (caddr x) -1)
            x)
            => (1 2 -1 4 5)

 -- Function: length list
     [R5RS] Returns the length of a proper list LIST.  If LIST is a
     dotted list, an error is signalled.  If LIST is a circular list,
     this function diverges.

     If you want to handle circular lists as well, See `length+' in
     *note SRFI-1 List miscellaneous routines::.

 -- Function: list-tail list k &optional fallback
     [R5RS] Returns K-th cdr of LIST.  LIST can be a proper, dotted or
     circular list.  (If LIST is a dotted list, its last `cdr' is
     simply ignored).

     If K is negative or larger than the length of LIST, the behavior
     depends on whether the optional FALLBACK argument is given or not.
     If FALLBACK is given, it is returned.  Otherwise, an error is
     signalled.

 -- Function: list-ref list k &optional fallback
     [R5RS+] Returns K-th element of LIST.  LIST can be a proper,
     dotted or circular list.

     By default, `list-ref' signals an error if K is negative, or
     greater than or equal to the length of LIST.  However, if an
     optional argument FALLBACK is given, it is returned for such case.
     This is an extension of Gauche.

 -- Function: last-pair list
     [SRFI-1] Returns the last pair of LIST.  LIST can be a proper or
     dotted list.


File: gauche-refe.info,  Node: Other list procedures,  Prev: List accessors and modifiers,  Up: Pairs and Lists

6.4.5 Other list procedures
---------------------------

 -- Function: append list ...
     [R5RS] Returns a list consisting of the elements of the first LIST
     followed by the elements of the other lists.  The resulting list
     is always newly allocated, except that it shares structure with
     the last list argument.  The last argument may actually be any
     object; an improper list results if the last argument is not a
     proper list.

 -- Function: append! list ...
     [SRFI-1] Returns a list consisting of the elements of the first
     LIST followed by the elements of the other lists.  The cells in
     the lists except the last one may be reused to construct the
     result.   The last argument may be any object.

 -- Function: reverse list
     [R5RS] Returns a newly allocated list consisting of the elements
     of LIST in reverse order.

 -- Function: reverse! list
     [SRFI-1] Returns a list consisting of the elements of LIST in
     reverse order.  The cells of LIST may be reused to construct the
     returned list.

 -- Function: memq obj list
 -- Function: memv obj list
 -- Function: member obj list
     [R5RS] Searches OBJ in the LIST.  If `n'-th element of LIST equals
     to OBJ (in the sense of `eq?' for `memq', `eqv?' for `memv', and
     `equal?' for `member'), `(list-tail LIST N)' is returned.
     Otherwise, `#f' is returned.

     If you use SRFI-1 (*Note List library::), `member' is extended to
     take optional argument for a equality procedure.
          (memq 'a '(a b c))          => (a b c)
          (memq 'b '(a b c))          =>  (b c)
          (memq 'a '(b c d))          => #f
          (memq (list 'a) '(b (a) c)) => #f
          (memv 101 '(100 101 102))   => (101 102)

 -- Function: assq obj list
 -- Function: assv obj list
 -- Function: assoc obj list
     [R5RS] Each element in LIST must be a pair.  These procedures
     search a pair whose car matches OBJ (in the sense of `eq?' for
     `assq', `eqv?' for `assv', and `equal?' for `assoc') from left to
     right, and return the leftmost matched pair if any.  If no pair
     matches, these return `#f'.

     If you use SRFI-1 (*Note List library::), `assoc' is extended to
     take optional argument for a equality procedure.


File: gauche-refe.info,  Node: Symbols,  Next: Keywords,  Prev: Pairs and Lists,  Up: Core library

6.5 Symbols
===========

 -- Builtin Class: <symbol>
     A class for symbols.

 -- Reader Syntax: `|name|'
     Denotes a symbol that has weird name, i.e. the name including the
     characters which is not allowed in the R5RS symbol syntax.  If the
     interpreter is running in case-insensitive mode, this syntax can
     be used to include uppercase characters in a symbol (*Note
     Case-sensitivity::).

     The syntax is taken from CommonLisp.  Some other Scheme
     implementation use it as well.

 -- Function: symbol? obj
     [R5RS] Returns true if and only if OBJ is a symbol.
          (symbol? 'abc)     => #t
          (symbol? 0)        => #f
          (symbol? 'i)       => #t
          (symbol? '-i)      => #f
          (symbol? '|-i|)    => #t

 -- Function: symbol->string symbol
     [R5RS] Returns the name of SYMBOL in a string.  Returned string is
     immutable.

          (symbol->string 'foo) => foo

 -- Function: string->symbol string
     [R5RS] Returns a symbol whose name is a string STRING.  STRING may
     contain weird characters.

          (string->symbol "a") => a
          (string->symbol "A") => A
          (string->symbol "weird symbol name") => |weird symbol name|

 -- Function: gensym &optional prefix


File: gauche-refe.info,  Node: Keywords,  Next: Identifiers,  Prev: Symbols,  Up: Core library

6.6 Keywords
============

 -- Builtin Class: <keyword>
     A keyword is a sort of a special symbol that is automatically
     quoted.  It is extensively used in pass-by-name arguments (keyword
     arguments), and keyword-value list.  Unlike CommonLisp, keywords
     and symbols are distinct types.

     See also `let-keywords' macro (*note Optional argument parsing::)
     for keyword argument processing.

 -- Reader syntax: `:NAME'
     Read to a keyword whose name is NAME.  (Note that the preceding
     ':' is not a part of the keyword's name.)

 -- Function: keyword? obj
     Returns `#t' if OBJ is a keyword.

 -- Function: make-keyword name
     Returns a keyword whose name is NAME, which can be can be a string
     or a symbol.
          (make-keyword "foo")  => :foo

          (make-keyword 'foo)   => :foo

 -- Function: keyword->string keyword
     Returns the name of the keyword KEYWORD, in a string.
          (keyword->string :foo) => "foo"

 -- Function: get-keyword key kv-list &optional fallback
     A useful procedure to extract a value from key-value list.  A
     key-value list KV-LIST must contains even number of elements; the
     first, third, fifth ... elements are regarded as keys, and the
     second, fourth, sixth ... elements are the values of the preceding
     keys.

     This procedure looks for KEY from the keys, and if it finds one,
     it returns the corresponding value.  If there are more than one
     matching keys, the leftmost one is taken.  If there is no matching
     key, it returns FALLBACK if provided, or signals an error
     otherwise.

     It is an error if KV-LIST is not a proper, even-number element
     list.

     Actually, `keywords' in the keyword-value list and the KEY argument
     need not be a keyword--it can be any Scheme object.  Key comparison
     is done by `eq?'.

     This procedure is taken from STk.

          (get-keyword :y '(:x 1 :y 2 :z 3))
            => 2
          (get-keyword 'z '(x 1 y 2 z 3))
            => 3

          (get-keyword :t '(:x 1 :y 2 :z 3))
            => #<error>
          (get-keyword :t '(:x 1 :y 2 :z 3) #f)
            => #f

 -- Macro: get-keyword* key kv-list &optional fallback
     Like `get-keyword', but FALLBACK is evaluated only if KV-LIST does
     not have KEY.

 -- Function: delete-keyword key kv-list
 -- Function: delete-keyword! key kv-list
     Removes all the keys and values from KV-LIST for keys that are
     `eq?' to KEY.

     `delete-keyword' doesn't change KV-LIST, but the returned list may
     share the common tail of it.

     `delete-keyword!' doesn't allocate, and _may_ destructively
     changes KV-LIST.  You still have to use the returned value, for
     the original list may not be changed if its first key matches KEY.

     If there's no key that matches KEY, KV-LIST is returned.

          (delete-keyword :y '(:x 1 :y 2 :z 3 :y 4))
           => (:x 1 :z 3)



File: gauche-refe.info,  Node: Identifiers,  Next: Characters,  Prev: Keywords,  Up: Core library

6.7 Identifiers
===============

 -- Builtin Class: <identifier>

 -- Function: identifier? obj

 -- Function: identifier->symbol identifier


File: gauche-refe.info,  Node: Characters,  Next: Character set,  Prev: Identifiers,  Up: Core library

6.8 Characters
==============

 -- Builtin Class: <char>

 -- Reader Syntax: `#\charname'
     [R5RS] Denotes a literal character.

     When the reader reads `#\', it fetches a subsequent character.  If
     it is one of `()[]{}" \|;#', this is a character literal of itself.
     Otherwise, the reader reads subsequent characters until it sees a
     non word-constituent character.  If only one character is read, it
     is the character.  Otherwise, the reader matches the read
     characters with predefined character names.  If it doesn't match
     any, an error is signalled.

     The following character names are recognized.  These character
     names are case insensitive.
    `space'
          Whitespace (ASCII #x20)

    `newline, nl, lf'
          Newline (ASCII #x0a)

    `return, cr'
          Carriage return (ASCII #x0d)

    `tab, ht'
          Horizontal tab (ASCII #x09)

    `page'
          Form feed (ASCII #x0c)

    `escape, esc'
          Escape (ASCII #x1b)

    `delete, del'
          Delete (ASCII #x7f)

    `null'
          NUL character (ASCII #x00)

    `xN'
          A character whose internal encoding is the integer N, when N
          is a hexadecimal integer.  Note that this notation is not
          portable among different internal encoding schemes except
          ASCII character range.

    `uN'
          A character whose UCS character code is the integer N, where
          N is 4-digit or 8-digit hexadecimal number.  If Gauche is
          compiled with the internal encoding other than UTF-8, the
          reader uses `gauche.charconv' module to convert Unicode to
          the internal character code.  Note that the specified
          character may not be defined in the internal encoding; in
          which case, either a substitution character is used, or an
          error is signalled.

          #\newline => #\newline ; newline character
          #\x0a     => #\newline ; ditto
          #\x41     => #\A       ; ASCII letter 'A'
          #\u0041   => #\A       ; ASCII letter 'A', specified by UCS
          #\u3042   => ; Hiragana letter A, specified by UCS
          #\u0002a6b2 => ; JISX0213 Kanji 2-94-86, specified by UCS4

     You can denote multibyte characters with this syntax if the
     program text is written in the same encoding as the internal
     character encoding.

 -- Function: char? obj
     [R5RS] Returns `#t' if OBJ is a character, `#f' otherwise.

 -- Function: char`='? char1 char2
 -- Function: char`<'? char1 char2
 -- Function: char`<='? char1 char2
 -- Function: char`>'? char1 char2
 -- Function: char`>='? char1 char2
     [R5RS] Compares characters.  Character comparison is done in
     internal character encoding.

 -- Function: char-ci`='? char1 char2
 -- Function: char-ci`<'? char1 char2
 -- Function: char-ci`<='? char1 char2
 -- Function: char-ci`>'? char1 char2
 -- Function: char-ci`>='? char1 char2
     [R5RS] Compares characters in case-insensitive way.  In the
     current version, character cases are not well defined outside the
     ASCII character range.

 -- Function: char-alphabetic? char
 -- Function: char-numeric? char
 -- Function: char-whitespace? char
 -- Function: char-upper-case? char
 -- Function: char-lower-case? char
     [R5RS] Returns true if a character CHAR is an alphabetic character
     (`[A-Za-z]'), a numeric character (`[0-9]'), a whitespace
     character, an upper case character or a lower case character,
     respectively.  Currently, these procedures works only for ASCII
     characters.  They return `#f' for all other characters.

 -- Function: char->integer char
 -- Function: integer->char n
     [R5RS] `char->integer' returns an exact integer that represents
     internal encoding of the character CHAR.  `integer->char' returns
     a character whose internal encoding is an exact integer N.  The
     following expression is always true for valid character CHAR:
          (eq? char (integer->char (char->integer char)))

     The result is undefined if you pass N to `integer->char' that
     doesn't have a corresponding character.

 -- Function: char->ucs char
 -- Function: ucs->char n
     Converts a character CHAR to integer UCS codepoint, and integer
     UCS codepoint N to a character, respectively.

     If Gauche is compiled with UTF-8 encoding, these procedures are the
     same as `char->integer' and `integer->char'.

     When Gauche's internal encoding differs from UTF-8, these
     procedures implicitly loads `gauche.charconv' module to convert
     internal character code to UCS or vice versa (*Note Character code
     conversion::).  If CHAR doesn't have corresponding UCS codepoint,
     `char->ucs' returns `#f'.  If UCS codepoint N can't be represented
     in the internal character encoding, `ucs->char' returns `#f',
     unless the conversion routine provides a substitution character.

 -- Function: char-upcase char
 -- Function: char-downcase char
     [R5RS] Returns the upper case and lower case of CHAR, respectively.
     If CHAR doesn't have such distinction of upper or lower case,
     `char' itself is returned.

     In the current version, character cases are not well defined
     outside the ASCII character range.

 -- Function: digit->integer char &optional (radix 10)
     If given character CHAR is a valid digit character in radix RADIX
     number, the corresponding integer is returned.  Otherwise `#f' is
     returned.
          (digit->integer #\4) => 4
          (digit->integer #\e 16) => 14
          (digit->integer #\9 8) => #f
     Note: CommonLisp has a similar function in rather confusing name,
     `digit-char-p'.

 -- Function: integer->digit integer &optional (radix 10)
     Reverse operation of `digit->integer'.  Returns a character that
     represents the number INTEGER in the radix RADIX system.  If
     INTEGER is out of the valid range, `#f' is returned.
          (integer->digit 13 16) => #\d
          (integer->digit 10) => #f
     Note: CommonLisp's `digit-char'.

 -- Function: gauche-character-encoding
     Returns a symbol designates the native character encoding, selected
     at the compile time.  The possible return values are those:
    `euc-jp'
          EUC-JP

    `utf-8'
          UTF-8

    `sjis'
          Shift JIS

    `none'
          No multibyte character support (8-bit fixed-length character).

 -- Function: supported-character-encodings
     Returns a list of string names of character encoding schemes that
     are supported in the native multibyte encoding scheme.


File: gauche-refe.info,  Node: Character set,  Next: Strings,  Prev: Characters,  Up: Core library

6.9 Character Set
=================

 -- Builtin Class: <char-set>
     Character set class.  Character set object represents a set of
     characters.  Gauche provides built-in support of character set
     creation and a predicate that tests whether a character is in the
     set or not.

     Further operations, such as set algebra, is defined in SRFI-14
     module (*Note Character-set library::).

 -- Reader Syntax: `#[char-set-spec]'
     You can write a literal character set in this syntax.
     char-set-spec is a sequence of characters to be included in the
     set.  You can include the following special sequences:
    `X-Y'
          Characters between X and Y, inclusive.  X must be smaller
          than Y in the internal encoding.

    `^'
          If char-set-spec begins with caret, the actual character set
          is a complement of what the rest of char-set-spec indicates.

    `\xNN'
          A character whose internal code is a hexadecimal number NN.

    `\uNNNN'
          A character whose UCS-2 code is a 4-digit hexadecimal number
          NNNN.

    `\UNNNNNNNN'
          A character whose UCS-4 code is a 8-digit hexadecimal number
          NNNNNNNN.

    `\s'
          Whitespace characters.

    `\S'
          Complement of whitespace characters.

    `\d'
          Decimal digit characters.

    `\D'
          Complement of decimal digit characters.

    `\w'
          Word constituent characters.  Currently, it is alphanumeric
          characters and underscore.

    `\W'
          Complement of word constituent characters.

    `\\'
          A backslash character.

    `\-'
          A minus character.

    `\^'
          A caret character.

    `[:alnum:] ...'
          Character set a la POSIX.  The following character set name is
          recognized: `alnum', `alpha', `blank', `cntrl', `digit',
          `graph', `lower', `print', `punct', `space', `upper' and
          `xdigit'.

          #[aeiou]     ; a character set consists of vowels
          #[a-zA-Z]    ; alphabet
          #[[:alpha:]] ; alphabet (using POSIX notation)
          #[\x0d\x0a]  ; newline and carriage return
          #[\\\-]      ; backslash and minus
          #[]          ; empty charset

 -- Function: char-set? obj
     [SRFI-14] Returns true if and only if OBJ is a character set
     object.

 -- Function: char-set-contains? char-set char
     [SRFI-14] Returns true if and only if a character set object
     CHAR-SET contains a character CHAR.
          (char-set-contains? #[a-z] #\y) => #t
          (char-set-contains? #[a-z] #\3) => #f

          (char-set-contains? #[^ABC] #\A) => #f
          (char-set-contains? #[^ABC] #\D) => #t

 -- Function: char-set char ...
     [SRFI-14] Creates a character set that contains CHAR ....
          (char-set #\a #\b #\c)   => #[a-c]

 -- Function: char-set-copy char-set
     [SRFI-14] Copies a character set CHAR-SET.


File: gauche-refe.info,  Node: Strings,  Next: Regular expression,  Prev: Character set,  Up: Core library

6.10 Strings
============

 -- Builtin Class: <string>
     A string class.   In Gauche, a string can be viewed in two ways: a
     sequence of characters, or a sequence of bytes.

   It should be emphasized that Gauche's _internal_ string object,
_string body_, is immutable.  To comply R5RS in which strings are
mutable, a Scheme-level string object is an indirect pointer to a
string body.  Mutating a string means that Gauche creates a new
immutable string body that reflects the changes, then swap the pointer
in the Scheme-level string object.

   This may affect some assumptions on the cost of string operations.

   * Copying string is O(1), no matter how long the string is, since
     the same string body is shared.

   * Taking substring usually is also O(1), for the resulting string
     shares the substring of the original string body.  Gauche may copy
     a part of the string for better memory management, but the visible
     cost should stay pretty close to O(1).  (However, note that
     accessing to a specific point by index within the original string
     may cost O(N) because of multibyte string; which is a different
     story).

   * On the other hand, mutating a string cost O(N) where N is the
     length of string, even for replacing a character.

   Gauche does not attempt to make string mutation faster;
`(string-set! s k c)' is exactly as slow as to take two substrings,
before and after of k-th character, and concatenate them with a
single-character string inbetween.  So, just avoid string mutations; we
believe it's a better practice.  See also *note String Constructors::.

   R5RS string operations are very minimal.  Gauche supports some extra
built-in operations, and also a rich string library defined in SRFI-13.
 *Note String library::, for details about SRFI-13.

* Menu:

* String syntax::
* String Predicates::
* String Constructors::
* String interpolation::
* String Accessors & Modifiers::
* String Comparison::
* String utilities::
* Incomplete strings::


File: gauche-refe.info,  Node: String syntax,  Next: String Predicates,  Prev: Strings,  Up: Strings

6.10.1 String syntax
--------------------

 -- Reader syntax: `"'...`"'
     [R5RS+] Denotes a literal string.  Inside the double quotes, the
     following backslash escape sequences are recognized.

    `\"'
          [R5RS] Double-quote character

    `\\'
          [R5RS] Backslash character

    `\n'
          Newline character (ASCII 0x0a).

    `\r'
          Return character (ASCII 0x0d).

    `\f'
          Form-feed character (ASCII 0x0c).

    `\t'
          Tab character (ASCII 0x09)

    `\0'
          ASCII NUL character (ASCII 0x00).

    `\<whitespace>*<newline><whitespace>*'
          Ignored.  This can be used to break a long string literal for
          readability.  This escape sequence is introduced in R6RS.

    `\xNN'
          A byte represented by two-digit hexadecimal number NN.  The
          byte is interpreted as the internal multibyte encoding.

    `\uNNNN'
          A character whose UCS2 code is represented by four-digit
          hexadecimal number NNNN.

    `\UNNNNNNNN'
          A character whose UCS4 code is represented by eight-digit
          hexadecimal number NNNNNNNN.

     If Gauche is compiled with internal encoding other than UTF-8, the
     reader uses `gauche.charconv' module to interpret `\uNNNN' and
     `\UNNNNNNNN' escape sequence.

     The following code is an example of backslash-newline escape
     sequence:
          (define *message* "\
            This is a long message \
            in a literal string.")

          *message*
            => "This is a long message in a literal string."

     Note the whitespace just after `message'.   Since any whitespaces
     before `in' is eaten by the reader, you have to put a whitespace
     between `message' and the following backslash.  If you want to
     include an actual newline character in a string, and any
     indentation after it, you can put '\n' in the next line like this:

          (define *message/newline* "\
            This is a long message, \
            \n   with a line break.")

 -- Reader syntax: `#*"'...`"'
     Denotes incomplete string.  The same escape sequences as the
     complete string syntax are recognized.

     Rationale of the syntax: '`#*'' is used for bit vector in Common
     Lisp.  Since an incomplete strings is really a byte vector, it has
     similarity.  (Bit vector can be added later, if necessary, and two
     can coexist).


File: gauche-refe.info,  Node: String Predicates,  Next: String Constructors,  Prev: String syntax,  Up: Strings

6.10.2 String Predicates
------------------------

 -- Function: string? obj
     [R5RS] Returns `#t' if OBJ is a string, `#f' otherwise.

 -- Function: string-immutable? obj
     Returns `#t' if OBJ is an immutable string, `#f' otherwise

 -- Function: string-incomplete? obj
     Returns `#t' if OBJ is an incomplete string, `#f' otherwise


File: gauche-refe.info,  Node: String Constructors,  Next: String interpolation,  Prev: String Predicates,  Up: Strings

6.10.3 String Constructors
--------------------------

 -- Function: make-string k &optional char
     [R5RS] Returns a string of length K.  If optional CHAR is given,
     the new string is filled with it.  Otherwise, the string is filled
     with a whitespace.  The result string is always complete.

          (make-string 5 #\x) => "xxxxx"

     Note that the algorithm to allocate a string by `make-string' and
     then fills it one character at a time is _extremely_ inefficient
     in Gauche, and should be avoided.   That kind of algorithms
     unnecessarily assumes underlying string allocation and
     representation mechanism, which Gauche doesn't follow.  You can
     use an output string port for a string construction (*Note String
     ports::).  Even creating a list of characters and using
     `list->string' is faster than using `make-string' and
     `string-set!'.

 -- Function: make-byte-string k &optional byte
     Creates and returns an incomplete string o size K.  If BYTE is
     given, which must be an exact integer, and its lower 8 bits are
     used to initialize every byte in the created string.

 -- Function: string char ...
     [R5RS] Returns a string consisted by CHAR ....

 -- Generic Function: x->string obj
     A generic coercion function.  Returns a string representation of
     OBJ.  The default methods are defined as follows: strings are
     returned as is, numbers are converted by `number->string', symbols
     are converted by `symbol->string', and other objects are converted
     by `display'.

     Other class may provide a method to customize the behavior.


File: gauche-refe.info,  Node: String interpolation,  Next: String Accessors & Modifiers,  Prev: String Constructors,  Up: Strings

6.10.4 String interpolation
---------------------------

The term "string interpolation" is used in various scripting languages
such as Perl and Python to refer to the feature to embed expressions in
a string literal, which are evaluated and then their results are
inserted into the string literal at run time.

   Scheme doesn't define such a feature, but Gauche implements it as a
reader macro.

 -- Reader syntax: `#`'STRING-LITERAL
     Evaluates to a string.  If STRING-LITERAL contains the character
     sequence `,EXPR', where EXPR is a valid external representation of
     a Scheme expression, EXPR is evaluated and its result is inserted
     in the original place (by using `x->string', see *note String
     Constructors::).

     The comma and the following expression must be adjacent (without
     containing any whitespace characters), or it is not recognized as
     a special sequence.

     Two adjacent commas are converted to a single comma.  You can embed
     a comma before a non-whitespace character in STRING-LITERAL by
     this.

     Other characters in the STRING-LITERAL are copied as is.

     If you use a variable as EXPR and need to delimit it from the
     subsequent string, you can use the symbol escape syntax using `|'
     character, as shown in the last two examples below.

          #`"This is Gauche, version ,(gauche-version)."
           => "This is Gauche, version 0.8.14."

          #`"Date: ,(sys-strftime \"%Y/%m/%d\" (sys-localtime (sys-time)))"
           => "Date: 2002/02/18"

          (let ((a "AAA")
                (b "BBB"))
           #`"xxx ,a ,b zzz")
           => "xxx AAA BBB zzz"

          #`"123,,456,,789"
           => "123,456,789"

          (let ((n 5)) #`"R,|n|RS")
           => "R5RS"

          (let ((x "bar")) #`"foo,|x|.")
           => "foobar"

     In fact, the reader expands this syntax into a macro call, which
     is then expanded into a call of `string-append' as follows:
          #`"This is Gauche, version ,(gauche-version)."
           ==
          (string-append "This is Gauche, version "
                         (x->string (gauche-version))
                         ".")

   _Rationale of the syntax:_ Some other scripting languages use
``$expr'' or '`#{...}''.  I chose this syntax with respect to the
quasiquote (*Note Quasiquotation::).  Although it may be awkward to
delimit variable names by `|', the comma syntax should be easier to
read than the other exotic syntax for seasoned Scheme programmers.

   Note that Scheme allows wider range of characters for valid
identifier names than usual scripting languages.  Consequently, you
will almost always need to use `|' delimiters when you interpolate the
value of a variable.  For example, while you can write
`"$year/$month/$day $hour:$minutes:$seconds"' in Perl, you should write
`#`",|year|/,|month|/,day ,|hour|:,|minutes|:,seconds"'.  It may be
better always to delimit direct variable references in this syntax to
avoid confusion.


File: gauche-refe.info,  Node: String Accessors & Modifiers,  Next: String Comparison,  Prev: String interpolation,  Up: Strings

6.10.5 String Accessors & Modifiers
-----------------------------------

 -- Function: string-length string
     [R5RS] Returns a length of (possibly incomplete) string STRING.

 -- Function: string-size string
     Returns a size of (possibly incomplete) STRING.  A size of string
     is a number of bytes STRING occupies on memory.  The same string
     may have different sizes if the native encoding scheme differs.

     For incomplete string, its length and its size always match.

 -- Function: string-ref cstring k &optional fallback
     [R5RS+] Returns K-th character of a complete string CSTRING.  It
     is an error to pass an incomplete string.

     By default, an error is signalled if `k' is out of range
     (negative, or greater than or equal to the length of CSTRING).
     However, if an optional argument FALLBACK is given, it is returned
     in such case.  This is Gauche's extension.

 -- Function: string-byte-ref string k
     Returns K-TH byte of a (possibly incomplete) string STRING.
     Returned value is an integer in the range between 0 and 255.  K
     must be greater than or equal to zero, and less than `(string-size
     STRING)'.

 -- Function: string-set! string k char
     [R5RS] Substitute STRING's K-th character by CHAR.  K must be
     greater than or equal to zero, and less than `(string-length
     STRING)'.  Return value is undefined.

     If STRING is an incomplete string, integer value of the lower 8
     bits of CHAR is used to set STRING's K-th byte.

     See the notes in `make-string' about performance consideration.

 -- Function: string-byte-set! string k byte
     Substitute STRING's K-th byte by integer BYTE.  BYTE must be in
     the range between 0 to 255, inclusive.  K must be greater than or
     equal to zero, and less than `(string-size STRING)'.  If STRING is
     a complete string, it is turned to incomplete string by this
     operation.  Return value is undefined.


File: gauche-refe.info,  Node: String Comparison,  Next: String utilities,  Prev: String Accessors & Modifiers,  Up: Strings

6.10.6 String Comparison
------------------------

 -- Function: string=? string1 string2
 -- Function: string-ci`='? string1 string2
     [R5RS]

 -- Function: string`<'? string1 string2
 -- Function: string`<='? string1 string2
 -- Function: string`>'? string1 string2
 -- Function: string`>='? string1 string2
 -- Function: string-ci`<'? string1 string2
 -- Function: string-ci`<='? string1 string2
 -- Function: string-ci`>'? string1 string2
 -- Function: string-ci`>='? string1 string2
     [R5RS]


File: gauche-refe.info,  Node: String utilities,  Next: Incomplete strings,  Prev: String Comparison,  Up: Strings

6.10.7 String utilities
-----------------------

 -- Function: substring string start end
     [R5RS] Returns a substring of STRING, starting from START-th
     character (inclusive) and ending at END-th character (exclusive).
     The START and END arguments must satisfy `0 <= START < N', `0 <=
     END <= N', and `START <= END', where N is the length of the string.

     When START is zero and END is N, this procedure returns a copy of
     STRING.

     Actually, extended `string-copy' explained below is a superset of
     `substring'.  This procedure is kept mostly for compatibility of
     R5RS programs.  See also `subseq' in *note Sequence framework::,
     for the generic version.

 -- Function: string-append string ...
     [R5RS] Returns a newly allocated string whose content is
     concatenation of STRING ....

     See also `string-concatenate' in *note SRFI-13 String reverse &
     append::.

 -- Function: string->list string &optional start end
 -- Function: list->string list
     [R5RS+][SRFI-13] Converts a string to a list of characters or vice
     versa.

     You can give an optional start/end indexes to `string->list', as
     specified in SRFI-13.

     For LIST->STRING, every elements of LIST must be a character, or
     an error is signalled.  If you want to build a string out of a
     mixed list of strings and characters, you may want to use
     `tree->string' in *note Lazy text construction::.

 -- Function: string-copy string &optional start end
     [R5RS+][SRFI-13] Returns a copy of STRING.  You can give START
     and/or END index to extract the part of the original string (it
     makes `string-copy' a superset of `substring' effectively).

     If only START argument is given, a substring beginning from
     START-th character (inclusive) to the end of STRING is returned.
     If both START and END argument are given, a substring from
     START-th character (inclusive) to END-th character (exclusive) is
     returned.  See `substring' above for the condition that START and
     END should satisfy.

 -- Function: string-fill! string char &optional start end
     [R5RS+][SRFI-13] Fills STRING by CHAR.  Optional START and END
     limits the effective area.
          (string-fill! "orange" #\X)
            => "XXXXXX"
          (string-fill! "orange" #\X 2 4)
            => "orXXge"

 -- Function: string-join strs &optional delim grammer
     [SRFI-13] Concatenate strings in the list STRS, with a string
     DELIM as `glue'.

     The argument GRAMMER may be one of the following symbol to specify
     how the strings are concatenated.
    `infix'
          Use DELIM between each string.  This mode is default.  Note
          that this mode introduce ambiguity when STRS is an empty
          string or a list with a null string.
               (string-join '("apple" "mango" "banana") ", ")
                 => "apple, mango, banana"
               (string-join '() ":")
                 => ""
               (string-join '("") ":")
                 => ""

    `strict-infix'
          Works like `infix', but empty list is not allowed to STRS,
          thus avoiding ambiguity.

    `prefix'
          Use DELIM before each string.
               (string-join '("usr" "local" "bin") "/" 'prefix)
                 => "/usr/local/bin"
               (string-join '() "/" 'prefix)
                 => ""
               (string-join '("") "/" 'prefix)
                 => "/"

    `suffix'
          Use DELIM after each string.
               (string-join '("a" "b" "c") "&" 'suffix)
                 => "a&b&c&"
               (string-join '() "&" 'suffix)
                 => ""
               (string-join '("") "&" 'suffix)
                 => "&"


 -- Function: string-scan string item &optional return
     Scan ITEM (either a string or a character) in STRING.  The RETURN
     argument specifies what value should be returned when ITEM is
     found in STRING.  It must be one of the following symbols.

    `index'
          Returns the index in STRING if ITEM is found, or `#f'.  This
          is the default behavior.
               (string-scan "abracadabra" "ada") => 5
               (string-scan "abracadabra" #\c) => 4
               (string-scan "abracadabra" "aba") => #f

    `before'
          Returns a substring of STRING before ITEM, or `#f' if ITEM is
          not found.
               (string-scan "abracadabra" "ada" 'before) => "abrac"
               (string-scan "abracadabra" #\c 'before) => "abra"

    `after'
          Returns a substring of STRING after ITEM, or `#f' if ITEM is
          not found.
               (string-scan "abracadabra" "ada" 'after) => "bra"
               (string-scan "abracadabra" #\c 'after) => "adabra"

    `before*'
          Returns a substring of STRING before ITEM, and the substring
          after it.  If ITEM is not found, returns `(values #f #f)'.
               (string-scan "abracadabra" "ada" 'before*)
                 => "abrac" and "adabra"
               (string-scan "abracadabra" #\c 'before*)
                 => "abra" and "cadabra"

    `after*'
          Returns a substring of STRING up to the end of ITEM, and the
          rest.  If ITEM is not found, returns `(values #f #f)'.
               (string-scan "abracadabra" "ada" 'after*)
                 => "abracada" and "bra"
               (string-scan "abracadabra" #\c 'after*)
                 => "abrac" and "adabra"

    `both'
          Returns a substring of STRING before ITEM and after ITEM.  If
          ITEM is not found, returns `(values #f #f)'.
               (string-scan "abracadabra" "ada" 'both)
                 => "abrac" and "bra"
               (string-scan "abracadabra" #\c 'both)
                 => "abra" and "adabra"

 -- Function: string-split string splitter
     Splits STRING by SPLITTER and returns a list of strings.  SPLITTER
     can be a character, a character set, a string, a regexp, or a
     procedure.

     If SPLITTER is a character, the character is used as a delimiter.

     If SPLITTER is a character set, any consecutive characters that
     are member of the character set are used as a delimiter.

     If a procedure is given to SPLITTER, it is called for each
     character in STRING, and the consecutive characters that caused
     SPLITTER to return a true value are used as a delimiter.

          (string-split "/aa/bb//cc" #\/)    => ("" "aa" "bb" "" "cc")
          (string-split "/aa/bb//cc" "/")    => ("" "aa" "bb" "" "cc")
          (string-split "/aa/bb//cc" "//")   => ("/aa/bb" "cc")
          (string-split "/aa/bb//cc" #[/])   => ("" "aa" "bb" "cc")
          (string-split "/aa/bb//cc" #/\/+/) => ("" "aa" "bb" "cc")
          (string-split "/aa/bb//cc" #[\w])  => ("/" "/" "//" "")
          (string-split "/aa/bb//cc" char-alphabetic?) => ("/" "/" "//" "")

          ;; some boundary cases
          (string-split "abc" #\/) => ("abc")
          (string-split ""    #\/) => ("")

     See also `string-tokenize' in (*Note SRFI-13 other string
     operations::).


File: gauche-refe.info,  Node: Incomplete strings,  Prev: String utilities,  Up: Strings

6.10.8 Incomplete strings
-------------------------

A string can be flagged as "incomplete" if it may contain byte
sequences that do not consist of a valid multibyte character in the
Gauche's native encoding.

   Incomplete strings may be genereated in several circumstances;
reading binary data as a string, reading a string data that has been
'chopped' in middle of a multibyte character, or concatenating a string
with other incomplete strings, for example.

   Incomplete strings should be regarded as an exceptional case.  It
used to be a way to handle byte strings, but now we have u8vector
(*Note Uniform vectors::) for that purpose.  In fact, we're planning to
remove it in the future releases.

   Just in case, if you happen to get an incomplete string, you can
convert it to a complete string by the following procedure:

 -- Function: string-incomplete->complete str &optional handling
     Reinterpret the content of an incomplete string STR and returns a
     newly created complete string from it.  The HANDLING argument
     specifies how to handle the illegal byte sequences in STR.
    `#f'
          If STR contains an illegal byte sequence, give up the
          conversion and returns `#f'.  This is the default behavior.

    `:omit'
          Omit any illegal byte sequences.  Always returns a complete
          string.

    a character
          Replace each byte in illegal byte sequences by the given
          character.  Always returns a complete string.
     If STR is already a complete string, its copy is returned.


File: gauche-refe.info,  Node: Regular expression,  Next: Vectors,  Prev: Strings,  Up: Core library

6.11 Regular expression
=======================

Gauche has a built-in regular expression engine which is mostly
upper-compatible of POSIX extended regular expression.  Gauche's regexp
also includes some extensions from Perl 5 regexp.

 -- Builtin Class: <regexp>
     Regular expression object.  You can construct a regexp object from
     a string by `string->regexp' at run time.  Gauche also has a
     special syntax to denote regexp literals, which construct regexp
     object at loading time.

     Gauche's regexp engine is fully aware of multibyte characters.

 -- Builtin Class: <regmatch>
     Regexp match object.  A regexp matcher `rxmatch' returns this
     object if match.  This object contains all the information about
     the match, including submatches.

     The advantage of using match object, rather than substrings or
     list of indices is efficiency.  The regmatch object keeps internal
     state of match, and computes indices and/or substrings only when
     requested.  This is particularly effective for mutibyte strings,
     for index access is slow on them.

 -- Reader Syntax: `#/regexp-spec/'
 -- Reader Syntax: `#/regexp-spec/i'
     Denotes literal regular expression object.  When read, it becomes
     an instance of `<regexp>'.

     If a letter '`i'' is given at the end, the created regexp becomes
     _case-folding regexp_, i.e. it matches in the case-insensitive
     way.  (The current version only cares ASCII characters for
     case-folding-- beyond ASCII characters, the match is done in the
     same way as normal match.)

     The advantage of using this syntax over `string->regexp' is that
     the regexp is compiled only once.  You can use literal regexp
     inside loop without worrying about regexp compilation overhead.
     If you want to construct regexp on-the-fly, however, use
     `string->regexp'.

   Gauche's built-in regexp syntax follows POSIX extended regular
expression, with a bit of extensions taken from Perl.

   Note that the syntax described here is just a surface syntax.
Gauche's regexp compiler works on the abstract syntax tree, and
alternative syntax such as SRE will be supported in the future versions.

`re*'
     Matches zero or more repetition of re.

`re+'
     Matches one or more repetition of re.

`re?'
     Matches zero or one occurrence of re.

`re{n}'
`re{n,}'
`re{n,m}'
     Bounded repetition.  `re{n}' matches exactly n occurrences of re.
     `re{n,}' matches n or more occurrences of re.  `re{n,m}' matches
     at least N and at most M occurrences of re, where N <= M.

`re*?'
`re+?'
`re??'
`re{n,}?'
`re{n,m}?'
     Same as the above repetition construct, but these syntaxes use
     "non-greedy" or "lazy" match strategy.  That is, they try to match
     the minimum number of occurrences of re first, then retry longer
     ones only if it fails.  Compare the following examples:
          (rxmatch-substring (#/<.*>/ "<tag1><tag2><tag3>") 0)
            => "<tag1><tag2><tag3>"

          (rxmatch-substring (#/<.*?>/ "<tag1><tag2><tag3>") 0)
            => "<tag1>"

`(re...)'
     Clustering with capturing.  The regular expression enclosed by
     parenthesis works as a single re.  Besides, the string that
     matches re ... is saved as a _submatch_.

`(?:re...)'
     Clustering without capturing.   `re ...' works as a single re, but
     the matched string isn't saved.

`(?<name>re...)'
     Named capture and clustering.  Like `(re...)', but adds the name
     name to the matched substring.  You can refer to the matched
     substring by both index number and the name.

     When the same name appears more than once in a regular expression,
     it is undefined which matched substring is returned as the
     submatch of the named capture.

`(?i:re...)'
`(?-i:re...)'
     Lexical case sensitivity control.  `(?i:re...)' makes re...
     matches case-insensitively, while `(?-i:re...)' makes re...
     matches case-sensitively.

     Perl's regexp allows several more flags to appear between '?' and
     ':'.  Gauche only supports above two, for now.

`pattern1|pattern2|...'
     Alternation.  Matches either one of patterns, where each pattern
     is re ....

`\n'
     Backreference.  n is an integer.  Matches the substring captured
     by the n-th capturing group.  (counting from 1).  When capturing
     groups are nested, groups are counted by their beginnings.  If the
     n-th capturing group is in a repetition and has mached more than
     once, the last matched substring is used.

`\k<name>'
     Named backreference.  Matches the substring captured by the
     capturing group with the name name.  If the named capturing group
     is in a repetition and has mached more than once, the last matched
     substring is used.  If there are more than one capturing group
     with name, matching will succeed if the input matches either one
     of the substrings captured by those groups.

`.'
     Matches any character (including newline).

`[char-set-spec]'
     Matches any of the character set specified by char-set-spec.
     *Note Character set::, for the details of char-set-spec.

`\s, \d, \w'
     Matches a whitespace character (`#[[:space:]]'), a digit character
     (`#[[:digit:]]'), or a word-constituent character
     (`#[[:alpha:][:digit:]_]'), respectively.

     Can be used both inside and outside of character set.

`\S, \D, \W'
     Matches the complement character set of `\s', `\d' and `\w',
     respectively.

`^, $'
     Beginning and end of string assertion, when appears at the
     beginning or end of the pattern.

`\b, \B'
     Word boundary and non word boundary assertion, respectively.  That
     is, `\b' matches an empty string between word-constituent
     character and non-word-constituent character, and `\B' matches an
     empty string elsewhere.

`\;'
`\"'
`\#'
     These are the same as `;', `"', and `#', respectively, and can be
     used to avoid confusing Emacs or other syntax-aware editors that
     are not familiar with Gauche's extension.

`(?=pattern)'
`(?!pattern)'
     Positive/negative lookahead assertion.  Match succeeds if pattern
     matches (or does not match) the input string from the current
     position, but this doesn't move the current position itself, so
     that the following regular expression is applied again from the
     current position.

     For example, the following expression matches strings that might
     be a phone number, except the numbers in Japan (i.e. ones that
     begin with "81").
          \+(?!81)\d{9,}

`(?<=pattern)'
`(?<!pattern)'
     Positive/negative lookbehind assertion.

`re*+'
`re++'
`re?+'
     They are the same as (?>re*), (?>re+), (?>re?), respectively.


 -- Function: string->regexp string &keyword case-fold
     Takes STRING as a regexp specification, and constructs an instance
     of `<regexp>' object.

     If a true value is given to the keyword argument CASE-FOLD, the
     created regexp object becomes case-folding regexp.  (See the above
     explanation about case-folding regexp).

 -- Function: regexp? OBJ
     Returns true iff OBJ is a regexp object.

 -- Function: regexp->string REGEXP
     Returns a source string describing the regexp REGEXP.  The
     returned string is immutable.

 -- Function: rxmatch regexp string
     REGEXP is a regular expression object.  A string STRING is matched
     by REGEXP.  If it matches, the function returns a `<regmatch>'
     object.  Otherwise it returns `#f'.

     This is called `match', `regexp-search' or `string-match' in some
     other Scheme implementations.

 -- Generic application: REGEXP STRING
     A regular expression object can be applied directly to the string.
     This works the same as `(rxmatch REGEXP STRING)', but allows
     shorter notation.   *Note Applicable objects::, for generic
     mechanism used to implement this.

 -- Function: rxmatch-start match &optional (i 0)
 -- Function: rxmatch-end match &optional (i 0)
 -- Function: rxmatch-substring match &optional (i 0)
     MATCH is a match object returned by `rxmatch'.  If I equals to
     zero, the functions return start, end or the substring of entire
     match, respectively.  With positive integer I, it returns those of
     I-th submatches.  It is an error to pass other values to I.

     It is allowed to pass `#f' to MATCH for convenience.  The
     functions return `#f' in such case.

     These functions correspond to scsh's `match:start', `match:end'
     and `match:substring'.

 -- Function: rxmatch-num-matches match
     Returns the number of matches in MATCH.  The number includes the
     "whole match", so it is always a positive integer for a
     `<regmatch>' object.  The number also includes the submatches that
     don't have value (see the examples below).

     For the convenience, `rxmatch-num-matches' returns 0 if MATCH is
     `#f'.

          (rxmatch-num-matches (rxmatch #/abc/ "abc"))
            => 1

          (rxmatch-num-matches (rxmatch #/(a(.))|(b(.))/ "ba"))
            => 5

          (rxmatch-num-matches #f)
            => 0


 -- Function: rxmatch-after match &optional (i 0)
 -- Function: rxmatch-before match &optional (i 0)
     Returns substring of the input string after or before MATCH.  If
     optional argument is given, the I-th submatch is used (0-th
     submatch is the entire match).
          (define match (rxmatch #/(\d+)\.(\d+)/ "pi=3.14..."))

          (rxmatch-after match) => "..."
          (rxmatch-after match 1) => ".14..."

          (rxmatch-before match) => "pi="
          (rxmatch-before match 2) => "pi=3."

 -- Function: rxmatch->string regexp string &optional selector ...
     A convenience procedure to match a string to the given regexp,
     then returns the matched substring, or `#f' if it doesn't match.

     If no SELECTOR is given, it is the same as this:
          (rxmatch-substring (rxmatch REGEXP STRING))

     If an integer is given as a selector, it returns the subtring of
     the numbered submatch.

     If a symbol `after' or `before' is given, it returns the substring
     after or before the match.  You can give these symbols and an
     integer to extract a substring before or after the numbered
     submatch.

          gosh> (rxmatch->string #/\d+/ "foo314bar")
          "314"
          gosh> (rxmatch->string #/(\w+)@([\w.]+)/ "foo@example.com" 2)
          "example.com"
          gosh> (rxmatch->string #/(\w+)@([\w.]+)/ "foo@example.com" 'before 2)
          "foo@"

 -- Generic application: REGMATCH &optional INDEX
 -- Generic application: REGMATCH `'before' &optional INDEX
 -- Generic application: REGMATCH `'after' &optional INDEX
     A regmatch object can be applied directly to the integer index, or
     a symbol `before' or `after'.  They works the same as
     `(rxmatch-substring REGMATCH INDEX)', `(rxmatch-before REGMATCH)',
     and `(rxmatch-after REGMATCH)', respectively.  This allows shorter
     notation.  *Note Applicable objects::, for generic mechanism used
     to implement this.

          (define match (#/(\d+)\.(\d+)/ "pi=3.14..."))

            (match)           => "3.14"
            (match 1)         => "3"
            (match 2)         => "14"

            (match 'after)    => "..."
            (match 'after 1)  => ".14..."

            (match 'before)   => "pi="
            (match 'before 2) => "pi=3."

          (define match (#/(?<integer>\d+)\.(?<fraction>\d+)/ "pi=3.14..."))

            (match 1)         => "3"
            (match 2)         => "14"

            (match 'integer)  => "3"
            (match 'fraction) => "14"

            (match 'after 'integer)   => ".14..."
            (match 'before 'fraction) => "pi=3."

 -- Function: regexp-replace regexp string substitution
 -- Function: regexp-replace-all regexp string substitution
     Replaces the part of STRING that matched to REGEXP for
     SUBSTITUTION.  `regexp-replace' just replaces the first match of
     REGEXP, while `regexp-replace-all' repeats the replacing
     throughout entire STRING.

     SUBSTITUTION may be a string or a procedure.  If it is a string,
     it can contain references to the submatches by digits preceded by
     a backslash (e.g. `\2') or the named submatch reference (e.g.
     `\k<NAME>'.  `\0' refers to the entire match.  Note that you need
     two backslashes to include backslash character in the literal
     string; if you want to include a backslash character itself in the
     SUBSTITUTION, you need four backslashes.

          (regexp-replace #/def|DEF/ "abcdefghi" "...")
            => "abc...ghi"
          (regexp-replace #/def|DEF/ "abcdefghi" "|\\0|")
            => "abc|def|ghi"
          (regexp-replace #/def|DEF/ "abcdefghi" "|\\\\0|")
            => "abc|\\0|ghi"
          (regexp-replace #/c(.*)g/ "abcdefghi" "|\\1|")
            => "ab|def|hi"
          (regexp-replace #/c(?<match>.*)g/ "abcdefghi" "|\\k<match>|")
            => "ab|def|hi"

     If SUBSTITUTION is a procedure, for every match in STRING it is
     called with one argument, regexp-match object.  The returned value
     from the procedure is inserted to the output string using
     `display'.

          (regexp-replace #/c(.*)g/ "abcdefghi"
                          (lambda (m)
                            (list->string
                             (reverse
                              (string->list (rxmatch-substring m 1))))))
           => "abfedhi"

     Note: `regexp-replace-all' applies itself recursively to the
     remaining of the string after match.  So the beginning of string
     assertion in REGEXP doesn't only mean the beginning of input
     string.

 -- Function: regexp-replace* string rx1 sub1 rx2 sub2 ...
 -- Function: regexp-replace-all* string rx1 sub1 rx2 sub2 ...
     First applies `regexp-replace' or `regexp-replace-all' to STRING
     with a regular expression RX1 substituting for SUB1, then applies
     the function on the result string with a regular expression RX2
     substituting for SUB2, and so on.  These functions are handy when
     you want to apply multiple substitutions sequentially on a string.

 -- Function: regexp-quote string
     Returns a string with the characters that are special to regexp
     escaped.
          (regexp-quote "[2002/10/12] touched foo.h and *.c")
           => "\\[2002/10/12\\] touched foo\\.h and \\*\\.c"

   In the following macros, MATCH-EXPR is an expression which produces
a match object or `#f'. Typically it is a call of `rxmatch', but it can
be any expression.

 -- Macro: rxmatch-let match-expr (var ...) form ...
     Evaluates MATCH-EXPR, and if matched, binds VAR ...  to the
     matched strings, then evaluates FORMs.  The first VAR receives the
     entire match, and subsequent variables receive submatches.  If the
     number of submatches are smaller than the number of variables to
     receive them, the rest of variables will get `#f'.

     It is possible to put `#f' in variable position, which says you
     don't care that match.

          (rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                                "Jan  1 23:59:58, 2001")
             (time hh mm ss)
            (list time hh mm ss))
           => ("23:59:58" "23" "59" "58")

          (rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                                "Jan  1 23:59:58, 2001")
             (#f hh mm)
            (list hh mm))
           => ("23" "59")

     This macro corresponds to scsh's `let-match'.

 -- Macro: rxmatch-if match-expr (var ...) then-form else-form
     Evaluates MATCH-EXPR, and if matched, binds VAR ...  to the
     matched strings and evaluate THEN-FORM.  Otherwise evaluates
     ELSE-FORM.  The rule of binding VARs is the same as `rxmatch-let'.

          (rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11:22:33")
              (time)
            (format #f "time is ~a" time)
            "unknown time")
           => "time is 11:22"

          (rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11-22-33")
              (time)
            (format #f "time is ~a" time)
            "unknown time")
           => "unknown time"

     This macro corresponds to scsh's `if-match'.

 -- Macro: rxmatch-cond clause ...
     Evaluate condition in CLAUSEs one by one.  If a condition of a
     clause satisfies, rest portion of the clause is evaluated and
     becomes the result of `rxmatch-cond'.  CLAUSE may be one of the
     following pattern.

    `(MATCH-EXPR (VAR ...) FORM ...)'
          Evaluate MATCH-EXPR, which may return a regexp match object
          or `#f'.  If it returns a match object, the matches are bound
          to VARs, like RXMATCH-LET, and FORMs are evaluated.

    `(test EXPR FORM ...)'
          Evaluates EXPR.  If it yields true, evaluates FORMs.

    `(test EXPR => PROC)'
          Evaluates EXPR and if it is true, calls PROC with the result
          of EXPR as the only argument.

    `(else FORM ...)'
          If this clause exists, it must be the last clause.  If other
          clauses fail, FORMs are evaluated.

     If no `else' clause exists, and all the other clause fail, an
     undefined value is returned.

          ;; parses several possible date format
          (define (parse-date str)
            (rxmatch-cond
              ((rxmatch #/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ str)
                  (#f mm dd yyyy)
                (map string->number (list yyyy mm dd)))
              ((rxmatch #/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ str)
                  (#f yyyy mm dd)
                (map string->number (list yyyy mm dd)))
              ((rxmatch #/^\d+\/\d+\/\d+$/ str)
                  (#f)
               (errorf "ambiguous: ~s" str))
              (else (errorf "bogus: ~s" str))))

          (parse-date "2001/2/3") => (2001 2 3)
          (parse-date "12/25/1999") => (1999 12 25)

     This macro corresponds to scsh's `match-cond'.

 -- Macro: rxmatch-case string-expr clause ...
     STRING-EXPR is evaluated, and CLAUSEs are interpreted one by one.
     A CLAUSE may be one of the following pattern.

    `(RE (VAR ...) FORM ...)'
          RE must be a literal regexp object (*Note Regular
          expression::).  If the result of STRING-EXPR matches RE, the
          match result is bound to VARs and FORMs are evaluated, and
          `rxmatch-case' returns the result of the last FORM.

          If RE doesn't match the result of STRING-EXPR, STRING-EXPR
          yields non-string value, the interpretation proceeds to the
          next clause.

    `(test PROC FORM ...)'
          A procedure PROC is applied on the result of STRING-EXPR.  If
          it yields true value, FORMs are evaluated, and `rxmatch-case'
          returns the result of the last FORM.

          If PROC yieds `#f', the interpretation proceeds to the next
          clause.

    `(test PROC => PROC2)'
          A procedure PROC is applied on the result of STRING-EXPR.  If
          it yields true value, PROC2 is applied on the result, and its
          result is returned as the result of `rxmatch-case'.

          If PROC yieds `#f', the interpretation proceeds to the next
          clause.

    `(else FORM ...)'
          This form must appear at the end of CLAUSEs, if any.  If
          other clauses fail, FORMs are evaluated, and the result of
          the last FORM becomes the result of `rxmatch-case'.

     If no `else' clause exists, and all other clause fail, an
     undefined value is returned.

     The `parse-date' example above becomes simpler if you use
     `rxmatch-case'
          (define (parse-date2 str)
            (rxmatch-case str
              (test (lambda (s) (not (string? s))) #f)
              (#/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ (#f mm dd yyyy)
               (map string->number (list yyyy mm dd)))
              (#/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ (#f yyyy mm dd)
               (map string->number (list yyyy mm dd)))
              (#/^\d+\/\d+\/\d+$/                (#f)
               (errorf "ambiguous: ~s" str))
              (else (errorf "bogus: ~s" str))))


File: gauche-refe.info,  Node: Vectors,  Next: Hashtables,  Prev: Regular expression,  Up: Core library

6.12 Vectors
============

 -- Builtin Class: <vector>
     A vector is a simple 1-dimensional array of Scheme objects.  You
     can access its element by index in constant time.  Once created, a
     vector can't be resized.

     Class `<vector>' inherits `<sequence>' and you can use various
     generic functions such as `map' and `fold' on it.   *Note
     Collection framework::, and *Note Sequence framework::.

     If you keep only a homogeneous numeric type, you may be able to
     use SRFI-4 homogeneous vectors (*Note Homogeneous vectors::).

     *Note Vector library::, for additional operations on vectors.

 -- Function: vector? obj
     [R5RS] Returns `#t' if OBJ is a vector, `#f' otherwise.

 -- Function: make-vector k &optional fill
     [R5RS] Creates and returns a vector with length K.  If optional
     argument FILL is given, each element of the vector is initialized
     by it.  Otherwise, the initial value of each element is undefined.

 -- Function: vector obj ...
     [R5RS] Creates a vector whose elements are OBJ ....

 -- Function: vector-length vector
     [R5RS] Returns the length of a vector VECTOR.

     With `gauche.collection' module, you can also use a method
     `size-of'.

 -- Function: vector-ref vector k &optional fallback
     [R5RS+] Returns K-th element of vector VECTOR.

     By default, `vector-ref' signals an error if K is negative, or
     greater than or equal to the length of VECTOR.  However, if an
     optional argument FALLBACK is given, it is returned for such case.
     This is an extension of Gauche.

     With `gauche.sequence' module, you can also use a method `ref'.

 -- Function: vector-set! vector k obj
     [R5RS] Sets K-th element of the vector VECTOR to OBJ.  It is an
     error if K is negative or greater than or equal to the length of
     VECTOR.

     With `gauche.sequence' module, you can also use a setter method of
     `ref'.

 -- Function: vector->list vector &optional start end
 -- Function: list->vector list &optional start end
     [R5RS+][SRFI-43+] Converts a vector to a list, or vice versa.

     The optional START and END arguments limit the range of the source.
          (vector->list '#(1 2 3 4 5))     => (1 2 3 4 5)
          (list->vector '(1 2 3 4 5))      => #(1 2 3 4 5)
          (vector->list '#(1 2 3 4 5) 2 4) => (3 4)
          (list->vector (circular-list 'a 'b 'c) 1 6)
            => #(b c a b c)

     With GAUCHE.COLLECTION module, you can use `(coerce-to <list>
     VECTOR)' and `(coerce-to <vector> LIST)' as well.

 -- Function: vector-fill! vector fill &optional start end
     [R5RS+][SRFI-43] Sets all elements in a vector VECTOR to FILL.

     Optional START and END limits the range of effect between START-th
     index (inclusive) to END-th index (exclusive).  START defaults to
     zero, and END defaults to the length of VECTOR.  These optional
     arguments are Gauche's extension.

 -- Function: vector-copy vector &optional start end fill
     [SRFI-43] Copies a vector VECTOR.  Optional START and END
     arguments can be used to limit the range of VECTOR to be copied.
     If the range specified by START and END falls outside of the
     original VECTOR, the FILL value is used to fill the result vector.

          (vector-copy '#(1 2 3 4 5))     => #(1 2 3 4 5)
          (vector-copy '#(1 2 3 4 5) 2 4) => #(3 4)
          (vector-copy '#(1 2 3 4 5) 3 7 #f) => #(4 5 #f #f)


File: gauche-refe.info,  Node: Hashtables,  Next: Treemaps,  Prev: Vectors,  Up: Core library

6.13 Hashtables
===============

 -- Builtin Class: <hash-table>
     Hash table class.  Inherits `<collection>' and `<dictionary>'.

 -- Function: make-hash-table &optional type
     Creates a hash table.   A symbol TYPE specifies the type of the
     table.  The following types are currently supported.  (If TYPE is
     omitted, `eq?' is assumed.)
    `eq?'
          Keys are compared by `eq?'.

    `eqv?'
          Keys are compared by `eqv?'.

    `equal?'
          Keys are compared by `equal?'.

    `string=?'
          Keys are compared by `string=?'.  Key must be a string.

     Hash functions used for `eq?', `eqv?' and `string=?'-type hash
     tables are built in the system; they can be called from Scheme as
     `eq-hash', `eqv-hash', and `string-hash' (SRFI-13).  Those
     functions can't be extended for user-defined objects.   On the
     other hand, `equal?'-type hash tables uses `hash' function below,
     with which you define hash functions for user-defined objects.


 -- Function: hash obj
     Returns a hash value of OBJ.  This is the hash function used in
     `equal?'-type hash table.  The hash value is an exact non-negative
     integer, and it has two properties:
        * For any object A and B, if `(equal? A and B)', then `(= (hash
          A) (hash B))', while `hash' is defined for types of A and B.

        * The value of `hash' is independent from the runtime state of
          the machine (such as address of the data); so you can safely
          save the hash value to file and read it again with different
          process without losing validity of the hash value.
     If OBJ is either a number, a boolean, a character, a symbol, a
     keyword, a string, a list or a vector, internal hash function is
     used to calculate the hash value.  If OBJ is other than that,
     `hash' calls a generic function `object-hash' to calculate the
     hash value.

 -- Generic Function: object-hash obj
     By defining a method for this generic function, objects of
     user-defined types can have a hash value and can be used in
     `equal?' hash table.

     The method has to return an exact non-negative integer, and has to
     follow the same constraints as of `hash'.

     If the method needs to get hash value of OBJ's elements, it has to
     call `hash' on them, not `object-hash'.  For the hashing of
     primitive objects are done in `hash'.
          (define-class <myclass> () (x y))

          ;; user-defined equality function
          (define-method object-equal? ((a <myclass>) (b <myclass>))
            (and (equal? (ref a 'x) (ref b 'x))
                 (eq?    (ref a 'y) (ref b 'y))))

          ;; user-defined hash function
          (define-method object-hash ((a <myclass>))
            (hash (list (ref a 'x) (ref a 'y))))

 -- Function: eq-hash obj
 -- Function: eqv-hash obj
     These are hash functions used for `eq?'-type and `eqv?'-type hash
     tables.  Returns a non-negative integer up to 2^_n_-1, where _n_
     is system-dependent value no less than 32.  The returned hash
     value is system- and process-dependent, and can't be carried over
     the boundary of the running process.

     Note: don't hash numbers by `eq-hash'.  Two numbers are not
     guaranteed to be `eq?' even if they are numerically equal, so they
     are not supposed to be used as a key in `eq?'-type hash table.

 -- Function: hash-table? obj
     Returns `#t' if OBJ is a hash table.

 -- Function: hash-table-type ht
     Returns one of symbols `eq?', `eqv?', `equal?' or `string=?',
     indicating the type of the hash table HT.

 -- Function: hash-table-num-entries ht
     Returns the number of entries in the hash table HT.

 -- Function: hash-table type key&value ...
     Constructs and returns a hash table of type TYPE from given list
     of arguments.  TYPE is the same as of `make-hash-table'.  Each
     KEY&VALUE must be a pair, and its car is used as a key and its cdr
     is used as a value.

          (hash-table 'eq? '(a . 1) '(b . 2))
            ==
            (let ((h (make-hash-table 'eq?)))
               (hash-table-put! h 'a 1)
               (hash-table-put! h 'b 2)
               h)

 -- Function: hash-table-get ht key &optional default
     Search KEY from a hash table HT, and returns its value if found.
     If the key is not found in the table and DEFAULT is given, it is
     returned.  Otherwise an error is signalled.

 -- Function: hash-table-put! ht key value
     Puts a key KEY with a value VALUE to the hash table HT.

 -- Method: ref (ht <hash-table>) key &optional default
 -- Method: (setter ref) (ht <hash-table>) key value
     Method versions of `hash-table-get' and `hash-table-put!'.

 -- Function: hash-table-exists? ht key
     Returns `#t' if a hash table HT has a key KEY.

 -- Function: hash-table-delete! ht key
     Deletes an entry that has a key KEY from the hash table HT.
     Returns `#t' if the entry has exist, or `#f' if the entry hasn't
     exist.   The same function is called `hash-table-remove!' in STk
     (except that it returns an undefined value); I use `delete' for
     consistency to SRFI-1, SRFI-13 and other parts of the libraries.

 -- Function: hash-table-clear! ht
     Removes all entries in the hash table HT.

 -- Function: hash-table-push! ht key value
     Conses VALUE to the existing value for the key KEY in the hash
     table HT and makes it the new value for KEY.  If there's no entry
     for KEY, an entry is created with the value `(list VALUE)'.

     Works the same as the following code, except that this function
     only looks up the KEY once, thus it's more efficient.
          (hash-table-put! ht key
              (cons value (hash-table-get ht key '())))

 -- Function: hash-table-pop! ht key &optional default
     Looks for the value for the key KEY in the hash table HT.  If
     found and it is a pair, replaces the value for its cdr and returns
     car of the original value.  If no entry for KEY is in the table,
     or the value is not a pair, the table is not modified and the
     procedure returns DEFAULT if given, or signals an error otherwise.

     During the operation the key is looked for only once, thus runs
     efficiently.

 -- Function: hash-table-update! ht key proc &optional default
     A more general version of `hash-table-push!' etc.  It works
     basically as the following code piece, except that the lookup of
     KEY is only done once.
          (let ((tmp (proc (hash-table-get HT KEY DEFAULT))))
            (hash-table-put! HT KEY tmp)
            tmp)

     For example, when you use a hash table to count the occurrences of
     items, the following line is suffice to increment the counter of
     the item, regardless of whether ITEM has already appeared or not.

          (hash-table-update! ht item (cut + 1 <>) 0))


 -- Function: hash-table-for-each ht proc
 -- Function: hash-table-map ht proc
     A procedure PROC is called with two arguments, a key and its
     associated value, over all the entries in the hash table HT.

 -- Function: hash-table-fold ht kons knil
     For all entries in the hash table HT, a procedure KONS is called
     with three arguments; a key, its associated value, and the
     previous return value of KONS.  The first call of KONS receives
     KNIL as the third argument.  The return value of the last call of
     KONS is returned from `hash-table-fold'.

 -- Function: hash-table-keys ht
 -- Function: hash-table-values ht
     Returns all the keys or values of hash table HT in a list,
     respectively.

   See also *note Additional list library::, where `hash-table->alist'
and `alist->hash-table' are defined.


File: gauche-refe.info,  Node: Treemaps,  Next: Weak pointers,  Prev: Hashtables,  Up: Core library

6.14 Treemaps
=============

 -- Builtin Class: <tree-map>
     Tree map class.   Tree maps are a data structure that maps key
     objects to value objects.  It's like hash tables except tree maps
     uses balanced tree internally.  Insertion and lookup is O(log n).

     Unlike hashtables, a tree map keeps the order of the keys, so it
     is easy to traverse entries in the order of keys, to find
     minimum/maximum keys, or to find a key closest to the given value.

     The `<tree-map>' class inherits `<sequence>' and
     `<ordered-dictionary>'.

 -- Function: make-tree-map key=? key<?
     Creates and returns an instance of `<tree-map>'.  The arguments
     KEY=? and KEY<? are both procedures that take two arguments, which
     are the keys.  The `key=?' procedure should return `#t' if two
     arguments are equivalent, or `#f' otherwise.  The `key<?'
     procedure should return `#t' if the first argument is strictly
     less than the second argument, or `#f' otherwise.

 -- Function: tree-map-copy tree-map
     Copies and returns  TREE-MAP.  Modification on the returned tree
     doesn't affect the original tree.

 -- Function: tree-map-empty? tree-map
     Returns `#t' if TREE-MAP doesn't have any elements, or `#f'
     otherwise.

 -- Function: tree-map-num-entries tree-map
     Returns the number of elements in TREE-MAP.

 -- Function: tree-map-exists? tree-map key
     Returns `#t' if TREE-MAP has an entry with KEY, or `#f' otherwise.

 -- Function: tree-map-get tree-map key &optional fallback
     Looks for KEY in TREE-MAP.  If the entry is found, returns a value
     corresponding to the key.  Otherwise, returns FALLBACK if it is
     provided, or signals an error.

 -- Function: tree-map-put! tree-map key value
     Inserts an entry with a KEY and corresponding VALUE into TREE-MAP.
     If there already exists an entry with a key which is equivalent
     (under KEY=?), the entry is modified to have VALUE.

 -- Function: tree-map-delete! tree-map key
     Deletes an entry with KEY from TREE-MAP if such an entry exists,
     and returns `#t'.  If TREE-MAP doesn't have such an entry, `#f' is
     returned.

 -- Function: tree-map-clear! tree-map
     Removes all entries in TREE-MAP.

 -- Function: tree-map-update! tree-map key proc &optional fallback
     A generalized version of `tree-map-push!' etc.  It works like the
     following code, except that searching for the key is done only
     once.
          (let ((tmp (proc (tree-map-get TREE-MAP KEY FALLBACK))))
            (tree-map-put! TREE-MAP KEY tmp)
            tmp)

 -- Function: tree-map-push! tree-map key value
     Looks for an entry with KEY in TREE-MAP.  If it exists, the
     procedure conses VALUE to the original value and makes it as a new
     value.  Otherwise, the procedure creates a new entry for the KEY
     and makes `(list VALUE)' its value.

 -- Function: tree-map-pop! tree-map key &optional fallback
     Looks for an entry with KEY in TREE-MAP.  If it exists and its
     value is a pair, then the procedure updates its value with `cdr'
     of the original value, and returns `car' of the original entry.
     If such an entry does not exist, or has a non-pair value, the
     procedure doesn't modify TREE-MAP and returns FALLBACK if it is
     given, otherwise reports an error.

 -- Function: tree-map-min tree-map
 -- Function: tree-map-max tree-map
     Returns a pair of a key and its value with the minimum or maximum
     key, respectively.   If TREE-MAP is empty, `#f' is returned.

 -- Function: tree-map-pop-min! tree-map
 -- Function: tree-map-pop-max! tree-map
     Looks for an entry with minimum or maximum key, respectively, then
     deletes the entry from TREE-MAP and returns a pair of the key and
     its value of the original entry.  If TREE-MAP is empty, `#f' is
     returned.

 -- Function: tree-map-fold tree-map proc seed
 -- Function: tree-map-fold-right tree-map proc seed
     Iterate over elements in TREE-MAP, applying PROC which has a type
     `(key, value, seed) -> seed'.  The difference of `tree-map-fold'
     and `tree-map-fold-right' is the associative order of applying
     `proc', just like the difference between `fold' and `fold-right'.
          tree-map-fold:
            (proc Kn Vn (proc Kn-1 Vn-1 ... (proc K0 V0 seed)))

          tree-map-fold-right
            (proc K0 V0 (proc K1 V1 ... (proc Kn Vn seed)))

     Some examples:
          (define tree (alist->tree-map '((3 . a) (7 . b) (5 . c)) = <))

          (tree-map-fold tree list* '())
             => (7 b 5 c 3 a)
          (tree-map-fold-right tree list* '())
             => (3 a 5 c 7 b)

 -- Function: tree-map-floor tree-map probe &optional fallback-key
          fallback-value
 -- Function: tree-map-ceiling tree-map probe &optional fallback-key
          fallback-value
 -- Function: tree-map-predecessor tree-map probe &optional
          fallback-key fallback-value
 -- Function: tree-map-successor tree-map probe &optional fallback-key
          fallback-value
     These procedures search the entry which has the closest key to the
     given PROBE.  If such an entry is found, returns two values, its
     key and its value.  Otherwise, returns two values, FALLBACK-KEY
     and FALLBACK-VALUE, both defaulted to `#f'.

     The criteria of "closest" differ slightly among these procedures;
     `tree-map-floor' finds the maximum key which is no greater than
     PROBE; `tree-map-ceiling' finds the minimum key which is no less
     than PROBE; `tree-map-predecessor' finds the maximum key which is
     strictly less than PROBE; and `tree-map-successor' finds the
     minimum key which is strictly greater than PROBE.

 -- Function: tree-map-floor-key tree-map probe OPTIONAL fallback-key
 -- Function: tree-map-ceiling-key tree-map probe OPTIONAL fallback-key
 -- Function: tree-map-predecessor-key tree-map probe OPTIONAL
          fallback-key
 -- Function: tree-map-successor-key tree-map probe OPTIONAL
          fallback-key
     Like `tree-map-floor' etc., but only returns the key of the found
     entry (or FALLBACK-KEY if there's no entry which satisfies the
     criteria).

 -- Function: tree-map-floor-value tree-map probe OPTIONAL
          fallback-value
 -- Function: tree-map-ceiling-value tree-map probe OPTIONAL
          fallback-value
 -- Function: tree-map-predecessor-value tree-map probe OPTIONAL
          fallback-value
 -- Function: tree-map-successor-value tree-map probe OPTIONAL
          fallback-value
     Like `tree-map-floor' etc., but only returns the value of the
     found entry (or FALLBACK-VALUE if there's no entry which satisfies
     the criteria).

 -- Function: tree-map-keys tree-map
 -- Function: tree-map-values tree-map
     Returns a list of all keys and all values, respectively.  The keys
     and values are in ascending order of the keys.

 -- Function: tree-map->alist tree-map
     Returns a list of pairs of keys and values for all entries.  The
     pairs are in ascending order of the keys.

 -- Function: alist->tree-map alist key=? key<?
     Creates a new tree map with KEY=? and KEY<?, then populates it
     with ALIST, each pair in which are interpreted as a cons of a key
     and its value.  Returns the created tree map.


File: gauche-refe.info,  Node: Weak pointers,  Next: Control features,  Prev: Treemaps,  Up: Core library

6.15 Weak pointers
==================

A weak pointer is a reference to an object that doesn't prevent the
object from being garbage-collected.  Gauche provides weak pointers as
a _weak vector_ object.  A weak vector is like a vector of objects,
except each object can be garbage collected if it is not referenced
from objects other than weak vectors.   If the object is collected, the
entry of the weak vector is replaced for `#f.'
     gosh> (define v (make-weak-vector 1))
     v
     gosh> (weak-vector-ref v 0)
     #f
     gosh> (weak-vector-set! v 0 (cons 1 1))
     #<undef>
     gosh> (weak-vector-ref v 0)
     (1 . 1)
     gosh> (gc)
     #<undef>
     gosh> (gc)
     #<undef>
     gosh> (weak-vector-ref v 0)
     #f

 -- Builtin Class: <weak-vector>
     The weak vector class.  Inherits `<sequence>' and `<collection>',
     so you can use `gauche.collection' (*Note Collection framework::)
     and `gauche.sequence' (*Note Sequence framework::).
          (coerce-to <weak-vector> '(1 2 3 4))
            => a weak vector with four elements

 -- Function: make-weak-vector size
     Creates and returns a weak vector of size SIZE.

 -- Function: weak-vector-length wvec
     Returns the length of a weak vector WVEC.

 -- Function: weak-vector-ref wvec k &optioal fallback
     Returns K-th element of a weak vector WVEC.

     By default, `weak-vector-ref' signals an error if K is negative,
     or greater than or equal to the size of WVEC.  However, if an
     optional argument FALLBACK is given, it is returned for such case.

     If the element has been garbage collected, this procedure returns
     FALLBACK if it is provided,  `#f' otherwise.

     With `gauche.sequence' module, you can also use a method `ref'.

 -- Function: weak-vector-set! wvec k obj
     Sets K-th element of the weak vector WVEC to OBJ.  It is an error
     if K is negative or greater than or equal to the size of WEC.


File: gauche-refe.info,  Node: Control features,  Next: Exceptions,  Prev: Weak pointers,  Up: Core library

6.16 Control features
=====================

* Menu:

* Procedures::
* Applicable objects::
* Continuation::
* Multiple values::
* Delayed evaluation::


File: gauche-refe.info,  Node: Procedures,  Next: Applicable objects,  Prev: Control features,  Up: Control features

6.16.1 Procedures
-----------------

 -- Builtin Class: <procedure>

 -- Function: procedure? obj
     [R5RS] Returns `#t' if OBJ is a procedure, `#f' otherwise.

 -- Function: apply proc arg1 ... args
     [R5RS] Calls a procedure PROC with a list of arguments, `(ARG1 ...
     . ARGS)'.  The last argument ARGS must be a proper list.  Returns
     (a) value(s) PROC returns.
          (apply list 'a 'b '(c d e)) => (a b c d e)

          (apply + 1 2 '(3 4 5))      => 15

* Menu:

* Mapping::
* Combinators::
* Optional argument parsing::
* Procedure arity::


File: gauche-refe.info,  Node: Mapping,  Next: Combinators,  Prev: Procedures,  Up: Procedures

6.16.1.1 Mapping
................

 -- Function: map proc list1 list2 ...
     [R5RS+] Applies PROC for each element(s) of given list(s), and
     returns a list of the results.  R5RS doesn't specify the
     application order of `map', but Gauche guarantees PROC is always
     applied in order of the list(s).  Gauche's `map' also terminates
     as soon as one of the list is exhausted.

          (map car '((a b) (c d) (e f))) => (a c e)

          (map cons '(a b c) '(d e f))
            => ((a . d) (b . e) (c . f))

     Note that the `gauche.collection' module (*Note Collection
     framework::) extends `map' to work on any type of collection.

 -- Function: for-each proc list1 list2 ...
     [R5RS] Applies PROC for each element(s) of given list(s) in order.
     The results of PROC are discarded.  The return value of `for-each'
     is undefined.  When more than one list is given, `for-each'
     terminates as soon as one of the list is exhausted.

     Note that the `gauche.collection' module (*Note Collection
     framework::) extends `for-each' to work on any type of collection.


File: gauche-refe.info,  Node: Combinators,  Next: Optional argument parsing,  Prev: Mapping,  Up: Procedures

6.16.1.2 Combinators
....................

Gauche has some primitive procedures that allows combinatory
programming.

 -- Function: pa$ proc arg ...
     Partial application.  Returns a procedure, and when it is called
     with arguments M ..., it is equivalent to call `(proc arg ... m
     ...)'.

          (define add3 (pa$ + 3))
          (add3 4) => 7

          (map (pa$ * 2) '(1 2 3)) => (2 4 6)

     Macros `cut' and `cute' defined in SRFI-26 provide a similar
     abstraction, with a bit more flexible but less compact notation.
     *Note Making Procedures::.

 -- Function: apply$ proc
 -- Function: map$ proc
 -- Function: for-each$ proc
     Partial application versions of `apply', `map' and `for-each'.

          (define map2* (map$ (pa$ * 2)))
          (map2* '(1 2 3)) => (2 4 6)


 -- Function: count$ pred
 -- Function: fold$ kons &optional knil
 -- Function: fold-right$ kons &optional knil
 -- Function: reduce$ f &optional ridentity
 -- Function: reduce-right$ f &optional ridentity
 -- Function: filter$ pred
 -- Function: remove$ pred
 -- Function: partition$ pred
 -- Function: member$ item
 -- Function: find$ pred
 -- Function: find-tail$ pred
 -- Function: any$ pred
 -- Function: every$ pred
 -- Function: delete$ pred
 -- Function: assoc$ item
     Partial application versions of some srfi-1 procedures (*Note List
     library::).

 -- Function: compose f ...
     Combine procedures.  All arguments must be procedures.  When two
     procedures are given, `(compose f g)' is equivalent to the
     following code:
          (lambda args (call-with-values (lambda () (apply g args)) f))

     When more than two arguments are passed, they are composed as
     follows:
          (compose f g h ...) == (compose (compose f g) h ...)

     Some examples:

          (define not-zero? (compose not zero?))
          (not-zero? 3) => #t
          (not-zero? 0) => #f

          (define dot-product (compose (apply$ +) (map$ *)))
          (dot-product '(1 2 3) '(4 5 6)) => 32

     A couple of edge cases: if only one argument is given, the argument
     itself is returned.  If no arguments are given, the procedure
     `values' is returned.

 -- Function: complement pred
     Returns a procedure that reverses the meaning of the predicate
     PRED.  That is, for the arguments for which PRED returns true
     return false, and vice versa.

          (map (complement even?) '(1 2 3)) => '(#t #f #t)
          (map (complement =) '(1 2 3) '(1 1 3)) => '(#f #t #f)
          ((complement (lambda () #f))) => #t

 -- Function: any-pred pred ...
     Returns a procedure which applies given argument(s) to each
     predicate PRED.  If any PRED returns a non-`#f' value, the value
     is returned.  If all the PREDs return `#f', `#f' is returned.

          (define string-or-symbol? (any-pred string? symbol?))
          (string-or-symbol? "abc") => #t
          (string-or-symbol? 'abc)  => #t
          (string-or-symbol? 3)     => #f

          (define <> (any-pred < >))
          (<> 3 4) => #t
          (<> 3 3) => #f

          ((any-pred (cut memq <> '(a b c))
                     (cut memq <> '(1 2 3)))
           'b)  => '(b c)

 -- Function: every-pred pred ...
     Returns a procedure which applies given argument(s) to each
     predicate PRED.  If every PRED returns a non-`#f' value, the value
     returned by the last PRED is returned.  If any PRED returns `#f',
     `every-pred' returns `#f' without calling further PREDs.

          ((every-pred odd? positive?) 3)  => #t
          ((every-pred odd? positive?) 4)  => #f
          ((every-pred odd? positive?) -3) => #f

          (define safe-length (every-pred list? length))
          (safe-length '(a b c))  => 3
          (safe-length "aaa")     => #f


File: gauche-refe.info,  Node: Optional argument parsing,  Next: Procedure arity,  Prev: Combinators,  Up: Procedures

6.16.1.3 Optional argument parsing
..................................

To have optional arguments or keyword arguments in Scheme, you have to
take variable arguments as a list and decompose them by yourself.   The
following macros help it.

 -- Macro: let-optionals* restargs (var-spec ...) body ...
 -- Macro: let-optionals* restargs (var-spec ... . restvar) body ...
     Given a list of values RESTARGS, binds variables according to
     VAR-SPEC, then evaluates BODY.

     VAR-SPEC can be either a symbol, or a list of two elements and its
     car is a symbol.  The symbol is the bound variable name.  The
     values in RESTARGS are bound to the symbol in order.  If there are
     not as many values in RESTARGS as VAR-SPEC, the rest of SYMBOLs
     are bound to the default values, determined as follows: If
     VAR-SPEC is just a symbol, the default value is undefined.  If
     VAR-SPEC is a list, the default value is the result of evaluation
     of the second element of the list.  In the latter case the second
     element is only evaluated when there are not enough arguments.
     The binding proceeds in the order of VAR-SPEC, so the second
     element may refer to the bindings of previous VAR-SPEC.

     In the second form, RESTVAR must be a symbol and bound to the list
     of values whatever left from RESTARGS after binding to VAR-SPEC.

     It is not an error if RESTARG has more values than VAR-SPECs.  The
     extra values are simply ignored in the first form.

          (define (proc x . args)
            (let-optionals* args ((a 'a)
                                  (b 'b)
                                  (c 'c))
              (list x a b c)))

          (proc 0)         => (0 a b c)
          (proc 0 1)       => (0 1 b c)
          (proc 0 1 2)     => (0 1 2 c)
          (proc 0 1 2 3)   => (0 1 2 3)

          (define (proc2 . args)
            (let-optionals* args ((a 'a) . b)
              (list a b)))

          (proc2)          => (a ())
          (proc2 0)        => (0 ())
          (proc2 0 1)      => (0 (1))
          (proc2 0 1 2)    => (0 (1 2))

          (define (proc3 . args)
            (let-optionals* args ((a 0)
                                  (b (+ a 1))
                                  (c (+ b 1)))
              (list a b c)))

          (proc3)          => (0 1 2)
          (proc3 8)        => (8 9 10)
          (proc3 8 2)      => (8 2 3)
          (proc3 8 2 -1)   => (8 2 -1)

 -- Macro: get-optional restargs default
     This is a short version of LET-OPTIONALS* where you have only one
     optional argument.  Given the optional argument list RESTARGS,
     this macro returns the value of optional argument if one is given,
     or the result of DEFAULT otherwise.  DEFAULT is not evaluated
     unless RESTARGS is an empty list.

          (define (proc x . maybe-opt)
            (let ((option (get-optional maybe-opt #f)))
              (list x option)))

          (proc 0)         => (0 #f)
          (proc 0 1)       => (0 1)

 -- Macro: let-keywords restarg (var-spec ...) body ...
 -- Macro: let-keywords restarg (var-spec ... . restvar) body ...
     This macro is for keyword arguments.  VAR-SPEC can be one of the
     following forms:

    `(SYMBOL EXPR)'
          If the RESTRAG contains keyword which has the same name as
          SYMBOL, binds SYMBOL to the corresponding value.  If such a
          keyword doesn't appear in RESTARG, binds SYMBOL to the result
          of EXPR.

    `(SYMBOL KEYWORD EXPR)'
          If the RESTARG contains keyword KEYWORD, binds SYMBOL to the
          corresponding value.  If such a keyword doesn't appear in
          RESTARG, binds SYMBOL to the result of EXPR.

     The default value EXPR is only evaluated when the keyword is not
     given to the RESTARG.

     If you use the first form, `let-keyword' regards it an error when
     `restarg' contains a keyword argument that is not listed in
     VAR-SPECs.  For the backward compatibility it only issues warning
     now, but in future releases it will raise an error.  When you want
     to allow keyword arguments other than listed in VAR-SPECs, use the
     second form.

     In the second form, RESTVAR must be either a symbol or `#f'.  If
     it is a symbol, it is bound to a list of keyword arguments that
     are not processed by VAR-SPECs.  If it is `#f', such keyword
     arguments are just ignored.

          (define (proc x . options)
            (let-keywords options ((a 'a)
                                   (b :beta 'b)
                                   (c 'c)
                                   . rest)
              (list x a b c rest)))

          (proc 0)         => (0 a b c ())
          (proc 0 :a 1)    => (0 1 b c ())
          (proc 0 :beta 1) => (0 a 1 c ())
          (proc 0 :beta 1 :c 3 :unknown 4) => (0 a 1 3 (:unknown 4))

 -- Macro: let-keywords* restarg (var-spec ...) body ...
 -- Macro: let-keywords* restarg (var-spec ... . restvar) body ...
     Like `let-keywords', but the binding is done in the order of
     VAR-SPECs.  So each EXPR can refer to the variables bound by
     preceding VAR-SPECs.


File: gauche-refe.info,  Node: Procedure arity,  Prev: Optional argument parsing,  Up: Procedures

6.16.1.4 Procedure arity
........................

Interface to query procedure's arity.  The API is taken from MzScheme
(PLT Scheme).

 -- Function: arity PROC
     Given procedure PROC, returns an integer, an _arity-at-least_
     object, or a list of integer(s) and _arity-at-least_ objects.

     An integer result indicates PROC takes exactly that number of
     arguments.  An _arity-at-least_ indicates PROC takes at least
     `(arity-at-least-value _arity-at-least_)' arguments.   The list
     indicates there are multiple procedures with different arities.

     Since one can add methods to an existing procedure or generic
     function at any moment in Gauche, the value returned by `arity'
     only indicates the current state of the procedure.  It will change
     if new method is added to the procedure/generic-function.

          (arity cons) => 2
          (arity list) => #<arity-at-least 0>
          (arity make) => (#<arity-at-least 1>)

 -- Function: arity-at-least? OBJ
     Returns true if OBJ is an arity-at-least object.

 -- Function: arity-at-least-value ARITY-AT-LEAST
     Returns the number of required arguments the arity-at-least object
     indicates.

 -- Function: procedure-arity-includes? PROC K
     If a procedure PROC can take K arguments, returns `#t'.  Otherwise
     returns `#f'.


File: gauche-refe.info,  Node: Applicable objects,  Next: Continuation,  Prev: Procedures,  Up: Control features

6.16.2 Applicable objects
-------------------------

Gauche has a special hook to make an arbitrary object _applicable_.

 -- Generic Function: object-apply OBJECT ARG ...
     If an object that is neither a procedure nor a generic function is
     applied to some arguments, the object and the arguments are passed
     to a generic function `object-apply'.

     This can be explained better by examples.

   For example, suppose you try to evaluate the following expression:

     ("abcde" 2)

   The operator evaluates to a string, which is neither a procedure nor
a generic function.  So Gauche interprets the expression as if it were
like this:

     (object-apply "abcde" 2)

   Gauche doesn't define a method of `object-apply' that takes
`<string>' and `<integer>' by default, so this signals an error.
However, if you define such a method:

     (define-method object-apply ((s <string>) (i <integer>))
       (string-ref s i))

   Then the first expression works as if a string is _applied_ on the
integer:

     ("abcde" 2) => #\c

   This mechanism works on almost all occasions where a procedure is
allowed.

     (apply "abcde" '(1))   => (#\b)
     (map "abcde" '(3 2 1)) => (#\d #\c #\b)

   Among Gauche built-in objects, `<regexp>' object and `<regmatch>'
object have `object-apply' defined.  *Note Regular expression::.

 -- Generic Function: (setter object-apply) OBJECT ARG ... VALUE
     If a form of applying an applicable object appears in the first
     position of `set!' form, this method is called, that is:
          (set! (OBJECT ARG ...) VALUE)
           => ((setter object-apply) OBJECT ARG ... VALUE)


File: gauche-refe.info,  Node: Continuation,  Next: Multiple values,  Prev: Applicable objects,  Up: Control features

6.16.3 Continuation
-------------------

 -- Function: call-with-current-continuation proc
 -- Function: call/cc proc
     [R5RS] Encapsulates the current continuation to a procedure
     ("continuation procedure"), and calls PROC with it.  When PROC
     returns, its value becomes `call/cc''s value.  When the
     continuation procedure is invoked with zero or more arguments
     somewhere, the further calculation is abandoned and `call/cc'
     returns with the arguments given to the continuation procedure.

     First class continuation is one of the most distinct feature of
     Scheme, but this margin is too small to contain explanation.
     Please consult to the appropriate documents.

     Gauche supports full continuation, with a few limitations in rare
     cases.   Normally a continuation has an unlimited extent.  However,
     if a continuation is created during "callback" from C code-- that
     is, you call some C-implemented function that calls Scheme code
     again--the continuation's extent is limited until the Scheme
     evaluation returns to the C code.   If you try to invoke the
     continuation from out of its extent, Gauche detects it and signals
     an error.  This is a fundamental limitation and not likely to be
     addressed.

     Note that it is still allowed to invoke a continuation from such
     callbacks.  Also, the typical higher-order functions such as
     `map', `for-each' or `apply' are not using callbacks, and not
     affected by this limitation

     Fortunately, there are not much cases that you need to create an
     unlimited extent continuation in such callbacks.  So far, the
     following code is executed in such callbacks.  Besides them,
     typical callback functions from external C libraries, like GUI
     toolkit, obeys the same limitation.
        * A `write-object' method that is invoked from `write',
          `display' or `format' (*Note Output::).

        * A filler and a flusher callbacks of buffered ports (*Note
          Virtual ports::).


 -- Macro: let/cc var body ...
     This macro expands to : `(call/cc (lambda (VAR) BODY ...))'.  The
     API is taken from PLT Scheme.

 -- Function: dynamic-wind before thunk after
     [R5RS] BEFORE, THUNK and AFTER are all procedures with no
     arguments.  In normal situation, `dynamic-wind' calls BEFORE, then
     THUNK, then AFTER, then returns whatever value(s) THUNK returned.

     If a control flow goes out from THUNK by invoking a continuation
     captured outside of the dynamic scope of `dynamic-wind' (for
     example, an error is signalled in THUNK), AFTER is called.

     If a control flow goes into THUNK by invoking a continuation
     captured inside THUNK from outside of the dynamic scope of
     `dynamic-wind', BEFORE is called.
          (letrec ((paths '())
                   (c #f)
                   (add (lambda (s) (push! paths s))))
            (dynamic-wind
             (lambda () (add 'connect))
             (lambda ()
               (add (call/cc (lambda (c0) (set! c c0) 'talk1))))
             (lambda () (add 'disconnect)))
            (if (< (length paths) 4)
                (c 'talk2)
                (reverse paths)))
           => (connect talk1 disconnect connect talk2 disconnect)


File: gauche-refe.info,  Node: Multiple values,  Next: Delayed evaluation,  Prev: Continuation,  Up: Control features

6.16.4 Multiple values
----------------------

 -- Function: values obj ...
     [R5RS] Returns OBJ ... as multiple values.  Caller can capture
     multiple values by a built-in syntax `receive' (*note Binding
     constructs::), or the R5Rs procedure `call-with-values' described
     below.  See also *note Let-values::.
          (values 1 2) => 1 and 2

 -- Function: call-with-values producer consumer
     [R5RS] Call a procedure PRODUCER with no argument.  Then applies a
     procedure CONSUMER on the value(s) PRODUCER returned.  Returns the
     value(s) CONSUMER returns.
          (call-with-values (lambda () (values 1 2)) cons)
            => (1 . 2)

 -- Macro: values-ref mv-expr k
     Returns K-th value of what MV-EXPR returns.  Conceptually, it is
     the same as the following code.
          (call-with-values (lambda () mv-expr) (lambda r (list-ref r k)))
     This macro uses shortcuts for the typical cases like K is zero.

     Similar to Common Lisp's `nth-value', but the argument order is
     flipped to match other Scheme's `*-ref' procedures.


File: gauche-refe.info,  Node: Delayed evaluation,  Prev: Multiple values,  Up: Control features

6.16.5 Delayed evaluation
-------------------------

Gauche provides an extended lazy evaluation mechanism according to
srfi-45.  Instead of two primitives as R5RS, we have three: `lazy',
`delay', and `force'.

   It is found that the traditional mechanism that uses only `delay'
and `force' didn't mix well with tail-recursive algorithms: It required
unbound memory, despite that the body of the algorithm could be
expressed in iterative manner.  For the detailed explanation please
look at the srfi-45 document.  Here we explain how to use those
primitives.

 -- Special Form: lazy expression
 -- Special Form: delay expression
     [SRFI-45][R5RS] These forms creates a _promise_ that delays the
     evaluation of EXPRESSION.  EXPRESSION will be evaluated when the
     promise is passed to `force'.

     If EXPRESSION itself is expected to yield a promise, you should
     use `lazy'.  Othewise, you should use `delay'.  If you can think
     in types, the difference may be clearer.

          lazy  : Promise a -> Promise a
          delay : a -> Promise a

     Since we don't have static typing, we can't enforce this usage.
     The programmer has to choose appropriate one from the context.
     Generally, `lazy' appearers only to surround the entire body of
     function that express a lazy algorithm.

     For the real-world example of use of `lazy', you may want to check
     the implementation of `util.stream' (*Note Stream library::).

 -- Function: force promise
     [R5RS] If PROMISE is not a promise, it is just returned.

     Otherwise, if PROMISE's value hasn't been computed, `force' makes
     PROMISE's encapsulated expression be evaluated, and returns the
     result.

     Once PROMISE's value is computed, it is memorized in it so that
     subsequent `force' on it won't cause the computation.

 -- Function: promise? obj
     Returns `#t' iff OBJ is a promise object.

   The following example represents Fibonacci numbers by a lazy list.
The list `fib' is calculated by adding `fib' itself shifted one element.
Since it uses cached result of previous elements, calculation of n-th
Fibonacci number can be done in O(n).

     (define (lcar lis)   ;; lazy car
       (car (force lis)))

     (define (lcdr lis)   ;; lazy cdr
       (cdr (force lis)))

     (define (ltake lis n)  ;; lazy take
       (if (<= n 0) '() (cons (lcar lis) (ltake (lcdr lis) (- n 1)))))

     (define (lmap proc l1 l2)  ;; lazy map
       (if (null? l1)
         '()
         (cons (proc (lcar l1) (lcar l2))
               (delay (lmap proc (lcdr l1) (lcdr l2))))))

     ;; lazy list of fibonacci numbers
     (define fibs (list* 1 1 (delay (lmap + fibs (cdr fibs)))))

     ;; take a look
     (ltake fibs 20)
       => (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610
           987 1597 2584 4181 6765)

   Note that, although it is elegant, it also requires O(n) storage
even when you only need n-th Fibonacci number.  That's because the
`delay' expression in the tail of `fibs' is grabbing the head of `fibs'
list and never releases it.


File: gauche-refe.info,  Node: Exceptions,  Next: Eval and repl,  Prev: Control features,  Up: Core library

6.17 Exceptions
===============

Gauche's exception system consists of three components; (1) the way to
signal an exceptional case has occurred, (2) the way to specify how to
handle such a case, and (3) the standard objects (_conditions_) to
communicate the code that signals an exceptional case and the code that
handles it.

   Those three components are typically used together, so first we
explain the typical usage patterns using examples.  Then we describe
each feature in detail.

   Note for terminology: some languages use the word _exception_ to
refer to an object used to communicate the code that encountered an
exceptional situation with a handler that deals with it.  Gauche uses a
term _condition_ to refer to such objects, following SRFI-35.
_Exception_ is the situation, and _condition_ is a runtime object that
describes it.

* Menu:

* Exception handling overview::
* Signalling exceptions::
* Handling exceptions::
* Conditions::


File: gauche-refe.info,  Node: Exception handling overview,  Next: Signalling exceptions,  Prev: Exceptions,  Up: Exceptions

6.17.1 Exception handling overview
----------------------------------

Catching specific errors
........................

One of the most typical exception handling is to catch a specific error
raised by some built-in or library procedures.  A macro `guard' can be
used for such a purpose.  The code looks like this:

     (guard (exc
             ((condition-has-type? exc <read-error>) (format #t "read error!")
                                                     'read-error)
             (else 'other-error))
       (read-from-string "(abc"))

   The cadr of `guard' clause is a form of `(VARIABLE CLAUSE ...)'.  In
this example, the variable is `exc', and it has two clauses.  Each
CLAUSE has the form like the one in `cond'.

   The cddr of `guard' is the body, a list of expressions.  This
example has only one expression, `(read-from-string "(abc")'.

   `guard' starts executing its body.  `read-from-string' raises an
error of type `<read-error>' when it encounters syntactic errors.  The
form `guard' intercepts the error, and binds the condition object to
the variable EXC, then checks the clauses following EXC in a similar
manner to `cond'--in this case, the thrown condition is of type
`<read-error>', so the test of the first clause is satisfied, and the
rest of clause is executed, i.e. `"read error!"' is printed and a
symbol `read-error' is returned.

   If you're familiar with other languages, you may recognize the
pattern.  The cddr of `guard' form is like TRY clause of C++/Java or
the cadr of `handler-case' of Common Lisp; and the cdadr of `guard'
form is like `catch' clauses or the cddr of `handler-case'.

   In the test expressions it is common to check the type of thrown
condition.  The function `condition-has-type?' is defined in SRFI-35
but it's rather lengthy.  Gauche's condition classes can also work like
a predicate, so you can write the above expression like this.

     (guard (exc
             ((<read-error> exc) 'read-error)
             (else 'other-error))
       (read-from-string "(abc")))

   _Note:_ Generally you can't use `is-a?' to test if the thrown
condition is of a specific type, since a condition may be _compound_.
See *note Conditions:: about compound conditions.

   If no tests of CLAUSEs satisfy and no `else' clause is given, the
exception `falls off' the `guard' construct, i.e.  it will be handled
by the outer level of `guard' form or top-level.  For example, the
following `guard' form only handles `<read-error>' and `<system-error>';
if the body throws other type of conditions, it must be handled by
outer level.

     (guard (exc
             ((<read-error> exc) (handle-read-error))
             ((<system-error> exc) (handle-system-error))
             )
       body ...)

   See *note Handling exceptions:: for more details on `guard' and
other lower-level exception handling constructs.

Signalling exceptions from your code
....................................

The generic way to signal an exception is to use `raise' procedure.

     (raise CONDITION)

   You can pass any object to CONDITION; its interpretation solely
depends on the exception handler.  If you know the code raises an
integer as a condition, you can catch it by `guard' as this:

     (guard (exc
             ((integer? exc) 'raised))
       (raise 3))

   However, as a convention, it is preferable to use an instance of
`<condition>' or one of its subclasses.  A macro `condition' can be
used to create a condition object.  The following examples show how to
create a condition with some slot values and then raise it.

     ;; create and raise an error condition
     (raise (condition
             (<error> (message "An error occurred."))))

     ;; create and raise a system error condition
     (raise (condition
             (<system-error> (message "A system error occurred.")
                             (errno EINTR))))

   See *note Conditions:: for the details of `condition' macro and what
kind of condition classes are provided.

   The most common type of condition is an error condition, so a
convenience procedure `error' and `errorf' are provided.  They create
an error condition with a message and raise it.

     ;; `error' concatenates the arguments into a message.
     (unless (integer? obj)
       (error "Integer expected, but got:" obj))

     ;; `errorf' uses format to create a message.
     (unless (equal? x y)
       (errorf "~s and ~s don't match" x y))

   _Note:_ unlike the exception throwing constructs in some languages,
such as `throw' of C++/Java, which abandons its continuation, Scheme's
`raise' may return to its caller.   If you don't want `raise' to
return, a rule of thumb is always to pass one of error conditions to
it; then Gauche guarantees `raise' wont return.   See the description
of `raise' in *note Signalling exceptions:: for more details.

Defining your own condition
...........................

You can also define your own condition classes to pass
application-specific information from the point of raising exception to
the handlers.

   To fit to Gauche's framework (SRFI-35), it is desirable that the new
condition class inherits a built-in `<condition>' class or one of its
descendants, and also is an instance of a metaclass `<condition-meta>'.

   One way of ensuring the above convention as well as increasing
portability is to use `define-condition-type' macro, defined in
`SRFI-35'.

     (define-condition-type <myapp-error> <error>
       myapp-error?
       (debug-info myapp-error-debug-info)
       (reason myapp-error-reason))

   This defines a condition type (which is a class in Gauche)
`<myapp-error>', with a predicate `myapp-error?' and slots with
accessors.   Then you can use the new condition type like the following
code:

     (guard (exc
              ((myapp-error? exc)
               (let ((debug-info (myapp-error-debug-info exc))
                     (reason (myapp-error-reason exc)))
                 ... handle myapp-error ...)))
       ...
       ...
       (if (something-went-wrong)
         (raise (condition
                  (<myapp-error> (debug-info "during processing xxx")
                                 (reason "something went wrong")))))
       ...
       ...
       )

   If you don't mind to lose srfi compatibility, you can use Gauche's
extended `error' and `errorf' procedures to write more concise code to
raise a condition of subtype of `<error>':

       (if (something-went-wrong)
         (error <myapp-error>
                :debug-info "during processing xxx"
                :reason "something went wrong"))

   See the description of `define-condition-type' macro for how the
condition type is implemented in Gauche's object system.


File: gauche-refe.info,  Node: Signalling exceptions,  Next: Handling exceptions,  Prev: Exception handling overview,  Up: Exceptions

6.17.2 Signalling exceptions
----------------------------

Signalling errors
.................

The most common case of exceptions is an error.  Two convenience
functions to signal an error condition in simple cases are provided.
To signal a compound condition, you can use `raise' as explained below.

 -- Function: error string arg ...
 -- Function: error condition-type keyword-arg ... string arg ...
     [SRFI-23+] Signals an error.  The first form creates an `<error>'
     condition, with a message consists of STRING and ARG ..., and
     raises it.  It is compatible to srfi-23's `error' behavior.

          gosh> (define (check-integer x)
                  (unless (integer? x)
                     (error "Integer required, but got:" x)))
          check-integer
          gosh> (check-integer "a")
          *** ERROR: Integer required, but got: "a"
          Stack Trace:
          _______________________________________

     The second form can be used to raise an error other than the
     `<error>' condition.  CONDITION-TYPE must be a condition type (see
     *note Conditions:: for more explanation of condition types).  It
     may be followed by keyword-value list to initialize the condition
     slots, and then optionally followed by a string and other objects
     that becomes an error message.

          (define-condition-type <my-error> <error> #f
            (reason)
            (priority))

          ...
            (unless (memq operation *supported-operations*)
              (error <my-error>
                     :reason 'not-supported :priority 'urgent
                     "Operation not supported:" operation))
          ...

 -- Function: errorf fmt-string arg ...
 -- Function: errorf condition-type keyword-arg ... fmt-string arg ...
     Similar to `error', but the error message is formatted by
     `format', i.e. the first form is equivalent to:
          (define (errorf fmt . args)
            (error (apply format #f fmt args)))

     The second form can be used to raise an error other than an
     `<error>' condition.  Meaning of CONDITION-TYPE and KEYWORD-ARGs
     are the same as `error'.

Signalling generic conditions
.............................

 -- Function: raise condition
     [SRFI-18] This is the base mechanism of signalling exceptions.

     The procedure invokes the current exception handler.  The argument
     CONDITION represents the nature of the exception, and passed to
     the exception handler.  Gauche's built-in and library functions
     always use an instance of `<condition>' or one of its subclasses
     as CONDITION, but you can pass any Scheme object to `raise'.  The
     interpretation of CONDITION is up to the exception handler.

     _Note:_ Unlike some of the mainstream languages in which
     "throwing" an exception never returns, you can set up an exception
     handler in the way that `raise' may return.  The details are
     explained in *note Handling exceptions::.

     If you don't want `raise' to return, the best way is to pass a
     condition which is an instance of `<serious-condition>' or one of
     its subclasses.  Gauche's internal mechanism guarantees raising
     such an exception won't return.  See *note Conditions:: for the
     hierarchy of built-in conditions.


File: gauche-refe.info,  Node: Handling exceptions,  Next: Conditions,  Prev: Signalling exceptions,  Up: Exceptions

6.17.3 Handling exceptions
--------------------------

High-level exception handling mechanism
.......................................

 -- Macro: guard (var clause ...) body ...
     [SRFI-34] This is _the_ high-level form to handle errors in Gauche.

     VAR is a symbol, and CLAUSEs are the same form as `cond''s
     clauses, i.e. each clause can be either one of the following forms:
       1. `(TEST EXPR ...)'

       2. `(TEST => PROC)'

     The last CLAUSE may be `(else EXPR ...)'.

     This form evaluates BODY ... and returns the value(s) of the last
     BODY expression in normal case.  If an exception is raised during
     the evaluation of body expressions, the raised exception is bound
     to a variable VAR, then evaluates TEST expression of each clause.
     If one of TEST expressions returns true value, then the
     corresponding EXPRs are evaluated if the clause is the first form
     above, or an PROC is evaluated and the result of TEST is passed to
     the procedure PROC if the clause is the second form.

     When the TEST(s) and EXPR(s) in the clauses are evaluated, the
     exception handler that is in effect of the caller of `guard' are
     installed; that is, if an exception is raised again within CLAUSEs,
     it is handled by the _outer_ exception handler or `guard' form.

     If no TEST returns true value and the last `clause' is `else'
     clause, then the associated EXPRs are evaluated.  If no TEST
     returns true value and there's no `else' clause, the raised
     exception is re-raised, to be handled by the outer exception
     handler.

     When the exception is handled by one of `clause's, `guard' returns
     the value(s) of the last EXPR in the handling clause.

     The CLAUSEs are evaluated in the same dynamic environment as the
     `guard' form, i.e. any `dynamic-wind's inside `body' are unwound
     before evaluation of the CLAUSEs.  It is different from the lower
     level forms `with-error-handler' and `with-exception-handler',
     whose handler is evaluated before the dynamic environment are
     unwound.

          (let ((z '()))
            (guard (e (else (push! z 'caught)))
              (dynamic-wind (lambda () (push! z 'pre))
                            (lambda () (error "foo"))
                            (lambda () (push! z 'post))))
            (reverse z))
           => (pre post caught)

          (guard (e (else (print 'OUTER) #f))
            (with-output-to-string ()
              (print 'INNER)
              (error "foo")))
           => prints OUTER to the current output port of guard,
                not to the string port.

 -- Macro: unwind-protect body cleanup
     Executes BODY, then executes CLEANUP, and returns the result(s) of
     BODY.  If an exception is raised within BODY, CLEANUP is executed
     before the exception escapes from the `unwind-protect' form.  For
     example, the following code calls `start-motor', `drill-a-hole',
     and `stop-motor' in order if everything goes ok, and if anything
     goes wrong in `start-motor' or `drill-a-hole', `stop-motor' is
     still called before the exception escapes `unwind-protect'.

          (unwind-protect
            (begin (start-motor)
                   (drill-a-hole))
            (stop-motor))

     The CLEANUP form is evaluated in the same dynamic environment as
     `unwind-protect'.  If an exception is thrown within CLEANUP, it
     will be handled outside of the `unwind-protect' form.

     Although this form looks similar to `dynamic-wind', they work at
     different layers and should not be confused.  `dynamic-wind' is
     the bottom-level building block and used to manage current
     exception handlers, current i/o ports, parameters, etc.
     `dynamic-wind''s BEFORE and AFTER thunks are called whenever any
     of those control flow transition occurs.  On the other hand,
     `unwind-protect' only cares about the Gauche's exception system.
     `unwind-protect''s CLEANUP is called only when BODY throws
     Gauche's exception.  In the above example, if control escapes from
     `drill-a-hole' by calling a continuation captured outside of
     `unwind-protect', CLEANUP is not called; because the control may
     return to `drill-a-hole' again.  It can happen if user-level thread
     system is implemented by `call/cc', for example.

     The name of this form is taken from Common Lisp.  Some Scheme
     systems have similar macros in different names, such as
     `try-finally'.

 -- Function: with-error-handler handler thunk
     Makes HANDLER the active error handler and executes THUNK.  If
     THUNK returns normally, the result(s) will be returned.  If an
     error is signalled during execution of THUNK, HANDLER is called
     with one argument, an exception object representing the error,
     with the continuation of `with-error-handler'.  That is,
     `with-error-handler' returns whatever value(s) HANDLER returns.

     If HANDLER signals an error, it will be handled by the handler
     installed when `with-error-handler' called.

     The dynamic environment where HANDLER is executed is the same as
     the error occurs.  If `dynamic-wind' is used in THUNK, its AFTER
     method is called after HANDLER has returned, and before
     `with-error-handler' returns.

     Note: Using this procedure directly is _no longer recommended_,
     since `guard' is more safe and portable.  We'll keep this for a
     while for the backward compatibility, but we recommend to rewrite
     code to use `guard' instead of this.  The common idiom of "cleanup
     on error" code:
          (with-error-handler (lambda (e) (cleanup) (raise e))
            (lambda () body ...))
     should be written like this:
          (guard (e (else (cleanup) (raise e)))
            body ...)

Behavior of unhandled exception
...............................

If an exception is raised where no program-defined exception handler is
installed, the following action is taken.

   * If the program is running interactively (in repl), the information
     of the thrown exception and stack trace are displayed, and the
     program returns to the toplevel prompt.

   * If the program is running non-interactively, the information of
     the thrown exception and stack trace are displayed, then the
     program exits with an exit status `EX_SOFTWARE' (70).

Low-level exception handling mechanism
......................................

This layer provides SRFI-18 compatible simple exception mechanism.  You
can override the behavior of higher-level constructs such as
`with-error-handler' by using `with-exception-handler'.

   Note that it is a double-edged sword.  You'll get a freedom to
construct your own exception handling semantics, but the Gauche system
won't save if something goes wrong.   Use these primitives when you
want to customize the system's higher-level semantics or you are
porting from other SRFI-18 code.

 -- Function: current-exception-handler
     [SRFI-18] Returns the current exception handler.

 -- Function: with-exception-handler handler thunk
     [SRFI-18] A procedure HANDLER must take one argument.  This
     procedure sets HANDLER to the current exception handler and calls
     THUNK.

   Generally, if you want to handle non-continuable exception such as
errors using this low-level mechanism, you have to transfer the control
from the handler explicitly (See the explanation of
`with-error-handler' above).  `raise' detects if the handler returns on
the non-continuable exceptions and reports an error using the default
error handler mechanism, but it is just a safety net.

   Note also that HANDLER is called in the same dynamic environment of
`raise'.  So if you raise an exception inside HANDLER, it is captured
by HANDLER again.   It is the programmer's responsibility to propagate
the exception handling to the "outer" exception handlers.

   The behavior of those procedures can be explained in the following
conceptual Scheme code.

     ;; Conceptual implementation of low-level exception mechanism.
     ;; Suppose %xh is a list of exception handlers

     (define (current-exception-handler) (car %xh))

     (define (raise exn)
       (receive r ((car %xh) exn)
         (when (uncontinuable-exception? exn)
           (set! %xh (cdr %xh))
           (raise (make-error "returned from uncontinuable exception")))
         (apply values r)))

     (define (with-exception-handler handler thunk)
       (let ((prev %xh))
         (dynamic-wind
           (lambda () (set! %xh (cons handler %xh)))
           thunk
           (lambda () (set! %xh prev)))))


File: gauche-refe.info,  Node: Conditions,  Prev: Handling exceptions,  Up: Exceptions

6.17.4 Conditions
-----------------

Built-in Condition classes
..........................

Gauche currently has the following hierarchy of built-in condition
classes.  It approximately reflects SRFI-35 and SRFI-36 condition
hierarchy, although they have Gauche-style class names.  If there's a
corresponding SRFI condition type, the class has the SRFI name as well.

       <condition>
         +- <compound-condition>
         +- <serious-condition>
         |    +- <serious-compound-condition> ; also inherits <compound-condition>
         +- <message-condition>
              +- <error>                      ; also inherits <serious-condition>
                   +- <system-error>
                   +- <unhandled-signal-error>
                   +- <read-error>
                   +- <io-error>
                        +- <port-error>
                             +- <io-read-error>
                             +- <io-write-error>
                             +- <io-closed-error>
                             +- <io-unit-error>

   Note that some conditions may occur simultaneously; for example,
error during reading from a file because of device failure may consist
both `<system-error>' _and_ `<io-read-error>'.  In such cases, a
_compound condition_ is raised.  So you can't just use, for instance,
`(is-a? obj <io-read-error>)' to check if `<io-read-error>' is thrown.
See the "Condition API" section below.

 -- Metaclass: <condition-meta>
     Every condition class is an instance of this class.  This class
     defines `object-apply' so that you can use a condition class as a
     predicate, e.g.:

          (<error> obj) == (condition-has-type? obj <error>)

 -- Class: <condition>
 -- Condition Type: &condition
     [SRFI-35] The root class of the condition hierarchy.

 -- Class: <compound-condition>
     Represents a compound condition.  A compound condition can be
     created from one or more conditions by `make-compound-condition'.
     Don't use this class directly.

     A compound condition returns `#t' for `condition-has-type?' if any
     of the original conditions has the given type.

 -- Class: <serious-condition>
 -- Condition Type: &serious
     [SRFI-35] Conditions of this class are for the situations that are
     too serious to ignore or continue.  Particularly, you can safely
     assume that if you `raise' this type of condition, it never
     returns.

 -- Class: <serious-compound-condition>
     This is an internal class to represent a compound condition with
     any of its component condition is serious.   Inherits both
     `<compound-condition>' and `<serious-condition>'.
     `make-compound-condition' uses this class if the passed conditions
     includes a serious one.  Don't use this class directly.

 -- Class: <message-condition>
 -- Condition Type: &message
     [SRFI-35] This class represents a condition with a message.  It
     has one slot.

      -- Instance Variable of <message-condition>: message
          A message.


 -- Class: <error>
 -- Condition Type: &error
     [SRFI-35] Indicates an error.  Inherits `<serious-condition>' and
     `<message-condition>', thus has `message' slot.

     Note: SRFI-35 `&error' condition only inherits `&serious' and not
     `&message', so you have to use compound condition to attach a
     message to the error condition.  Gauche uses multiple inheritance
     here, largely because of backward compatibility.  To write a
     portable code, an error condition should be used with a message
     condition, like this:

          (condition
            (&message (message "Error message"))
            (&error))

 -- Class: <system-error>
     A subclass of `<error>'.  When a system call returns an error,
     this type of exception is thrown.  The `message' slot usually
     contains the description of the error (like the one from
     `strerror(3)').  Besides that, this class has one more instance
     slot:

      -- Instance Variable of <system-error>: errno
          Contains an integer value of system's error number.

          Error numbers may differ among systems.  Gauche defines
          constants for typical Unix error values (e.g. `EACCES',
          `EBADF', etc), so it is desirable to use them instead of
          literal numbers.  See the description of `sys-strerror' in
          *note System inquiry:: for available constants.

     This class doesn't have corresponding SRFI condition type, but
     important to obtain OS's raw error code.  In some cases, this type
     of condition is compounded with other condition types, like
     `<io-read-error>'.

 -- Class: <unhandled-signal-error>
     A subclass of `<error>'.  The default handler of most of signals
     raises this condition.   See *note Handling signals:: for the
     details.

      -- Instance Variable of <unhandled-signal-error>: signal
          An integer indicating the received signal number.  There are
          constants defined for typical signal numbers; see *note
          Signals and signal sets::.

 -- Class: <read-error>
 -- Condition Type: &read-error
     [SRFI-36] A subclass of `<error>'.  When the reader detects a
     lexical or syntactic error during reading an S-expression, this
     type of condition is raised.

      -- Instance Variable of <read-error>: port
          A port from which the reader is reading.  (NB: SRFI-36's
          `&read-error' doesn't have this slot.  Portable program
          shouldn't rely on this slot).

      -- Instance Variable of <read-error>: line
          A line count (1-base) of the input where the reader raised
          this error.  It may be -1 if the reader is reading from a
          port that doesn't keep track of line count.

      -- Instance Variable of <read-error>: column
      -- Instance Variable of <read-error>: position
      -- Instance Variable of <read-error>: span
          These slots are defined in SRFI-36's `&read-error'.  For the
          time being, these slots always hold `#f'.


 -- Class: <io-error>
 -- Condition Type: &io-error
     [SRFI-36] A base class of I/O errors.  Inherits `<error>'.

 -- Class: <port-error>
 -- Condition Type: &io-port-error
     [SRFI-36] An I/O error related to a port.   Inherits `<io-error>'.

      -- Instance Variable of <port-error>: port
          Holds the port where the error occurred.

 -- Class: <io-read-error>
 -- Condition Type: &io-read-error
     [SRFI-36] An I/O error during reading from a port.  Inherits
     `<port-error>'.

 -- Class: <io-write-error>
 -- Condition Type: &io-write-error
     [SRFI-36] An I/O error during writing to a port.  Inherits
     `<port-error>'.

 -- Class: <io-closed-error>
 -- Condition Type: &io-closed-error
     [SRFI-36] An I/O error when read/write is attempted on a closed
     port.  Inherits `<port-error>'.

 -- Class: <io-unit-error>
     An I/O error when the read/write is requested with a unit that is
     not supported by the port (e.g. a binary I/O is requested on a
     character-only port).   Inherits `<port-error>'.

Condition API
.............

 -- Macro: define-condition-type name supertype predicate field-spec ...
     [SRFI-35+] Defines a new condition type.  In Gauche, a condition
     type is a class, whose metaclass is `<condition-meta>'.

     NAME becomes the name of the new type, and also the variable of
     that name is bound to the created condition type.  SUPERTYPE is
     the name of the supertype (direct superclass) of this condition
     type.  A condition type must inherit from `<condition>' or its
     descendants.  (Multiple inheritance can't be specified by this
     form, and generally should be avoided in condition type hierarchy.
     Instead, you can use compound conditions, which don't introduce
     multiple inheritance.)

     A variable PREDICATE is bound to a predicate procedure for this
     condition type.

     Each `field-spec' is a form of `(field-name accessor-name)', and
     the condition will have fields named by FIELD-NAME, and a variable
     ACCESSOR-NAME will be bound to a procedure that accesses the
     field.   In Gauche, each field becomes a slot of the created class.

     Gauche extends srfi-35 to allow PREDICATE and/or `accessor-name'
     to be `#f', or `accessor-name' to be omitted, if you don't need to
     them to be defined.

     When `define-condition-type' is expanded into a class definition,
     each slot gets a `:init-keyword' slot option with the keyword
     whose name is the same as the slot name.

 -- Function: condition-type? obj
     [SRFI-35] Returns `#t' iff OBJ is a condition type.  In Gauche, it
     means `(is-a? obj <condition-meta>)'.

 -- Function: make-condition-type name parent field-names
     [SRFI-35] A procedural version to create a new condition type.

 -- Function: make-condition type field-name value ...
     [SRFI-35] Creates a new condition of condition-type TYPE, and
     initializes its fields as specified by `field-name' and `value'
     pairs Returns `#t' iff OBJ is a condition.  In Gauche, it means
     `(is-a? obj <condition>)'.

 -- Function: condition-has-type? obj type
     [SRFI-35] Returns `#t' iff OBJ belongs to a condition type TYPE.
     Because of compound conditions, this is not equivalent to `is-a?'.

 -- Function: condition-ref condition field-name
     [SRFI-35] Retrieves the value of field FIELD-NAME of CONDITION.
     If CONDITION is a compound condition, you can access to the field
     of its original conditions; if more than one original condition
     have FIELD-NAME, the first one passed to `make-compound-condition'
     has precedence.

     You can use SLOT-REF and/or REF to access to the field of
     conditions; compound conditions define a `slot-missing' method so
     that SLOT-REF behaves as if the compound conditions have all the
     slots of the original conditions.  Using `condition-ref' increases
     portability, though.

 -- Function: make-compound-condition condition0 condition1 ...
     [SRFI-35] Returns a compound condition that has all CONDITION0
     CONDITION1 ....  The returned condition's fields are the union of
     all the fields of given conditions; if any conditions have the
     same name of fields, the first one takes precedence.   The
     returned condition also has condition-type of all the types of
     given conditions.  (This is not a multiple inheritance.  See
     `<compound-condition>' above.)

 -- Function: extract-condition condition condition-type
     [SRFI-35] CONDITION must be a condition and have type
     CONDITION-TYPE.  This procedure returns a condition of
     CONDITION-TYPE, with field values extracted from CONDITION.

 -- Macro: condition type-field-binding ...
     [SRFI-35] A convenience macro to create a (possibly compound)
     condition.  TYPE-FIELD-BINDING is a form of `(CONDITION-TYPE
     (FIELD-NAME VALUE-EXPR) ...)'.

          (condition
            (type0 (field00 value00) ...)
            (type1 (field10 value10) ...)
            ...)
           ==
          (make-compound-condition
            (make-condition type0 'field00 value00 ...)
            (make-condition type1 'field10 value10 ...)
            ...)


File: gauche-refe.info,  Node: Eval and repl,  Next: Input and output,  Prev: Exceptions,  Up: Core library

6.18 Eval and repl
==================

 -- Function: eval expr env
     [R5RS] Evaluate EXPR.   ENV must be a value returned by the
     following procedures below.  Right now it is just a `<module>'
     object, but it is possible that the Gauche adopts a first-class
     environment object in future.

 -- Function: null-environment version
 -- Function: scheme-report-environment version
 -- Function: interaction-environment
     [R5RS] Returns an environment specifier which can be used as the
     second argument of `eval'.   Right now an environment specifier is
     just a module.  `(null-environment 5)' returns a `null' module,
     which contains just the syntactic bindings specified in R5RS,
     `(scheme-report-environment 5)' returns a `scheme' module, which
     contains syntactic and procedure bindings in R5RS, and
     `(interaction-environment)' returns a `user' module that contains
     all the Gauche built-ins plus whatever the user defined.  It is
     possible that the Gauche adopts a first-class environment object
     in future, so do not rely on the fact that the environment
     specifier is just a module.

     An error is signaled if a value other than 5 is passed as VERSION
     argument.


 -- Function: read-eval-print-loop &optional reader evaluator printer
          prompter
     This exports `Gosh''s default read-eval-print loop to applications.
     Each argument can be `#f', which indicates it to use Gauche's
     default procedure(s), or a procedure that satisfies the following
     conditions.

    _reader_
          A procedure that takes no arguments.  It is supposed to read
          an expression and returns it.

    _evaluator_
          A procedure that takes two arguments, an expression and an
          environment specifier.  It is supposed to evaluate the
          expression and returns zero or more value(s).

    _printer_
          A procedure that takes zero or more arguments.   It is
          supposed to print out these values.   The result of this
          procedure is discarded.

    _prompter_
          A procedure that takes no arguments.  It is supposed to print
          out the prompt.   The result of this procedure is discarded.

     Given those procedures, `read-eval-print-loop' runs as follows:

       1. Prints the prompt by calling PROMPTER.

       2. Reads an expression by calling READER.  If it returns EOF,
          exits the loop and returns from `read-eval-print-loop'.

       3. Evaluates an expression by calling EVALUATOR

       4. Prints the result by calling PRINTER, then repeats from 1.

     When an error is signaled from one of those procedures, it is
     captured and reported by the default escape handler, then the loop
     restarts from 1.

     It is OK to capture a continuation within those procedures and
     re-invoke them afterwards.


File: gauche-refe.info,  Node: Input and output,  Next: Loading Programs,  Prev: Eval and repl,  Up: Core library

6.19 Input and Output
=====================

* Menu:

* Ports::
* Port and threads::
* Common port operations::
* File ports::
* String ports::
* Coding-aware ports::
* Input::
* Output::


File: gauche-refe.info,  Node: Ports,  Next: Port and threads,  Prev: Input and output,  Up: Input and output

6.19.1 Ports
------------

 -- Builtin Class: <port>
     A port class.   A port is Scheme's way of abstraction of I/O
     channel.  Gauche extends a port in number of ways so that it can
     be used in wide range of applications.

     Standard Scheme (R5RS) essentially defines a port as an entity that
     you can fetch a character at a time and look one character ahead
     from an input port, and put a character at a time to an output
     port.  Other R5RS I/O routines can be built on top of them.

     Besides this basics, Gauche's port can handle the following
     operations.

    Binary I/O
          You can read/write one octet at a time, instead of a
          character.  (Remember, Gauche handles multibyte characters,
          so a character may be consisted from more than one bytes).
          Most ports allow you to mix binary I/O and character I/O, if
          needed.

          The most basic binary I/O primitives are `read-byte' and
          `write-byte'.  You can also use higher-level functionality,
          such as `pack' and `unpack' in *note Packing Binary Data::.

    Block I/O
          You can read/write a specified number of byte sequences.
          This can be an efficient way of moving block of data, if the
          port's underlying implementation supports block I/O operation.

    Conversion
          Some ports can be used to convert a data stream from one
          format to another; one of such applications is character code
          conversion ports, provided by `gauche.charconv' module (*Note
          Character code conversion::, for details).

    Extra features
          There are also a ports with special functionality.  A
          coding-aware port (*Note Coding-aware ports::) recognizes a
          special "magic comment" in the file to know which character
          encoding the file is written.  Virtual ports (*Note Virtual
          ports::) allows you to program the behavior of the port in
          Scheme.



File: gauche-refe.info,  Node: Port and threads,  Next: Common port operations,  Prev: Ports,  Up: Input and output

6.19.2 Port and threads
-----------------------

When Gauche is compiled with thread support, the builtin port
operations locks the port, so that port access from multiple threads
will be serialized.  (It is required by SRFI-18, BTW).  Here, "builtin
port operations" are the port access functions that takes a port and
does some I/O or query on it, such as `read'/`write',
`read-char'/`write-char', `port->string', etc.  Note that `call-with-*'
and `with-*' procedures do not lock the port during calling the given
procedures, since the procedure may pass the reference of the port to
the other thread, and Gauche wouldn't know if that's the case.

   This means you don't need to be too paranoia to worry about ports
under multithreaded environment.  However, keep it in mind that this
locking mechanism is meant to be a safety net from breaking the port's
internal state, and not to be a general mutex mechanism.  It assumes
port accesses rarely conflict, and uses spin lock to reduce the
overhead of majority cases.  If you know there will be more than one
thread accessing the same port, you should use explicit mutex to avoid
conflicts.

 -- Function: with-port-locking port thunk
     Executes THUNK, while making the calling thread hold the exclusive
     lock of PORT during the dynamic extent of THUNK.

     Calls of the builtin port functions during the lock is held would
     bypass mutex operations and yield better performance.

     Note that the lock is held during the dynamic extent of THUNK; so,
     if THUNK invokes a continuation captured outside of
     `with-port-locking', the lock is released.  If the continuation
     captured within THUNK is invoked afterwards, the lock is
     re-acquired.

     `With-port-locking' may be nested.  The lock is valid during the
     outermost call of `with-port-locking'.

     Note that this procedure uses the port's built-in lock mechanism
     which uses busy wait when port access conflicts.  It should be
     used only for avoiding fine-grain lock overhead; use explicit
     mutex if you know there will be conflicts.

