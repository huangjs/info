This is slime.info, produced by makeinfo version 4.8 from slime.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* SLIME: (slime).    Superior Lisp Interaction Mode for Emacs.
END-INFO-DIR-ENTRY


File: slime.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

SLIME
*****

SLIME is the "Superior Lisp Interaction Mode for Emacs". This is the
manual for version 1.2.

* Menu:

* Introduction::
* Getting started::
* slime-mode::
* REPL::
* Debugger::
* Extras::
* Customization::
* Tips and Tricks::
* Credits::
* Index to Key Bindings::
* Index to Functions::


File: slime.info,  Node: Introduction,  Next: Getting started,  Prev: Top,  Up: Top

1 Introduction
**************

SLIME is the "Superior Lisp Interaction Mode for Emacs."

   SLIME extends Emacs with new support for interactive programming in
Common Lisp. The features are centered around `slime-mode', an Emacs
minor-mode that complements the standard `lisp-mode'. While `lisp-mode'
supports editing Lisp source files, `slime-mode' adds support for
interacting with a running Common Lisp process for compilation,
debugging, documentation lookup, and so on.

   The `slime-mode' programming environment follows the example of
Emacs's native Emacs Lisp environment. We have also included good ideas
from similar systems (such as ILISP) and some new ideas of our own.

   SLIME is constructed from two parts: a user-interface written in
Emacs Lisp, and a supporting server program written in Common Lisp. The
two sides are connected together with a socket and communicate using an
RPC-like protocol.

   The Lisp server is primarily written in portable Common Lisp. The
required implementation-specific functionality is specified by a
well-defined interface and implemented separately for each Lisp
implementation. This makes SLIME readily portable.


File: slime.info,  Node: Getting started,  Next: slime-mode,  Prev: Introduction,  Up: Top

2 Getting started
*****************

This chapter tells you how to get SLIME up and running.

* Menu:

* Platforms::
* Downloading::
* Installation::
* Running::


File: slime.info,  Node: Platforms,  Next: Downloading,  Prev: Getting started,  Up: Getting started

2.1 Supported Platforms
=======================

SLIME supports a wide range of operating systems and Lisp
implementations. SLIME runs on Unix systems, Mac OSX, and Microsoft
Windows. GNU Emacs versions 20 and 21 and XEmacs version 21 are
supported.

   The supported Lisp implementations, roughly ordered from the
best-supported, are:

   * CMU Common Lisp (CMUCL), 18e or newer

   * Steel Bank Common Lisp (SBCL), latest official release

   * OpenMCL, version 0.14.3 or newer

   * LispWorks, version 4.3 or newer

   * Allegro Common Lisp (ACL), version 6 or newer

   * CLISP, version 2.33.2 or newer

   * Armed Bear Common Lisp (ABCL)

   * Corman Common Lisp (CCL), version 2.51 or newer with the patches
     from `http://www.grumblesmurf.org/lisp/corman-patches')

   * Scieneer Common Lisp (SCL), version 1.2.7 or newer

   Most features work uniformly across implementations, but some are
prone to variation. These include the precision of placing
compiler-note annotations, XREF support, and fancy debugger commands
(like "restart frame").


File: slime.info,  Node: Downloading,  Next: Installation,  Prev: Platforms,  Up: Getting started

2.2 Downloading SLIME
=====================

You can choose between using a released version of SLIME or accessing
our CVS repository directly. You can download the latest released
version from our website:

   `http://www.common-lisp.net/project/slime/'

   We recommend that users who participate in the `slime-devel' mailing
list use the CVS version of the code.

* Menu:

* CVS::
* CVS Incantations::


File: slime.info,  Node: CVS,  Next: CVS Incantations,  Prev: Downloading,  Up: Downloading

2.2.1 Downloading from CVS
--------------------------

SLIME is available from the CVS repository on `common-lisp.net'. You
have the option to use either the very latest code or the tagged
`FAIRLY-STABLE' snapshot.

   The latest version tends to have more features and fewer bugs than
the `FAIRLY-STABLE' version, but it can be unstable during times of
major surgery. As a rule-of-thumb recommendation we suggest that if you
follow the `slime-devel' mailing list then you're better off with the
latest version (we'll send a note when it's undergoing major hacking).
If you don't follow the mailing list you won't know the status of the
latest code, so tracking `FAIRLY-STABLE' or using a released version is
the safe option.

   If you checkout from CVS then remember to `cvs update' occasionally.
Improvements are continually being committed, and the `FAIRLY-STABLE'
tag is moved forward from time to time (about once per month).

* Menu:

* CVS Incantations::


File: slime.info,  Node: CVS Incantations,  Prev: CVS,  Up: Downloading

2.2.2 CVS incantations
----------------------

To download SLIME you first configure your `CVSROOT' and login to the
repository.

     export CVSROOT=:pserver:anonymous@common-lisp.net:/project/slime/cvsroot
     cvs login
   _(The password is `anonymous')_

   The latest version can then be checked out with:
     cvs checkout slime

   Or the `FAIRLY-STABLE' version can be checked out with:

     cvs checkout -rFAIRLY-STABLE slime

   If you want to find out what's new since the version you're currently
running, you can diff the local `ChangeLog' against the repository
version:

     cvs diff -rHEAD ChangeLog      # or: -rFAIRLY-STABLE


File: slime.info,  Node: Installation,  Next: Running,  Prev: Downloading,  Up: Getting started

2.3 Installation
================

With a Lisp implementation that can be started from the command-line,
installation just requires a few lines in your `~/.emacs':

     (setq inferior-lisp-program "_the path to your Lisp system_")
     (add-to-list 'load-path "_the path of your `slime' directory_")
     (require 'slime)
     (slime-setup)

   We recommend not loading the ILISP package into Emacs if you intend
to use SLIME. Doing so will add a lot of extra bindings to the keymap
for Lisp source files that may be confusing and may not work correctly
for a Lisp process started by SLIME.


File: slime.info,  Node: Running,  Prev: Installation,  Up: Getting started

2.4 Running SLIME
=================

SLIME is started with the Emacs command `M-x slime'. This uses the
`inferior-lisp' package to start a Lisp process, loads and starts the
Lisp-side server (known as "Swank"), and establishes a socket
connection between Emacs and Lisp. Finally a REPL buffer is created
where you can enter Lisp expressions for evaluation.

   At this point SLIME is up and running and you can start exploring.

   You can restart the `inferior-lisp' process using the function:
`M-x'
     `slime-restart-inferior-lisp'


File: slime.info,  Node: slime-mode,  Next: REPL,  Prev: Getting started,  Up: Top

3 `slime-mode'
**************

SLIME's commands are provided via `slime-mode', a minor-mode used in
conjunction with Emacs's `lisp-mode'. This chapter describes the
`slime-mode' and its relatives.

* Menu:

* User-interface conventions::
* Commands::
* Semantic indentation::
* Reader conditionals::


File: slime.info,  Node: User-interface conventions,  Next: Commands,  Prev: slime-mode,  Up: slime-mode

3.1 User-interface conventions
==============================

To use SLIME comfortably it is important to understand a few "global"
user-interface characteristics. The most important principles are
described in this section.

* Menu:

* Temporary buffers::
* About key bindings::
* inferior-lisp::
* Multithreading::


File: slime.info,  Node: Temporary buffers,  Next: About key bindings,  Prev: User-interface conventions,  Up: User-interface conventions

3.1.1 Temporary buffers
-----------------------

Some SLIME commands create temporary buffers to display their results.
Although these buffers usually have their own special-purpose
major-modes, certain conventions are observed throughout.

   Temporary buffers can be dismissed by pressing `q'. This kills the
buffer and restores the window configuration as it was before the
buffer was displayed. Temporary buffers can also be killed with the
usual commands like `kill-buffer', in which case the previous window
configuration won't be restored.

   Pressing `RET' is supposed to "do the most obvious useful thing."
For instance, in an apropos buffer this prints a full description of
the symbol at point, and in an XREF buffer it displays the source code
for the reference at point. This convention is inherited from Emacs's
own buffers for apropos listings, compilation results, etc.

   Temporary buffers containing Lisp symbols use `slime-mode' in
addition to any special mode of their own. This makes the usual SLIME
commands available for describing symbols, looking up function
definitions, and so on.


File: slime.info,  Node: About key bindings,  Next: inferior-lisp,  Prev: Temporary buffers,  Up: User-interface conventions

3.1.2 About key bindings
------------------------

A (near) complete list of the default keybindings set by SLIME is given
in an appendix (*note Index to Key Bindings::), with links to their
descriptions.

   In general we try to make our key bindings fit with the overall Emacs
style. We also have the following somewhat unusual convention of our
own: when entering a three-key sequence, the final key can be pressed
either with control or unmodified. For example, the
`slime-describe-symbol' command is bound to `C-c C-d d', but it also
works to type `C-c C-d C-d'. We're simply binding both key sequences
because some people like to hold control for all three keys and others
don't, and with the two-key prefix we're not afraid of running out of
keys.

   There is one exception to this rule, just to trip you up. We never
bind `C-h' anywhere in a key sequence, so `C-c C-d C-h' doesn't do the
same thing as `C-c C-d h'. This is because Emacs has a built-in default
so that typing a prefix followed by `C-h' will display all bindings
starting with that prefix, so `C-c C-d C-h' will actually list the
bindings for all documentation commands.  This feature is just a bit
too useful to clobber!

   You can assign or change default key bindings globally using the
`global-set-key' function in your `~/.emacs' file like this:
     (global-set-key "\C-c s" 'slime-selector)
   which binds `C-c s' to the function `slime-selector'.

   Alternatively, if you want to assign or change a key binding in just
a particular slime mode, you can use the `global-set-key' function in
your `~/.emacs' file like this:
     (define-key slime-repl-mode-map (kbd "C-c ;") 'slime-insert-balanced-comments)
   which binds `C-c ;' to the function `slime-insert-balanced-comments'
in the REPL buffer.


File: slime.info,  Node: inferior-lisp,  Next: Multithreading,  Prev: About key bindings,  Up: User-interface conventions

3.1.3 `*inferior-lisp*' buffer
------------------------------

SLIME internally uses the `inferior-lisp' package to start Lisp
processes. This has a few user-visible consequences, some good and some
not-so-terribly. To avoid confusion it is useful to understand the
interactions.

   The buffer `*inferior-lisp*' contains the Lisp process's own
top-level. This direct access to Lisp is useful for troubleshooting,
and some degree of SLIME integration is available using the
`inferior-slime-mode'. However, in normal use we recommend using the
fully-integrated SLIME REPL and ignoring the `*inferior-lisp*' buffer.

   An unfortunate property of `inferior-lisp' is it inserts some
commands of its own directly into the `lisp-mode' keymap, such that
they aren't easily disabled. This makes Lisp source buffers slightly
schizophrenic, having both SLIME and `inferior-lisp' commands bound to
keys and operating independently.

   SLIME overrides most key bindings, so in practice you are unlikely
to accidentally use an `inferior-lisp' command. If you do find a
command that pops up the `*inferior-lisp*' buffer, that command doesn't
belong to SLIME, and you should probably lookup our equivalent.


File: slime.info,  Node: Multithreading,  Prev: inferior-lisp,  Up: User-interface conventions

3.1.4 Multithreading
--------------------

If the Lisp system supports multithreading, SLIME spawns a new thread
for each request, e.g., `C-x C-e' creates a new thread to evaluate the
expression.  An exception to this rule are requests from the REPL: all
commands entered in the REPL buffer are evaluated in a dedicated REPL
thread.

   Some complications arise with multithreading and special variables.
Non-global special bindings are thread-local, e.g., changing the value
of a let bound special variable in one thread has no effect on the
binding of the variables with the same name in other threads.  This
makes it sometimes difficult to change the printer or reader behaviour
for new threads.  The variable `swank:*default-worker-thread-bindings*'
was introduced for such situtuations: instead of modifying the global
value of a variable, add a binding the
`swank:*default-worker-thread-bindings*'.  E.g., with the following
code, new threads will read floating point values as doubles by default:

     (push '(*read-default-float-format* . double-float)
            swank:*default-worker-thread-bindings*).


File: slime.info,  Node: Commands,  Next: Semantic indentation,  Prev: User-interface conventions,  Up: slime-mode

3.2 Commands
============

SLIME commands are divided into the following general categories:
*Programming, Compilation, Evaluation, Recovery, Inspector, and
Profiling*, discussed in separate sections below. There are also
comprehensive indices to commands by function (*note Index to
Functions::) and by key binding (*note Index to Key Bindings::).

* Menu:

* Programming::
* Compilation::
* Evaluation::
* Recovery::
* Inspector::
* Profiling::
* Other::


File: slime.info,  Node: Programming,  Next: Compilation,  Up: Commands

3.2.1 Programming commands
--------------------------

Programming commands are divided into the following categories:
*Completion, Documentation, Coss-reference, Finding definitions,
Macro-expansion, and Disassembly*, discussed in separate sections below.

* Menu:

* Completion::
* Closure::
* Indentation::
* Documentation::
* Cross-reference::
* Finding definitions::
* Macro-expansion::
* Disassembly::


File: slime.info,  Node: Completion,  Next: Closure,  Up: Programming

3.2.1.1 Completion commands
...........................

Completion commands are used to complete a symbol or form based on what
is already present at point. Classical completion assumes an exact
prefix and gives choices only where branches may occur. Fuzzy
completion tries harder.

`M-TAB'

`C-c C-i'

`C-M-i'
     `slime-complete-symbol'
     Complete the symbol at point. Note that three styles of completion
     are available in SLIME, and the default differs from normal Emacs
     completion (*note slime-complete-symbol-function::).  *Note
     Emacs-side customization::.

`C-c C-s'
     `slime-complete-form'
     Looks up and inserts into the current buffer the argument list for
     the function at point, if there is one.  More generally, the
     command completes an incomplete form with a template for the
     missing arguments.  There is special code for discovering extra
     keywords of generic functions and for handling `make-instance' and
     `defmethod'. Examples:

          (subseq "abc" <C-c C-s>
            --inserts--> start [end])
          (find 17 <C-c C-s>
            --inserts--> sequence :from-end from-end :test test
                         :test-not test-not :start start :end end
                         :key key)
          (find 17 '(17 18 19) :test #'= <C-c C-s>
            --inserts--> :from-end from-end
                         :test-not test-not :start start :end end
                         :key key)
          (defclass foo () ((bar :initarg :bar)))
          (defmethod print-object <C-c C-s>
            --inserts-->   (object stream)
                         body...)
          (defmethod initialize-instance :after ((object foo) &key blub))
          (make-instance 'foo <C-c C-s>
            --inserts--> :bar bar :blub blub initargs...)

`C-c M-i'
     `slime-fuzzy-complete-symbol'
     Presents a list of likely completions to choose from for an
     abbreviation at point.  This is a third completion method and it is
     very different from the more traditional completion to which
     `slime-complete-symbol' defaults.  It attempts to complete a
     symbol all at once, instead of in pieces.  For example, "mvb" will
     find "`multiple-value-bind'" and "norm-df" will find
     "`least-positive-normalized-double-float'".  This can also be
     selected as the method of completion used for
     `slime-complete-symbol'.

`M-x'
     `slime-fuzzy-completions-mode'
`M-x'
     `slime-fuzzy-abort'


File: slime.info,  Node: Closure,  Next: Indentation,  Prev: Completion,  Up: Programming

3.2.1.2 Closure commands
........................

Closure commands are used to fill in missing parenthesis.

`C-c C-q'
     `slime-close-parens-at-point'
     Closes parentheses at point to complete the top-level-form by
     inserting ')' characters at until `beginning-of-defun' and
     `end-of-defun' execute without errors, or
     `slime-close-parens-limit' is exceeded.

`C-]'
     `slime-close-all-sexp'
     Balance parentheses of open s-expressions at point.  Insert enough
     right-parentheses to balance unmatched left-parentheses.  Delete
     extra left-parentheses.  Reformat trailing parentheses
     Lisp-stylishly.

     If `REGION' is true, operate on the region. Otherwise operate on
     the top-level sexp before point.


File: slime.info,  Node: Indentation,  Next: Documentation,  Prev: Closure,  Up: Programming

3.2.1.3 Indentation commands
............................

`C-c M-q'
     `slime-reindent-defun'
     Re-indents the current defun, or refills the current paragraph.
     If point is inside a comment block, the text around point will be
     treated as a paragraph and will be filled with `fill-paragraph'.
     Otherwise, it will be treated as Lisp code, and the current defun
     will be reindented.  If the current defun has unbalanced parens,
     an attempt will be made to fix it before reindenting.

     When given a prefix argument, the text around point will always be
     treated as a paragraph.  This is useful for filling docstrings."


File: slime.info,  Node: Documentation,  Next: Cross-reference,  Prev: Indentation,  Up: Programming

3.2.1.4 Documentation commands
..............................

SLIME's online documentation commands follow the example of Emacs Lisp.
The commands all share the common prefix `C-c C-d' and allow the final
key to be modified or unmodified (*note About key bindings::.)

`SPC'
     `slime-space'
     The space key inserts a space, but also looks up and displays the
     argument list for the function at point, if there is one.

`C-c C-d d'
     `slime-describe-symbol'
     Describe the symbol at point.

`C-c C-f'
     `slime-describe-function'
     Describe the function at point.

`C-c C-d a'
     `slime-apropos'
     Perform an apropos search on Lisp symbol names for a regular
     expression match and display their documentation strings. By
     default the external symbols of all packages are searched. With a
     prefix argument you can choose a specific package and whether to
     include unexported symbols.

`C-c C-d z'
     `slime-apropos-all'
     Like `slime-apropos' but also includes internal symbols by default.

`C-c C-d p'
     `slime-apropos-package'
     Show apropos results of all symbols in a package. This command is
     for browsing a package at a high-level. With package-name
     completion it also serves as a rudimentary Smalltalk-ish
     image-browser.

`C-c C-d h'
     `slime-hyperspec-lookup'
     Lookup the symbol at point in the `Common Lisp Hyperspec'. This
     uses the familiar `hyperspec.el' to show the appropriate section
     in a web browser. The Hyperspec is found either on the Web or in
     `common-lisp-hyperspec-root', and the browser is selected by
     `browse-url-browser-function'.

     Note: this is one case where `C-c C-d h' is _not_ the same as `C-c
     C-d C-h'.

`C-c C-d ~'
     `common-lisp-hyperspec-format'
     Lookup a _format character_ in the `Common Lisp Hyperspec'.


File: slime.info,  Node: Cross-reference,  Next: Finding definitions,  Prev: Documentation,  Up: Programming

3.2.1.5 Cross-reference commands
................................

SLIME's cross-reference commands are based on the support provided by
the Lisp system, which varies widely between Lisps. For systems with no
built-in XREF support SLIME queries a portable XREF package, which is
taken from the `CMU AI Repository' and bundled with SLIME.

   Each command operates on the symbol at point, or prompts if there is
none. With a prefix argument they always prompt. You can either enter
the key bindings as shown here or with the control modified on the last
key, *Note About key bindings::.

`C-c C-w c'
     `slime-who-calls'
     Show function callers.

`C-c C-w r'
     `slime-who-references'
     Show references to global variable.

`C-c C-w b'
     `slime-who-binds'
     Show bindings of a global variable.

`C-c C-w s'
     `slime-who-sets'
     Show assignments to a global variable.

`C-c C-w m'
     `slime-who-macroexpands'
     Show expansions of a macro.

`M-x'
     `slime-who-specializes'
     Show all known methods specialized on a class.

`M-x'
     `slime-goto-xref'
     Go to the cross-referenced location at point.


   There are also "List callers/callees" commands. These operate by
rummaging through function objects on the heap at a low-level to
discover the call graph. They are only available with some Lisp
systems, and are most useful as a fallback when precise XREF
information is unavailable.

`C-c <'
     `slime-list-callers'
     List callers of a function.

`C-c >'
     `slime-list-callees'
     List callees of a function.

`M-x'
     `slime-calls-who'
     Show all known functions called by the function SYMBOL.


File: slime.info,  Node: Finding definitions,  Next: Macro-expansion,  Prev: Cross-reference,  Up: Programming

3.2.1.6 Finding definitions ("Meta-Point" commands).
....................................................

The familiar `M-.' command is provided. For generic functions this
command finds all methods, and with some systems it does other fancy
things (like tracing structure accessors to their `DEFSTRUCT'
definition).

`M-.'
     `slime-edit-definition'
     Go to the definition of the symbol at point.

`M-,'
`M-*'
     `slime-pop-find-definition-stack' Go back to the point where `M-.'
     was invoked. This gives multi-level backtracking when `M-.' has
     been used several times.

`C-x 4 .'
     `slime-edit-definition-other-window'
     Like `slime-edit-definition' but switchs to the other window to
     edit the definition in.

`C-x 5 .'
     `slime-edit-definition-other-frame'
     Like `slime-edit-definition' but opens another frame to edit the
     definition in.

`M-x'
     `slime-edit-definition-with-etags'
     Use an ETAGS table to find definition at point.


File: slime.info,  Node: Macro-expansion,  Next: Disassembly,  Prev: Finding definitions,  Up: Programming

3.2.1.7 Macro-expansion commands
................................

`C-c C-m'
`C-c RET'
     `slime-macroexpand-1'
     Macroexpand the expression at point once.  If invoked with a prefix
     argument, use macroexpand instead of macroexpand-1.

`C-c M-m'
     `slime-macroexpand-all'
     Fully macroexpand the expression at point.

`C-c C-t'
     `slime-toggle-trace-fdefinition'
     Toggle tracing of the function at point.  If invoked with a prefix
     argument, read additional information, like which particular method
     should be traced.

`M-x'
     `slime-untrace-all'
     Untrace all functions.


   For additional minor-mode commands and discussion, *note
slime-macroexpansion-minor-mode::.


File: slime.info,  Node: Disassembly,  Prev: Macro-expansion,  Up: Programming

3.2.1.8 Disassembly commands
............................

`C-c M-d'
     `slime-disassemble-symbol'
     Disassemble the function definition of the symbol at point.


File: slime.info,  Node: Compilation,  Next: Evaluation,  Prev: Programming,  Up: Commands

3.2.2 Compilation commands
--------------------------

SLIME has fancy commands for compiling functions, files, and packages.
The fancy part is that notes and warnings offered by the Lisp compiler
are intercepted and annotated directly onto the corresponding
expressions in the Lisp source buffer. (Give it a try to see what this
means.)

`C-c C-c'
     `slime-compile-defun'
     Compile the top-level form at point.  

`C-c C-y'
     `slime-call-defun'
     Insert a call to the function defined around point into the REPL.

`C-c C-k'
     `slime-compile-and-load-file'
     Compile and load the current buffer's source file.

`C-c M-k'
     `slime-compile-file'
     Compile (but don't load) the current buffer's source file.

`C-c C-l'
     `slime-load-file'
     Load a source file and compile if necessary, without loading into
     a buffer..

`C-c C-z'
     `slime-switch-to-output-buffer'
     Select the output buffer, preferably in a different window.

`M-x'
     `slime-compile-region'
     Compile region at point.

`M-x'
     `slime-compiler-macroexpand'
     Display the compiler-macro expansion of sexp at point.

`M-x'
     `slime-compiler-macroexpand-1'
     Display the compiler-macro expansion of sexp at point.

`M-x'
     `slime-compiler-notes-default-action-or-show-details'
     Invoke the action at point, or show details.

`M-x'
     `slime-compiler-notes-default-action-or-show-details/mouse'
     Invoke the action pointed at by the mouse, or show details.

`M-x'
     `slime-compiler-notes-mode'
`M-x'
     `slime-compiler-notes-quit'
`M-x'
     `slime-compiler-notes-show-details'

   The annotations are indicated as underlining on source forms. The
compiler message associated with an annotation can be read either by
placing the mouse over the text or with the selection commands below.

`M-n'
     `slime-next-note'
     Move the point to the next compiler note and displays the note.

`M-p'
     `slime-previous-note'
     Move the point to the previous compiler note and displays the note.

`C-c M-c'
     `slime-remove-notes'
     Remove all annotations from the buffer.


File: slime.info,  Node: Evaluation,  Next: Recovery,  Prev: Compilation,  Up: Commands

3.2.3 Evaluation commands
-------------------------

These commands each evaluate a Lisp expression in a different way. By
default they show their results in a message, but a prefix argument
causes the results to be printed in the REPL instead.

`C-M-x'
     `slime-eval-defun'
     Evaluate the current toplevel form.  Use
     `slime-re-evaluate-defvar' if the from starts with `(defvar'.

`C-x C-e'
     `slime-eval-last-expression'
     Evaluate the expression before point.

   If `C-M-x' or `C-x C-e' is given a numeric argument, it inserts the
value into the current buffer at point, rather than displaying it in the
echo area.

`C-c C-p'
     `slime-pprint-eval-last-expression'
     Evaluate the expression before point and pretty-print the result.

`C-c C-r'
     `slime-eval-region'
     Evaluate the region.

`C-x M-e'
     `slime-eval-last-expression-display-output'
     Display output buffer and evaluate the expression preceding point.

`C-c :'
     `slime-interactive-eval'
     Evaluate an expression read from the minibuffer.

`M-x'
     `slime-scratch'
     Create a `*slime-scratch*' buffer. In this buffer you can enter
     Lisp expressions and evaluate them with `C-j', like in Emacs's
     `*scratch*' buffer.

`C-c E'
     `slime-edit-value'
     Edit the value of a setf-able form in a new buffer `*Edit <form>*'.
     The value is inserted into a temporary buffer for editing and then
     set in Lisp when committed with `slime-edit-value-commit'.

`C-c C-u'
     `slime-undefine-function'
     Unbind symbol for function at point.


File: slime.info,  Node: Recovery,  Next: Inspector,  Prev: Evaluation,  Up: Commands

3.2.4 Abort/Recovery commands
-----------------------------

`C-c C-b'
     `slime-interrupt'
     Interrupt Lisp (send `SIGINT').

`C-c ~'
     `slime-sync-package-and-default-directory'
     Synchronize the current package and working directory from Emacs to
     Lisp.

`C-c M-p'
     `slime-repl-set-package'
     Set the current package of the REPL.



File: slime.info,  Node: Inspector,  Next: Profiling,  Prev: Recovery,  Up: Commands

3.2.5 Inspector commands
------------------------

The SLIME inspector is a very fancy Emacs-based alternative to the
standard `INSPECT' function. The inspector presents objects in Emacs
buffers using a combination of plain text, hyperlinks to related
objects, and "actions" that can be selected to invoke Lisp code on the
inspected object. For example, to present a generic function the
inspector shows the documentation in plain text and presents each
method with both a hyperlink to inspect the method object and a "remove
method" action that you can invoke interactively.

   The inspector can easily be specialized for the objects in your own
programs. For details see the the `inspect-for-emacs' generic function
in `swank-backend.lisp'.

`C-c I'
     `slime-inspect'
     Inspect the value of an expression entered in the minibuffer.


   The standard commands available in the inspector are:

`RET'
     `slime-inspector-operate-on-point'
     If point is on a value then recursivly call the inspcetor on that
     value. If point is on an action then call that action.

`d'
     `slime-inspector-describe'
     Describe the slot at point.

`l'
     `slime-inspector-pop'
     Go back to the previous object (return from `RET').

`n'
     `slime-inspector-next'
     The inverse of `l'. Also bound to `SPC'.

`q'
     `slime-inspector-quit'
     Dismiss the inspector buffer.

`M-RET'
     `slime-inspector-copy-down'
     Evaluate the value under point via the REPL (to set `*').



File: slime.info,  Node: Profiling,  Next: Other,  Prev: Inspector,  Up: Commands

3.2.6 Profiling commands
------------------------

`M-x'
     `slime-toggle-profile-fdefinition'
     Toggle profiling of a function.

`M-x'
     `slime-profile-package'
     Profile all functions in a package.

`M-x'
     `slime-unprofile-all'
     Unprofile all functions.

`M-x'
     `slime-profile-report'
     Report profiler data.

`M-x'
     `slime-profile-reset'
     Reset profiler data.

`M-x'
     `slime-profiled-functions'
     Show list of currently profiled functions.


File: slime.info,  Node: Other,  Prev: Profiling,  Up: Commands

3.2.7 Shadowed Commands
-----------------------

`C-c C-a'
     `slime-nop'
     This key-binding is shadowed from lisp-inf.

`C-c C-v'
     `slime-nop'
     This key-binding is shadowed from lisp-inf.



File: slime.info,  Node: Semantic indentation,  Next: Reader conditionals,  Prev: Commands,  Up: slime-mode

3.3 Semantic indentation
========================

SLIME automatically discovers how to indent the macros in your Lisp
system. To do this the Lisp side scans all the macros in the system and
reports to Emacs all the ones with `&body' arguments. Emacs then
indents these specially, putting the first arguments four spaces in and
the "body" arguments just two spaces, as usual.

   This should "just work." If you are a lucky sort of person you
needn't read the rest of this section.

   To simplify the implementation, SLIME doesn't distinguish between
macros with the same symbol-name but different packages. This makes it
fit nicely with Emacs's indentation code. However, if you do have
several macros with the same symbol-name then they will all be indented
the same way, arbitrarily using the style from one of their arglists.
You can find out which symbols are involved in collisions with:

     (swank:print-indentation-lossage)

   If a collision causes you irritation, don't have a nervous breakdown,
just override the Elisp symbol's `common-lisp-indent-function' property
to your taste. SLIME won't override your custom settings, it just tries
to give you good defaults.

   A more subtle issue is that imperfect caching is used for the sake of
performance. (1)

   In an ideal world, Lisp would automatically scan every symbol for
indentation changes after each command from Emacs. However, this is too
expensive to do every time. Instead Lisp usually just scans the symbols
whose home package matches the one used by the Emacs buffer where the
request comes from. That is sufficient to pick up the indentation of
most interactively-defined macros. To catch the rest we make a full scan
of every symbol each time a new Lisp package is created between commands
- that takes care of things like new systems being loaded.

   You can use `M-x slime-update-indentation' to force all symbols to
be scanned for indentation information.

   ---------- Footnotes ----------

   (1) _Of course_ we made sure it was actually too slow before making
the ugly optimization.


File: slime.info,  Node: Reader conditionals,  Prev: Semantic indentation,  Up: slime-mode

3.4 Reader conditional fontification
====================================

SLIME automatically evaluates reader-conditional expressions in source
buffers and "grays out" code that will be skipped for the current Lisp
connection.


File: slime.info,  Node: REPL,  Next: Debugger,  Prev: slime-mode,  Up: Top

4 REPL: the "top level"
***********************

SLIME uses a custom Read-Eval-Print Loop (REPL, also known as a "top
level"). The REPL user-interface is written in Emacs Lisp, which gives
more Emacs-integration than the traditional `comint'-based Lisp
interaction:

   * Conditions signalled in REPL expressions are debugged with SLDB.

   * Return values are distinguished from printed output by separate
     Emacs faces (colours).

   * Emacs manages the REPL prompt with markers. This ensures that Lisp
     output is inserted in the right place, and doesn't get mixed up
     with user input.

* Menu:

* REPL commands::
* Input Navigation::
* Shortcuts::


File: slime.info,  Node: REPL commands,  Next: Input Navigation,  Prev: REPL,  Up: REPL

4.1 REPL commands
=================

`RET'
     `slime-repl-return'
     Evaluate the current input in Lisp if it is complete. If
     incomplete, open a new line and indent. If a prefix argument is
     given then the input is evaluated without checking for
     completeness.

`C-RET'
     `slime-repl-closing-return'
     Close any unmatched parenthesis and then evaluate the current
     input in Lisp. Also bound to `M-RET'.

`C-j'
     `slime-repl-newline-and-indent'
     Open and indent a new line.

`C-c C-c'
     `slime-interrupt'
     Interrupt the Lisp process with `SIGINT'.

`C-c M-g'
     `slime-quit'
     Quit slime.

`C-c C-o'
     `slime-repl-clear-output'
     Remove the output and result of the previous expression from the
     buffer.

`C-c C-t'
     `slime-repl-clear-buffer'
     Clear the entire buffer, leaving only a prompt.



File: slime.info,  Node: Input Navigation,  Next: Shortcuts,  Prev: REPL commands,  Up: REPL

4.2 Input navigation
====================

`C-a'
     `slime-repl-bol'
     Go to the beginning of the line, but stop at the REPL prompt.

`M-n'
`M-p'
     `slime-repl-next-input, slime-repl-previous-input'
     Go to next/previous in command history.

`M-s'
`M-r'
     `slime-repl-next-matching-input,
     slime-repl-previous-matching-input'
     Search forward/reverse through command history with regex

`C-c C-n'
`C-c C-p'
     `slime-repl-next-prompt, slime-repl-previous-prompt'
     Move between the current and previous prompts in the REPL buffer.

`C-M-a'
`C-M-e'
     `slime-repl-beginning-of-defun, slime-repl-end-of-defun' These
     commands are like `beginning-of-defun' and `end-of-defun', but
     when used inside the REPL input area they instead go directly to
     the beginning or the end, respectively.



File: slime.info,  Node: Shortcuts,  Prev: Input Navigation,  Up: REPL

4.3 Shortcuts
=============

"Shortcuts" are a special set of REPL commands that are invoked by
name. To invoke a shortcut you first press `,' (comma) at the REPL
prompt and then enter the shortcut's name when prompted.

   Shortcuts deal with things like switching between directories and
compiling and loading Lisp systems. The set of shortcuts is listed
below, and you can also use the `help' shortcut to list them
interactively.

`change-directory (aka !d, cd)'
     Change the current directory.

`change-package (aka !p)'
     Change the current package.

`compile-and-load (aka cl)'
     Compile (if neccessary) and load a lisp file.

`compile-system'
     Compile (but not load) an ASDF system.

`defparameter (aka !)'
     Define a new global, special, variable.

`force-compile-system'
     Recompile (but not load) an ASDF system.

`force-load-system'
     Recompile and load an ASDF system.

`help (aka ?)'
     Display the help.

`load-system'
     Compile (as needed) and load an ASDF system.

`pop-directory (aka -d)'
     Pop the current directory.

`pop-package (aka -p)'
     Pop the top of the package stack.

`push-directory (aka +d, pushd)'
     Push a new directory onto the directory stack.

`push-package (aka +p)'
     Push a package onto the package stack.

`pwd'
     Show the current directory.

`quit'
     Quit the current Lisp.

`resend-form'
     Resend the last form.

`restart-inferior-lisp'
     Restart *inferior-lisp* and reconnect SLIME.

`sayoonara'
     Quit all Lisps and close all SLIME buffers.



File: slime.info,  Node: Debugger,  Next: Extras,  Prev: REPL,  Up: Top

5 SLDB: the SLIME debugger
**************************

SLIME has a custom Emacs-based debugger called SLDB. Conditions
signalled in the Lisp system invoke SLDB in Emacs by way of the Lisp
`*DEBUGGER-HOOK*'.

   SLDB pops up a buffer when a condition is signalled. The buffer
displays a description of the condition, a list of restarts, and a
backtrace. Commands are offered for invoking restarts, examining the
backtrace, and poking around in stack frames.

* Menu:

* Examining frames::
* Restarts::
* Frame Navigation::
* Miscellaneous::


File: slime.info,  Node: Examining frames,  Next: Restarts,  Prev: Debugger,  Up: Debugger

5.1 Examining frames
====================

Commands for examining the stack frame at point.

`t'
     `sldb-toggle-details'
     Toggle display of local variables and `CATCH' tags.

`v'
     `sldb-show-source'
     View the frame's current source expression. The expression is
     presented in the Lisp source file's buffer.

`e'
     `sldb-eval-in-frame'
     Evaluate an expression in the frame. The expression can refer to
     the available local variables in the frame.

`d'
     `sldb-pprint-eval-in-frame'
     Evaluate an expression in the frame and pretty-print the result in
     a temporary buffer.

`D'
     `sldb-disassemble'
     Disassemble the frame's function. Includes information such as the
     instruction pointer within the frame.

`i'
     `sldb-inspect-in-frame'
     Inspect the result of evaluating an expression in the frame.


File: slime.info,  Node: Restarts,  Next: Frame Navigation,  Prev: Examining frames,  Up: Debugger

5.2 Invoking restarts
=====================

`a'
     `sldb-abort'
     Invoke the `ABORT' restart.

`q'
     `sldb-quit'
     "Quit" - `THROW' to a tag that the top-level SLIME request-loop
     catches.

`c'
     `sldb-continue'
     Invoke the `CONTINUE' restart.

`0 ... 9'
     Invoke a restart by number.

   Restarts can also be invoked by pressing `RET' or `Mouse-2' on them
in the buffer.


File: slime.info,  Node: Frame Navigation,  Next: Miscellaneous,  Prev: Restarts,  Up: Debugger

5.3 Navigating between frames
=============================

`n'

`p'
     `sldb-down, sldb-up'
     Move between frames.

`M-n'

`M-p'
     `sldb-details-{down,up}'
     Move between frames "with sugar": hide the details of the original
     frame and display the details and source code of the next. Sugared
     motion makes you see the details and source code for the current
     frame only.


File: slime.info,  Node: Miscellaneous,  Prev: Frame Navigation,  Up: Debugger

5.4 Miscellaneous Commands
==========================

`r'
     `sldb-restart-frame'
     Restart execution of the frame with the same arguments it was
     originally called with. (This command is not available in all
     implementations.)

`R'
     `sldb-return-from-frame'
     Return from the frame with a value entered in the minibuffer. (This
     command is not available in all implementations.)

`s'
     `sldb-step'
     Step to the next expression in the frame. (This command is not
     available in all implementations.)

`B'
     `sldb-break-with-default-debugger'
     Exit SLDB and debug the condition using the Lisp system's default
     debugger.

`M-x'
     `in-sldb-face'
     Return STRING propertised with face sldb-NAME-face.

`C-c :'
     `slime-interactive-eval'
     Evaluate an expression entered in the minibuffer.


File: slime.info,  Node: Extras,  Next: Customization,  Prev: Debugger,  Up: Top

6 Extras
********

* Menu:

* slime-selector::
* slime-autodoc-mode::
* slime-macroexpansion-minor-mode::
* Multiple connections::
* Typeout frames::


File: slime.info,  Node: slime-selector,  Next: slime-autodoc-mode,  Prev: Extras,  Up: Extras

6.1 `slime-selector'
====================

The `slime-selector' command is for quickly switching to important
buffers: the REPL, SLDB, the Lisp source you were just hacking, etc.
Once invoked the command prompts for a single letter to specify which
buffer it should display. Here are some of the options:

`?'
     A help buffer listing all `slime-selectors''s available buffers.

`r'
     The REPL buffer for the current SLIME connection.

`d'
     The most recently activated SLDB buffer for the current connection.

`l'
     The most recently visited `lisp-mode' source buffer.

`s'
     The `*slime-scratch*' buffer. *Note slime-scratch::.

   `slime-selector' doesn't have a key binding by default but we
suggest that you assign it a global one. You can bind it to `C-c s'
like this:

     (global-set-key "\C-cs" 'slime-selector)

And then you can switch to the REPL from anywhere with `C-c s r'.

   The macro `def-slime-selector-method' can be used to define new
buffers for `slime-selector' to find.


File: slime.info,  Node: slime-autodoc-mode,  Next: slime-macroexpansion-minor-mode,  Prev: slime-selector,  Up: Extras

6.2 `slime-autodoc-mode'
========================

`M-x'
     `slime-autodoc-mode'
     Autodoc mode is an additional minor-mode for automatically showing
     information about symbols near the point. For function names the
     argument list is displayed, and for global variables, the value.
     This is a clone of `eldoc-mode' for Emacs Lisp.

   The mode can be enabled by default in the `slime-setup' call of your
`~/.emacs':
     (slime-setup :autodoc t)


File: slime.info,  Node: slime-macroexpansion-minor-mode,  Next: Multiple connections,  Prev: slime-autodoc-mode,  Up: Extras

6.3 slime-macroexpansion-minor-mode
===================================

Within a slime macroexpansion buffer some extra commands are provided
(these commands are always available but are only bound to keys in a
macroexpansion buffer).

`C-c C-m'
     `slime-macroexpand-1-inplace'
     Just like slime-macroexpand-1 but the original form is replaced
     with the expansion.

`g'
     `slime-macroexpand-1-inplace'
     The last macroexpansion is performed again, the current contents of
     the macroexpansion buffer are replaced with the new expansion.

`q'
     `slime-temp-buffer-quit'
     Close the expansion buffer.



File: slime.info,  Node: Multiple connections,  Next: Typeout frames,  Prev: slime-macroexpansion-minor-mode,  Up: Extras

6.4 Multiple connections
========================

SLIME is able to connect to multiple Lisp processes at the same time.
The `M-x slime' command, when invoked with a prefix argument, will
offer to create an additional Lisp process if one is already running.
This is often convenient, but it requires some understanding to make
sure that your SLIME commands execute in the Lisp that you expect them
to.

   Some buffers are tied to specific Lisp processes. Each Lisp
connection has its own REPL buffer, and all expressions entered or
SLIME commands invoked in that buffer are sent to the associated
connection. Other buffers created by SLIME are similarly tied to the
connections they originate from, including SLDB buffers, apropos result
listings, and so on. These buffers are the result of some interaction
with a Lisp process, so commands in them always go back to that same
process.

   Commands executed in other places, such as `slime-mode' source
buffers, always use the "default" connection. Usually this is the most
recently established connection, but this can be reassigned via the
"connection list" buffer:

`C-c C-x c'
     `slime-list-connections'
     Pop up a buffer listing the established connections.

`C-c C-x t'
     `slime-list-threads'
     Pop up a buffer listing the current threads.

`M-x'
     `slime-abort-connection'
     Abort the current connection.

`M-x'
     `slime-restart-connection-at-point'

   The buffer displayed by `slime-list-connections' gives a one-line
summary of each connection. The summary shows the connection's serial
number, the name of the Lisp implementation, and other details of the
Lisp process. The current "default" connection is indicated with an
asterisk.

   The commands available in the connection-list buffer are:

`RET'
     `slime-goto-connection'
     Pop to the REPL buffer of the connection at point.

`d'
     `slime-connection-list-make-default'
     Make the connection at point the "default" connection. It will then
     be used for commands in `slime-mode' source buffers.

`g'
     `slime-update-connection-list'
     Update the connection list in the buffer.

`q'
     `slime-temp-buffer-quit'
     Quit the connection list (kill buffer, restore window
     configuration).

`M-x'
     `slime-connect'
     Connect to a running Swank server.

`M-x'
     `slime-disconnect'
     Disconnect all connections.

`M-x'
     `slime-connection-list-mode'
     Connection-list. SLIME Connection List Mode.


File: slime.info,  Node: Typeout frames,  Prev: Multiple connections,  Up: Extras

6.5 Typeout frames
==================

A "typeout frame" is a special Emacs frame which is used instead of the
echo area (minibuffer) to display messages from SLIME commands.  This
is an optional feature. The advantage of a typeout frame over the echo
area is that it can hold more text, it can be scrolled, and its
contents don't disappear when you press a key. All potentially long
messages are sent to the typeout frame, such as argument lists, macro
expansions, and so on.

`M-x'
     `slime-ensure-typeout-frame'
     Ensure that a typeout frame exists, creating one if necessary.

   If the typeout frame is closed then the echo area will be used again
as usual.

   To have a typeout frame created automatically at startup you can add
the `slime-connected-hook' to your `~/.emacs' file:

     (add-hook 'slime-connected-hook 'slime-ensure-typeout-frame)


File: slime.info,  Node: Customization,  Next: Tips and Tricks,  Prev: Extras,  Up: Top

7 Customization
***************

* Menu:

* Emacs-side customization::
* Lisp-side::


File: slime.info,  Node: Emacs-side customization,  Next: Lisp-side,  Prev: Customization,  Up: Customization

7.1 Emacs-side
==============

The Emacs part of SLIME can be configured with the Emacs `customize'
system, just use `M-x customize-group slime RET'. Because the customize
system is self-describing, we only cover a few important or obscure
configuration options here in the manual.

`slime-truncate-lines'
     The value to use for `truncate-lines' in line-by-line summary
     buffers popped up by SLIME. This is `t' by default, which ensures
     that lines do not wrap in backtraces, apropos listings, and so on.
     It can however cause information to spill off the screen.

`slime-multiprocessing'
     This should be set to `t' if you want to use multiprocessing
     (threads) in your Lisp system. It causes any necessary
     initialization to be performed during Lisp server startup.

`slime-complete-symbol-function'
     The function to use for completion of Lisp symbols. Three
     completion styles are available. The default
     `slime-complete-symbol*' performs completion "in parallel" over
     the hyphen-delimited sub-words of a symbol name.  (1) Formally
     this means that "`a-b-c'" can complete to any symbol matching the
     regular expression "`^a.*-b.*-c.*'" (where "dot" matches anything
     but a hyphen). Examples give a more intuitive feeling:
        * `m-v-b' completes to `multiple-value-bind'.

        * `w-open' is ambiguous: it completes to either
          `with-open-file' or `with-open-stream'. The symbol is
          expanded to the longest common completion (`with-open-') and
          the point is placed at the first point of ambiguity, which in
          this case is the end.

        * `w--stream' completes to `with-open-stream'.
     An alternative is `slime-simple-complete-symbol', which completes
     in the usual Emacs way.  Finally, there is
     `slime-fuzzy-complete-symbol', which is quite different from both
     of the above and tries to find best matches to an abbreviated
     symbol.  It also has its own key binding, defaulting to `C-c M-i'.
     *Note slime-fuzzy-complete-symbol::, for more information.

`slime-filename-translations'
     This variable controls filename translation between Emacs and the
     Lisp system. It is useful if you run Emacs and Lisp on separate
     machines which don't share a common file system or if they share
     the filessytem but have different layouts, as is the case with
     SMB-based file sharing.

`slime-net-coding-system'
     If you want to transmit Unicode characters between Emacs and the
     Lisp system, you should customize this variable.  E.g., if you use
     SBCL, you can set:
          (setq slime-net-coding-system 'utf-8-unix)
     To actually display Unicode characters you also need appropriate
     fonts, otherwise the characters will be rendered as hollow boxes.
     If you are using Allegro CL and GNU Emacs, you can also use
     `emacs-mule-unix' as coding system.  GNU Emacs has often nicer
     fonts for the latter encoding.


* Menu:

* Hooks::

   ---------- Footnotes ----------

   (1) This style of completion is modelled on `completer.el' by Chris
McConnell. That package is bundled with ILISP.


File: slime.info,  Node: Hooks,  Prev: Emacs-side customization,  Up: Emacs-side customization

7.1.1 Hooks
-----------

`M-x'
     `slime-mode-hook'
`slime-mode-hook'
     This hook is run each time a buffer enters `slime-mode'. It is
     most useful for setting buffer-local configuration in your Lisp
     source buffers. An example use is to enable `slime-autodoc-mode'
     (*Note slime-autodoc-mode::.)

`slime-connected-hook'
     This hook is run when SLIME establishes a connection to a Lisp
     server. An example use is to create a Typeout frame (*Note Typeout
     frames::.)

`sldb-hook'
     This hook is run after SLDB is invoked. The hook functions are
     called from the SLDB buffer after it is initialized. An example use
     is to add `sldb-print-condition' to this hook, which makes all
     conditions debugged with SLDB be recorded in the REPL buffer.



File: slime.info,  Node: Lisp-side,  Prev: Emacs-side customization,  Up: Customization

7.2 Lisp-side (Swank)
=====================

The Lisp server side of SLIME (known as "Swank") offers several
variables to configure. The initialization file `~/.swank.lisp' is
automatically evaluated at startup and can be used to set these
variables.

* Menu:

* Communication style::
* Other configurables::


File: slime.info,  Node: Communication style,  Next: Other configurables,  Prev: Lisp-side,  Up: Lisp-side

7.2.1 Communication style
-------------------------

The most important configurable is `SWANK:*COMMUNICATION-STYLE*', which
specifies the mechanism by which Lisp reads and processes protocol
messages from Emacs. The choice of communication style has a global
influence on SLIME's operation.

   The available communication styles are:

`NIL'
     This style simply loops reading input from the communication socket
     and serves SLIME protocol events as they arise. The simplicity
     means that the Lisp cannot do any other processing while under
     SLIME's control.

`:FD-HANDLER'
     This style uses the classical Unix-style "`select()'-loop."  Swank
     registers the communication socket with an event-dispatching
     framework (such as `SERVE-EVENT' in CMUCL and SBCL) and receives a
     callback when data is available. In this style requests from Emacs
     are only detected and processed when Lisp enters the event-loop.
     This style is simple and predictable.

`:SIGIO'
     This style uses "signal-driven I/O" with a `SIGIO' signal handler.
     Lisp receives requests from Emacs along with a signal, causing it
     to interrupt whatever it is doing to serve the request. This style
     has the advantage of responsiveness, since Emacs can perform
     operations in Lisp even while it is busy doing other things. It
     also allows Emacs to issue requests concurrently, e.g. to send one
     long-running request (like compilation) and then interrupt that
     with several short requests before it completes. The disadvantages
     are that it may conflict with other uses of `SIGIO' by Lisp code,
     and it may cause untold havoc by interrupting Lisp at an awkward
     moment.

`:SPAWN'
     This style uses multiprocessing support in the Lisp system to
     execute each request in a separate thread. This style has similar
     properties to `:SIGIO', but it does not use signals and all
     requests issued by Emacs can be executed in parallel.


   The default request handling style is chosen according to the
capabilities of your Lisp system. The general order of preference is
`:SPAWN', then `:SIGIO', then `:FD-HANDLER', with `NIL' as a last
resort. You can check the default style by calling
`SWANK-BACKEND:PREFERRED-COMMUNICATION-STYLE'. You can also override
the default by setting `SWANK:*COMMUNICATION-STYLE*' in your Swank init
file.


File: slime.info,  Node: Other configurables,  Prev: Communication style,  Up: Lisp-side

7.2.2 Other configurables
-------------------------

These Lisp variables can be configured via your `~/.swank.lisp' file:

`SWANK:*CONFIGURE-EMACS-INDENTATION*'
     This variable controls whether indentation styles for
     `&body'-arguments in macros are discovered and sent to Emacs. It
     is enabled by default.

`SWANK:*GLOBALLY-REDIRECT-IO*'
     When true this causes the standard streams (`*standard-output*',
     etc) to be globally redirected to the REPL in Emacs. When `NIL'
     (the default) these streams are only temporarily redirected to
     Emacs using dynamic bindings while handling requests. Note that
     `*standard-input*' is currently never globally redirected into
     Emacs, because it can interact badly with the Lisp's native REPL by
     having it try to read from the Emacs one.

`SWANK:*GLOBAL-DEBUGGER*'
     When true (the default) this causes `*DEBUGGER-HOOK*' to be
     globally set to `SWANK:SWANK-DEBUGGER-HOOK' and thus for SLIME to
     handle all debugging in the Lisp image. This is for debugging
     multithreaded and callback-driven applications.

`SWANK:*SLDB-PRINTER-BINDINGS*'
`SWANK:*MACROEXPAND-PRINTER-BINDINGS*'
`SWANK:*SWANK-PPRINT-BINDINGS*'
     These variables can be used to customize the printer in various
     situations.  The values of the variables are association lists of
     printer variable names with the corresponding value.  E.g., to
     enable the pretty printer for formatting backtraces in SLDB, you
     can use:
          (push '(*print-pretty* . t) swank:*sldb-printer-bindings*).

`SWANK:*USE-DEDICATED-OUTPUT-STREAM*'
     This variable controls an optimization for sending printed output
     from Lisp to Emacs. When `t' a separate socket is established
     solely for Lisp to send printed output to Emacs through. Without
     the optimization it is necessary to send output in
     protocol-messages to Emacs which must then be decoded, and this
     doesn't always keep up if Lisp starts "spewing" copious output.

`SWANK:*DEDICATED-OUTPUT-STREAM-PORT*'
     When `*USE-DEDICATED-OUTPUT-STREAM*' is `t' the stream will be
     opened on this port. The default value, `0', means that the stream
     will be opened on some random port.

`SWANK:*LOG-EVENTS*'
     Setting this variable to `t' causes all protocol messages
     exchanged with Emacs to be printed to `*TERMINAL-IO*'. This is
     useful for low-level debugging and for observing how SLIME works
     "on the wire." The output of `*TERMINAL-IO*' can be found in your
     Lisp system's own listener, usually in the buffer
     `*inferior-lisp*'.



File: slime.info,  Node: Tips and Tricks,  Next: Credits,  Prev: Customization,  Up: Top

8 Tips and Tricks
*****************

* Menu:

* Connecting to a remote lisp::
* Global IO Redirection::
* Auto-SLIME::


File: slime.info,  Node: Connecting to a remote lisp,  Next: Global IO Redirection,  Up: Tips and Tricks

8.1 Connecting to a remote lisp
===============================

One of the advantages of the way SLIME is implemented is that we can
easily run the Emacs side (slime.el) on one machine and the lisp
backend (swank) on another. The basic idea is to start up lisp on the
remote machine, load swank and wait for incoming slime connections. On
the local machine we start up emacs and tell slime to connect to the
remote machine. The details are a bit messier but the underlying idea
is that simple.

* Menu:

* Setting up the lisp image::
* Setting up Emacs::
* Setting up pathname translations::


File: slime.info,  Node: Setting up the lisp image,  Next: Setting up Emacs,  Up: Connecting to a remote lisp

8.1.1 Setting up the lisp image
-------------------------------

When you want to load swank without going through the normal, Emacs
based, process just load the `swank-loader.lisp' file. Just execute

     (load "/path/to/swank-loader.lisp")

   inside a running lisp image(1). Now all we need to do is startup our
swank server. The first example assumes we're using the default
settings.

     (swank:create-server)

   Since we're going to be tunneling our connection via ssh(2) and
we'll only have one port open we want to tell swank to not use an extra
connection for output:

     (setf swank:*use-dedicated-output-stream* nil)

   If you need to do anything particular (like be able to reconnect to
swank after you're done), look into `swank:create-server''s other
arguments. Some of these arguments are
`:PORT'
     Port number for the server to listen on (default: 4005).

`:STYLE'
     See *Note Communication style::.

`:DONT-CLOSE'
     Boolean indicating if the server will continue to accept
     connections after the first one (default: `NIL'). For
     "long-running" lisp processes to which you want to be able to
     connect from time to time, specify `:dont-close t'

`:CODING-SYSTEM'
     String designating the encoding to be used to communicate between
     the Emacs and Lisp.

   So the more complete example will be
     (swank:create-server :port 4005  :dont-close t :coding-system "utf-8-unix")
   On the emacs side you will use something like
     (setq slime-net-coding-system 'utf-8-unix)
     (slime-connect "127.0.0.1" 4005))
   to connect to this lisp image from the same machine.

   ---------- Footnotes ----------

   (1) SLIME also provides an ASDF system definiton which does the same
thing

   (2) there is a way to connect without an ssh tunnel, but it has the
side-effect of giving the entire world access to your lisp image, se
we're not gonig to talk about it


File: slime.info,  Node: Setting up Emacs,  Next: Setting up pathname translations,  Prev: Setting up the lisp image,  Up: Connecting to a remote lisp

8.1.2 Setting up Emacs
----------------------

Now we need to create the tunnel between the local machine and the
remote machine.

     ssh -L4005:127.0.0.1:4005 username@remote.example.com

   That ssh invocation creates an ssh tunnel between the port 4005 on
our local machine and the port 4005 on the remote machine(1).

   Finally we can start SLIME:

     M-x slime-connect RET RET

   The `RET RET' sequence just means that we want to use the default
host (`127.0.0.1') and the default port (`4005'). Even though we're
connecting to a remote machine the ssh tunnel fools Emacs into thinking
it's actually `127.0.0.1'.

   ---------- Footnotes ----------

   (1) By default swank listens for incoming connections on port 4005,
had we passed a `:port' parameter to `swank:create-server' we'd be
using that port number instead


File: slime.info,  Node: Setting up pathname translations,  Prev: Setting up Emacs,  Up: Connecting to a remote lisp

8.1.3 Setting up pathname translations
--------------------------------------

One of the main problems with running swank remotely is that Emacs
assumes the files can be found using normal filenames. if we want
things like `slime-compile-and-load-file' (`C-c C-k') and
`slime-edit-definition' (`M-.') to work correctly we need to find a way
to let our local Emacs refer to remote files.

   There are, mainly, two ways to do this. The first is to mount, using
NFS or similar, the remote machine's hard disk on the local machine's
file system in such a fashion that a filename like
`/opt/project/source.lisp' refers to the same file on both machines.
Unfortunetly NFS is usually slow, often buggy, and not always feasable,
fortunetely we have an ssh connection and Emacs' `tramp-mode' can do
the rest.

   What we do is teach Emacs how to take a filename on the remote
machine and translate it into something that tramp can understand and
access (and vice-versa). Assuming the remote machine's host name is
`remote.example.com', `cl:machine-instance' returns "remote" and we
login as the user "user" we can use SLIME's built-in mechanism to setup
the proper transaltions by simply doing:

     (push (slime-create-filename-translator :machine-instance "remote.example.com"
                                             :remote-host "remote"
                                             :username "user")
           slime-filename-translations)


File: slime.info,  Node: Global IO Redirection,  Next: Auto-SLIME,  Prev: Connecting to a remote lisp,  Up: Tips and Tricks

8.2 Globally redirecting all IO to the REPL
===========================================

By default SLIME does not change `*standard-output*' and friends
outside of the REPL. If you have any other threads which call `format',
`write-string', etc. that output will be seen only in the
`*inferior-lisp*' buffer or on the terminal, more often than not this
is inconvenient. So, if you want code such as this:

     (run-in-new-thread
       (lambda ()
         (write-line "In some random thread.~%" *standard-output*)))

   to send its output to SLIME's repl buffer, as opposed to
`*inferior-lisp*', set `swank:*globally-redirect-io*' to T.

   Note that the value of this variable is only checked when swank
accepts the connection so you should set it via `~/.swank.lisp'.
Otherwise you will need to call
`swank::globally-redirect-io-to-connection' yourself, but you shouldn't
do that unless you know what you're doing.


File: slime.info,  Node: Auto-SLIME,  Prev: Global IO Redirection,  Up: Tips and Tricks

8.3 Connecting to SLIME automatically
=====================================

To make SLIME connect to your lisp whenever you open a lisp file just
add this to your `.emacs':

     (add-hook 'slime-mode-hook
               (lambda ()
                 (unless (slime-connected-p)
                   (save-excursion (slime)))))


File: slime.info,  Node: Credits,  Next: Index to Key Bindings,  Prev: Tips and Tricks,  Up: Top

9 Credits
*********

_The soppy ending..._

Hackers of the good hack
========================

SLIME is an Extension of SLIM by Eric Marsden. At the time of writing,
the authors and code-contributors of SLIME are:

Helmut Eller             Luke Gorrie              Matthias Koeppe
Marco Baringer           Alan Ruttenberg          Edi Weitz
Juho Snellman            Peter Seibel             Attila Lendvai
Christophe Rhodes        Daniel Barlow            Wolfgang Jenkner
Martin Simmons           Douglas Crosher          Nikodemus Siivola
Lawrence Mitchell        Brian Downing            Andras Simon
Espen Wiborg             Bill Clementson          Thomas Schilling
Thomas F. Burdick        Michael Weber            Matthew Danish
James Bielman            Gbor Melis              Antonio Menezes Leitao
Zach Beane               Utz-Uwe Haus             Lus Oliveira
Lars Magne Ingebrigtsen  John Paul Wallington     Joerg Hoehle
Bryan O'Connor           Alan Shutko              Tobias Rittweiler
Tiago Maduro-Dias        Stefan Kamphausen        Robert Lehr
Robert E. Brown          Raymond Toy              Nathan Bird
Jouni K Seppanen         Ivan Toshkov             Ian Eslick
Harald Hanche-Olsen      Eric Blood               Eduardo Muoz
Christian Lynbech        Chris Capel              Bjrn Nordb
Andreas Fuchs            Alexey Dejneka           Yaroslav Kavenchuk
Wolfgang Mederle         Wojciech Kaczmarek       William Bland
Willem Broekema          Travis Cross             Tom Pierce
Tobias C. Rittweiler     Tim Daly Jr.             Taylor R. Campbell
Taylor R Campbell        Taylor Campbell          Svein Ove Aas
Sean O'Rourke            Russell McManus          Rui Patrocnio
Robert Macomber          Reini Urban              Pawel Ostrowski
Paul Collins             NIIMI Satoshi            Mszros Levente
Mikel Bancroft           Matthew D. Swank         Mark Wooding
Marco Monteiro           Lynn Quam                Levente Mszros
Lasse Rasinen            Kai Kaminski             Julian Stecklina
Juergen Gmeiner          Johan Bockgrd           Jan Rychter
James McIlree            Ivan Boldyrev            Ignas Mikalajunas
Hannu Koivisto           Gerd Flaig               Gary King
Frederic Brunel          Daniel Koning            Dan Weinreb
Dan Pierson              Brian Mastenbrook        Brandon Bergren
Bob Halley               Barry Fishman            Aleksandar Bakic
Alan Caulkins                                     

   ... not counting the bundled code from `hyperspec.el', `CLOCC', and
the `CMU AI Repository'.

   Many people on the `slime-devel' mailing list have made non-code
contributions to SLIME. Life is hard though: you gotta send code to get
your name in the manual. `:-)'

Thanks!
=======

We're indebted to the good people of `common-lisp.net' for their
hosting and help, and for rescuing us from "Sourceforge hell."

   Implementors of the Lisps that we support have been a great help.
We'd like to thank the CMUCL maintainers for their helpful answers,
Craig Norvell and Kevin Layer at Franz providing Allegro CL licenses
for SLIME development, and Peter Graves for his help to get SLIME
running with ABCL.

   Most of all we're happy to be working with the Lisp implementors
who've joined in the SLIME development: Dan Barlow and Christophe
Rhodes of SBCL, Gary Byers of OpenMCL, and Martin Simmons of LispWorks.
Thanks also to Alain Picard and Memetrics for funding Martin's initial
work on the LispWorks backend!


File: slime.info,  Node: Index to Key Bindings,  Next: Index to Functions,  Prev: Credits,  Up: Top

Appendix A Index to Key Bindings
********************************

These are the keybindings set by default in Slime.

`SPC'
     *Note slime-space::.

`C-c RET'
     *Note slime-macroexpand-1::.

`C-c :'
     *Note slime-interactive-eval::.

`C-c <'
     *Note slime-list-callers::.

`C-c >'
     *Note slime-list-callees::.

`C-c E'
     *Note slime-edit-value::.

`C-c I'
     *Note slime-inspect::.

`C-c u'
     *Note slime-undefine-function::.

`C-c ~'
     *Note slime-sync-package-and-default-directory::.

`C-c C-]'
     *Note slime-close-all-sexp::.

`C-c C-a'
     *Note slime-nop::.

`C-c C-b'
     *Note slime-interrupt::.

`C-c C-c'
     *Note slime-compile-defun::.

`C-c C-d d'
     *Note slime-describe-symbol::.

`C-c C-d ~'
     *Note common-lisp-hyperspec-format::.

`C-c C-e'
     *Note slime-interactive-eval::.

`C-c C-f'
     *Note slime-describe-function::.

`C-c C-i'
     *Note slime-complete-symbol::.

`C-c C-k'
     *Note slime-compile-and-load-file::.

`C-c C-l'
     *Note slime-load-file::.

`C-c C-m'
     *Note slime-macroexpand-1::.

`C-c C-p'
     *Note slime-pprint-eval-last-expression::.

`C-c C-q'
     *Note slime-close-parens-at-point::.

`C-c C-r'
     *Note slime-eval-region::.

`C-c C-s'
     *Note slime-complete-form::.

`C-c C-t'
     *Note slime-toggle-trace-fdefinition::.

`C-c C-v'
     *Note slime-nop::.

`C-c C-w s'
     *Note slime-who-sets::.

`C-c C-x c'
     *Note slime-list-connections::.

`C-c C-x t'
     *Note slime-list-threads::.

`C-c C-y'
     *Note slime-call-defun::.

`C-c C-z'
     *Note slime-switch-to-output-buffer::.

`C-c M-c'
     *Note slime-remove-notes::..

`C-c M-d'
     *Note slime-disassemble-symbol::.

`C-c M-i'
     *Note slime-fuzzy-complete-symbol::.

`C-c M-g'
     *Note slime-quit::.

`C-c M-k'
     *Note slime-compile-file::.

`C-c M-m'
     *Note slime-macroexpand-all::.

`C-c M-p'
     *Note slime-repl-set-package::.

`C-c M-q'
     *Note slime-reindent-defun::.

`C-x 4 .'
     *Note slime-edit-definition-other-window::.

`C-x 5 .'
     *Note slime-edit-definition-other-frame::.

`C-x C-e'
     *Note slime-eval-last-expression::.

`C-x M-e'
     *Note slime-eval-last-expression-display-output::.

`M-TAB'
     *Note slime-complete-symbol::.

`M-*'
     *Note slime-pop-find-definition-stack::.

`M-.'
     *Note slime-edit-definition::.

`M-,'
     *Note slime-pop-find-definition-stack::.

`M-n'
     *Note slime-next-note::.

`M-p'
     *Note slime-previous-note::.

`C-M-i'
     *Note slime-complete-symbol::.

`C-M-x'
     *Note slime-eval-defun::.


File: slime.info,  Node: Index to Functions,  Prev: Index to Key Bindings,  Up: Top

Appendix B Index to Functions
*****************************

These functions are all available (when relevant). To find the
keybinding (if there is one) refer to the function description.

`common-lisp-hyperspec-format'
     *Note common-lisp-hyperspec-format::.

`in-sldb-face'
     *Note in-sldb-face::.

`sldb-abort'
     *Note sldb-abort::.

`sldb-break-with-default-debugger'
     *Note sldb-break-with-default-debugger::.

`sldb-continue'
     *Note sldb-continue::.

`sldb-disassemble'
     *Note sldb-disassemble::.

`sldb-eval-in-frame'
     *Note sldb-eval-in-frame::.

`sldb-inspect-in-frame'
     *Note sldb-inspect-in-frame::.

`sldb-pprint-eval-in-frame'
     *Note sldb-pprint-eval-in-frame::.

`sldb-quit'
     *Note sldb-quit::.

`sldb-restart-frame'
     *Note sldb-restart-frame::.

`sldb-return-from-frame'
     *Note sldb-return-from-frame::.

`sldb-show-source'
     *Note sldb-show-source::.

`sldb-step'
     *Note sldb-step::.

`sldb-toggle-details'
     *Note sldb-toggle-details::.

`slime-abort-connection'
     *Note slime-abort-connection::.

`slime-apropos'
     *Note slime-apropos::.

`slime-apropos-all'
     *Note slime-apropos-all::.

`slime-apropos-package'
     *Note slime-apropos-package::.

`slime-autodoc-mode'
     *Note slime-autodoc-mode::.

`slime-call-defun'
     *Note slime-call-defun::.

`slime-calls-who'
     *Note slime-calls-who::.

`slime-close-all-sexp'
     *Note slime-close-all-sexp::.

`slime-close-parens-at-point'
     *Note slime-close-parens-at-point::.

`slime-compile-and-load-file'
     *Note slime-compile-and-load-file::.

`slime-compile-defun'
     *Note slime-compile-defun::.

`slime-compile-file'
     *Note slime-compile-file::.

`slime-compile-region'
     *Note slime-compile-region::.

`slime-compiler-macroexpand'
     *Note slime-compiler-macroexpand::.

`slime-compiler-macroexpand-1'
     *Note slime-compiler-macroexpand-1::.

`slime-compiler-notes-default-action-or-show-details'
     *Note slime-compiler-notes-default-action-or-show-details::.

`slime-compiler-notes-default-action-or-show-details/mouse'
     *Note slime-compiler-notes-default-action-or-show-details/mouse::.

`slime-compiler-notes-quit'
     *Note slime-compiler-notes-quit::.

`slime-compiler-notes-show-details'
     *Note slime-compiler-notes-show-details::.

`slime-complete-form'
     *Note slime-complete-form::.

`slime-complete-symbol'
     *Note slime-complete-symbol::.

`slime-connect'
     *Note slime-connect::.

`slime-connection-list-make-default'
     *Note slime-connection-list-make-default::.

`slime-connection-list-mode'
     *Note slime-connection-list-mode::.

`slime-describe-function'
     *Note slime-describe-function::.

`slime-describe-symbol'
     *Note slime-describe-symbol::.

`slime-disassemble-symbol'
     *Note slime-disassemble-symbol::.

`slime-disconnect'
     *Note slime-disconnect::.

`slime-edit-definition'
     *Note slime-edit-definition::.

`slime-edit-definition-other-frame'
     *Note slime-edit-definition-other-frame::.

`slime-edit-definition-other-window'
     *Note slime-edit-definition-other-window::.

`slime-edit-definition-with-etags'
     *Note slime-edit-definition-with-etags::.

`slime-edit-value'
     *Note slime-edit-value::.

`slime-ensure-typeout-frame'
     *Note slime-ensure-typeout-frame::.

`slime-eval-defun'
     *Note slime-eval-defun::.

`slime-eval-last-expression'
     *Note slime-eval-last-expression::.

`slime-eval-last-expression-display-output'
     *Note slime-eval-last-expression-display-output::.

`slime-eval-region'
     *Note slime-eval-region::.

`slime-fuzzy-abort'
     *Note slime-fuzzy-abort::.

`slime-fuzzy-complete-symbol'
     *Note slime-fuzzy-complete-symbol::.

`slime-fuzzy-completions-mode'
     *Note slime-fuzzy-completions-mode::.

`slime-goto-connection'
     *Note slime-goto-connection::.

`slime-goto-xref'
     *Note slime-goto-xref::.

`slime-hyperspec-lookup'
     *Note slime-hyperspec-lookup::.

`slime-inspect'
     *Note slime-inspect::.

`slime-inspector-copy-down'
     *Note slime-inspector-copy-down::.

`slime-inspector-describe'
     *Note slime-inspector-describe::.

`slime-inspector-next'
     *Note slime-inspector-next::.

`slime-inspector-quit'
     *Note slime-inspector-quit::.

`slime-interactive-eval'
     *Note slime-interactive-eval::.

`slime-interrupt'
     *Note slime-interrupt::.

`slime-list-callees'
     *Note slime-list-callees::.

`slime-list-callers'
     *Note slime-list-callers::.

`slime-list-connections'
     *Note slime-list-connections::.

`slime-list-threads'
     *Note slime-list-threads::.

`slime-load-file'
     *Note slime-load-file::.

`slime-macroexpand-1'
     *Note slime-macroexpand-1::.

`slime-macroexpand-1-inplace'
     *Note slime-macroexpand-1-inplace::.

`slime-macroexpand-all'
     *Note slime-macroexpand-all::.

`slime-mode'
     *Note slime-mode::.

`slime-next-note'
     *Note slime-next-note::.

`slime-nop'
     *Note slime-nop::.

`slime-pop-find-definition-stack'
     *Note slime-pop-find-definition-stack::.

`slime-pprint-eval-last-expression'
     *Note slime-pprint-eval-last-expression::.

`slime-previous-note'
     *Note slime-previous-note::.

`slime-profile-package'
     *Note slime-profile-package::.

`slime-profile-report'
     *Note slime-profile-report::.

`slime-profile-reset'
     *Note slime-profile-reset::.

`slime-profiled-functions'
     *Note slime-profiled-functions::.

`slime-quit'
     *Note slime-quit::.

`slime-reindent-defun'
     *Note slime-reindent-defun::.

`slime-remove-notes'
     *Note slime-remove-notes::.

`slime-repl-beginning-of-defun'
     *Note slime-repl-beginning-of-defun::.

`slime-repl-bol'
     *Note slime-repl-bol::.

`slime-repl-clear-buffer'
     *Note slime-repl-clear-buffer::.

`slime-repl-clear-output'
     *Note slime-repl-clear-output::.

`slime-repl-closing-return'
     *Note slime-repl-closing-return::.

`slime-repl-end-of-defun'
     *Note slime-repl-end-of-defun::.

`slime-repl-newline-and-indent'
     *Note slime-repl-newline-and-indent::.

`slime-repl-next-input'
     *Note slime-repl-next-input::.

`slime-repl-next-matching-input'
     *Note slime-repl-next-matching-input::.

`slime-repl-next-prompt'
     *Note slime-repl-next-prompt::.

`slime-repl-previous-input'
     *Note slime-repl-previous-input::.

`slime-repl-previous-matching-input'
     *Note slime-repl-previous-matching-input::.

`slime-repl-previous-prompt'
     *Note slime-repl-previous-prompt::.

`slime-repl-return'
     *Note slime-repl-return::.

`slime-repl-set-package'
     *Note slime-repl-set-package::.

`slime-restart-connection-at-point'
     *Note slime-restart-connection-at-point::.

`slime-restart-inferior-lisp'
     *Note slime-restart-inferior-lisp::.

`slime-scratch'
     *Note slime-scratch::.

`slime-selector'
     *Note slime-selector::.

`slime-space'
     *Note slime-space::.

`slime-switch-to-output-buffer'
     *Note slime-switch-to-output-buffer::.

`slime-sync-package-and-default-directory'
     *Note slime-sync-package-and-default-directory::.

`slime-temp-buffer-quit'
     *Note slime-temp-buffer-quit::.

`slime-toggle-profile-fdefinition'
     *Note slime-toggle-profile-fdefinition::.

`slime-toggle-trace-fdefinition'
     *Note slime-toggle-trace-fdefinition::.

`slime-undefine-function'
     *Note slime-undefine-function::.

`slime-unprofile-all'
     *Note slime-unprofile-all::.

`slime-untrace-all'
     *Note slime-untrace-all::.

`slime-update-connection-list'
     *Note slime-update-connection-list::.

`slime-who-binds'
     *Note slime-who-binds::.

`slime-who-calls'
     *Note slime-who-calls::.

`slime-who-macroexpands'
     *Note slime-who-macroexpands::.

`slime-who-references'
     *Note slime-who-references::.

`slime-who-sets'
     *Note slime-who-sets::.

`slime-who-specializes'
     *Note slime-who-specializes::.



Tag Table:
Node: Top198
Node: Introduction578
Node: Getting started1831
Node: Platforms2088
Node: Downloading3247
Node: CVS3754
Node: CVS Incantations4813
Node: Installation5534
Node: Running6226
Ref: slime-restart-inferior-lisp6801
Node: slime-mode6843
Node: User-interface conventions7230
Node: Temporary buffers7657
Node: About key bindings8909
Node: inferior-lisp10819
Node: Multithreading12139
Node: Commands13353
Node: Programming13929
Node: Completion14413
Ref: slime-complete-symbol14770
Ref: slime-complete-form15069
Ref: slime-fuzzy-complete-symbol16286
Ref: slime-fuzzy-completions-mode16880
Ref: slime-fuzzy-abort16922
Node: Closure16954
Ref: slime-close-parens-at-point17157
Ref: slime-close-all-sexp17426
Node: Indentation17793
Ref: slime-reindent-defun17948
Node: Documentation18540
Ref: slime-space18914
Ref: slime-describe-symbol19074
Ref: slime-describe-function19151
Ref: slime-apropos19230
Ref: slime-apropos-all19570
Ref: slime-apropos-package19681
Ref: slime-hyperspec-lookup19939
Ref: common-lisp-hyperspec-format20381
Node: Cross-reference20495
Ref: slime-who-calls21194
Ref: slime-who-references21258
Ref: slime-who-binds21340
Ref: slime-who-sets21417
Ref: slime-who-macroexpands21496
Ref: slime-who-specializes21572
Ref: slime-goto-xref21660
Ref: slime-list-callers22029
Ref: slime-list-callees22097
Ref: slime-calls-who22165
Node: Finding definitions22256
Ref: slime-edit-definition22689
Ref: slime-pop-find-definition-stack22775
Ref: slime-edit-definition-other-window22959
Ref: slime-edit-definition-other-frame23110
Ref: slime-edit-definition-with-etags23252
Node: Macro-expansion23352
Ref: slime-macroexpand-123529
Ref: slime-macroexpand-all23707
Ref: slime-toggle-trace-fdefinition23795
Ref: slime-untrace-all24012
Node: Disassembly24169
Ref: slime-disassemble-symbol24310
Node: Compilation24418
Ref: slime-compile-defun24851
Ref: slime-call-defun24933
Ref: slime-compile-and-load-file25039
Ref: slime-compile-file25141
Ref: slime-load-file25242
Ref: slime-switch-to-output-buffer25363
Ref: slime-compile-region25476
Ref: slime-compiler-macroexpand25541
Ref: slime-compiler-macroexpand-125642
Ref: slime-compiler-notes-default-action-or-show-details25745
Ref: slime-compiler-notes-default-action-or-show-details/mouse25861
Ref: slime-compiler-notes-mode25998
Ref: slime-compiler-notes-quit26037
Ref: slime-compiler-notes-show-details26076
Ref: slime-next-note26333
Ref: slime-previous-note26432
Ref: slime-remove-notes26539
Node: Evaluation26621
Ref: slime-eval-defun26958
Ref: slime-eval-last-expression27104
Ref: slime-pprint-eval-last-expression27348
Ref: slime-eval-region27471
Ref: slime-eval-last-expression-display-output27533
Ref: slime-interactive-eval27665
Ref: slime-scratch27758
Ref: slime-edit-value27948
Ref: slime-undefine-function28190
Node: Recovery28274
Ref: slime-interrupt28424
Ref: slime-sync-package-and-default-directory28495
Ref: slime-repl-set-package28636
Node: Inspector28720
Ref: slime-inspect29553
Ref: slime-inspector-operate-on-point29709
Ref: slime-inspector-describe29887
Ref: slime-inspector-pop29957
Ref: slime-inspector-next30046
Ref: slime-inspector-quit30125
Ref: slime-inspector-copy-down30193
Node: Profiling30299
Ref: slime-toggle-profile-fdefinition30435
Ref: slime-profile-package30519
Ref: slime-unprofile-all30596
Ref: slime-profile-report30660
Ref: slime-profile-reset30722
Ref: slime-profiled-functions30782
Node: Other30869
Ref: slime-nop30985
Node: Semantic indentation31140
Ref: Semantic indentation-Footnote-133228
Node: Reader conditionals33323
Node: REPL33647
Node: REPL commands34389
Ref: slime-repl-return34517
Ref: slime-repl-closing-return34759
Ref: slime-repl-newline-and-indent34911
Ref: slime-quit35069
Ref: slime-repl-clear-output35115
Ref: slime-repl-clear-buffer35240
Node: Input Navigation35336
Ref: slime-repl-bol35475
Ref: slime-repl-next-input35571
Ref: slime-repl-previous-input35571
Ref: slime-repl-next-matching-input35685
Ref: slime-repl-previous-matching-input35685
Ref: slime-repl-next-prompt35840
Ref: slime-repl-previous-prompt35840
Ref: slime-repl-beginning-of-defun35990
Ref: slime-repl-end-of-defun35990
Node: Shortcuts36259
Node: Debugger37873
Node: Examining frames38489
Ref: sldb-toggle-details38676
Ref: sldb-show-source38765
Ref: sldb-eval-in-frame38910
Ref: sldb-pprint-eval-in-frame39060
Ref: sldb-disassemble39195
Ref: sldb-inspect-in-frame39339
Node: Restarts39439
Ref: sldb-abort39586
Ref: sldb-quit39642
Ref: sldb-continue39747
Node: Frame Navigation39940
Node: Miscellaneous40437
Ref: sldb-restart-frame40574
Ref: sldb-return-from-frame40762
Ref: sldb-step40925
Ref: sldb-break-with-default-debugger41055
Ref: in-sldb-face41186
Node: Extras41364
Node: slime-selector41599
Node: slime-autodoc-mode42707
Node: slime-macroexpansion-minor-mode43294
Ref: slime-macroexpand-1-inplace43660
Ref: slime-temp-buffer-quit43981
Node: Multiple connections44050
Ref: slime-list-connections45295
Ref: slime-list-threads45396
Ref: slime-abort-connection45485
Ref: slime-restart-connection-at-point45557
Ref: slime-goto-connection45955
Ref: slime-connection-list-make-default46047
Ref: slime-update-connection-list46225
Ref: slime-connect46428
Ref: slime-disconnect46496
Ref: slime-connection-list-mode46560
Node: Typeout frames46651
Ref: slime-ensure-typeout-frame47214
Node: Customization47598
Node: Emacs-side customization47775
Ref: slime-complete-symbol-function48683
Ref: Emacs-side customization-Footnote-150919
Node: Hooks51038
Ref: slime-mode-hook51161
Node: Lisp-side51921
Node: Communication style52322
Node: Other configurables54816
Node: Tips and Tricks57509
Node: Connecting to a remote lisp57721
Node: Setting up the lisp image58423
Ref: Setting up the lisp image-Footnote-160189
Ref: Setting up the lisp image-Footnote-260268
Node: Setting up Emacs60442
Ref: Setting up Emacs-Footnote-161257
Node: Setting up pathname translations61427
Node: Global IO Redirection62991
Node: Auto-SLIME64038
Node: Credits64455
Node: Index to Key Bindings68046
Node: Index to Functions70709

End Tag Table
